a9mpcore.c: * Cortex-A9MPCore internal peripheral emulation.
a9mpcore.c:        DEFINE_PROP_UINT32("num-cpu", mpcore_priv_state, num_cpu, 1),
ac97.c:#define SR_VALID_MASK ((1 << 5) - 1)
ac97.c:#define CR_VALID_MASK ((1 << 5) - 1)
ac97.c:#define GC_VALID_MASK ((1 << 6) - 1)
ac97.c:#define GS_VALID_MASK ((1 << 18) - 1)
ac97.c:    cpu_physical_memory_read (r->bdbar + r->civ * 8, b, 8);
ac97.c:    r->bd_valid = 1;
ac97.c:    r->bd.addr = le32_to_cpu (*(uint32_t *) &b[0]) & ~3;
ac97.c:    r->bd.ctl_len = le32_to_cpu (*(uint32_t *) &b[4]);
ac97.c:    r->picb = r->bd.ctl_len & 0xffff;
ac97.c:           r->civ, r->bd.addr, r->bd.ctl_len >> 16,
ac97.c:           r->bd.ctl_len & 0xffff,
ac97.c:           (r->bd.ctl_len & 0xffff) << 1);
ac97.c:    uint32_t old_mask = r->sr & SR_INT_MASK;
ac97.c:            if ((new_mask & SR_LVBCI) && (r->cr & CR_LVBIE)) {
ac97.c:            if ((new_mask & SR_BCIS) && (r->cr & CR_IOCE)) {
ac97.c:    r->sr = new_sr;
ac97.c:           r->sr & SR_BCIS, r->sr & SR_LVBCI,
ac97.c:           r->sr,
ac97.c:        s->glob_sta |= masks[r - s->bm_regs];
ac97.c:        qemu_set_irq (s->dev.irq[0], 1);
ac97.c:        s->glob_sta &= ~masks[r - s->bm_regs];
ac97.c:        qemu_set_irq (s->dev.irq[0], 0);
ac97.c:        AUD_set_active_in (s->voice_pi, on);
ac97.c:        AUD_set_active_out (s->voice_po, on);
ac97.c:        AUD_set_active_in (s->voice_mc, on);
ac97.c:    r->bdbar = 0;
ac97.c:    r->civ = 0;
ac97.c:    r->lvi = 0;
ac97.c:    r->picb = 0;
ac97.c:    r->piv = 0;
ac97.c:    r->cr = r->cr & CR_DONT_CLEAR_MASK;
ac97.c:    r->bd_valid = 0;
ac97.c:    voice_set_active (s, r - s->bm_regs, 0);
ac97.c:    memset (s->silence, 0, sizeof (s->silence));
ac97.c:    if (i + 2 > sizeof (s->mixer_data)) {
ac97.c:               i, sizeof (s->mixer_data));
ac97.c:    s->mixer_data[i + 0] = v & 0xff;
ac97.c:    s->mixer_data[i + 1] = v >> 8;
ac97.c:    if (i + 2 > sizeof (s->mixer_data)) {
ac97.c:               i, sizeof (s->mixer_data));
ac97.c:        val = s->mixer_data[i + 0] | (s->mixer_data[i + 1] << 8);
ac97.c:        s->invalid_freq[index] = 0;
ac97.c:            s->voice_pi = AUD_open_in (
ac97.c:                &s->card,
ac97.c:                s->voice_pi,
ac97.c:            s->voice_po = AUD_open_out (
ac97.c:                &s->card,
ac97.c:                s->voice_po,
ac97.c:            s->voice_mc = AUD_open_in (
ac97.c:                &s->card,
ac97.c:                s->voice_mc,
ac97.c:        s->invalid_freq[index] = freq;
ac97.c:            AUD_close_in (&s->card, s->voice_pi);
ac97.c:            s->voice_pi = NULL;
ac97.c:            AUD_close_out (&s->card, s->voice_po);
ac97.c:            s->voice_po = NULL;
ac97.c:            AUD_close_in (&s->card, s->voice_mc);
ac97.c:            s->voice_mc = NULL;
ac97.c:    AUD_set_active_in (s->voice_pi, active[PI_INDEX]);
ac97.c:    AUD_set_active_out (s->voice_po, active[PO_INDEX]);
ac97.c:    AUD_set_active_in (s->voice_mc, active[MC_INDEX]);
ac97.c:    uint8_t rvol = VOL_MASK - (val & VOL_MASK);
ac97.c:    uint8_t lvol = VOL_MASK - ((val >> 8) & VOL_MASK);
ac97.c:        AUD_set_volume_out (s->voice_po, mute, lvol, rvol);
ac97.c:    rvol = VOL_MASK - ((VOL_MASK * rvol) / 255);
ac97.c:    lvol = VOL_MASK - ((VOL_MASK * lvol) / 255);
ac97.c:    memset (s->mixer_data, 0, sizeof (s->mixer_data));
ac97.c:    s->cas = 0;
ac97.c:    uint32_t index = addr - s->base[0];
ac97.c:    s->cas = 0;
ac97.c:    s->cas = 0;
ac97.c:    dolog ("U nam writeb %#x <- %#x\n", addr, val);
ac97.c:    s->cas = 0;
ac97.c:    uint32_t index = addr - s->base[0];
ac97.c:    s->cas = 0;
ac97.c:        dolog ("U nam writew %#x <- %#x\n", addr, val);
ac97.c:    dolog ("U nam writel %#x <- %#x\n", addr, val);
ac97.c:    s->cas = 0;
ac97.c:    uint32_t index = addr - s->base[1];
ac97.c:        dolog ("CAS %d\n", s->cas);
ac97.c:        val = s->cas;
ac97.c:        s->cas = 1;
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->civ;
ac97.c:        dolog ("CIV[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->lvi;
ac97.c:        dolog ("LVI[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->piv;
ac97.c:        dolog ("PIV[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->cr;
ac97.c:        dolog ("CR[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->sr & 0xff;
ac97.c:        dolog ("SRb[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        dolog ("U nabm readb %#x -> %#x\n", addr, val);
ac97.c:    uint32_t index = addr - s->base[1];
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->sr;
ac97.c:        dolog ("SR[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->picb;
ac97.c:        dolog ("PICB[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        dolog ("U nabm readw %#x -> %#x\n", addr, val);
ac97.c:    uint32_t index = addr - s->base[1];
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->bdbar;
ac97.c:        dolog ("BMADDR[%d] -> %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->civ | (r->lvi << 8) | (r->sr << 16);
ac97.c:        dolog ("CIV LVI SR[%d] -> %#x, %#x, %#x\n", GET_BM (index),
ac97.c:               r->civ, r->lvi, r->sr);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        val = r->picb | (r->piv << 16) | (r->cr << 24);
ac97.c:        dolog ("PICB PIV CR[%d] -> %#x %#x %#x %#x\n", GET_BM (index),
ac97.c:               val, r->picb, r->piv, r->cr);
ac97.c:        val = s->glob_cnt;
ac97.c:        dolog ("glob_cnt -> %#x\n", val);
ac97.c:        val = s->glob_sta | GS_S0CR;
ac97.c:        dolog ("glob_sta -> %#x\n", val);
ac97.c:        dolog ("U nabm readl %#x -> %#x\n", addr, val);
ac97.c:    uint32_t index = addr - s->base[1];
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        if ((r->cr & CR_RPBM) && (r->sr & SR_DCH)) {
ac97.c:            r->sr &= ~(SR_DCH | SR_CELV);
ac97.c:            r->civ = r->piv;
ac97.c:            r->piv = (r->piv + 1) % 32;
ac97.c:        r->lvi = val % 32;
ac97.c:        dolog ("LVI[%d] <- %#x\n", GET_BM (index), val);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:            r->cr = val & CR_VALID_MASK;
ac97.c:            if (!(r->cr & CR_RPBM)) {
ac97.c:                voice_set_active (s, r - s->bm_regs, 0);
ac97.c:                r->sr |= SR_DCH;
ac97.c:                r->civ = r->piv;
ac97.c:                r->piv = (r->piv + 1) % 32;
ac97.c:                r->sr &= ~SR_DCH;
ac97.c:                voice_set_active (s, r - s->bm_regs, 1);
ac97.c:        dolog ("CR[%d] <- %#x (cr %#x)\n", GET_BM (index), val, r->cr);
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        r->sr |= val & ~(SR_RO_MASK | SR_WCLEAR_MASK);
ac97.c:        update_sr (s, r, r->sr & ~(val & SR_WCLEAR_MASK));
ac97.c:        dolog ("SR[%d] <- %#x (sr %#x)\n", GET_BM (index), val, r->sr);
ac97.c:        dolog ("U nabm writeb %#x <- %#x\n", addr, val);
ac97.c:    uint32_t index = addr - s->base[1];
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        r->sr |= val & ~(SR_RO_MASK | SR_WCLEAR_MASK);
ac97.c:        update_sr (s, r, r->sr & ~(val & SR_WCLEAR_MASK));
ac97.c:        dolog ("SR[%d] <- %#x (sr %#x)\n", GET_BM (index), val, r->sr);
ac97.c:        dolog ("U nabm writew %#x <- %#x\n", addr, val);
ac97.c:    uint32_t index = addr - s->base[1];
ac97.c:        r = &s->bm_regs[GET_BM (index)];
ac97.c:        r->bdbar = val & ~3;
ac97.c:        dolog ("BDBAR[%d] <- %#x (bdbar %#x)\n",
ac97.c:               GET_BM (index), val, r->bdbar);
ac97.c:            s->glob_cnt = val & GC_VALID_MASK;
ac97.c:        dolog ("glob_cnt <- %#x (glob_cnt %#x)\n", val, s->glob_cnt);
ac97.c:        s->glob_sta &= ~(val & GS_WCLEAR_MASK);
ac97.c:        s->glob_sta |= (val & ~(GS_WCLEAR_MASK | GS_RO_MASK)) & GS_VALID_MASK;
ac97.c:        dolog ("glob_sta <- %#x (glob_sta %#x)\n", val, s->glob_sta);
ac97.c:        dolog ("U nabm writel %#x <- %#x\n", addr, val);
ac97.c:    uint32_t addr = r->bd.addr;
ac97.c:    uint32_t temp = r->picb << 1;
ac97.c:        copied = AUD_write (s->voice_po, tmpbuf, to_copy);
ac97.c:        temp -= copied;
ac97.c:            s->last_samp = 0;
ac97.c:            s->last_samp = *(uint32_t *) &tmpbuf[to_copy - 4];
ac97.c:    r->bd.addr = addr;
ac97.c:    if (!(s->bup_flag & BUP_SET)) {
ac97.c:        if (s->bup_flag & BUP_LAST) {
ac97.c:            uint8_t *p = s->silence;
ac97.c:            for (i = 0; i < sizeof (s->silence) / 4; i++, p += 4) {
ac97.c:                *(uint32_t *) p = s->last_samp;
ac97.c:            memset (s->silence, 0, sizeof (s->silence));
ac97.c:        s->bup_flag |= BUP_SET;
ac97.c:        int temp = audio_MIN (elapsed, sizeof (s->silence));
ac97.c:            int copied = AUD_write (s->voice_po, s->silence, temp);
ac97.c:            temp -= copied;
ac97.c:            elapsed -= copied;
ac97.c:    uint32_t addr = r->bd.addr;
ac97.c:    uint32_t temp = r->picb << 1;
ac97.c:    SWVoiceIn *voice = (r - s->bm_regs) == MC_INDEX ? s->voice_mc : s->voice_pi;
ac97.c:        temp -= acquired;
ac97.c:    r->bd.addr = addr;
ac97.c:    AC97BusMasterRegs *r = &s->bm_regs[index];
ac97.c:    if (s->invalid_freq[index]) {
ac97.c:                 index, s->invalid_freq[index]);
ac97.c:    if (r->sr & SR_DCH) {
ac97.c:        if (r->cr & CR_RPBM) {
ac97.c:        if (!r->bd_valid) {
ac97.c:        if (!r->picb) {
ac97.c:                   r->civ, r->bd.addr, r->bd.ctl_len);
ac97.c:            if (r->civ == r->lvi) {
ac97.c:                r->sr |= SR_DCH; /* CELV? */
ac97.c:                s->bup_flag = 0;
ac97.c:            r->sr &= ~SR_CELV;
ac97.c:            r->civ = r->piv;
ac97.c:            r->piv = (r->piv + 1) % 32;
ac97.c:            elapsed -= temp;
ac97.c:            r->picb -= (temp >> 1);
ac97.c:            elapsed -= temp;
ac97.c:            r->picb -= (temp >> 1);
ac97.c:        if (!r->picb) {
ac97.c:            uint32_t new_sr = r->sr & ~SR_CELV;
ac97.c:            if (r->bd.ctl_len & BD_IOC) {
ac97.c:            if (r->civ == r->lvi) {
ac97.c:                dolog ("Underrun civ (%d) == lvi (%d)\n", r->civ, r->lvi);
ac97.c:                s->bup_flag = (r->bd.ctl_len & BD_BUP) ? BUP_LAST : 0;
ac97.c:                r->civ = r->piv;
ac97.c:                r->piv = (r->piv + 1) % 32;
ac97.c:    active[PI_INDEX] = !!(s->bm_regs[PI_INDEX].cr & CR_RPBM);
ac97.c:    active[PO_INDEX] = !!(s->bm_regs[PO_INDEX].cr & CR_RPBM);
ac97.c:    active[MC_INDEX] = !!(s->bm_regs[MC_INDEX].cr & CR_RPBM);
ac97.c:    s->bup_flag = 0;
ac97.c:    s->last_samp = 0;
ac97.c:    PCIDevice *d = &s->dev;
ac97.c:        s->base[0] = addr;
ac97.c:        s->base[1] = addr;
ac97.c:    reset_bm_regs (s, &s->bm_regs[0]);
ac97.c:    reset_bm_regs (s, &s->bm_regs[1]);
ac97.c:    reset_bm_regs (s, &s->bm_regs[2]);
ac97.c:    uint8_t *c = s->dev.config;
ac97.c:    pci_register_bar (&s->dev, 0, 256 * 4, PCI_BASE_ADDRESS_SPACE_IO,
ac97.c:    pci_register_bar (&s->dev, 1, 64 * 4, PCI_BASE_ADDRESS_SPACE_IO, ac97_map);
ac97.c:    AUD_register_card ("ac97", &s->card);
ac97.c:    pci_create_simple (bus, -1, "AC97");
acpi.c:#include "qemu-timer.h"
acpi.c:#include "qemu-kvm.h"
acpi.c:    pmsts = s->pmsts;
acpi.c:    if (d >= s->tmr_overflow_time)
acpi.c:        s->pmsts |= TMROF_EN;
acpi.c:    return s->pmsts;
acpi.c:    sci_level = (((pmsts & s->pmen) &
acpi.c:    qemu_set_irq(s->irq, sci_level);
acpi.c:    if ((s->pmen & TMROF_EN) && !(pmsts & TMROF_EN)) {
acpi.c:        expire_time = muldiv64(s->tmr_overflow_time, get_ticks_per_sec(), PM_FREQ);
acpi.c:        qemu_mod_timer(s->tmr_timer, expire_time);
acpi.c:        qemu_del_timer(s->tmr_timer);
acpi.c:                s->tmr_overflow_time = (d + 0x800000LL) & ~0x7fffffLL;
acpi.c:            s->pmsts &= ~val;
acpi.c:        s->pmen = val;
acpi.c:            s->pmcntrl = val & ~(SUS_EN);
acpi.c:                    s->pmsts |= (RSM_STS | PWRBTN_STS);
acpi.c:        val = s->pmen;
acpi.c:        val = s->pmcntrl;
acpi.c:        s->apmc = val;
acpi.c:            s->pmcntrl |= SCI_EN;
acpi.c:            s->pmcntrl &= ~SCI_EN;
acpi.c:        if (s->dev.config[0x5b] & (1 << 1)) {
acpi.c:        s->apms = val;
acpi.c:        val = s->apmc;
acpi.c:        val = s->apms;
acpi.c:    uint8_t prot = (s->smb_ctl >> 2) & 0x07;
acpi.c:    uint8_t read = s->smb_addr & 0x01;
acpi.c:    uint8_t cmd = s->smb_cmd;
acpi.c:    uint8_t addr = s->smb_addr >> 1;
acpi.c:    i2c_bus *bus = s->smbus;
acpi.c:            s->smb_data0 = smbus_receive_byte(bus, addr);
acpi.c:            s->smb_data0 = smbus_read_byte(bus, addr, cmd);
acpi.c:            smbus_write_byte(bus, addr, cmd, s->smb_data0);
acpi.c:            s->smb_data0 = val;
acpi.c:            s->smb_data1 = val >> 8;
acpi.c:            smbus_write_word(bus, addr, cmd, (s->smb_data1 << 8) | s->smb_data0);
acpi.c:            s->smb_data0 = smbus_read_block(bus, addr, cmd, s->smb_data);
acpi.c:            smbus_write_block(bus, addr, cmd, s->smb_data, s->smb_data0);
acpi.c:    s->smb_stat |= 0x04;
acpi.c:        s->smb_stat = 0;
acpi.c:        s->smb_index = 0;
acpi.c:        s->smb_ctl = val;
acpi.c:        s->smb_cmd = val;
acpi.c:        s->smb_addr = val;
acpi.c:        s->smb_data0 = val;
acpi.c:        s->smb_data1 = val;
acpi.c:        s->smb_data[s->smb_index++] = val;
acpi.c:        if (s->smb_index > 31)
acpi.c:            s->smb_index = 0;
acpi.c:        val = s->smb_stat;
acpi.c:        s->smb_index = 0;
acpi.c:        val = s->smb_ctl & 0x1f;
acpi.c:        val = s->smb_cmd;
acpi.c:        val = s->smb_addr;
acpi.c:        val = s->smb_data0;
acpi.c:        val = s->smb_data1;
acpi.c:        val = s->smb_data[s->smb_index++];
acpi.c:        if (s->smb_index > 31)
acpi.c:            s->smb_index = 0;
acpi.c:    if (s->dev.config[0x80] & 1) {
acpi.c:        pm_io_base = le32_to_cpu(*(uint32_t *)(s->dev.config + 0x40));
acpi.c:    uint8_t *pci_conf = s->dev.config;
acpi.c:    } else if (s->pmen & PWRBTN_EN) {
acpi.c:        s->pmsts |= PWRBTN_EN;
acpi.c:    pci_conf = s->dev.config;
acpi.c:    s->pmcntrl = SCI_EN;
acpi.c:    s->tmr_timer = qemu_new_timer(vm_clock, pm_tmr_timer, s);
acpi.c:    s->smbus = i2c_init_bus(NULL, "i2c");
acpi.c:    s->irq = sci_irq;
acpi.c:    return s->smbus;
acpi.c:            val = g->cpus_sts[addr - PROC_BASE];
acpi.c:            val = gpe_read_val(g->sts, addr);
acpi.c:            val = gpe_read_val(g->en, addr);
acpi.c:    *cur = (*cur & (0xff << (8 - shift))) | (x1 << shift);
acpi.c:            gpe_reset_val(&g->sts, addr, val);
acpi.c:            gpe_write_val(&g->en, addr, val);
acpi.c:            val = g->up;
acpi.c:            val = g->down;
acpi.c:            g->up = val;
acpi.c:            g->down = val;
acpi.c:    int slot = ffs(val) - 1;
acpi.c:    QLIST_FOREACH_SAFE(qdev, &bus->children, sibling, next) {
acpi.c:        if (PCI_SLOT(dev->devfn) == slot) {
acpi.c:        gpe.cpus_sts[i++] = (cpus < 8) ? (1 << cpus) - 1 : 0xff;
acpi.c:        cpus -= 8;
acpi.c:    g->sts |= 4;
acpi.c:    g->cpus_sts[cpu/8] |= (1 << (cpu%8));
acpi.c:    g->sts |= 4;
acpi.c:    g->cpus_sts[cpu/8] &= ~(1 << (cpu%8));
acpi.c:        env->cpuid_apic_id = cpu;
acpi.c:        qemu_set_irq(pm_state->irq, 1);
acpi.c:        qemu_set_irq(pm_state->irq, 0);
acpi.c:    g->sts |= 2;
acpi.c:    p->up |= (1 << slot);
acpi.c:    g->sts |= 2;
acpi.c:    p->down |= (1 << slot);
acpi.c:    int slot = PCI_SLOT(dev->devfn);
acpi.c:        qemu_set_irq(pm_state->irq, 1);
acpi.c:        qemu_set_irq(pm_state->irq, 0);
acpi.c:    return (-sum) & 0xff;
acpi.c:                s.st_size -= r;
acpi.c:    ((struct acpi_table_header*)p)->checksum = acpi_checksum((uint8_t*)p, off);
acpi.c:    return -1;
adb.c:#define ADB_RET_NOTPRESENT (-2)
adb.c:        for(i = 0; i < s->nb_devices; i++) {
adb.c:            d = &s->devices[i];
adb.c:            if (d->devreset) {
adb.c:                d->devreset(d);
adb.c:    for(i = 0; i < s->nb_devices; i++) {
adb.c:        d = &s->devices[i];
adb.c:        if (d->devaddr == devaddr) {
adb.c:            return d->devreq(d, obuf, buf, len);
adb.c:    for(i = 0; i < s->nb_devices; i++) {
adb.c:        if (s->poll_index >= s->nb_devices)
adb.c:            s->poll_index = 0;
adb.c:        d = &s->devices[s->poll_index];
adb.c:        buf[0] = ADB_READREG | (d->devaddr << 4);
adb.c:        s->poll_index++;
adb.c:    if (s->nb_devices >= MAX_ADB_DEVICES)
adb.c:    d = &s->devices[s->nb_devices++];
adb.c:    d->bus = s;
adb.c:    d->devaddr = devaddr;
adb.c:    d->devreq = devreq;
adb.c:    d->devreset = devreset;
adb.c:    d->opaque = opaque;
adb.c:    KBDState *s = d->opaque;
adb.c:    if (s->count < sizeof(s->data)) {
adb.c:        s->data[s->wptr] = keycode;
adb.c:        if (++s->wptr == sizeof(s->data))
adb.c:            s->wptr = 0;
adb.c:        s->count++;
adb.c:    KBDState *s = d->opaque;
adb.c:        if (s->count == 0)
adb.c:        keycode = s->data[s->rptr];
adb.c:        if (++s->rptr == sizeof(s->data))
adb.c:            s->rptr = 0;
adb.c:        s->count--;
adb.c:    KBDState *s = d->opaque;
adb.c:        s->wptr = s->rptr = s->count = 0;
adb.c:                d->devaddr = buf[1] & 0xf;
adb.c:                d->devaddr = buf[1] & 0xf;
adb.c:                d->handler = buf[2];
adb.c:            obuf[0] = d->handler;
adb.c:            obuf[1] = d->devaddr;
adb.c:    qemu_put_buffer(f, s->data, sizeof(s->data));
adb.c:    qemu_put_sbe32s(f, &s->rptr);
adb.c:    qemu_put_sbe32s(f, &s->wptr);
adb.c:    qemu_put_sbe32s(f, &s->count);
adb.c:        return -EINVAL;
adb.c:    qemu_get_buffer(f, s->data, sizeof(s->data));
adb.c:    qemu_get_sbe32s(f, &s->rptr);
adb.c:    qemu_get_sbe32s(f, &s->wptr);
adb.c:    qemu_get_sbe32s(f, &s->count);
adb.c:    KBDState *s = d->opaque;
adb.c:    d->handler = 1;
adb.c:    d->devaddr = ADB_KEYBOARD;
adb.c:    register_savevm("adb_kbd", -1, 1, adb_kbd_save,
adb.c:    MouseState *s = d->opaque;
adb.c:    s->dx += dx1;
adb.c:    s->dy += dy1;
adb.c:    s->dz += dz1;
adb.c:    s->buttons_state = buttons_state;
adb.c:    MouseState *s = d->opaque;
adb.c:    if (s->last_buttons_state == s->buttons_state &&
adb.c:        s->dx == 0 && s->dy == 0)
adb.c:    dx = s->dx;
adb.c:    if (dx < -63)
adb.c:        dx = -63;
adb.c:    dy = s->dy;
adb.c:    if (dy < -63)
adb.c:        dy = -63;
adb.c:    s->dx -= dx;
adb.c:    s->dy -= dy;
adb.c:    s->last_buttons_state = s->buttons_state;
adb.c:    if (!(s->buttons_state & MOUSE_EVENT_LBUTTON))
adb.c:    if (!(s->buttons_state & MOUSE_EVENT_RBUTTON))
adb.c:    MouseState *s = d->opaque;
adb.c:        s->buttons_state = s->last_buttons_state;
adb.c:        s->dx = 0;
adb.c:        s->dy = 0;
adb.c:        s->dz = 0;
adb.c:                d->devaddr = buf[1] & 0xf;
adb.c:                d->devaddr = buf[1] & 0xf;
adb.c:            obuf[0] = d->handler;
adb.c:            obuf[1] = d->devaddr;
adb.c:    MouseState *s = d->opaque;
adb.c:    d->handler = 2;
adb.c:    d->devaddr = ADB_MOUSE;
adb.c:    qemu_put_sbe32s(f, &s->buttons_state);
adb.c:    qemu_put_sbe32s(f, &s->last_buttons_state);
adb.c:    qemu_put_sbe32s(f, &s->dx);
adb.c:    qemu_put_sbe32s(f, &s->dy);
adb.c:    qemu_put_sbe32s(f, &s->dz);
adb.c:        return -EINVAL;
adb.c:    qemu_get_sbe32s(f, &s->buttons_state);
adb.c:    qemu_get_sbe32s(f, &s->last_buttons_state);
adb.c:    qemu_get_sbe32s(f, &s->dx);
adb.c:    qemu_get_sbe32s(f, &s->dy);
adb.c:    qemu_get_sbe32s(f, &s->dz);
adb.c:    register_savevm("adb_mouse", -1, 1, adb_mouse_save,
adlib.c: * Copyright (c) 2004-2005 Vassili Karpov (malc)
adlib.c:#include "qemu-timer.h"
adlib.c:    OPLTimerOver (s->opl, n);
adlib.c:    s->ticking[n] = 0;
adlib.c:        if (s->ticking[i]) {
adlib.c:            delta = AUD_get_elapsed_usec_out (s->voice, &s->ats);
adlib.c:                s->dexp[i] / 1000000.0,
adlib.c:                delta >= s->dexp[i]
adlib.c:            if (ADLIB_KILL_TIMERS || delta >= s->dexp[i]) {
adlib.c:                AUD_init_time_stamp_out (s->voice, &s->ats);
adlib.c:    s->active = 1;
adlib.c:    AUD_set_active_out (s->voice, 1);
adlib.c:    status = OPLWrite (s->opl, a, val);
adlib.c:    data = OPLRead (s->opl, a);
adlib.c:        s->ticking[n] = 0;
adlib.c:    s->ticking[n] = 1;
adlib.c:    s->exp[n] = exp;
adlib.c:    s->dexp[n] = interval_Sec * 1000000.0;
adlib.c:    AUD_init_time_stamp_out (s->voice, &s->ats);
adlib.c:    int pos = s->pos;
adlib.c:            s->voice,
adlib.c:            s->mixbuf + (pos << (SHIFT - 1)),
adlib.c:            samples -= wsampl;
adlib.c:            pos = (pos + wsampl) % s->samples;
adlib.c:    if (!(s->active && s->enabled) || !samples) {
adlib.c:    to_play = audio_MIN (s->left, samples);
adlib.c:            s->left -= written;
adlib.c:            samples -= written;
adlib.c:            to_play -= written;
adlib.c:            s->pos = (s->pos + written) % s->samples;
adlib.c:    samples = audio_MIN (samples, s->samples - s->pos);
adlib.c:    YMF262UpdateOneQEMU (0, s->mixbuf + s->pos * 2, samples);
adlib.c:    YM3812UpdateOne (s->opl, s->mixbuf + s->pos, samples);
adlib.c:            samples -= written;
adlib.c:            s->pos = (s->pos + written) % s->samples;
adlib.c:            s->left = samples;
adlib.c:    if (s->opl) {
adlib.c:        OPLDestroy (s->opl);
adlib.c:        s->opl = NULL;
adlib.c:    if (s->mixbuf) {
adlib.c:        qemu_free (s->mixbuf);
adlib.c:    s->active = 0;
adlib.c:    s->enabled = 0;
adlib.c:    AUD_remove_card (&s->card);
adlib.c:        return -1;
adlib.c:        s->enabled = 1;
adlib.c:    s->opl = OPLCreate (OPL_TYPE_YM3812, 3579545, conf.freq);
adlib.c:    if (!s->opl) {
adlib.c:        return -1;
adlib.c:        OPLSetTimerHandler (s->opl, timer_handler, 0);
adlib.c:        s->enabled = 1;
adlib.c:    AUD_register_card ("adlib", &s->card);
adlib.c:    s->voice = AUD_open_out (
adlib.c:        &s->card,
adlib.c:        s->voice,
adlib.c:    if (!s->voice) {
adlib.c:        return -1;
adlib.c:    s->samples = AUD_get_buffer_size_out (s->voice) >> SHIFT;
adlib.c:    s->mixbuf = qemu_mallocz (s->samples << SHIFT);
ads7846.c:/* Control-byte bitfields */
ads7846.c:    if (s->interrupt)
ads7846.c:        qemu_set_irq(s->interrupt, s->pressure == 0);
ads7846.c:    switch (s->cycle ++) {
ads7846.c:            s->cycle = 0;
ads7846.c:        s->output = s->input[(value >> 4) & 7];
ads7846.c:        s->noise = (s->noise + 3) & 7;
ads7846.c:        case 1: s->output += s->noise ^ 2; break;
ads7846.c:        case 3: s->output += s->noise ^ 0; break;
ads7846.c:        case 4: s->output += s->noise ^ 7; break;
ads7846.c:        case 5: s->output += s->noise ^ 5; break;
ads7846.c:            s->output >>= 4;	/* 8 bits instead of 12 */
ads7846.c:        s->cycle = 0;
ads7846.c:    return s->output;
ads7846.c:        x = 0x7fff - x;
ads7846.c:        s->input[1] = ADS_XPOS(x, y);
ads7846.c:        s->input[3] = ADS_Z1POS(x, y);
ads7846.c:        s->input[4] = ADS_Z2POS(x, y);
ads7846.c:        s->input[5] = ADS_YPOS(x, y);
ads7846.c:    if (s->pressure == !buttons_state) {
ads7846.c:        s->pressure = !!buttons_state;
ads7846.c:        qemu_put_be32(f, s->input[i]);
ads7846.c:    qemu_put_be32(f, s->noise);
ads7846.c:    qemu_put_be32(f, s->cycle);
ads7846.c:    qemu_put_be32(f, s->output);
ads7846.c:        s->input[i] = qemu_get_be32(f);
ads7846.c:    s->noise = qemu_get_be32(f);
ads7846.c:    s->cycle = qemu_get_be32(f);
ads7846.c:    s->output = qemu_get_be32(f);
ads7846.c:    s->pressure = 0;
ads7846.c:    qdev_init_gpio_out(&dev->qdev, &s->interrupt, 1);
ads7846.c:    s->input[0] = ADS_TEMP0;	/* TEMP0 */
ads7846.c:    s->input[2] = ADS_VBAT;	/* VBAT */
ads7846.c:    s->input[6] = ADS_VAUX;	/* VAUX */
ads7846.c:    s->input[7] = ADS_TEMP1;	/* TEMP1 */
ads7846.c:                    "QEMU ADS7846-driven Touchscreen");
ads7846.c:    register_savevm("ads7846", -1, 0, ads7846_save, ads7846_load, s);
alpha_palcode.c: *  Alpha emulation - PALcode emulation for qemu.
alpha_palcode.c:#include "exec-all.h"
alpha_palcode.c:        env->pal_handler = pal_handler;
alpha_palcode.c:        env->ipr[IPR_PAL_BASE] = -1ULL;
alpha_palcode.c:        (*pal_handler->reset)(env);
alpha_palcode.c:        env->ir[0] = 1;
alpha_palcode.c:        env->pal_handler = NULL;
alpha_palcode.c:        env->ipr[IPR_PAL_BASE] = palid;
alpha_palcode.c:        env->pc = env->ipr[IPR_PAL_BASE];
alpha_palcode.c:        if (!(env->ps >> 3)) {
alpha_palcode.c:        /* Implemented as no-op */
alpha_palcode.c:        palid = env->ir[16];
alpha_palcode.c:        /* Implemented as no-op */
alpha_palcode.c:        if (!(env->ps >> 3)) {
alpha_palcode.c:        /* Implemented as no-op */
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        palid = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        /* Implemented as no-op */
alpha_palcode.c:        if (!(env->ps >> 3)) {
alpha_palcode.c:        /* Implemented as no-op */
alpha_palcode.c:        palid = env->ir[16];
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        val = env->ir[16];
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:            env->ir[0] = val;
alpha_palcode.c:        /* Implemented as no-op */
alpha_palcode.c:    pal_handler_t *pal_handler = env->pal_handler;
alpha_palcode.c:    switch (env->exception_index) {
alpha_palcode.c:        (*pal_handler->reset)(env);
alpha_palcode.c:        (*pal_handler->machine_check)(env);
alpha_palcode.c:        (*pal_handler->arithmetic)(env);
alpha_palcode.c:        (*pal_handler->interrupt)(env);
alpha_palcode.c:        (*pal_handler->dfault)(env);
alpha_palcode.c:        (*pal_handler->dtb_miss_pal)(env);
alpha_palcode.c:        (*pal_handler->dtb_miss_native)(env);
alpha_palcode.c:        (*pal_handler->unalign)(env);
alpha_palcode.c:        (*pal_handler->itb_miss)(env);
alpha_palcode.c:        (*pal_handler->itb_acv)(env);
alpha_palcode.c:        (*pal_handler->opcdec)(env);
alpha_palcode.c:        (*pal_handler->fen)(env);
alpha_palcode.c:        if (env->exception_index >= EXCP_CALL_PAL &&
alpha_palcode.c:            env->exception_index < EXCP_CALL_PALP) {
alpha_palcode.c:            (*pal_handler->call_pal)
alpha_palcode.c:                (env, (env->exception_index - EXCP_CALL_PAL) >> 6);
alpha_palcode.c:        } else if (env->exception_index >= EXCP_CALL_PALP &&
alpha_palcode.c:                   env->exception_index < EXCP_CALL_PALE) {
alpha_palcode.c:            (*pal_handler->call_pal)
alpha_palcode.c:                (env, ((env->exception_index - EXCP_CALL_PALP) >> 6) + 0x80);
alpha_palcode.c:    env->ipr[IPR_EXC_ADDR] &= ~1;
alpha_palcode.c:    if ((env->features & FEATURE_VIRBND)) {
alpha_palcode.c:    page_mask = (1ULL << page_bits) - 1ULL;
alpha_palcode.c:    lvl_bits = page_bits - 3;
alpha_palcode.c:    lvl_mask = (1ULL << lvl_bits) - 1ULL;
alpha_palcode.c:    sva = ((int64_t)(virtual << (64 - VA_BITS))) >> (64 - VA_BITS);
alpha_palcode.c:        seg = -1;
alpha_palcode.c:        seg = sva >> (VA_BITS - 2);
alpha_palcode.c:    virtual &= ~(0xFFFFFC0000000000ULL << (VA_BITS - 43));
alpha_palcode.c:        address &= ~(page_size - 1);
alpha_palcode.c:        env->exception_index = EXCP_DFAULT;
alpha_palcode.c:        env->ipr[IPR_EXC_ADDR] = address;
alpha_palcode.c:        env->exception_index = EXCP_ACCESS_VIOLATION;
alpha_palcode.c:        env->ipr[IPR_EXC_ADDR] = address;
alpha_palcode.c:        env->exception_index = EXCP_FAULT_ON_READ;
alpha_palcode.c:        env->ipr[IPR_EXC_ADDR] = address;
alpha_palcode.c:        env->exception_index = EXCP_FAULT_ON_EXECUTE;
alpha_palcode.c:        env->ipr[IPR_EXC_ADDR] = address;
alpha_palcode.c:        env->exception_index = EXCP_FAULT_ON_WRITE;
alpha_palcode.c:        env->ipr[IPR_EXC_ADDR] = address;
alpha_palcode.c:        env->exception_index = EXCP_MCHK;
alpha_palcode.c:        env->ipr[IPR_EXC_ADDR] = address;
alpha_palcode.c:        qemu_log("CALLSYS n " TARGET_FMT_ld "\n", env->ir[0]);
alpha_palcode.c:        ret = do_syscall(env, env->ir[IR_V0], env->ir[IR_A0], env->ir[IR_A1],
alpha_palcode.c:                         env->ir[IR_A2], env->ir[IR_A3], env->ir[IR_A4],
alpha_palcode.c:                         env->ir[IR_A5]);
alpha_palcode.c:            env->ir[IR_A3] = 0;
alpha_palcode.c:            env->ir[IR_V0] = ret;
alpha_palcode.c:            env->ir[IR_A3] = 1;
alpha_palcode.c:            env->ir[IR_V0] = -ret;
alpha_palcode.c:        env->ir[IR_V0] = env->unique;
alpha_palcode.c:        qemu_log("RDUNIQUE: " TARGET_FMT_lx "\n", env->unique);
alpha_palcode.c:        env->unique = env->ir[IR_A0];
alpha_palcode.c:        qemu_log("WRUNIQUE: " TARGET_FMT_lx "\n", env->unique);
an5206.c:    env->vbr = 0;
an5206.c:    env->mbar = AN5206_MBAR_ADDR | 1;
an5206.c:    env->rambar0 = AN5206_RAMBAR_ADDR | 1;
an5206.c:                                          ram_size - KERNEL_LOAD_ADDR);
an5206.c:    env->pc = entry;
apb_pci.c: * http://www.sun.com/processors/manuals/805-0087.pdf
apb_pci.c: * http://www.sun.com/processors/manuals/805-1251.pdf
apb_pci.c:    return ((pci_dev->devfn & 0x18) >> 1) + irq_num;
apb_pci.c:    if (pci_dev->devfn & 1)
apb_pci.c:     * According to manual (805-1251.pdf).
apb_pci.c:    pci_set_word(dev->config + PCI_COMMAND,
apb_pci.c:    dev->config[PCI_LATENCY_TIMER] = 0x10;
apb_pci.c:    dev->config[PCI_HEADER_TYPE] |= PCI_HEADER_TYPE_MULTI_FUNCTION;
apb_pci.c:    /* mem_config: XXX size should be 4G-prom */
apb_pci.c:    d->host_state.bus = pci_register_bus(&d->busdev.qdev, "pci",
apb_pci.c:    pci_create_simple(d->host_state.bus, 0, "pbm");
apb_pci.c:    *bus2 = pci_bridge_init(d->host_state.bus, PCI_DEVFN(1, 0),
apb_pci.c:    *bus3 = pci_bridge_init(d->host_state.bus, PCI_DEVFN(1, 1),
apb_pci.c:    return d->host_state.bus;
apb_pci.c:    pci_mem_config = pci_host_conf_register_mmio(&s->host_state);
apb_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
apb_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_SUN);
apb_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_SUN_SABRE);
apb_pci.c:    d->config[0x04] = 0x06; // command = bus master, pci mem
apb_pci.c:    d->config[0x05] = 0x00;
apb_pci.c:    d->config[0x06] = 0xa0; // status = fast back-to-back, 66MHz, no error
apb_pci.c:    d->config[0x07] = 0x03; // status = medium devsel
apb_pci.c:    d->config[0x08] = 0x00; // revision
apb_pci.c:    d->config[0x09] = 0x00; // programming i/f
apb_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
apb_pci.c:    d->config[0x0D] = 0x10; // latency_timer
apb_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
apb_pci.h:#include "qemu-common.h"
apic.c: *  Copyright (c) 2004-2005 Fabrice Bellard
apic.c:#include "qemu-timer.h"
apic.c:#include "host-utils.h"
apic.c:#include "qemu-kvm.h"
apic.c:    return 31 - clz32(value);
apic.c:    APICState *s = env->apic_state;
apic.c:    uint32_t lvt = s->lvt[vector];
apic.c:        APICState *s = env->apic_state;
apic.c:        uint32_t lvt = s->lvt[APIC_LVT_LINT0];
apic.c:            reset_bit(s->irr, lvt & 0xff);
apic.c:                d = -1;
apic.c:                cpu_interrupt(apic_iter->cpu_env, CPU_INTERRUPT_SMI) );
apic.c:                cpu_interrupt(apic_iter->cpu_env, CPU_INTERRUPT_NMI) );
apic.c:                         cpu_interrupt(apic_iter->cpu_env, CPU_INTERRUPT_INIT) );
apic.c:    APICState *s = env->apic_state;
apic.c:        s->apicbase = val;
apic.c:        s->apicbase = (val & 0xfffff000) |
apic.c:            (s->apicbase & (MSR_IA32_APICBASE_BSP | MSR_IA32_APICBASE_ENABLE));
apic.c:        s->apicbase &= ~MSR_IA32_APICBASE_ENABLE;
apic.c:        env->cpuid_features &= ~CPUID_APIC;
apic.c:        s->spurious_vec &= ~APIC_SV_ENABLE;
apic.c:    APICState *s = env->apic_state;
apic.c:           s ? (uint64_t)s->apicbase: 0);
apic.c:    return s ? s->apicbase : 0;
apic.c:    APICState *s = env->apic_state;
apic.c:    s->tpr = (val & 0x0f) << 4;
apic.c:    APICState *s = env->apic_state;
apic.c:    return s ? s->tpr >> 4 : 0;
apic.c:/* return -1 if no bit is set */
apic.c:    for(i = 7; i >= 0; i--) {
apic.c:    return -1;
apic.c:    tpr = (s->tpr >> 4);
apic.c:    isrv = get_highest_priority_int(s->isr);
apic.c:        ppr = s->tpr;
apic.c:    if (!(s->spurious_vec & APIC_SV_ENABLE))
apic.c:    irrv = get_highest_priority_int(s->irr);
apic.c:    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
apic.c:    apic_irq_delivered += !get_bit(s->irr, vector_num);
apic.c:    set_bit(s->irr, vector_num);
apic.c:        set_bit(s->tmr, vector_num);
apic.c:        reset_bit(s->tmr, vector_num);
apic.c:    isrv = get_highest_priority_int(s->isr);
apic.c:    reset_bit(s->isr, isrv);
apic.c:    if (apic && apic->id == dest)
apic.c:        return dest;  /* shortcut in case apic->id == apic->idx */
apic.c:	if (apic && apic->id == dest)
apic.c:    return -1;
apic.c:                if (apic_iter->dest_mode == 0xf) {
apic.c:                    if (dest & apic_iter->log_dest)
apic.c:                } else if (apic_iter->dest_mode == 0x0) {
apic.c:                    if ((dest & 0xf0) == (apic_iter->log_dest & 0xf0) &&
apic.c:                        (dest & apic_iter->log_dest & 0x0f)) {
apic.c:    APICState *s = env->apic_state;
apic.c:    s->tpr = 0;
apic.c:    s->spurious_vec = 0xff;
apic.c:    s->log_dest = 0;
apic.c:    s->dest_mode = 0xf;
apic.c:    memset(s->isr, 0, sizeof(s->isr));
apic.c:    memset(s->tmr, 0, sizeof(s->tmr));
apic.c:    memset(s->irr, 0, sizeof(s->irr));
apic.c:        s->lvt[i] = 1 << 16; /* mask LVT */
apic.c:    s->esr = 0;
apic.c:    memset(s->icr, 0, sizeof(s->icr));
apic.c:    s->divide_conf = 0;
apic.c:    s->count_shift = 0;
apic.c:    s->initial_count = 0;
apic.c:    s->initial_count_load_time = 0;
apic.c:    s->next_time = 0;
apic.c:    s->wait_for_sipi = 1;
apic.c:    env->halted = !(s->apicbase & MSR_IA32_APICBASE_BSP);
apic.c:        env->mp_state
apic.c:            = env->halted ? KVM_MP_STATE_UNINITIALIZED : KVM_MP_STATE_RUNNABLE;
apic.c:    s->sipi_vector = vector_num;
apic.c:    cpu_interrupt(s->cpu_env, CPU_INTERRUPT_SIPI);
apic.c:    APICState *s = env->apic_state;
apic.c:    if (!s->wait_for_sipi)
apic.c:    env->eip = 0;
apic.c:    cpu_x86_load_seg_cache(env, R_CS, s->sipi_vector << 8, s->sipi_vector << 12,
apic.c:                           env->segs[R_CS].limit, env->segs[R_CS].flags);
apic.c:    env->halted = 0;
apic.c:    s->wait_for_sipi = 0;
apic.c:    int dest_shorthand = (s->icr[0] >> 18) & 3;
apic.c:        set_bit(deliver_bitmask, s->idx);
apic.c:        reset_bit(deliver_bitmask, s->idx);
apic.c:                int trig_mode = (s->icr[0] >> 15) & 1;
apic.c:                int level = (s->icr[0] >> 14) & 1;
apic.c:                                 apic_iter->arb_id = apic_iter->id );
apic.c:    APICState *s = env->apic_state;
apic.c:        return -1;
apic.c:    if (!(s->spurious_vec & APIC_SV_ENABLE))
apic.c:        return -1;
apic.c:    intno = get_highest_priority_int(s->irr);
apic.c:        return -1;
apic.c:    if (s->tpr && intno <= s->tpr)
apic.c:        return s->spurious_vec & 0xff;
apic.c:    reset_bit(s->irr, intno);
apic.c:    set_bit(s->isr, intno);
apic.c:    APICState *s = env->apic_state;
apic.c:        return -1;
apic.c:    lvt0 = s->lvt[APIC_LVT_LINT0];
apic.c:    if ((s->apicbase & MSR_IA32_APICBASE_ENABLE) == 0 ||
apic.c:    d = (qemu_get_clock(vm_clock) - s->initial_count_load_time) >>
apic.c:        s->count_shift;
apic.c:    if (s->lvt[APIC_LVT_TIMER] & APIC_LVT_TIMER_PERIODIC) {
apic.c:        val = s->initial_count - (d % ((uint64_t)s->initial_count + 1));
apic.c:        if (d >= s->initial_count)
apic.c:            val = s->initial_count - d;
apic.c:    if (!(s->lvt[APIC_LVT_TIMER] & APIC_LVT_MASKED)) {
apic.c:        d = (current_time - s->initial_count_load_time) >>
apic.c:            s->count_shift;
apic.c:        if (s->lvt[APIC_LVT_TIMER] & APIC_LVT_TIMER_PERIODIC) {
apic.c:            if (!s->initial_count)
apic.c:            d = ((d / ((uint64_t)s->initial_count + 1)) + 1) * ((uint64_t)s->initial_count + 1);
apic.c:            if (d >= s->initial_count)
apic.c:            d = (uint64_t)s->initial_count + 1;
apic.c:        next_time = s->initial_count_load_time + (d << s->count_shift);
apic.c:        qemu_mod_timer(s->timer, next_time);
apic.c:        s->next_time = next_time;
apic.c:        qemu_del_timer(s->timer);
apic.c:    apic_local_deliver(s->cpu_env, APIC_LVT_TIMER);
apic.c:    apic_timer_update(s, s->next_time);
apic.c:    s = env->apic_state;
apic.c:        val = s->id << 24;
apic.c:        val = 0x11 | ((APIC_LVT_NB - 1) << 16); /* version 0x11 */
apic.c:        val = s->tpr;
apic.c:        val = s->log_dest << 24;
apic.c:        val = s->dest_mode << 28;
apic.c:        val = s->spurious_vec;
apic.c:        val = s->isr[index & 7];
apic.c:        val = s->tmr[index & 7];
apic.c:        val = s->irr[index & 7];
apic.c:        val = s->esr;
apic.c:        val = s->icr[index & 1];
apic.c:        val = s->lvt[index - 0x32];
apic.c:        val = s->initial_count;
apic.c:        val = s->divide_conf;
apic.c:        s->esr |= ESR_ILLEGAL_ADDRESS;
apic.c:    s = env->apic_state;
apic.c:        s->id = (val >> 24);
apic.c:        s->tpr = val;
apic.c:        s->log_dest = val >> 24;
apic.c:        s->dest_mode = val >> 28;
apic.c:        s->spurious_vec = val & 0x1ff;
apic.c:        s->icr[0] = val;
apic.c:        apic_deliver(s, (s->icr[1] >> 24) & 0xff, (s->icr[0] >> 11) & 1,
apic.c:                     (s->icr[0] >> 8) & 7, (s->icr[0] & 0xff),
apic.c:                     (s->icr[0] >> 14) & 1, (s->icr[0] >> 15) & 1);
apic.c:        s->icr[1] = val;
apic.c:            int n = index - 0x32;
apic.c:            s->lvt[n] = val;
apic.c:        s->initial_count = val;
apic.c:        s->initial_count_load_time = qemu_get_clock(vm_clock);
apic.c:        apic_timer_update(s, s->initial_count_load_time);
apic.c:            s->divide_conf = val & 0xb;
apic.c:            v = (s->divide_conf & 3) | ((s->divide_conf >> 1) & 4);
apic.c:            s->count_shift = (v + 1) & 7;
apic.c:        s->esr |= ESR_ILLEGAL_ADDRESS;
apic.c:    return *((uint32_t *) (kapic->regs + (reg_id << 4)));
apic.c:    *((uint32_t *) (kapic->regs + (reg_id << 4))) = val;
apic.c:    kvm_get_lapic(s->cpu_env, kapic);
apic.c:    s->id = kapic_reg(kapic, 0x2) >> 24;
apic.c:    s->tpr = kapic_reg(kapic, 0x8);
apic.c:    s->arb_id = kapic_reg(kapic, 0x9);
apic.c:    s->log_dest = kapic_reg(kapic, 0xd) >> 24;
apic.c:    s->dest_mode = kapic_reg(kapic, 0xe) >> 28;
apic.c:    s->spurious_vec = kapic_reg(kapic, 0xf);
apic.c:        s->isr[i] = kapic_reg(kapic, 0x10 + i);
apic.c:        s->tmr[i] = kapic_reg(kapic, 0x18 + i);
apic.c:        s->irr[i] = kapic_reg(kapic, 0x20 + i);
apic.c:    s->esr = kapic_reg(kapic, 0x28);
apic.c:    s->icr[0] = kapic_reg(kapic, 0x30);
apic.c:    s->icr[1] = kapic_reg(kapic, 0x31);
apic.c:	s->lvt[i] = kapic_reg(kapic, 0x32 + i);
apic.c:    s->initial_count = kapic_reg(kapic, 0x38);
apic.c:    s->divide_conf = kapic_reg(kapic, 0x3e);
apic.c:    v = (s->divide_conf & 3) | ((s->divide_conf >> 1) & 4);
apic.c:    s->count_shift = (v + 1) & 7;
apic.c:    s->initial_count_load_time = qemu_get_clock(vm_clock);
apic.c:    apic_timer_update(s, s->initial_count_load_time);
apic.c:    kapic_set_reg(klapic, 0x2, s->id << 24);
apic.c:    kapic_set_reg(klapic, 0x8, s->tpr);
apic.c:    kapic_set_reg(klapic, 0xd, s->log_dest << 24);
apic.c:    kapic_set_reg(klapic, 0xe, s->dest_mode << 28 | 0x0fffffff);
apic.c:    kapic_set_reg(klapic, 0xf, s->spurious_vec);
apic.c:        kapic_set_reg(klapic, 0x10 + i, s->isr[i]);
apic.c:        kapic_set_reg(klapic, 0x18 + i, s->tmr[i]);
apic.c:        kapic_set_reg(klapic, 0x20 + i, s->irr[i]);
apic.c:    kapic_set_reg(klapic, 0x28, s->esr);
apic.c:    kapic_set_reg(klapic, 0x30, s->icr[0]);
apic.c:    kapic_set_reg(klapic, 0x31, s->icr[1]);
apic.c:        kapic_set_reg(klapic, 0x32 + i, s->lvt[i]);
apic.c:    kapic_set_reg(klapic, 0x38, s->initial_count);
apic.c:    kapic_set_reg(klapic, 0x3e, s->divide_conf);
apic.c:    kvm_set_lapic(s->cpu_env, klapic);
apic.c:        kvm_kernel_lapic_load_from_user(env->apic_state);
apic.c:        return -EINVAL;
apic.c:    qemu_get_be32s(f, &s->apicbase);
apic.c:    qemu_get_8s(f, &s->id);
apic.c:    qemu_get_8s(f, &s->arb_id);
apic.c:    qemu_get_8s(f, &s->tpr);
apic.c:    qemu_get_be32s(f, &s->spurious_vec);
apic.c:    qemu_get_8s(f, &s->log_dest);
apic.c:    qemu_get_8s(f, &s->dest_mode);
apic.c:        qemu_get_be32s(f, &s->isr[i]);
apic.c:        qemu_get_be32s(f, &s->tmr[i]);
apic.c:        qemu_get_be32s(f, &s->irr[i]);
apic.c:        qemu_get_be32s(f, &s->lvt[i]);
apic.c:    qemu_get_be32s(f, &s->esr);
apic.c:    qemu_get_be32s(f, &s->icr[0]);
apic.c:    qemu_get_be32s(f, &s->icr[1]);
apic.c:    qemu_get_be32s(f, &s->divide_conf);
apic.c:    s->count_shift=qemu_get_be32(f);
apic.c:    qemu_get_be32s(f, &s->initial_count);
apic.c:    s->initial_count_load_time=qemu_get_be64(f);
apic.c:    s->next_time=qemu_get_be64(f);
apic.c:        qemu_get_timer(f, s->timer);
apic.c:    qemu_kvm_load_lapic(s->cpu_env);
apic.c:    cpu_synchronize_state(s->cpu_env);
apic.c:    bsp = cpu_is_bsp(s->cpu_env);
apic.c:    s->apicbase = 0xfee00000 |
apic.c:    cpu_reset(s->cpu_env);
apic.c:    apic_init_reset(s->cpu_env);
apic.c:        s->lvt[APIC_LVT_LINT0] = 0x700;
apic.c:    qemu_kvm_load_lapic(s->cpu_env);
apic.c:        return -1;
apic.c:    env->apic_state = s;
apic.c:    s->idx = last_apic_idx++;
apic.c:    s->id = env->cpuid_apic_id;
apic.c:    s->cpu_env = env;
apic.c:        /* NOTE: the APIC is directly connected to the CPU - it is not
apic.c:    s->timer = qemu_new_timer(vm_clock, apic_timer, s);
apic.c:    vmstate_register(s->idx, &vmstate_apic, s);
apic.c:     * registers, in qemu-kvm.
apic.c:    local_apics[s->idx] = s;
arm11mpcore.c: * Copyright (c) 2006-2007 CodeSourcery.
arm11mpcore.c:/* ??? The MPCore TRM says the on-chip controller has 224 external IRQ lines
arm11mpcore.c:   are fed into a single SMP-aware interrupt controller on the CPU.  */
arm11mpcore.c:    -1, -1, -1, -1,  1,  2, -1, -1,
arm11mpcore.c:    -1, -1,  6, -1,  4,  5, -1, -1,
arm11mpcore.c:    -1, 14, 15,  0,  7,  8, -1, -1,
arm11mpcore.c:    -1, -1, -1, -1,  9,  3, -1, -1,
arm11mpcore.c:        qemu_set_irq(s->rvic[i][irq], level);
arm11mpcore.c:            qemu_set_irq(s->cpuic[irq], level);
arm11mpcore.c:    sysbus_mmio_map(s->priv, 0, base);
arm11mpcore.c:    qdev_prop_set_uint32(priv, "num-cpu", s->num_cpu);
arm11mpcore.c:    s->priv = sysbus_from_qdev(priv);
arm11mpcore.c:    sysbus_pass_irq(dev, s->priv);
arm11mpcore.c:        s->cpuic[i] = qdev_get_gpio_in(priv, i);
arm11mpcore.c:                                   s->cpuic[10 + n]);
arm11mpcore.c:            s->rvic[n][i] = qdev_get_gpio_in(gic, i);
arm11mpcore.c:    qdev_init_gpio_in(&dev->qdev, mpcore_rirq_set_irq, 64);
arm11mpcore.c:        DEFINE_PROP_UINT32("num-cpu", mpcore_rirq_state, num_cpu, 1),
arm11mpcore.c:        DEFINE_PROP_UINT32("num-cpu", mpcore_priv_state, num_cpu, 1),
arm_boot.c: * Copyright (c) 2006-2007 CodeSourcery.
arm_boot.c:#include "arm-misc.h"
arm_boot.c:/* The worlds second smallest bootloader.  Set r0-r2, then jump to kernel.  */
arm_boot.c:    WRITE_WORD(p, info->ram_size);
arm_boot.c:    WRITE_WORD(p, info->loader_start);
arm_boot.c:        WRITE_WORD(p, info->loader_start + INITRD_LOAD_ADDR);
arm_boot.c:    if (info->kernel_cmdline && *info->kernel_cmdline) {
arm_boot.c:        cmdline_size = strlen(info->kernel_cmdline);
arm_boot.c:        cpu_physical_memory_write(p + 8, (void *)info->kernel_cmdline,
arm_boot.c:    if (info->atag_board) {
arm_boot.c:        atag_board_len = (info->atag_board(info, atag_board_buf) + 3) & ~3;
arm_boot.c:    /* see linux/include/asm-arm/setup.h */
arm_boot.c:    WRITE_WORD(p, info->ram_size / 4096);
arm_boot.c:        WRITE_WORD(p, info->loader_start + INITRD_LOAD_ADDR);
arm_boot.c:    s = info->kernel_cmdline;
arm_boot.c:    struct arm_boot_info *info = env->boot_info;
arm_boot.c:        if (!info->is_linux) {
arm_boot.c:            env->regs[15] = info->entry & 0xfffffffe;
arm_boot.c:            env->thumb = info->entry & 1;
arm_boot.c:                set_kernel_args_old(info, info->initrd_size,
arm_boot.c:                                    info->loader_start);
arm_boot.c:                set_kernel_args(info, info->initrd_size, info->loader_start);
arm_boot.c:    if (!info->kernel_filename) {
arm_boot.c:    if (info->nb_cpus == 0)
arm_boot.c:        info->nb_cpus = 1;
arm_boot.c:    env->boot_info = info;
arm_boot.c:    kernel_size = load_elf(info->kernel_filename, 0, &elf_entry, NULL, NULL,
arm_boot.c:        kernel_size = load_uimage(info->kernel_filename, &entry, NULL,
arm_boot.c:        entry = info->loader_start + KERNEL_LOAD_ADDR;
arm_boot.c:        kernel_size = load_image_targphys(info->kernel_filename, entry,
arm_boot.c:                                          ram_size - KERNEL_LOAD_ADDR);
arm_boot.c:                info->kernel_filename);
arm_boot.c:    info->entry = entry;
arm_boot.c:        if (info->initrd_filename) {
arm_boot.c:            initrd_size = load_image_targphys(info->initrd_filename,
arm_boot.c:                                              info->loader_start
arm_boot.c:                                              ram_size - INITRD_LOAD_ADDR);
arm_boot.c:                        info->initrd_filename);
arm_boot.c:        bootloader[1] |= info->board_id & 0xff;
arm_boot.c:        bootloader[2] |= (info->board_id >> 8) & 0xff;
arm_boot.c:        bootloader[5] = info->loader_start + KERNEL_ARGS_ADDR;
arm_boot.c:                           info->loader_start);
arm_boot.c:        if (info->nb_cpus > 1) {
arm_boot.c:            smpboot[10] = info->smp_priv_base;
arm_boot.c:                               info->smp_loader_start);
arm_boot.c:        info->initrd_size = initrd_size;
arm_boot.c:    info->is_linux = is_linux;
arm_gic.c: * Copyright (c) 2006-2007 CodeSourcery.
arm_gic.c:   controller, MPCore distributed interrupt controller and ARMv7-M
arm_gic.c:       for per-cpu interrupts.  This seems strange.  */
arm_gic.c:#define ALL_CPU_MASK ((1 << NCPU) - 1)
arm_gic.c:#define NUM_CPU(s) ((s)->num_cpu)
arm_gic.c:#define GIC_SET_ENABLED(irq) s->irq_state[irq].enabled = 1
arm_gic.c:#define GIC_CLEAR_ENABLED(irq) s->irq_state[irq].enabled = 0
arm_gic.c:#define GIC_TEST_ENABLED(irq) s->irq_state[irq].enabled
arm_gic.c:#define GIC_SET_PENDING(irq, cm) s->irq_state[irq].pending |= (cm)
arm_gic.c:#define GIC_CLEAR_PENDING(irq, cm) s->irq_state[irq].pending &= ~(cm)
arm_gic.c:#define GIC_TEST_PENDING(irq, cm) ((s->irq_state[irq].pending & (cm)) != 0)
arm_gic.c:#define GIC_SET_ACTIVE(irq, cm) s->irq_state[irq].active |= (cm)
arm_gic.c:#define GIC_CLEAR_ACTIVE(irq, cm) s->irq_state[irq].active &= ~(cm)
arm_gic.c:#define GIC_TEST_ACTIVE(irq, cm) ((s->irq_state[irq].active & (cm)) != 0)
arm_gic.c:#define GIC_SET_MODEL(irq) s->irq_state[irq].model = 1
arm_gic.c:#define GIC_CLEAR_MODEL(irq) s->irq_state[irq].model = 0
arm_gic.c:#define GIC_TEST_MODEL(irq) s->irq_state[irq].model
arm_gic.c:#define GIC_SET_LEVEL(irq, cm) s->irq_state[irq].level = (cm)
arm_gic.c:#define GIC_CLEAR_LEVEL(irq, cm) s->irq_state[irq].level &= ~(cm)
arm_gic.c:#define GIC_TEST_LEVEL(irq, cm) ((s->irq_state[irq].level & (cm)) != 0)
arm_gic.c:#define GIC_SET_TRIGGER(irq) s->irq_state[irq].trigger = 1
arm_gic.c:#define GIC_CLEAR_TRIGGER(irq) s->irq_state[irq].trigger = 0
arm_gic.c:#define GIC_TEST_TRIGGER(irq) s->irq_state[irq].trigger
arm_gic.c:  (((irq) < 32) ? s->priority1[irq][cpu] : s->priority2[(irq) - 32])
arm_gic.c:#define GIC_TARGET(irq) s->irq_target[irq]
arm_gic.c:    int priority2[GIC_NIRQ - 32];
arm_gic.c:        s->current_pending[cpu] = 1023;
arm_gic.c:        if (!s->enabled || !s->cpu_enabled[cpu]) {
arm_gic.c:	    qemu_irq_lower(s->parent_irq[cpu]);
arm_gic.c:        if (best_prio <= s->priority_mask[cpu]) {
arm_gic.c:            s->current_pending[cpu] = best_irq;
arm_gic.c:            if (best_prio < s->running_priority[cpu]) {
arm_gic.c:        qemu_set_irq(s->parent_irq[cpu], level);
arm_gic.c:    s->running_irq[cpu] = irq;
arm_gic.c:        s->running_priority[cpu] = 0x100;
arm_gic.c:        s->running_priority[cpu] = GIC_GET_PRIORITY(irq, cpu);
arm_gic.c:    new_irq = s->current_pending[cpu];
arm_gic.c:            || GIC_GET_PRIORITY(new_irq, cpu) >= s->running_priority[cpu]) {
arm_gic.c:    s->last_active[new_irq][cpu] = s->running_irq[cpu];
arm_gic.c:    if (s->running_irq[cpu] == 1023)
arm_gic.c:    if (irq != s->running_irq[cpu]) {
arm_gic.c:        int tmp = s->running_irq[cpu];
arm_gic.c:        while (s->last_active[tmp][cpu] != 1023) {
arm_gic.c:            if (s->last_active[tmp][cpu] == irq) {
arm_gic.c:                s->last_active[tmp][cpu] = s->last_active[irq][cpu];
arm_gic.c:            tmp = s->last_active[tmp][cpu];
arm_gic.c:        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);
arm_gic.c:            return s->enabled;
arm_gic.c:            return ((GIC_NIRQ / 32) - 1) | ((NUM_CPU(s) - 1) << 5);
arm_gic.c:            irq = (offset - 0x100) * 8;
arm_gic.c:            irq = (offset - 0x180) * 8;
arm_gic.c:            irq = (offset - 0x200) * 8;
arm_gic.c:            irq = (offset - 0x280) * 8;
arm_gic.c:        irq = (offset - 0x300) * 8 + GIC_BASE_IRQ;
arm_gic.c:        irq = (offset - 0x400) + GIC_BASE_IRQ;
arm_gic.c:        irq = (offset - 0x800) + GIC_BASE_IRQ;
arm_gic.c:        irq = (offset - 0xc00) * 2 + GIC_BASE_IRQ;
arm_gic.c:            res = gic_id[(offset - 0xfe0) >> 2];
arm_gic.c:            s->enabled = (value & 1);
arm_gic.c:            DPRINTF("Distribution %sabled\n", s->enabled ? "En" : "Dis");
arm_gic.c:        irq = (offset - 0x100) * 8 + GIC_BASE_IRQ;
arm_gic.c:        irq = (offset - 0x180) * 8 + GIC_BASE_IRQ;
arm_gic.c:        irq = (offset - 0x200) * 8 + GIC_BASE_IRQ;
arm_gic.c:        irq = (offset - 0x280) * 8 + GIC_BASE_IRQ;
arm_gic.c:               for per-CPU interrupts.  It's unclear whether this is the
arm_gic.c:        irq = (offset - 0x400) + GIC_BASE_IRQ;
arm_gic.c:            s->priority1[irq][cpu] = value;
arm_gic.c:            s->priority2[irq - 32] = value;
arm_gic.c:        irq = (offset - 0x800) + GIC_BASE_IRQ;
arm_gic.c:        s->irq_target[irq] = value & ALL_CPU_MASK;
arm_gic.c:        irq = (offset - 0xc00) * 4 + GIC_BASE_IRQ;
arm_gic.c:        /* 0xf00 is only handled for 32-bit writes.  */
arm_gic.c:        return s->cpu_enabled[cpu];
arm_gic.c:        return s->priority_mask[cpu];
arm_gic.c:        return s->running_priority[cpu];
arm_gic.c:        return s->current_pending[cpu];
arm_gic.c:        s->cpu_enabled[cpu] = (value & 1);
arm_gic.c:        DPRINTF("CPU %d %sabled\n", cpu, s->cpu_enabled ? "En" : "Dis");
arm_gic.c:        s->priority_mask[cpu] = (value & 0xff);
arm_gic.c:    memset(s->irq_state, 0, GIC_NIRQ * sizeof(gic_irq_state));
arm_gic.c:        s->priority_mask[i] = 0xf0;
arm_gic.c:        s->current_pending[i] = 1023;
arm_gic.c:        s->running_irq[i] = 1023;
arm_gic.c:        s->running_priority[i] = 0x100;
arm_gic.c:        /* The NVIC doesn't have per-cpu interfaces, so enable by default.  */
arm_gic.c:        s->cpu_enabled[i] = 1;
arm_gic.c:        s->cpu_enabled[i] = 0;
arm_gic.c:    s->enabled = 1;
arm_gic.c:    s->enabled = 0;
arm_gic.c:    qemu_put_be32(f, s->enabled);
arm_gic.c:        qemu_put_be32(f, s->cpu_enabled[i]);
arm_gic.c:        qemu_put_be32(f, s->irq_target[i]);
arm_gic.c:            qemu_put_be32(f, s->priority1[j][i]);
arm_gic.c:            qemu_put_be32(f, s->last_active[j][i]);
arm_gic.c:        qemu_put_be32(f, s->priority_mask[i]);
arm_gic.c:        qemu_put_be32(f, s->running_irq[i]);
arm_gic.c:        qemu_put_be32(f, s->running_priority[i]);
arm_gic.c:        qemu_put_be32(f, s->current_pending[i]);
arm_gic.c:    for (i = 0; i < GIC_NIRQ - 32; i++) {
arm_gic.c:        qemu_put_be32(f, s->priority2[i]);
arm_gic.c:        qemu_put_byte(f, s->irq_state[i].enabled);
arm_gic.c:        qemu_put_byte(f, s->irq_state[i].pending);
arm_gic.c:        qemu_put_byte(f, s->irq_state[i].active);
arm_gic.c:        qemu_put_byte(f, s->irq_state[i].level);
arm_gic.c:        qemu_put_byte(f, s->irq_state[i].model);
arm_gic.c:        qemu_put_byte(f, s->irq_state[i].trigger);
arm_gic.c:        return -EINVAL;
arm_gic.c:    s->enabled = qemu_get_be32(f);
arm_gic.c:        s->cpu_enabled[i] = qemu_get_be32(f);
arm_gic.c:        s->irq_target[i] = qemu_get_be32(f);
arm_gic.c:            s->priority1[j][i] = qemu_get_be32(f);
arm_gic.c:            s->last_active[j][i] = qemu_get_be32(f);
arm_gic.c:        s->priority_mask[i] = qemu_get_be32(f);
arm_gic.c:        s->running_irq[i] = qemu_get_be32(f);
arm_gic.c:        s->running_priority[i] = qemu_get_be32(f);
arm_gic.c:        s->current_pending[i] = qemu_get_be32(f);
arm_gic.c:    for (i = 0; i < GIC_NIRQ - 32; i++) {
arm_gic.c:        s->priority2[i] = qemu_get_be32(f);
arm_gic.c:        s->irq_state[i].enabled = qemu_get_byte(f);
arm_gic.c:        s->irq_state[i].pending = qemu_get_byte(f);
arm_gic.c:        s->irq_state[i].active = qemu_get_byte(f);
arm_gic.c:        s->irq_state[i].level = qemu_get_byte(f);
arm_gic.c:        s->irq_state[i].model = qemu_get_byte(f);
arm_gic.c:        s->irq_state[i].trigger = qemu_get_byte(f);
arm_gic.c:    s->num_cpu = num_cpu;
arm_gic.c:    qdev_init_gpio_in(&s->busdev.qdev, gic_set_irq, GIC_NIRQ - 32);
arm_gic.c:        sysbus_init_irq(&s->busdev, &s->parent_irq[i]);
arm_gic.c:    s->iomemtype = cpu_register_io_memory(gic_dist_readfn,
arm_gic.c:    register_savevm("arm_gic", -1, 1, gic_save, gic_load, s);
arm_pic.c:#include "arm-misc.h"
arm_sysctl.c: * Copyright (c) 2006-2007 CodeSourcery.
arm_sysctl.c:#include "qemu-timer.h"
arm_sysctl.c:    s->leds = 0;
arm_sysctl.c:    s->lockval = 0;
arm_sysctl.c:    s->cfgdata1 = 0;
arm_sysctl.c:    s->cfgdata2 = 0;
arm_sysctl.c:    s->flags = 0;
arm_sysctl.c:    s->resetlevel = 0;
arm_sysctl.c:        return s->sys_id;
arm_sysctl.c:        return s->leds;
arm_sysctl.c:        return s->lockval;
arm_sysctl.c:        return s->cfgdata1;
arm_sysctl.c:        return s->cfgdata2;
arm_sysctl.c:        return s->flags;
arm_sysctl.c:        return s->nvflags;
arm_sysctl.c:        return s->resetlevel;
arm_sysctl.c:        return s->proc_id;
arm_sysctl.c:        s->leds = val;
arm_sysctl.c:            s->lockval = val;
arm_sysctl.c:            s->lockval = val & 0x7fff;
arm_sysctl.c:        s->cfgdata1 = val;
arm_sysctl.c:        s->cfgdata2 = val;
arm_sysctl.c:        s->flags |= val;
arm_sysctl.c:        s->flags &= ~val;
arm_sysctl.c:        s->nvflags |= val;
arm_sysctl.c:        s->nvflags &= ~val;
arm_sysctl.c:        if (s->lockval == LOCK_VALUE) {
arm_sysctl.c:            s->resetlevel = val;
arm_timer.c: * Copyright (c) 2005-2006 CodeSourcery.
arm_timer.c:#include "qemu-timer.h"
arm_timer.c:    if (s->int_level && (s->control & TIMER_CTRL_IE)) {
arm_timer.c:        qemu_irq_raise(s->irq);
arm_timer.c:        qemu_irq_lower(s->irq);
arm_timer.c:        return s->limit;
arm_timer.c:        return ptimer_get_count(s->timer);
arm_timer.c:        return s->control;
arm_timer.c:        return s->int_level;
arm_timer.c:        if ((s->control & TIMER_CTRL_IE) == 0)
arm_timer.c:        return s->int_level;
arm_timer.c:    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {
arm_timer.c:        if (s->control & TIMER_CTRL_32BIT)
arm_timer.c:          limit = s->limit;
arm_timer.c:    ptimer_set_limit(s->timer, limit, reload);
arm_timer.c:        s->limit = value;
arm_timer.c:        if (s->control & TIMER_CTRL_ENABLE) {
arm_timer.c:            ptimer_stop(s->timer);
arm_timer.c:        s->control = value;
arm_timer.c:        freq = s->freq;
arm_timer.c:        ptimer_set_freq(s->timer, freq);
arm_timer.c:        if (s->control & TIMER_CTRL_ENABLE) {
arm_timer.c:            ptimer_run(s->timer, (s->control & TIMER_CTRL_ONESHOT) != 0);
arm_timer.c:        s->int_level = 0;
arm_timer.c:        s->limit = value;
arm_timer.c:    s->int_level = 1;
arm_timer.c:    qemu_put_be32(f, s->control);
arm_timer.c:    qemu_put_be32(f, s->limit);
arm_timer.c:    qemu_put_be32(f, s->int_level);
arm_timer.c:    qemu_put_ptimer(f, s->timer);
arm_timer.c:        return -EINVAL;
arm_timer.c:    s->control = qemu_get_be32(f);
arm_timer.c:    s->limit = qemu_get_be32(f);
arm_timer.c:    s->int_level = qemu_get_be32(f);
arm_timer.c:    qemu_get_ptimer(f, s->timer);
arm_timer.c:    s->freq = freq;
arm_timer.c:    s->control = TIMER_CTRL_IE;
arm_timer.c:    s->timer = ptimer_init(bh);
arm_timer.c:    register_savevm("arm_timer", -1, 1, arm_timer_save, arm_timer_load, s);
arm_timer.c:    s->level[irq] = level;
arm_timer.c:    qemu_set_irq(s->irq, s->level[0] || s->level[1]);
arm_timer.c:        return arm_timer_read(s->timer[0], offset);
arm_timer.c:        return arm_timer_read(s->timer[1], offset - 0x20);
arm_timer.c:        arm_timer_write(s->timer[0], offset, value);
arm_timer.c:        arm_timer_write(s->timer[1], offset - 0x20, value);
arm_timer.c:    qemu_put_be32(f, s->level[0]);
arm_timer.c:    qemu_put_be32(f, s->level[1]);
arm_timer.c:        return -EINVAL;
arm_timer.c:    s->level[0] = qemu_get_be32(f);
arm_timer.c:    s->level[1] = qemu_get_be32(f);
arm_timer.c:    sysbus_init_irq(dev, &s->irq);
arm_timer.c:    s->timer[0] = arm_timer_init(1000000);
arm_timer.c:    s->timer[1] = arm_timer_init(1000000);
arm_timer.c:    s->timer[0]->irq = qi[0];
arm_timer.c:    s->timer[1]->irq = qi[1];
arm_timer.c:    register_savevm("sp804", -1, 1, sp804_save, sp804_load, s);
arm_timer.c:    return arm_timer_read(s->timer[n], offset & 0xff);
arm_timer.c:    arm_timer_write(s->timer[n], offset & 0xff, value);
arm_timer.c:    s->timer[0] = arm_timer_init(40000000);
arm_timer.c:    s->timer[1] = arm_timer_init(1000000);
arm_timer.c:    s->timer[2] = arm_timer_init(1000000);
arm_timer.c:    sysbus_init_irq(dev, &s->timer[0]->irq);
arm_timer.c:    sysbus_init_irq(dev, &s->timer[1]->irq);
arm_timer.c:    sysbus_init_irq(dev, &s->timer[2]->irq);
armv7m.c: * Copyright (c) 2006-2007 CodeSourcery.
armv7m.c:#include "arm-misc.h"
armv7m.c:                                       &s->base);
armv7m.c:    dev = qdev_create(NULL, "ARM,bitband-memory");
armv7m.c:    dev = qdev_create(NULL, "ARM,bitband-memory");
armv7m.c:/* Init CPU and memory for a v7-M based board.
armv7m.c:	cpu_model = "cortex-m3";
armv7m.c:    code_size = ram_size - sram_size;
armv7m.c:    env->v7m.nvic = nvic;
armv7m.c:	env->regs[13] = ldl_phys(0);
armv7m.c:    env->thumb = pc & 1;
armv7m.c:    env->regs[15] = pc & ~1;
armv7m.c:    .qdev.name  = "ARM,bitband-memory",
armv7m_nvic.c: * Copyright (c) 2006-2007 CodeSourcery.
armv7m_nvic.c:#include "qemu-timer.h"
armv7m_nvic.c:#include "arm-misc.h"
armv7m_nvic.c:    if (s->systick.control & SYSTICK_CLKSOURCE)
armv7m_nvic.c:        s->systick.tick = qemu_get_clock(vm_clock);
armv7m_nvic.c:    s->systick.tick += (s->systick.reload + 1) * systick_scale(s);
armv7m_nvic.c:    qemu_mod_timer(s->systick.timer, s->systick.tick);
armv7m_nvic.c:    s->systick.control |= SYSTICK_COUNTFLAG;
armv7m_nvic.c:    if (s->systick.control & SYSTICK_TICKINT) {
armv7m_nvic.c:    if (s->systick.reload == 0) {
armv7m_nvic.c:        s->systick.control &= ~SYSTICK_ENABLE;
armv7m_nvic.c:    gic_set_pending_private(&s->gic, 0, irq);
armv7m_nvic.c:    irq = gic_acknowledge_irq(&s->gic, 0);
armv7m_nvic.c:        irq -= 16;
armv7m_nvic.c:    gic_complete_irq(&s->gic, 0, irq);
armv7m_nvic.c:        return (GIC_NIRQ / 32) - 1;
armv7m_nvic.c:        val = s->systick.control;
armv7m_nvic.c:        s->systick.control &= ~SYSTICK_COUNTFLAG;
armv7m_nvic.c:        return s->systick.reload;
armv7m_nvic.c:            if ((s->systick.control & SYSTICK_ENABLE) == 0)
armv7m_nvic.c:            if (t >= s->systick.tick)
armv7m_nvic.c:            val = ((s->systick.tick - (t + 1)) / systick_scale(s)) + 1;
armv7m_nvic.c:            if (val > s->systick.reload)
armv7m_nvic.c:        return cpu_single_env->cp15.c0_cpuid;
armv7m_nvic.c:        val = s->gic.running_irq[0];
armv7m_nvic.c:            val -= 16;
armv7m_nvic.c:        if (s->gic.running_irq[0] == 1023
armv7m_nvic.c:                || s->gic.last_active[s->gic.running_irq[0]][0] == 1023) {
armv7m_nvic.c:        if (s->gic.current_pending[0] != 1023)
armv7m_nvic.c:            val |= (s->gic.current_pending[0] << 12);
armv7m_nvic.c:            if (s->gic.irq_state[irq].pending) {
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending)
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending)
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_NMI].pending)
armv7m_nvic.c:        return cpu_single_env->v7m.vecbase;
armv7m_nvic.c:        irq = offset - 0xd14;
armv7m_nvic.c:        val = s->gic.priority1[irq++][0];
armv7m_nvic.c:        val = s->gic.priority1[irq++][0] << 8;
armv7m_nvic.c:        val = s->gic.priority1[irq++][0] << 16;
armv7m_nvic.c:        val = s->gic.priority1[irq][0] << 24;
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_MEM].active) val |= (1 << 0);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_BUS].active) val |= (1 << 1);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].active) val |= (1 << 3);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_SVC].active) val |= (1 << 7);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_DEBUG].active) val |= (1 << 8);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_PENDSV].active) val |= (1 << 10);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_SYSTICK].active) val |= (1 << 11);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].pending) val |= (1 << 12);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_MEM].pending) val |= (1 << 13);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_BUS].pending) val |= (1 << 14);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_SVC].pending) val |= (1 << 15);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_MEM].enabled) val |= (1 << 16);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_BUS].enabled) val |= (1 << 17);
armv7m_nvic.c:        if (s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled) val |= (1 << 18);
armv7m_nvic.c:        oldval = s->systick.control;
armv7m_nvic.c:        s->systick.control &= 0xfffffff8;
armv7m_nvic.c:        s->systick.control |= value & 7;
armv7m_nvic.c:                if (s->systick.tick) {
armv7m_nvic.c:                    s->systick.tick += now;
armv7m_nvic.c:                    qemu_mod_timer(s->systick.timer, s->systick.tick);
armv7m_nvic.c:                qemu_del_timer(s->systick.timer);
armv7m_nvic.c:                s->systick.tick -= now;
armv7m_nvic.c:                if (s->systick.tick < 0)
armv7m_nvic.c:                  s->systick.tick = 0;
armv7m_nvic.c:        s->systick.reload = value;
armv7m_nvic.c:        s->systick.control &= ~SYSTICK_COUNTFLAG;
armv7m_nvic.c:            s->gic.irq_state[ARMV7M_EXCP_PENDSV].pending = 0;
armv7m_nvic.c:            gic_update(&s->gic);
armv7m_nvic.c:            s->gic.irq_state[ARMV7M_EXCP_SYSTICK].pending = 0;
armv7m_nvic.c:            gic_update(&s->gic);
armv7m_nvic.c:        cpu_single_env->v7m.vecbase = value & 0xffffff80;
armv7m_nvic.c:            irq = offset - 0xd14;
armv7m_nvic.c:            s->gic.priority1[irq++][0] = value & 0xff;
armv7m_nvic.c:            s->gic.priority1[irq++][0] = (value >> 8) & 0xff;
armv7m_nvic.c:            s->gic.priority1[irq++][0] = (value >> 16) & 0xff;
armv7m_nvic.c:            s->gic.priority1[irq][0] = (value >> 24) & 0xff;
armv7m_nvic.c:            gic_update(&s->gic);
armv7m_nvic.c:        s->gic.irq_state[ARMV7M_EXCP_MEM].enabled = (value & (1 << 16)) != 0;
armv7m_nvic.c:        s->gic.irq_state[ARMV7M_EXCP_BUS].enabled = (value & (1 << 17)) != 0;
armv7m_nvic.c:        s->gic.irq_state[ARMV7M_EXCP_USAGE].enabled = (value & (1 << 18)) != 0;
armv7m_nvic.c:    qemu_put_be32(f, s->systick.control);
armv7m_nvic.c:    qemu_put_be32(f, s->systick.reload);
armv7m_nvic.c:    qemu_put_be64(f, s->systick.tick);
armv7m_nvic.c:    qemu_put_timer(f, s->systick.timer);
armv7m_nvic.c:        return -EINVAL;
armv7m_nvic.c:    s->systick.control = qemu_get_be32(f);
armv7m_nvic.c:    s->systick.reload = qemu_get_be32(f);
armv7m_nvic.c:    s->systick.tick = qemu_get_be64(f);
armv7m_nvic.c:    qemu_get_timer(f, s->systick.timer);
armv7m_nvic.c:    gic_init(&s->gic);
armv7m_nvic.c:    cpu_register_physical_memory(0xe000e000, 0x1000, s->gic.iomemtype);
armv7m_nvic.c:    s->systick.timer = qemu_new_timer(vm_clock, systick_timer_tick, s);
armv7m_nvic.c:    register_savevm("armv7m_nvic", -1, 1, nvic_save, nvic_load, s);
axis_dev88.c:    r = nand_getio(s->nand);
axis_dev88.c:    nand_getpins(s->nand, &rdy);
axis_dev88.c:    s->rdy = rdy;
axis_dev88.c:    nand_setpins(s->nand, s->cle, s->ale, s->ce, 1, 0);
axis_dev88.c:    nand_setio(s->nand, value);
axis_dev88.c:    nand_getpins(s->nand, &rdy);
axis_dev88.c:    s->rdy = rdy;
axis_dev88.c:             clk, s->state, s->shiftreg));
axis_dev88.c:    if (s->count == 0) {
axis_dev88.c:        s->count = 16;
axis_dev88.c:        s->state = ST_OUT;
axis_dev88.c:    switch (s->state) {
axis_dev88.c:                s->count--;
axis_dev88.c:                s->shiftreg <<= 1;
axis_dev88.c:                if (s->count == 0) {
axis_dev88.c:                    s->shiftreg = 0;
axis_dev88.c:                    s->state = ST_IN;
axis_dev88.c:                    s->count = 16;
axis_dev88.c:                s->count--;
axis_dev88.c:                if (s->count == 0) {
axis_dev88.c:                    s->shiftreg = 0;
axis_dev88.c:                    s->state = ST_OUT;
axis_dev88.c:                    s->count = 16;
axis_dev88.c:                s->count--;
axis_dev88.c:                s->shiftreg <<= 1;
axis_dev88.c:                s->shiftreg |= data_in & 1;
axis_dev88.c:                if (s->count == 0) {
axis_dev88.c:                    D(printf("%s cfgreg=%x\n", __func__, s->shiftreg));
axis_dev88.c:                    s->regs[0] = s->shiftreg;
axis_dev88.c:                    s->state = ST_OUT;
axis_dev88.c:                    s->count = 16;
axis_dev88.c:                    if ((s->regs[0] & 0xff) == 0) {
axis_dev88.c:                        s->shiftreg = 0x0b9f;
axis_dev88.c:                    } else if ((s->regs[0] & 0xff) == 0xff) {
axis_dev88.c:                        s->shiftreg = 0x8100;
axis_dev88.c:                        printf("Invalid tempsens state %x\n", s->regs[0]);
axis_dev88.c:            r = s->regs[RW_PA_DOUT] & s->regs[RW_PA_OE];
axis_dev88.c:            r |= s->nand->rdy << 7;
axis_dev88.c:            r = s->regs[RW_PD_DOUT] & s->regs[RW_PD_OE];
axis_dev88.c:            r |= (!!(s->tempsensor.shiftreg & 0x10000)) << 4;
axis_dev88.c:            r = s->regs[addr];
axis_dev88.c:            s->nand->ale = !!(value & (1 << 6));
axis_dev88.c:            s->nand->cle = !!(value & (1 << 5));
axis_dev88.c:            s->nand->ce  = !!(value & (1 << 4));
axis_dev88.c:            s->regs[addr] = value;
axis_dev88.c:            if ((s->regs[addr] ^ value) & 2)
axis_dev88.c:                tempsensor_clkedge(&s->tempsensor, !!(value & 2),
axis_dev88.c:            s->regs[addr] = value;
axis_dev88.c:            s->regs[addr] = value;
axis_dev88.c:    env->pc = bootstrap_pc;
axis_dev88.c:    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the 
axis_dev88.c:    qdev_prop_set_ptr(dev, "interrupt_vector", &env->interrupt_vector);
axis_dev88.c:        /* Boots a kernel elf binary, os/linux-2.6/vmlinux from the axis 
axis_dev88.c:        kernel_size = load_elf(kernel_filename, -0x80000000LL,
axis_dev88.c:            env->regs[9] = 0x40004000 + kernel_size;
axis_dev88.c:        env->regs[8] = 0x56902387; /* RAM init magic.  */
axis_dev88.c:            env->regs[10] = 0x87109563;
axis_dev88.c:            env->regs[11] = 0x40000000;
axis_dev88.c:            pstrcpy_targphys("cmdline", env->regs[11], 256, kernel_cmdline);
axis_dev88.c:    env->pc = bootstrap_pc;
axis_dev88.c:    printf ("pc =%x\n", env->pc);
axis_dev88.c:    .name = "axis-dev88",
baum.c:#include "qemu-common.h"
baum.c:#include "qemu-char.h"
baum.c:#include "qemu-timer.h"
baum.c:    [BRLAPI_DOTS(0,0,1,0,0,1,0,0)] = '-',
baum.c:    BaumDriverState *baum = chr->opaque;
baum.c:    if (!baum->out_buf_used)
baum.c:    if (room > baum->out_buf_used)
baum.c:        room = baum->out_buf_used;
baum.c:    first = BUF_SIZE - baum->out_buf_ptr;
baum.c:        qemu_chr_read(chr, baum->out_buf + baum->out_buf_ptr, first);
baum.c:        baum->out_buf_ptr = 0;
baum.c:        baum->out_buf_used -= first;
baum.c:        room -= first;
baum.c:    qemu_chr_read(chr, baum->out_buf + baum->out_buf_ptr, room);
baum.c:    baum->out_buf_ptr += room;
baum.c:    baum->out_buf_used -= room;
baum.c:    while (len--)
baum.c:    room = qemu_chr_can_read(baum->chr);
baum.c:    len = cur - io_buf;
baum.c:        qemu_chr_read(baum->chr, io_buf, len);
baum.c:        qemu_chr_read(baum->chr, io_buf, room);
baum.c:        len -= room;
baum.c:        if (len > BUF_SIZE - baum->out_buf_used) {
baum.c:            baum->out_buf_used = 0;
baum.c:            baum->out_buf_ptr = 0;
baum.c:        out = baum->out_buf_ptr;
baum.c:        baum->out_buf_used += len;
baum.c:        first = BUF_SIZE - baum->out_buf_ptr;
baum.c:            memcpy(baum->out_buf + out, cur, first);
baum.c:            len -= first;
baum.c:        memcpy(baum->out_buf + out, cur, len);
baum.c:    uint8_t cell_count[] = { BAUM_RSP_CellCount, baum->x * baum->y };
baum.c:    if (!len--)
baum.c:            if (!len--)
baum.c:        DPRINTF("Dropped %d bytes!\n", cur - buf);
baum.c:    if (!len--) \
baum.c:        if (!len--) \
baum.c:		if (qemu_timer_pending(baum->cellCount_timer)) { \
baum.c:                qemu_del_timer(baum->cellCount_timer); \
baum.c:            return (cur - 2 - buf); \
baum.c:        uint8_t cells[baum->x * baum->y], c;
baum.c:        uint8_t text[baum->x * baum->y];
baum.c:        uint8_t zero[baum->x * baum->y];
baum.c:        qemu_mod_timer(baum->cellCount_timer, qemu_get_clock(vm_clock) +
baum.c:        for (i = 0; i < baum->x * baum->y ; i++) {
baum.c:        qemu_del_timer(baum->cellCount_timer);
baum.c:            .regionSize = baum->x * baum->y,
baum.c:            .textSize = baum->x * baum->y,
baum.c:            .charset = (char *)"ISO-8859-1",
baum.c:        if (brlapi__write(baum->brlapi, &wa) == -1)
baum.c:        identity[11] = '0' + baum->x / 10;
baum.c:        identity[12] = '0' + baum->x % 10;
baum.c:            if (!len--)
baum.c:        cur--;
baum.c:    return cur - buf;
baum.c:    BaumDriverState *baum = chr->opaque;
baum.c:    if (!baum->brlapi)
baum.c:        if (tocopy > BUF_SIZE - baum->in_buf_used)
baum.c:            tocopy = BUF_SIZE - baum->in_buf_used;
baum.c:        memcpy(baum->in_buf + baum->in_buf_used, buf, tocopy);
baum.c:        baum->in_buf_used += tocopy;
baum.c:        len -= tocopy;
baum.c:        while (cur < baum->in_buf_used &&
baum.c:                (eaten = baum_eat_packet(baum, baum->in_buf + cur, baum->in_buf_used - cur)))
baum.c:            memmove(baum->in_buf, baum->in_buf + cur, baum->in_buf_used - cur);
baum.c:            baum->in_buf_used -= cur;
baum.c:    BaumDriverState *baum = chr->opaque;
baum.c:        baum->in_buf_used = 0;
baum.c:    if (!baum->brlapi)
baum.c:    while ((ret = brlapi__readKey(baum->brlapi, 0, &code)) == 1) {
baum.c:    if (ret == -1 && (brlapi_errno != BRLAPI_ERROR_LIBCERR || errno != EINTR)) {
baum.c:        brlapi__closeConnection(baum->brlapi);
baum.c:        qemu_free(baum->brlapi);
baum.c:        baum->brlapi = NULL;
baum.c:    baum->chr = chr = qemu_mallocz(sizeof(CharDriverState));
baum.c:    chr->opaque = baum;
baum.c:    chr->chr_write = baum_write;
baum.c:    chr->chr_send_event = baum_send_event;
baum.c:    chr->chr_accept_input = baum_accept_input;
baum.c:    baum->brlapi = handle;
baum.c:    baum->brlapi_fd = brlapi__openConnection(handle, NULL, NULL);
baum.c:    if (baum->brlapi_fd == -1) {
baum.c:    baum->cellCount_timer = qemu_new_timer(vm_clock, baum_cellCount_timer_cb, baum);
baum.c:    if (brlapi__getDisplaySize(handle, &baum->x, &baum->y) == -1) {
baum.c:    if (brlapi__enterTtyMode(handle, tty, NULL) == -1) {
baum.c:    qemu_set_fd_handler(baum->brlapi_fd, baum_chr_read, NULL, baum);
baum.c:    qemu_free_timer(baum->cellCount_timer);
bitbang_i2c.c: * Bit-Bang i2c emulation extracted from
bitbang_i2c.c:    if (i2c->current_addr >= 0)
bitbang_i2c.c:        i2c_end_transfer(i2c->bus);
bitbang_i2c.c:    i2c->current_addr = -1;
bitbang_i2c.c:    i2c->state = STOPPED;
bitbang_i2c.c:    i2c->device_out = level;
bitbang_i2c.c:    //DPRINTF("%d %d %d\n", i2c->last_clock, i2c->last_data, i2c->device_out);
bitbang_i2c.c:    return level & i2c->last_data;
bitbang_i2c.c:    return bitbang_i2c_ret(i2c, i2c->device_out);
bitbang_i2c.c:        if (level == i2c->last_data) {
bitbang_i2c.c:        i2c->last_data = level;
bitbang_i2c.c:        if (i2c->last_clock == 0) {
bitbang_i2c.c:            i2c->state = SENDING_BIT7;
bitbang_i2c.c:            i2c->current_addr = -1;
bitbang_i2c.c:    data = i2c->last_data;
bitbang_i2c.c:    if (i2c->last_clock == level) {
bitbang_i2c.c:    i2c->last_clock = level;
bitbang_i2c.c:    switch (i2c->state) {
bitbang_i2c.c:        i2c->buffer = (i2c->buffer << 1) | data;
bitbang_i2c.c:        i2c->state++; 
bitbang_i2c.c:        if (i2c->current_addr < 0) {
bitbang_i2c.c:            i2c->current_addr = i2c->buffer;
bitbang_i2c.c:            DPRINTF("Address 0x%02x\n", i2c->current_addr);
bitbang_i2c.c:            i2c_start_transfer(i2c->bus, i2c->current_addr >> 1,
bitbang_i2c.c:                               i2c->current_addr & 1);
bitbang_i2c.c:            DPRINTF("Sent 0x%02x\n", i2c->buffer);
bitbang_i2c.c:            i2c_send(i2c->bus, i2c->buffer);
bitbang_i2c.c:        if (i2c->current_addr & 1) {
bitbang_i2c.c:            i2c->state = RECEIVING_BIT7;
bitbang_i2c.c:            i2c->state = SENDING_BIT7;
bitbang_i2c.c:        i2c->buffer = i2c_recv(i2c->bus);
bitbang_i2c.c:        DPRINTF("RX byte 0x%02x\n", i2c->buffer);
bitbang_i2c.c:        data = i2c->buffer >> 7;
bitbang_i2c.c:        i2c->state++;
bitbang_i2c.c:        i2c->buffer <<= 1;
bitbang_i2c.c:        i2c->state = RECEIVING_BIT7;
bitbang_i2c.c:            i2c_nack(i2c->bus);
bitbang_i2c.c:    s->bus = bus;
bitbang_i2c.c:    s->last_data = 1;
bitbang_i2c.c:    s->last_clock = 1;
bitbang_i2c.c:    s->device_out = 1;
bitbang_i2c.c:    level = bitbang_i2c_set(s->bitbang, irq, level);
bitbang_i2c.c:    if (level != s->last_level) {
bitbang_i2c.c:        s->last_level = level;
bitbang_i2c.c:        qemu_set_irq(s->out, level);
bitbang_i2c.c:    bus = i2c_init_bus(&dev->qdev, "i2c");
bitbang_i2c.c:    s->bitbang = bitbang_i2c_init(bus);
bitbang_i2c.c:    qdev_init_gpio_in(&dev->qdev, bitbang_i2c_gpio_set, 2);
bitbang_i2c.c:    qdev_init_gpio_out(&dev->qdev, &s->out, 1);
blizzard.c:#include "qemu-common.h"
blizzard.c:    *u = 0x80 + ((0xe0e * b - 0x04c1 * r - 0x94e * g) >> 13);
blizzard.c:    *v = 0x80 + ((0xe0e * r - 0x0bc7 * g - 0x247 * b) >> 13);
blizzard.c:    blizzard_fn_t fn = s->data.line_fn;
blizzard.c:    if (s->mx[0] > s->data.x)
blizzard.c:        s->mx[0] = s->data.x;
blizzard.c:    if (s->my[0] > s->data.y)
blizzard.c:        s->my[0] = s->data.y;
blizzard.c:    if (s->mx[1] < s->data.x + s->data.dx)
blizzard.c:        s->mx[1] = s->data.x + s->data.dx;
blizzard.c:    if (s->my[1] < s->data.y + s->data.dy)
blizzard.c:        s->my[1] = s->data.y + s->data.dy;
blizzard.c:    bypp[0] = s->bpp;
blizzard.c:    bypp[1] = (ds_get_bits_per_pixel(s->state) + 7) >> 3;
blizzard.c:    bypl[0] = bypp[0] * s->data.pitch;
blizzard.c:    bypl[1] = bypp[1] * s->x;
blizzard.c:    bypl[2] = bypp[0] * s->data.dx;
blizzard.c:    src = s->data.data;
blizzard.c:    dst = s->fb + bypl[1] * s->data.y + bypp[1] * s->data.x;
blizzard.c:    for (y = s->data.dy; y > 0; y --, src += bypl[0], dst += bypl[1])
blizzard.c:    if (s->source > 3 || !s->bpp ||
blizzard.c:                    s->ix[1] < s->ix[0] || s->iy[1] < s->iy[0])
blizzard.c:    s->data.angle = s->effect & 3;
blizzard.c:    s->data.line_fn = s->line_fn_tab[!!s->data.angle][s->iformat];
blizzard.c:    s->data.x = s->ix[0];
blizzard.c:    s->data.y = s->iy[0];
blizzard.c:    s->data.dx = s->ix[1] - s->ix[0] + 1;
blizzard.c:    s->data.dy = s->iy[1] - s->iy[0] + 1;
blizzard.c:    s->data.len = s->bpp * s->data.dx * s->data.dy;
blizzard.c:    s->data.pitch = s->data.dx;
blizzard.c:    if (s->data.len > s->data.buflen) {
blizzard.c:        s->data.buf = qemu_realloc(s->data.buf, s->data.len);
blizzard.c:        s->data.buflen = s->data.len;
blizzard.c:    s->data.ptr = s->data.buf;
blizzard.c:    s->data.data = s->data.buf;
blizzard.c:    s->data.len /= 2;
blizzard.c:    s->reg = 0;
blizzard.c:    s->swallow = 0;
blizzard.c:    s->pll = 9;
blizzard.c:    s->pll_range = 1;
blizzard.c:    s->pll_ctrl = 0x14;
blizzard.c:    s->pll_mode = 0x32;
blizzard.c:    s->clksel = 0x00;
blizzard.c:    s->memenable = 0;
blizzard.c:    s->memrefresh = 0x25c;
blizzard.c:    s->timing[0] = 0x3f;
blizzard.c:    s->timing[1] = 0x13;
blizzard.c:    s->timing[2] = 0x21;
blizzard.c:    s->priority = 0;
blizzard.c:    s->lcd_config = 0x74;
blizzard.c:    s->x = 8;
blizzard.c:    s->y = 1;
blizzard.c:    s->skipx = 0;
blizzard.c:    s->skipy = 0;
blizzard.c:    s->hndp = 3;
blizzard.c:    s->vndp = 2;
blizzard.c:    s->hsync = 1;
blizzard.c:    s->vsync = 1;
blizzard.c:    s->pclk = 0x80;
blizzard.c:    s->ix[0] = 0;
blizzard.c:    s->ix[1] = 0;
blizzard.c:    s->iy[0] = 0;
blizzard.c:    s->iy[1] = 0;
blizzard.c:    s->ox[0] = 0;
blizzard.c:    s->ox[1] = 0;
blizzard.c:    s->oy[0] = 0;
blizzard.c:    s->oy[1] = 0;
blizzard.c:    s->yrc[0] = 0x00;
blizzard.c:    s->yrc[1] = 0x30;
blizzard.c:    s->u = 0;
blizzard.c:    s->v = 0;
blizzard.c:    s->iformat = 3;
blizzard.c:    s->source = 0;
blizzard.c:    s->bpp = blizzard_iformat_bpp[s->iformat];
blizzard.c:    s->hssi_config[0] = 0x00;
blizzard.c:    s->hssi_config[1] = 0x00;
blizzard.c:    s->hssi_config[2] = 0x01;
blizzard.c:    s->tv_config = 0x00;
blizzard.c:    s->tv_timing[0] = 0x00;
blizzard.c:    s->tv_timing[1] = 0x00;
blizzard.c:    s->tv_timing[2] = 0x00;
blizzard.c:    s->tv_timing[3] = 0x00;
blizzard.c:    s->vbi = 0x10;
blizzard.c:    s->tv_x = 0x14;
blizzard.c:    s->tv_y = 0x03;
blizzard.c:    s->tv_test = 0x00;
blizzard.c:    s->tv_filter_config = 0x80;
blizzard.c:    s->tv_filter_idx = 0x00;
blizzard.c:    s->border_r = 0x10;
blizzard.c:    s->border_g = 0x80;
blizzard.c:    s->border_b = 0x80;
blizzard.c:    s->gamma_config = 0x00;
blizzard.c:    s->gamma_idx = 0x00;
blizzard.c:    s->matrix_ena = 0x00;
blizzard.c:    memset(&s->matrix_coeff, 0, sizeof(s->matrix_coeff));
blizzard.c:    s->matrix_r = 0x00;
blizzard.c:    s->matrix_g = 0x00;
blizzard.c:    s->matrix_b = 0x00;
blizzard.c:    s->pm = 0x02;
blizzard.c:    s->status = 0x00;
blizzard.c:    s->rgbgpio_dir = 0x00;
blizzard.c:    s->gpio_dir = 0x00;
blizzard.c:    s->gpio_edge[0] = 0x00;
blizzard.c:    s->gpio_edge[1] = 0x00;
blizzard.c:    s->gpio_irq = 0x00;
blizzard.c:    s->gpio_pdown = 0xff;
blizzard.c:    s->invalidate = 1;
blizzard.c:    case 0x04:	/* PLL M-Divider */
blizzard.c:        return (s->pll - 1) | (1 << 7);
blizzard.c:        return s->pll_range;
blizzard.c:        return s->pll_ctrl & 0xff;
blizzard.c:        return s->pll_ctrl >> 8;
blizzard.c:        return s->pll_mode;
blizzard.c:    case 0x0e:	/* Clock-Source Select */
blizzard.c:        return s->clksel;
blizzard.c:        return s->memenable;
blizzard.c:    case 0x18:	/* Auto-Refresh Interval Setting 0 */
blizzard.c:        return s->memrefresh & 0xff;
blizzard.c:    case 0x1a:	/* Auto-Refresh Interval Setting 1 */
blizzard.c:        return s->memrefresh >> 8;
blizzard.c:    case 0x1c:	/* Power-On Sequence Timing Control */
blizzard.c:        return s->timing[0];
blizzard.c:        return s->timing[1];
blizzard.c:        return s->timing[2];
blizzard.c:        return s->priority;
blizzard.c:        return s->lcd_config;
blizzard.c:        return s->x >> 3;
blizzard.c:    case 0x2c:	/* LCD Horizontal Non-display Period */
blizzard.c:        return s->hndp;
blizzard.c:        return s->y & 0xff;
blizzard.c:        return s->y >> 8;
blizzard.c:    case 0x32:	/* LCD Vertical Non-display Period */
blizzard.c:        return s->vndp;
blizzard.c:    case 0x34:	/* LCD HS Pulse-width */
blizzard.c:        return s->hsync;
blizzard.c:        return s->skipx >> 3;
blizzard.c:    case 0x38:	/* LCD VS Pulse-width */
blizzard.c:        return s->vsync;
blizzard.c:        return s->skipy;
blizzard.c:        return s->pclk;
blizzard.c:    case 0x3e:	/* High-speed Serial Interface Tx Configuration Port 0 */
blizzard.c:        return s->hssi_config[0];
blizzard.c:    case 0x40:	/* High-speed Serial Interface Tx Configuration Port 1 */
blizzard.c:        return s->hssi_config[1];
blizzard.c:    case 0x42:	/* High-speed Serial Interface Tx Mode */
blizzard.c:        return s->hssi_config[2];
blizzard.c:        return s->tv_config;
blizzard.c:        return s->tv_timing[(reg - 0x46) >> 1];
blizzard.c:        return s->vbi;
blizzard.c:        return s->tv_x;
blizzard.c:        return s->tv_y;
blizzard.c:        return s->tv_test;
blizzard.c:        return s->tv_filter_config;
blizzard.c:        return s->tv_filter_idx;
blizzard.c:        if (s->tv_filter_idx < 0x20)
blizzard.c:            return s->tv_filter_coeff[s->tv_filter_idx ++];
blizzard.c:        return s->yrc[0];
blizzard.c:        return s->yrc[1];
blizzard.c:        return s->u;
blizzard.c:        return s->v;
blizzard.c:        return s->mode;
blizzard.c:        return s->effect;
blizzard.c:        return s->ix[0] & 0xff;
blizzard.c:        return s->ix[0] >> 3;
blizzard.c:        return s->ix[0] & 0xff;
blizzard.c:        return s->ix[0] >> 3;
blizzard.c:        return s->ix[1] & 0xff;
blizzard.c:        return s->ix[1] >> 3;
blizzard.c:        return s->ix[1] & 0xff;
blizzard.c:        return s->ix[1] >> 3;
blizzard.c:        return s->ox[0] & 0xff;
blizzard.c:        return s->ox[0] >> 3;
blizzard.c:        return s->oy[0] & 0xff;
blizzard.c:        return s->oy[0] >> 3;
blizzard.c:        return s->ox[1] & 0xff;
blizzard.c:        return s->ox[1] >> 3;
blizzard.c:        return s->oy[1] & 0xff;
blizzard.c:        return s->oy[1] >> 3;
blizzard.c:        return s->iformat;
blizzard.c:        return s->source;
blizzard.c:        return s->border_r;
blizzard.c:        return s->border_g;
blizzard.c:        return s->border_b;
blizzard.c:        return s->gamma_config;
blizzard.c:        return s->gamma_idx;
blizzard.c:        return s->gamma_lut[s->gamma_idx ++];
blizzard.c:        return s->matrix_ena;
blizzard.c:        return s->matrix_coeff[(reg - 0xbc) >> 1];
blizzard.c:        return s->matrix_r;
blizzard.c:        return s->matrix_g;
blizzard.c:        return s->matrix_b;
blizzard.c:    case 0xe6:	/* Power-save */
blizzard.c:        return s->pm;
blizzard.c:    case 0xe8:	/* Non-display Period Control / Status */
blizzard.c:        return s->status | (1 << 5);
blizzard.c:        return s->rgbgpio_dir;
blizzard.c:        return s->rgbgpio;
blizzard.c:    case 0xee:	/* General-purpose IO Pins Configuration */
blizzard.c:        return s->gpio_dir;
blizzard.c:    case 0xf0:	/* General-purpose IO Pins Status / Control */
blizzard.c:        return s->gpio;
blizzard.c:        return s->gpio_edge[0];
blizzard.c:        return s->gpio_edge[1];
blizzard.c:        return s->gpio_irq;
blizzard.c:    case 0xf8:	/* GPIO Pull-down Control */
blizzard.c:        return s->gpio_pdown;
blizzard.c:    case 0x04:	/* PLL M-Divider */
blizzard.c:        s->pll = (value & 0x3f) + 1;
blizzard.c:        s->pll_range = value & 3;
blizzard.c:        s->pll_ctrl &= 0xf00;
blizzard.c:        s->pll_ctrl |= (value << 0) & 0x0ff;
blizzard.c:        s->pll_ctrl &= 0x0ff;
blizzard.c:        s->pll_ctrl |= (value << 8) & 0xf00;
blizzard.c:        s->pll_mode = value & 0x77;
blizzard.c:    case 0x0e:	/* Clock-Source Select */
blizzard.c:        s->clksel = value & 0xff;
blizzard.c:        s->memenable = value & 1;
blizzard.c:    case 0x18:	/* Auto-Refresh Interval Setting 0 */
blizzard.c:        s->memrefresh &= 0xf00;
blizzard.c:        s->memrefresh |= (value << 0) & 0x0ff;
blizzard.c:    case 0x1a:	/* Auto-Refresh Interval Setting 1 */
blizzard.c:        s->memrefresh &= 0x0ff;
blizzard.c:        s->memrefresh |= (value << 8) & 0xf00;
blizzard.c:    case 0x1c:	/* Power-On Sequence Timing Control */
blizzard.c:        s->timing[0] = value & 0x7f;
blizzard.c:        s->timing[1] = value & 0x17;
blizzard.c:        s->timing[2] = value & 0x35;
blizzard.c:        s->priority = value & 1;
blizzard.c:        s->lcd_config = value & 0xff;
blizzard.c:        s->x = value << 3;
blizzard.c:    case 0x2c:	/* LCD Horizontal Non-display Period */
blizzard.c:        s->hndp = value & 0xff;
blizzard.c:        s->y &= 0x300;
blizzard.c:        s->y |= (value << 0) & 0x0ff;
blizzard.c:        s->y &= 0x0ff;
blizzard.c:        s->y |= (value << 8) & 0x300;
blizzard.c:    case 0x32:	/* LCD Vertical Non-display Period */
blizzard.c:        s->vndp = value & 0xff;
blizzard.c:    case 0x34:	/* LCD HS Pulse-width */
blizzard.c:        s->hsync = value & 0xff;
blizzard.c:        s->skipx = value & 0xff;
blizzard.c:    case 0x38:	/* LCD VS Pulse-width */
blizzard.c:        s->vsync = value & 0xbf;
blizzard.c:        s->skipy = value & 0xff;
blizzard.c:        s->pclk = value & 0x82;
blizzard.c:        /* Affects calculation of s->hndp, s->hsync and s->skipx.  */
blizzard.c:    case 0x3e:	/* High-speed Serial Interface Tx Configuration Port 0 */
blizzard.c:        s->hssi_config[0] = value;
blizzard.c:    case 0x40:	/* High-speed Serial Interface Tx Configuration Port 1 */
blizzard.c:        s->hssi_config[1] = value;
blizzard.c:            fprintf(stderr, "%s: Illegal active-data-links value\n",
blizzard.c:    case 0x42:	/* High-speed Serial Interface Tx Mode */
blizzard.c:        s->hssi_config[2] = value & 0xbd;
blizzard.c:        s->tv_config = value & 0xfe;
blizzard.c:        s->tv_timing[(reg - 0x46) >> 1] = value;
blizzard.c:        s->vbi = value;
blizzard.c:        s->tv_x = value;
blizzard.c:        s->tv_y = value & 0x7f;
blizzard.c:        s->tv_test = value;
blizzard.c:        s->tv_filter_config = value & 0xbf;
blizzard.c:        s->tv_filter_idx = value & 0x1f;
blizzard.c:        if (s->tv_filter_idx < 0x20)
blizzard.c:            s->tv_filter_coeff[s->tv_filter_idx ++] = value;
blizzard.c:        s->yrc[0] = value & 0xb0;
blizzard.c:        s->yrc[1] = value & 0x30;
blizzard.c:        s->u = value & 0xff;
blizzard.c:        s->v = value & 0xff;
blizzard.c:        if ((s->mode ^ value) & 3)
blizzard.c:            s->invalidate = 1;
blizzard.c:        s->mode = value & 0xb7;
blizzard.c:        s->enable = value & 1;
blizzard.c:        s->blank = (value >> 1) & 1;
blizzard.c:        s->effect = value & 0xfb;
blizzard.c:        s->ix[0] &= 0x300;
blizzard.c:        s->ix[0] |= (value << 0) & 0x0ff;
blizzard.c:        s->ix[0] &= 0x0ff;
blizzard.c:        s->ix[0] |= (value << 8) & 0x300;
blizzard.c:        s->iy[0] &= 0x300;
blizzard.c:        s->iy[0] |= (value << 0) & 0x0ff;
blizzard.c:        s->iy[0] &= 0x0ff;
blizzard.c:        s->iy[0] |= (value << 8) & 0x300;
blizzard.c:        s->ix[1] &= 0x300;
blizzard.c:        s->ix[1] |= (value << 0) & 0x0ff;
blizzard.c:        s->ix[1] &= 0x0ff;
blizzard.c:        s->ix[1] |= (value << 8) & 0x300;
blizzard.c:        s->iy[1] &= 0x300;
blizzard.c:        s->iy[1] |= (value << 0) & 0x0ff;
blizzard.c:        s->iy[1] &= 0x0ff;
blizzard.c:        s->iy[1] |= (value << 8) & 0x300;
blizzard.c:        s->ox[0] &= 0x300;
blizzard.c:        s->ox[0] |= (value << 0) & 0x0ff;
blizzard.c:        s->ox[0] &= 0x0ff;
blizzard.c:        s->ox[0] |= (value << 8) & 0x300;
blizzard.c:        s->oy[0] &= 0x300;
blizzard.c:        s->oy[0] |= (value << 0) & 0x0ff;
blizzard.c:        s->oy[0] &= 0x0ff;
blizzard.c:        s->oy[0] |= (value << 8) & 0x300;
blizzard.c:        s->ox[1] &= 0x300;
blizzard.c:        s->ox[1] |= (value << 0) & 0x0ff;
blizzard.c:        s->ox[1] &= 0x0ff;
blizzard.c:        s->ox[1] |= (value << 8) & 0x300;
blizzard.c:        s->oy[1] &= 0x300;
blizzard.c:        s->oy[1] |= (value << 0) & 0x0ff;
blizzard.c:        s->oy[1] &= 0x0ff;
blizzard.c:        s->oy[1] |= (value << 8) & 0x300;
blizzard.c:        s->iformat = value & 0xf;
blizzard.c:        s->bpp = blizzard_iformat_bpp[s->iformat];
blizzard.c:        if (!s->bpp)
blizzard.c:                            __FUNCTION__, s->iformat);
blizzard.c:        s->source = value & 7;
blizzard.c:        if ((!(s->effect & (1 << 3)) && (s->ix[0] != s->ox[0] ||
blizzard.c:                                        s->iy[0] != s->oy[0] ||
blizzard.c:                                        s->ix[1] != s->ox[1] ||
blizzard.c:                                        s->iy[1] != s->oy[1])) ||
blizzard.c:                        !((s->ix[1] - s->ix[0]) & (s->iy[1] - s->iy[0]) &
blizzard.c:                          (s->ox[1] - s->ox[0]) & (s->oy[1] - s->oy[0]) & 1))
blizzard.c:        if (!s->data.len && !blizzard_transfer_setup(s))
blizzard.c:        *s->data.ptr ++ = value;
blizzard.c:        if (-- s->data.len == 0)
blizzard.c:        s->border_r = value;
blizzard.c:        s->border_g = value;
blizzard.c:        s->border_b = value;
blizzard.c:        s->gamma_config = value & 0x87;
blizzard.c:        s->gamma_idx = value;
blizzard.c:        s->gamma_lut[s->gamma_idx ++] = value;
blizzard.c:        s->matrix_ena = value & 1;
blizzard.c:        s->matrix_coeff[(reg - 0xbc) >> 1] = value & ((reg & 2) ? 0x80 : 0xff);
blizzard.c:        s->matrix_r = value;
blizzard.c:        s->matrix_g = value;
blizzard.c:        s->matrix_b = value;
blizzard.c:    case 0xe6:	/* Power-save */
blizzard.c:        s->pm = value & 0x83;
blizzard.c:        if (value & s->mode & 1)
blizzard.c:    case 0xe8:	/* Non-display Period Control / Status */
blizzard.c:        s->status = value & 0x1b;
blizzard.c:        s->rgbgpio_dir = value & 0x8f;
blizzard.c:        s->rgbgpio = value & 0xcf;
blizzard.c:    case 0xee:	/* General-purpose IO Pins Configuration */
blizzard.c:        s->gpio_dir = value;
blizzard.c:    case 0xf0:	/* General-purpose IO Pins Status / Control */
blizzard.c:        s->gpio = value;
blizzard.c:        s->gpio_edge[0] = value;
blizzard.c:        s->gpio_edge[1] = value;
blizzard.c:        s->gpio_irq &= value;
blizzard.c:    case 0xf8:	/* GPIO Pull-down Control */
blizzard.c:        s->gpio_pdown = value;
blizzard.c:    uint16_t value = blizzard_reg_read(s, s->reg);
blizzard.c:    if (s->swallow -- > 0)
blizzard.c:        s->reg ++;
blizzard.c:    if (s->swallow -- > 0)
blizzard.c:        blizzard_reg_write(s, s->reg, value);
blizzard.c:        if (s->reg != 0x90 && s->reg != 0x5a && s->reg != 0xb8)
blizzard.c:            s->reg += 2;
blizzard.c:        s->reg = value & 0xff;
blizzard.c:        if (s->reg == 0x90 && dc &&
blizzard.c:                        (s->data.len || blizzard_transfer_setup(s)) &&
blizzard.c:                        len >= (s->data.len << 1)) {
blizzard.c:            len -= s->data.len << 1;
blizzard.c:            s->data.len = 0;
blizzard.c:            s->data.data = buf;
blizzard.c:                s->data.pitch = pitch;
blizzard.c:            s->data.data = s->data.buf;
blizzard.c:        len -= 2;
blizzard.c:    if (!s->enable)
blizzard.c:    if (s->x != ds_get_width(s->state) || s->y != ds_get_height(s->state)) {
blizzard.c:        s->invalidate = 1;
blizzard.c:        qemu_console_resize(s->state, s->x, s->y);
blizzard.c:    if (s->invalidate) {
blizzard.c:        s->invalidate = 0;
blizzard.c:        if (s->blank) {
blizzard.c:            bypp = (ds_get_bits_per_pixel(s->state) + 7) >> 3;
blizzard.c:            memset(ds_get_data(s->state), 0, bypp * s->x * s->y);
blizzard.c:        s->mx[0] = 0;
blizzard.c:        s->mx[1] = s->x;
blizzard.c:        s->my[0] = 0;
blizzard.c:        s->my[1] = s->y;
blizzard.c:    if (s->mx[1] <= s->mx[0])
blizzard.c:    bypp = (ds_get_bits_per_pixel(s->state) + 7) >> 3;
blizzard.c:    bypl = bypp * s->x;
blizzard.c:    bwidth = bypp * (s->mx[1] - s->mx[0]);
blizzard.c:    y = s->my[0];
blizzard.c:    src = s->fb + bypl * y + bypp * s->mx[0];
blizzard.c:    dst = ds_get_data(s->state) + bypl * y + bypp * s->mx[0];
blizzard.c:    for (; y < s->my[1]; y ++, src += bypl, dst += bypl)
blizzard.c:    dpy_update(s->state, s->mx[0], s->my[0],
blizzard.c:                    s->mx[1] - s->mx[0], y - s->my[0]);
blizzard.c:    s->mx[0] = s->x;
blizzard.c:    s->mx[1] = 0;
blizzard.c:    s->my[0] = s->y;
blizzard.c:    s->my[1] = 0;
blizzard.c:    if (s && ds_get_data(s->state))
blizzard.c:        ppm_save(filename, s->state->surface);
blizzard.c:    s->fb = qemu_malloc(0x180000);
blizzard.c:    s->state = graphic_console_init(blizzard_update_display,
blizzard.c:    switch (ds_get_bits_per_pixel(s->state)) {
blizzard.c:        s->line_fn_tab[0] = s->line_fn_tab[1] =
blizzard.c:        s->line_fn_tab[0] = blizzard_draw_fn_8;
blizzard.c:        s->line_fn_tab[1] = blizzard_draw_fn_r_8;
blizzard.c:        s->line_fn_tab[0] = blizzard_draw_fn_15;
blizzard.c:        s->line_fn_tab[1] = blizzard_draw_fn_r_15;
blizzard.c:        s->line_fn_tab[0] = blizzard_draw_fn_16;
blizzard.c:        s->line_fn_tab[1] = blizzard_draw_fn_r_16;
blizzard.c:        s->line_fn_tab[0] = blizzard_draw_fn_24;
blizzard.c:        s->line_fn_tab[1] = blizzard_draw_fn_r_24;
blizzard.c:        s->line_fn_tab[0] = blizzard_draw_fn_32;
blizzard.c:        s->line_fn_tab[1] = blizzard_draw_fn_r_32;
blizzard_template.h:    /* TODO: check if SDL 24-bit planes are not in the same format and
bt.c:#include "qemu-common.h"
bt.c:    if (link->slave->reject_reason)
bt.c:    exit(-1);
bt.c:    exit(-1);
bt.c:    exit(-1);
bt.c:    link->slave = req->slave;
bt.c:    link->host = req->host;
bt.c:    req->host->reject_reason = 0;
bt.c:    req->host->lmp_connection_complete(link);
bt.c:    dev->inquiry_scan = 1;
bt.c:    dev->page_scan = 1;
bt.c:    dev->bd_addr.b[0] = bt_dev_idx & 0xff;
bt.c:    dev->bd_addr.b[1] = bt_dev_idx >> 8;
bt.c:    dev->bd_addr.b[2] = 0xd0;
bt.c:    dev->bd_addr.b[3] = 0xba;
bt.c:    dev->bd_addr.b[4] = 0xbe;
bt.c:    dev->bd_addr.b[5] = 0xba;
bt.c:    /* Simple slave-only devices need to implement only .lmp_acl_data */
bt.c:    dev->lmp_connection_complete = bt_dummy_lmp_connection_complete;
bt.c:    dev->lmp_disconnect_master = bt_dummy_lmp_disconnect_master;
bt.c:    dev->lmp_acl_resp = bt_dummy_lmp_acl_resp;
bt.c:    dev->lmp_mode_change = bt_dummy_lmp_mode_change;
bt.c:    dev->lmp_connection_request = bt_dummy_lmp_connection_request;
bt.c:    dev->lmp_disconnect_slave = bt_dummy_lmp_disconnect_slave;
bt.c:    dev->handle_destroy = bt_dummy_destroy;
bt.c:    dev->net = net;
bt.c:    dev->next = net->slave;
bt.c:    net->slave = dev;
bt.c:    struct bt_device_s **p = &dev->net->slave;
bt.c:        p = &(*p)->next;
bt.c:                        dev->lmp_name ?: "(null)");
bt.c:        exit(-1);
bt.c:    *p = dev->next;
bt.h: * Copyright (C) 2000-2001  Qualcomm Incorporated
bt.h: * Copyright (C) 2002-2003  Maxim Krasnyansky <maxk@qualcomm.com>
bt.h: * Copyright (C) 2002-2006  Marcel Holtmann <marcel@holtmann.org>
bt.h:    (orig)->b[0], (orig)->b[1], (orig)->b[2],	\
bt.h:    (orig)->b[3], (orig)->b[4], (orig)->b[5],	\
bt.h:    uint16_t clkoff;	/* Note: Always little-endian */
bt.h:/* bt-hci.c */
bt.h:/* bt-vhci.c */
bt.h:/* bt-hci-csr.c */
bt.h:/* bt-l2cap.c */
bt.h:/* bt-sdp.c */
bt.h:/* bt-hid.c */
bt.h: * are little-endian while SDP is big-endian.  */
bt-hci.c:#include "qemu-common.h"
bt-hci.c:#include "qemu-timer.h"
bt-hci.c:    int last_cmd;	/* Note: Always little-endian */
bt-hci.c:    uint16_t voice_setting;	/* Notw: Always little-endian */
bt-hci.c:    length --;
bt-hci.c:        length --;
bt-hci.c:        bt->setup = 1;
bt-hci.c:        bt->setup = 0;
bt-hci.c:        /* data[0-15]	Random number
bt-hci.c:            if (bt->key_present) {
bt-hci.c:            memcpy(respdata + 1, bt->key, 16);
bt-hci.c:        /* data[0-15]	Key
bt-hci.c:        memcpy(bt->key, data, 16);
bt-hci.c:        bt->key_present = 1;
bt-hci.c:        /* data[0-3]	Authentication response
bt-hci.c:        /* data[0-7]	Features
bt-hci.c:            respdata[1] = (bt->lmp_caps >> 0) & 0xff;
bt-hci.c:            respdata[2] = (bt->lmp_caps >> 8) & 0xff;
bt-hci.c:            respdata[3] = (bt->lmp_caps >> 16) & 0xff;
bt-hci.c:            respdata[4] = (bt->lmp_caps >> 24) & 0xff;
bt-hci.c:            respdata[5] = (bt->lmp_caps >> 32) & 0xff;
bt-hci.c:            respdata[6] = (bt->lmp_caps >> 40) & 0xff;
bt-hci.c:            respdata[7] = (bt->lmp_caps >> 48) & 0xff;
bt-hci.c:            respdata[8] = (bt->lmp_caps >> 56) & 0xff;
bt-hci.c:        respdata[2] = strlen(bt->lmp_name);
bt-hci.c:            memcpy(respdata + 3, bt->lmp_name + respdata[1],
bt-hci.c:                            respdata[2] - respdata[1]);
bt-hci.c:         * data[2-15]	Name fragment
bt-hci.c:    slave = net->slave;
bt-hci.c:        bt_submit_lmp(slave, length - 1, data + 1);
bt-hci.c:        bt_sumbit_l2cap(slave, length - 1, data + 1, (data[0] >> 2) & 1);
bt-hci.c: * be valid as connection identifiers for the guest - they don't have to
bt-hci.c:        exit(-1);
bt-hci.c:    mask_byte = (evt - 1) >> 3;
bt-hci.c:    mask = 1 << ((evt - 1) & 3);
bt-hci.c:    if (mask & bt_event_reserved_mask[mask_byte] & ~hci->event_mask[mask_byte])
bt-hci.c:    packet = hci->evt_packet(hci->opaque);
bt-hci.c:    hci->evt_submit(hci->opaque, len + 2);
bt-hci.c:        .opcode	= hci->last_cmd,
bt-hci.c:    params->ncmd	= 1;
bt-hci.c:    params->opcode	= hci->last_cmd;
bt-hci.c:    hci->evt_submit(hci->opaque, len + EVT_CMD_COMPLETE_SIZE + 2);
bt-hci.c:    if (!hci->lm.periodic)
bt-hci.c:        hci->lm.inquire = 0;
bt-hci.c:     * nearby Bluetooth devices that responded [so hci->responses].", but
bt-hci.c:        .bdaddr			= BAINIT(&slave->bd_addr),
bt-hci.c:        .pscan_period_mode	= 0x00,	/* P0 - deprecated */
bt-hci.c:        .pscan_mode		= 0x00,	/* Standard scan - deprecated */
bt-hci.c:        .dev_class[0]		= slave->class[0],
bt-hci.c:        .dev_class[1]		= slave->class[1],
bt-hci.c:        .dev_class[2]		= slave->class[2],
bt-hci.c:        .clock_offset		= slave->clkoff,	/* Note: no swapping */
bt-hci.c:        .bdaddr			= BAINIT(&slave->bd_addr),
bt-hci.c:        .pscan_period_mode	= 0x00,	/* P0 - deprecated */
bt-hci.c:        .dev_class[0]		= slave->class[0],
bt-hci.c:        .dev_class[1]		= slave->class[1],
bt-hci.c:        .dev_class[2]		= slave->class[2],
bt-hci.c:        .clock_offset		= slave->clkoff,	/* Note: no swapping */
bt-hci.c:    if (!slave->inquiry_scan || !hci->lm.responses_left)
bt-hci.c:    hci->lm.responses_left --;
bt-hci.c:    hci->lm.responses ++;
bt-hci.c:    switch (hci->lm.inquiry_mode) {
bt-hci.c:                        hci->lm.inquiry_mode);
bt-hci.c:        exit(-1);
bt-hci.c:    hci->lm.inquiry_length = length;
bt-hci.c:    for (slave = hci->device.net->slave; slave; slave = slave->next)
bt-hci.c:        if (slave != &hci->device)
bt-hci.c:     * an Inquiry Result is generated immediately.  Alternatively re-loop
bt-hci.c:    if (hci->lm.responses_left)
bt-hci.c:        bt_hci_mod_timer_1280ms(hci->lm.inquiry_done, hci->lm.inquiry_length);
bt-hci.c:    if (hci->lm.periodic)
bt-hci.c:        bt_hci_mod_timer_1280ms(hci->lm.inquiry_next, hci->lm.inquiry_period);
bt-hci.c:    hci->lm.responses_left += hci->lm.responses;
bt-hci.c:    hci->lm.responses = 0;
bt-hci.c:    bt_hci_inquiry_start(hci,  hci->lm.inquiry_length);
bt-hci.c:            !hci->lm.handle[handle & ~HCI_HANDLE_OFFSET].link;
bt-hci.c:    return !!(hci->lm.role_bmp & (1 << (handle & ~HCI_HANDLE_OFFSET)));
bt-hci.c:    struct bt_link_s *link = hci->lm.handle[handle & ~HCI_HANDLE_OFFSET].link;
bt-hci.c:    return bt_hci_role_master(hci, handle) ? link->slave : link->host;
bt-hci.c:    hci->lm.handle[hci->lm.last_handle].link = link;
bt-hci.c:        hci->lm.role_bmp |= 1 << hci->lm.last_handle;
bt-hci.c:        hci->lm.handle[hci->lm.last_handle].lmp_acl_data =
bt-hci.c:                link->slave->lmp_acl_data;
bt-hci.c:        hci->lm.role_bmp &= ~(1 << hci->lm.last_handle);
bt-hci.c:        hci->lm.handle[hci->lm.last_handle].lmp_acl_data =
bt-hci.c:                link->host->lmp_acl_resp;
bt-hci.c:        link->acl_mode = acl_active;
bt-hci.c:        hci->lm.handle[hci->lm.last_handle].acl_mode_timer =
bt-hci.c:    hci->lm.handle[handle].link = NULL;
bt-hci.c:        qemu_del_timer(hci->lm.handle[handle].acl_mode_timer);
bt-hci.c:        qemu_free_timer(hci->lm.handle[handle].acl_mode_timer);
bt-hci.c:    for (slave = hci->device.net->slave; slave; slave = slave->next)
bt-hci.c:        if (slave->page_scan && !bacmp(&slave->bd_addr, bdaddr))
bt-hci.c:    if (!slave || slave == &hci->device)
bt-hci.c:        return -ENODEV;
bt-hci.c:    bacpy(&hci->lm.awaiting_bdaddr[hci->lm.connecting ++], &slave->bd_addr);
bt-hci.c:    link.host = &hci->device;
bt-hci.c:    link.slave->lmp_connection_request(&link);	/* Always last */
bt-hci.c:        .slave	= &hci->device,
bt-hci.c:    host->reject_reason = because;
bt-hci.c:    host->lmp_connection_complete(&link);
bt-hci.c:        while (hci->lm.handle[++ hci->lm.last_handle].link && -- tries)
bt-hci.c:            hci->lm.last_handle &= HCI_HANDLES_MAX - 1;
bt-hci.c:        handle = hci->lm.last_handle | HCI_HANDLE_OFFSET;
bt-hci.c:    } while ((handle == hci->asb_handle || handle == hci->psb_handle) &&
bt-hci.c:    link->btlink.slave	= &hci->device;
bt-hci.c:    link->btlink.host	= host;
bt-hci.c:    link->handle = handle;
bt-hci.c:    bt_hci_lmp_link_establish(hci, &link->btlink, 0);
bt-hci.c:    bacpy(&params.bdaddr, &host->bd_addr);
bt-hci.c:        host->reject_reason = 0;
bt-hci.c:        host->lmp_connection_complete(&link->btlink);
bt-hci.c:    struct bt_hci_s *hci = hci_from_device(link->slave);
bt-hci.c:    if (hci->conn_req_host) {
bt-hci.c:        bt_hci_connection_reject(hci, link->host,
bt-hci.c:    hci->conn_req_host = link->host;
bt-hci.c:    /* TODO: if masked and auto-accept, then auto-accept,
bt-hci.c:     * if masked and not auto-accept, then auto-reject */
bt-hci.c:    /* TODO: kick the hci->conn_accept_timer, timeout after
bt-hci.c:     * hci->conn_accept_tout * 0.625 msec */
bt-hci.c:    bacpy(&params.bdaddr, &link->host->bd_addr);
bt-hci.c:    memcpy(&params.dev_class, &link->host->class, sizeof(params.dev_class));
bt-hci.c:    if (!hci->conn_req_host)
bt-hci.c:    for (i = 0; i < hci->lm.connecting; i ++)
bt-hci.c:        if (!bacmp(&hci->lm.awaiting_bdaddr[i], bdaddr)) {
bt-hci.c:            if (i < -- hci->lm.connecting)
bt-hci.c:                bacpy(&hci->lm.awaiting_bdaddr[i],
bt-hci.c:                                &hci->lm.awaiting_bdaddr[hci->lm.connecting]);
bt-hci.c:    struct bt_hci_s *hci = hci_from_device(link->host);
bt-hci.c:    if (bt_hci_lmp_connection_ready(hci, &link->slave->bd_addr)) {
bt-hci.c:        if (!hci->device.reject_reason)
bt-hci.c:            link->slave->lmp_disconnect_slave(link);
bt-hci.c:    if (hci->device.reject_reason) {
bt-hci.c:        status = hci->device.reject_reason;
bt-hci.c:        while (hci->lm.handle[++ hci->lm.last_handle].link && -- tries)
bt-hci.c:            hci->lm.last_handle &= HCI_HANDLES_MAX - 1;
bt-hci.c:        handle = hci->lm.last_handle | HCI_HANDLE_OFFSET;
bt-hci.c:    } while ((handle == hci->asb_handle || handle == hci->psb_handle) &&
bt-hci.c:        link->slave->lmp_disconnect_slave(link);
bt-hci.c:    link->handle = handle;
bt-hci.c:    bacpy(&params.bdaddr, &link->slave->bd_addr);
bt-hci.c:            hci->lm.handle[handle & ~HCI_HANDLE_OFFSET].link;
bt-hci.c:        btlink->slave->reject_reason = reason;
bt-hci.c:        btlink->slave->lmp_disconnect_slave(btlink);
bt-hci.c:    btlink->host->reject_reason = reason;
bt-hci.c:    btlink->host->lmp_disconnect_master(btlink);
bt-hci.c:    struct bt_hci_s *hci = hci_from_device(link->host);
bt-hci.c:    uint16_t handle = link->handle;
bt-hci.c:    params.reason	= hci->device.reject_reason;
bt-hci.c:    struct bt_hci_s *hci = hci_from_device(btlink->slave);
bt-hci.c:    uint16_t handle = link->handle;
bt-hci.c:    params.reason	= hci->device.reject_reason;
bt-hci.c:    for (slave = hci->device.net->slave; slave; slave = slave->next)
bt-hci.c:        if (slave->page_scan && !bacmp(&slave->bd_addr, bdaddr))
bt-hci.c:        return -ENODEV;
bt-hci.c:    bacpy(&params.bdaddr, &slave->bd_addr);
bt-hci.c:                    "%s", slave->lmp_name ?: "");
bt-hci.c:    memset(params.name + len, 0, sizeof(params.name) - len);
bt-hci.c:        return -ENODEV;
bt-hci.c:    params.features[0]	= (slave->lmp_caps >>  0) & 0xff;
bt-hci.c:    params.features[1]	= (slave->lmp_caps >>  8) & 0xff;
bt-hci.c:    params.features[2]	= (slave->lmp_caps >> 16) & 0xff;
bt-hci.c:    params.features[3]	= (slave->lmp_caps >> 24) & 0xff;
bt-hci.c:    params.features[4]	= (slave->lmp_caps >> 32) & 0xff;
bt-hci.c:    params.features[5]	= (slave->lmp_caps >> 40) & 0xff;
bt-hci.c:    params.features[6]	= (slave->lmp_caps >> 48) & 0xff;
bt-hci.c:    params.features[7]	= (slave->lmp_caps >> 56) & 0xff;
bt-hci.c:        return -ENODEV;
bt-hci.c:        return -ENODEV;
bt-hci.c:    params.clock_offset	= slave->clkoff;	/* Note: no swapping */
bt-hci.c:        .mode		= link->acl_mode,
bt-hci.c:        .interval	= cpu_to_le16(link->acl_interval),
bt-hci.c:    link->acl_mode = mode;
bt-hci.c:    link->acl_interval = interval;
bt-hci.c:    bt_hci_event_mode(hci, link, link->handle);
bt-hci.c:    link->slave->lmp_mode_change(link);
bt-hci.c:    struct bt_hci_s *hci = hci_from_device(btlink->slave);
bt-hci.c:    bt_hci_event_mode(hci, btlink, link->handle);
bt-hci.c:        return -ENODEV;
bt-hci.c:    link = &hci->lm.handle[handle & ~HCI_HANDLE_OFFSET];
bt-hci.c:    if (link->link->acl_mode != acl_active) {
bt-hci.c:    qemu_mod_timer(link->acl_mode_timer, qemu_get_clock(vm_clock) +
bt-hci.c:    bt_hci_lmp_mode_change_master(hci, link->link, mode, interval);
bt-hci.c:        return -ENODEV;
bt-hci.c:    link = &hci->lm.handle[handle & ~HCI_HANDLE_OFFSET];
bt-hci.c:    if (link->link->acl_mode != mode) {
bt-hci.c:    qemu_del_timer(link->acl_mode_timer);
bt-hci.c:    bt_hci_lmp_mode_change_master(hci, link->link, acl_active, 0);
bt-hci.c:    struct bt_hci_s *hci = hci_from_device(link->host);
bt-hci.c:    hci->acl_len = 0;
bt-hci.c:    hci->last_cmd = 0;
bt-hci.c:    hci->lm.connecting = 0;
bt-hci.c:    hci->event_mask[0] = 0xff;
bt-hci.c:    hci->event_mask[1] = 0xff;
bt-hci.c:    hci->event_mask[2] = 0xff;
bt-hci.c:    hci->event_mask[3] = 0xff;
bt-hci.c:    hci->event_mask[4] = 0xff;
bt-hci.c:    hci->event_mask[5] = 0x1f;
bt-hci.c:    hci->event_mask[6] = 0x00;
bt-hci.c:    hci->event_mask[7] = 0x00;
bt-hci.c:    hci->device.inquiry_scan = 0;
bt-hci.c:    hci->device.page_scan = 0;
bt-hci.c:    if (hci->device.lmp_name)
bt-hci.c:        qemu_free((void *) hci->device.lmp_name);
bt-hci.c:    hci->device.lmp_name = NULL;
bt-hci.c:    hci->device.class[0] = 0x00;
bt-hci.c:    hci->device.class[1] = 0x00;
bt-hci.c:    hci->device.class[2] = 0x00;
bt-hci.c:    hci->voice_setting = 0x0000;
bt-hci.c:    hci->conn_accept_tout = 0x1f40;
bt-hci.c:    hci->lm.inquiry_mode = 0x00;
bt-hci.c:    hci->psb_handle = 0x000;
bt-hci.c:    hci->asb_handle = 0x000;
bt-hci.c:    /* XXX: qemu_del_timer(sl->acl_mode_timer); for all links */
bt-hci.c:    qemu_del_timer(hci->lm.inquiry_done);
bt-hci.c:    qemu_del_timer(hci->lm.inquiry_next);
bt-hci.c:    qemu_del_timer(hci->conn_accept_timer);
bt-hci.c:            /* Also, keep in sync with hci->device.lmp_caps in bt_new_hci */
bt-hci.c:            (hci->device.lmp_caps >>  0) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >>  8) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >> 16) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >> 24) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >> 32) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >> 40) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >> 48) & 0xff,
bt-hci.c:            (hci->device.lmp_caps >> 56) & 0xff,
bt-hci.c:        .bdaddr = BAINIT(&hci->device.bd_addr),
bt-hci.c:    if (hci->device.lmp_name)
bt-hci.c:        strncpy(params.name, hci->device.lmp_name, sizeof(params.name));
bt-hci.c:        .timeout	= cpu_to_le16(hci->conn_accept_tout),
bt-hci.c:                (hci->device.inquiry_scan ? SCAN_INQUIRY : 0) |
bt-hci.c:                (hci->device.page_scan ? SCAN_PAGE : 0),
bt-hci.c:    memcpy(params.dev_class, hci->device.class, sizeof(params.dev_class));
bt-hci.c:        .voice_setting	= hci->voice_setting,	/* Note: no swapping */
bt-hci.c:        .mode		= hci->lm.inquiry_mode,
bt-hci.c:    params->num_hndl			= 1;
bt-hci.c:    params->connection->handle		= HNDL(handle);
bt-hci.c:    params->connection->num_packets	= cpu_to_le16(packets);
bt-hci.c:    memcpy(&hci->last_cmd, data, 2);
bt-hci.c:    length -= HCI_COMMAND_HDR_SIZE;
bt-hci.c:#define PARAM(cmd, param)	(((cmd##_cp *) data)->param)
bt-hci.c:        hci->lm.inquire = 1;
bt-hci.c:        hci->lm.periodic = 0;
bt-hci.c:        hci->lm.responses_left = PARAM(inquiry, num_rsp) ?: INT_MAX;
bt-hci.c:        hci->lm.responses = 0;
bt-hci.c:        if (!hci->lm.inquire || hci->lm.periodic) {
bt-hci.c:        hci->lm.inquire = 0;
bt-hci.c:        qemu_del_timer(hci->lm.inquiry_done);
bt-hci.c:        hci->lm.inquire = 1;
bt-hci.c:        hci->lm.periodic = 1;
bt-hci.c:        hci->lm.responses_left = PARAM(periodic_inquiry, num_rsp);
bt-hci.c:        hci->lm.responses = 0;
bt-hci.c:        hci->lm.inquiry_period = PARAM16(periodic_inquiry, max_period);
bt-hci.c:        if (!hci->lm.inquire || !hci->lm.periodic) {
bt-hci.c:        hci->lm.inquire = 0;
bt-hci.c:        qemu_del_timer(hci->lm.inquiry_done);
bt-hci.c:        qemu_del_timer(hci->lm.inquiry_next);
bt-hci.c:        if (hci->lm.connecting >= HCI_HANDLES_MAX) {
bt-hci.c:                if (bt_hci_role_master(hci, i) && hci->lm.handle[i].link &&
bt-hci.c:                                !bacmp(&hci->lm.handle[i].link->slave->bd_addr,
bt-hci.c:        if (!hci->conn_req_host ||
bt-hci.c:                                &hci->conn_req_host->bd_addr)) {
bt-hci.c:        bt_hci_connection_accept(hci, hci->conn_req_host);
bt-hci.c:        hci->conn_req_host = NULL;
bt-hci.c:        if (!hci->conn_req_host ||
bt-hci.c:                                &hci->conn_req_host->bd_addr)) {
bt-hci.c:        bt_hci_connection_reject(hci, hci->conn_req_host,
bt-hci.c:        bt_hci_connection_reject_event(hci, &hci->conn_req_host->bd_addr);
bt-hci.c:        hci->conn_req_host = NULL;
bt-hci.c:        memcpy(hci->event_mask, PARAM(set_event_mask, mask), 8);
bt-hci.c:        if (hci->device.lmp_name)
bt-hci.c:            qemu_free((void *) hci->device.lmp_name);
bt-hci.c:        hci->device.lmp_name = qemu_strndup(PARAM(change_local_name, name),
bt-hci.c:        hci->conn_accept_tout = PARAM16(write_conn_accept_timeout, timeout);
bt-hci.c:        hci->device.inquiry_scan =
bt-hci.c:        hci->device.page_scan =
bt-hci.c:        memcpy(hci->device.class, PARAM(write_class_of_dev, dev_class),
bt-hci.c:        hci->voice_setting = PARAM(write_voice_setting, voice_setting);
bt-hci.c:        hci->lm.inquiry_mode = PARAM(write_inquiry_mode, mode);
bt-hci.c:    struct hci_acl_hdr *pkt = (void *) hci->acl_buf;
bt-hci.c:    if (len + HCI_ACL_HDR_SIZE > sizeof(hci->acl_buf)) {
bt-hci.c:    memcpy(hci->acl_buf + HCI_ACL_HDR_SIZE, data, len);
bt-hci.c:    pkt->handle = cpu_to_le16(
bt-hci.c:    pkt->dlen = cpu_to_le16(len);
bt-hci.c:    hci->info.acl_recv(hci->info.opaque,
bt-hci.c:                    hci->acl_buf, len + HCI_ACL_HDR_SIZE);
bt-hci.c:    bt_hci_lmp_acl_data(hci_from_device(btlink->slave),
bt-hci.c:                    link->handle, data, start, len);
bt-hci.c:    bt_hci_lmp_acl_data(hci_from_device(link->host),
bt-hci.c:                    link->handle, data, start, len);
bt-hci.c:    length -= HCI_ACL_HDR_SIZE;
bt-hci.c:    link = hci->lm.handle[handle].link;
bt-hci.c:        if (!hci->asb_handle)
bt-hci.c:            hci->asb_handle = handle;
bt-hci.c:        else if (handle != hci->asb_handle) {
bt-hci.c:        if (!hci->psb_handle)
bt-hci.c:            hci->psb_handle = handle;
bt-hci.c:        else if (handle != hci->psb_handle) {
bt-hci.c:    hci->lm.handle[handle].lmp_acl_data(link, data,
bt-hci.c:    length -= 3;
bt-hci.c:    link = hci->lm.handle[handle].link;
bt-hci.c:    return s->evt_buf;
bt-hci.c:    s->info.evt_recv(s->info.opaque, s->evt_buf, len);
bt-hci.c:    bacpy(&hci->device.bd_addr, (const bdaddr_t *) bd_addr);
bt-hci.c:    bt_hci_done(&hci->info);
bt-hci.c:    s->lm.inquiry_done = qemu_new_timer(vm_clock, bt_hci_inquiry_done, s);
bt-hci.c:    s->lm.inquiry_next = qemu_new_timer(vm_clock, bt_hci_inquiry_next, s);
bt-hci.c:    s->conn_accept_timer =
bt-hci.c:    s->evt_packet = bt_hci_evt_packet;
bt-hci.c:    s->evt_submit = bt_hci_evt_submit;
bt-hci.c:    s->opaque = s;
bt-hci.c:    bt_device_init(&s->device, net);
bt-hci.c:    s->device.lmp_connection_request = bt_hci_lmp_connection_request;
bt-hci.c:    s->device.lmp_connection_complete = bt_hci_lmp_connection_complete;
bt-hci.c:    s->device.lmp_disconnect_master = bt_hci_lmp_disconnect_host;
bt-hci.c:    s->device.lmp_disconnect_slave = bt_hci_lmp_disconnect_slave;
bt-hci.c:    s->device.lmp_acl_data = bt_hci_lmp_acl_data_slave;
bt-hci.c:    s->device.lmp_acl_resp = bt_hci_lmp_acl_data_host;
bt-hci.c:    s->device.lmp_mode_change = bt_hci_lmp_mode_change_slave;
bt-hci.c:    s->device.lmp_caps = 0x8000199b7e85355fll;
bt-hci.c:    s->info.cmd_send = bt_submit_hci;
bt-hci.c:    s->info.sco_send = bt_submit_sco;
bt-hci.c:    s->info.acl_send = bt_submit_acl;
bt-hci.c:    s->info.bdaddr_set = bt_hci_bdaddr_set;
bt-hci.c:    s->device.handle_destroy = bt_hci_destroy;
bt-hci.c:    return &s->info;
bt-hci.c:    bt_device_done(&hci->device);
bt-hci.c:    if (hci->device.lmp_name)
bt-hci.c:        qemu_free((void *) hci->device.lmp_name);
bt-hci.c:    if (hci->conn_req_host) {
bt-hci.c:                                 hci->conn_req_host, HCI_OE_POWER_OFF);
bt-hci.c:     * an accept or a reject, so we should also check if hci->lm.connecting
bt-hci.c:     * is non-zero and if so, avoid freeing the hci but otherwise disappear
bt-hci.c:     * removed from s->device.net) and arrange for
bt-hci.c:     * s->device.lmp_connection_complete to free the remaining bits once
bt-hci.c:     * hci->lm.awaiting_bdaddr[] is empty.  */
bt-hci.c:    qemu_free_timer(hci->lm.inquiry_done);
bt-hci.c:    qemu_free_timer(hci->lm.inquiry_next);
bt-hci.c:    qemu_free_timer(hci->conn_accept_timer);
bt-hci-csr.c:#include "qemu-common.h"
bt-hci-csr.c:#include "qemu-char.h"
bt-hci-csr.c:#include "qemu-timer.h"
bt-hci-csr.c:/* CSR41814 vendor-specific command OCFs */
bt-hci-csr.c:    if (!s->enable || !s->out_len)
bt-hci-csr.c:    /* XXX: Should wait for s->modem_state & CHR_TIOCM_RTS? */
bt-hci-csr.c:    if (s->chr.chr_can_read && s->chr.chr_can_read(s->chr.handler_opaque) &&
bt-hci-csr.c:                    s->chr.chr_read) {
bt-hci-csr.c:        s->chr.chr_read(s->chr.handler_opaque,
bt-hci-csr.c:                        s->outfifo + s->out_start ++, 1);
bt-hci-csr.c:        s->out_len --;
bt-hci-csr.c:        if (s->out_start >= s->out_size) {
bt-hci-csr.c:            s->out_start = 0;
bt-hci-csr.c:            s->out_size = FIFO_LEN;
bt-hci-csr.c:    if (s->out_len)
bt-hci-csr.c:        qemu_mod_timer(s->out_tm, qemu_get_clock(vm_clock) + s->baud_delay);
bt-hci-csr.c:    int off = s->out_start + s->out_len;
bt-hci-csr.c:    s->out_len += len;
bt-hci-csr.c:        if (off + len > FIFO_LEN && (s->out_size = off + len) > FIFO_LEN * 2) {
bt-hci-csr.c:            exit(-1);
bt-hci-csr.c:        return s->outfifo + off;
bt-hci-csr.c:    if (s->out_len > s->out_size) {
bt-hci-csr.c:        exit(-1);
bt-hci-csr.c:    return s->outfifo + off - s->out_size;
bt-hci-csr.c:    ((struct hci_event_hdr *) ret)->evt = evt;
bt-hci-csr.c:    ((struct hci_event_hdr *) ret)->plen = len;
bt-hci-csr.c:            s->bd_addr.b[0] = data[offset + 7];	/* Beyond cmd packet end(!?) */
bt-hci-csr.c:            s->bd_addr.b[1] = data[offset + 6];
bt-hci-csr.c:            s->bd_addr.b[2] = data[offset + 4];
bt-hci-csr.c:            s->bd_addr.b[3] = data[offset + 0];
bt-hci-csr.c:            s->bd_addr.b[4] = data[offset + 3];
bt-hci-csr.c:            s->bd_addr.b[5] = data[offset + 2];
bt-hci-csr.c:            s->hci->bdaddr_set(s->hci, s->bd_addr.b);
bt-hci-csr.c:                            s->bd_addr.b[0], s->bd_addr.b[1], s->bd_addr.b[2],
bt-hci-csr.c:                            s->bd_addr.b[3], s->bd_addr.b[4], s->bd_addr.b[5]);
bt-hci-csr.c:        opc = le16_to_cpu(((struct hci_command_hdr *) pkt)->opcode);
bt-hci-csr.c:                            s->in_len - sizeof(struct hci_command_hdr) - 1);
bt-hci-csr.c:         * bt-hci.c we could just have hooks for this kind of commands but
bt-hci-csr.c:         * we can't with bt-host.c.  */
bt-hci-csr.c:        s->hci->cmd_send(s->hci, pkt, s->in_len - 1);
bt-hci-csr.c:        s->hci->acl_send(s->hci, pkt, s->in_len - 1);
bt-hci-csr.c:        s->hci->sco_send(s->hci, pkt, s->in_len - 1);
bt-hci-csr.c:        if (s->in_hdr != sizeof(csrhci_neg_packet) ||
bt-hci-csr.c:                        memcmp(pkt - 1, csrhci_neg_packet, s->in_hdr)) {
bt-hci-csr.c:        if (s->in_hdr != 4 || pkt[1] != 0x55 || pkt[2] != 0x00) {
bt-hci-csr.c:    exit(-1);
bt-hci-csr.c:        /* It seems that vendor-specific command packets for H4+ are all
bt-hci-csr.c:        if (le16_to_cpu(((struct hci_command_hdr *) pkt)->opcode) == 0xfc00)
bt-hci-csr.c:            return (((struct hci_command_hdr *) pkt)->plen + 1) & ~1;
bt-hci-csr.c:        return ((struct hci_command_hdr *) pkt)->plen;
bt-hci-csr.c:        return ((struct hci_event_hdr *) pkt)->plen;
bt-hci-csr.c:        return le16_to_cpu(((struct hci_acl_hdr *) pkt)->dlen);
bt-hci-csr.c:        return ((struct hci_sco_hdr *) pkt)->dlen;
bt-hci-csr.c:    exit(-1);
bt-hci-csr.c:    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;
bt-hci-csr.c:    int plen = s->in_len;
bt-hci-csr.c:    if (!s->enable)
bt-hci-csr.c:    s->in_len += len;
bt-hci-csr.c:    memcpy(s->inpkt + plen, buf, len);
bt-hci-csr.c:        if (s->in_len >= 2 && plen < 2)
bt-hci-csr.c:            s->in_hdr = csrhci_header_len(s->inpkt) + 1;
bt-hci-csr.c:        if (s->in_len >= s->in_hdr && plen < s->in_hdr)
bt-hci-csr.c:            s->in_data = csrhci_data_len(s->inpkt) + s->in_hdr;
bt-hci-csr.c:        if (s->in_len >= s->in_data) {
bt-hci-csr.c:            csrhci_in_packet(s, s->inpkt);
bt-hci-csr.c:            memmove(s->inpkt, s->inpkt + s->in_len, s->in_len - s->in_data);
bt-hci-csr.c:            s->in_len -= s->in_data;
bt-hci-csr.c:            s->in_hdr = INT_MAX;
bt-hci-csr.c:            s->in_data = INT_MAX;
bt-hci-csr.c:    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;
bt-hci-csr.c:    int prev_state = s->modem_state;
bt-hci-csr.c:        s->baud_delay = get_ticks_per_sec() / ssp->speed;
bt-hci-csr.c:        s->modem_state |= CHR_TIOCM_CTS;
bt-hci-csr.c:        *(int *) arg = s->modem_state;
bt-hci-csr.c:        s->modem_state = *(int *) arg;
bt-hci-csr.c:        if (~s->modem_state & prev_state & CHR_TIOCM_RTS)
bt-hci-csr.c:            s->modem_state &= ~CHR_TIOCM_CTS;
bt-hci-csr.c:        return -ENOTSUP;
bt-hci-csr.c:    s->out_len = 0;
bt-hci-csr.c:    s->out_size = FIFO_LEN;
bt-hci-csr.c:    s->in_len = 0;
bt-hci-csr.c:    s->baud_delay = get_ticks_per_sec();
bt-hci-csr.c:    s->enable = 0;
bt-hci-csr.c:    s->in_hdr = INT_MAX;
bt-hci-csr.c:    s->in_data = INT_MAX;
bt-hci-csr.c:    s->modem_state = 0;
bt-hci-csr.c:    s->modem_state |= CHR_TIOCM_CTS;
bt-hci-csr.c:    memset(&s->bd_addr, 0, sizeof(bdaddr_t));
bt-hci-csr.c:    int state = s->pin_state;
bt-hci-csr.c:    s->pin_state &= ~(1 << line);
bt-hci-csr.c:    s->pin_state |= (!!level) << line;
bt-hci-csr.c:    if ((state & ~s->pin_state) & (1 << csrhci_pin_reset)) {
bt-hci-csr.c:    if (s->pin_state == 3 && state != 3) {
bt-hci-csr.c:        s->enable = 1;
bt-hci-csr.c:    struct csrhci_s *s = (struct csrhci_s *) chr->opaque;
bt-hci-csr.c:    return s->pins;
bt-hci-csr.c:    s->chr.opaque = s;
bt-hci-csr.c:    s->chr.chr_write = csrhci_write;
bt-hci-csr.c:    s->chr.chr_ioctl = csrhci_ioctl;
bt-hci-csr.c:    s->hci = qemu_next_hci();
bt-hci-csr.c:    s->hci->opaque = s;
bt-hci-csr.c:    s->hci->evt_recv = csrhci_out_hci_packet_event;
bt-hci-csr.c:    s->hci->acl_recv = csrhci_out_hci_packet_acl;
bt-hci-csr.c:    s->out_tm = qemu_new_timer(vm_clock, csrhci_out_tick, s);
bt-hci-csr.c:    s->pins = qemu_allocate_irqs(csrhci_pins, s, __csrhci_pins);
bt-hci-csr.c:    return &s->chr;
bt-hid.c: * Copyright (C) 2007-2008 OpenMoko, Inc.
bt-hid.c:#include "qemu-common.h"
bt-hid.c:    struct bt_scatternet_s *net = s->btdev.device.net;
bt-hid.c:    bt_l2cap_device_done(&s->btdev);
bt-hid.c:    bt_l2cap_device_init(&s->btdev, net);
bt-hid.c:    s->usbdev->info->handle_reset(s->usbdev);
bt-hid.c:    s->proto = BT_HID_PROTO_REPORT;
bt-hid.c:    s->state = bt_state_ready;
bt-hid.c:    s->dataother.len = 0;
bt-hid.c:    s->datain.len = 0;
bt-hid.c:    s->dataout.len = 0;
bt-hid.c:    s->feature.len = 0;
bt-hid.c:    s->intrdataout.len = 0;
bt-hid.c:    s->intr_state = 0;
bt-hid.c:    if (s->data_type == BT_DATA_OUTPUT) {
bt-hid.c:        p.data = s->dataout.buffer;
bt-hid.c:        p.len = s->dataout.len;
bt-hid.c:        s->dataout.len = s->usbdev->info->handle_data(s->usbdev, &p);
bt-hid.c:        return s->dataout.len;
bt-hid.c:    if (s->data_type == BT_DATA_FEATURE) {
bt-hid.c:    return -1;
bt-hid.c:    p.data = s->datain.buffer;
bt-hid.c:    p.len = sizeof(s->datain.buffer);
bt-hid.c:    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);
bt-hid.c:    return s->datain.len;
bt-hid.c:    *s->control->sdu_out(s->control, 1) =
bt-hid.c:    s->control->sdu_submit(s->control);
bt-hid.c:    *s->control->sdu_out(s->control, 1) =
bt-hid.c:    s->control->sdu_submit(s->control);
bt-hid.c:    /* Disconnect s->control and s->interrupt */
bt-hid.c:        plen = MIN(len, ch->remote_mtu - 1);
bt-hid.c:        pkt = ch->sdu_out(ch, plen + 1);
bt-hid.c:        ch->sdu_submit(ch);
bt-hid.c:        len -= plen;
bt-hid.c:    } while (plen == ch->remote_mtu - 1);
bt-hid.c:    int rlen, ret = -1;
bt-hid.c:                                s->state == bt_state_transaction)) {
bt-hid.c:            if (s->state == bt_state_ready)
bt-hid.c:                s->state = bt_state_suspend;
bt-hid.c:            if (s->state == bt_state_suspend)
bt-hid.c:                s->state = bt_state_ready;
bt-hid.c:                        s->state != bt_state_ready) {
bt-hid.c:            /* Here we can as well poll s->usbdev */
bt-hid.c:            bt_hid_send_data(s->control, BT_DATA_INPUT,
bt-hid.c:                            s->datain.buffer, MIN(rlen, s->datain.len));
bt-hid.c:            bt_hid_send_data(s->control, BT_DATA_OUTPUT,
bt-hid.c:                            s->dataout.buffer, MIN(rlen, s->dataout.len));
bt-hid.c:            bt_hid_send_data(s->control, BT_DATA_FEATURE,
bt-hid.c:                            s->feature.buffer, MIN(rlen, s->feature.len));
bt-hid.c:        if (len < 2 || len > BT_HID_MTU || s->state != bt_state_ready ||
bt-hid.c:        s->data_type = parameter & 3;
bt-hid.c:        if (s->data_type == BT_DATA_OUTPUT) {
bt-hid.c:            s->dataout.len = len - 1;
bt-hid.c:            memcpy(s->dataout.buffer, data + 1, s->dataout.len);
bt-hid.c:            s->feature.len = len - 1;
bt-hid.c:            memcpy(s->feature.buffer, data + 1, s->feature.len);
bt-hid.c:            s->state = bt_state_transaction;
bt-hid.c:        if (len != 1 || s->state == bt_state_transaction) {
bt-hid.c:        *s->control->sdu_out(s->control, 1) = s->proto;
bt-hid.c:        s->control->sdu_submit(s->control);
bt-hid.c:        if (len != 1 || s->state == bt_state_transaction ||
bt-hid.c:        s->proto = parameter;
bt-hid.c:        s->usbdev->info->handle_control(s->usbdev, SET_PROTOCOL, s->proto, 0, 0,
bt-hid.c:        if (len != 1 || s->state == bt_state_transaction) {
bt-hid.c:        s->usbdev->info->handle_control(s->usbdev, GET_IDLE, 0, 0, 1,
bt-hid.c:                        s->control->sdu_out(s->control, 1));
bt-hid.c:        s->control->sdu_submit(s->control);
bt-hid.c:        if (len != 2 || s->state == bt_state_transaction) {
bt-hid.c:        ret = s->usbdev->info->handle_control(s->usbdev,
bt-hid.c:        if (len > BT_HID_MTU || s->state != bt_state_transaction) {
bt-hid.c:        if (s->data_type == BT_DATA_OUTPUT) {
bt-hid.c:            memcpy(s->dataout.buffer + s->dataout.len, data + 1, len - 1);
bt-hid.c:            s->dataout.len += len - 1;
bt-hid.c:            memcpy(s->feature.buffer + s->feature.len, data + 1, len - 1);
bt-hid.c:            s->feature.len += len - 1;
bt-hid.c:            s->state = bt_state_ready;
bt-hid.c:    if (ret != -1)
bt-hid.c:    /* If suspended, wake-up and send a wake-up event first.  We might
bt-hid.c:    if (hid->state == bt_state_suspend) {
bt-hid.c:        hid->state = bt_state_ready;
bt-hid.c:        /* TODO: when in boot-mode precede any Input reports with the ReportID
bt-hid.c:        bt_hid_send_data(hid->interrupt, BT_DATA_INPUT,
bt-hid.c:                        hid->datain.buffer, hid->datain.len);
bt-hid.c:        if (hid->intr_state)
bt-hid.c:        hid->data_type = BT_DATA_OUTPUT;
bt-hid.c:        hid->intrdataout.len = 0;
bt-hid.c:        if (!hid->intr_state)
bt-hid.c:    memcpy(hid->intrdataout.buffer + hid->intrdataout.len, data + 1, len - 1);
bt-hid.c:    hid->intrdataout.len += len - 1;
bt-hid.c:    hid->intr_state = (len == BT_HID_MTU);
bt-hid.c:    if (!hid->intr_state) {
bt-hid.c:        memcpy(hid->dataout.buffer, hid->intrdataout.buffer,
bt-hid.c:                        hid->dataout.len = hid->intrdataout.len);
bt-hid.c:    int prev = hid->connected;
bt-hid.c:    hid->connected = hid->control && hid->interrupt;
bt-hid.c:    /* Stop page-/inquiry-scanning when a host is connected.  */
bt-hid.c:    hid->btdev.device.page_scan = !hid->connected;
bt-hid.c:    hid->btdev.device.inquiry_scan = !hid->connected;
bt-hid.c:    if (hid->connected && !prev) {
bt-hid.c:        hid->usbdev->info->handle_reset(hid->usbdev);
bt-hid.c:        hid->proto = BT_HID_PROTO_REPORT;
bt-hid.c:    hid->control = NULL;
bt-hid.c:    hid->interrupt = NULL;
bt-hid.c:    if (hid->control)
bt-hid.c:    hid->control = params;
bt-hid.c:    hid->control->opaque = hid;
bt-hid.c:    hid->control->close = bt_hid_close_control;
bt-hid.c:    hid->control->sdu_in = bt_hid_control_sdu;
bt-hid.c:    if (hid->interrupt)
bt-hid.c:    hid->interrupt = params;
bt-hid.c:    hid->interrupt->opaque = hid;
bt-hid.c:    hid->interrupt->close = bt_hid_close_interrupt;
bt-hid.c:    hid->interrupt->sdu_in = bt_hid_interrupt_sdu;
bt-hid.c:    if (hid->connected)
bt-hid.c:    bt_l2cap_device_done(&hid->btdev);
bt-hid.c:    hid->usbdev->info->handle_destroy(hid->usbdev);
bt-hid.c:    bt_l2cap_device_init(&s->btdev, net);
bt-hid.c:    bt_l2cap_sdp_init(&s->btdev);
bt-hid.c:    bt_l2cap_psm_register(&s->btdev, BT_PSM_HID_CTRL,
bt-hid.c:    bt_l2cap_psm_register(&s->btdev, BT_PSM_HID_INTR,
bt-hid.c:    s->usbdev = dev;
bt-hid.c:    s->btdev.device.lmp_name = s->usbdev->product_desc;
bt-hid.c:    usb_hid_datain_cb(s->usbdev, s, bt_hid_datain);
bt-hid.c:    s->btdev.device.handle_destroy = bt_hid_destroy;
bt-hid.c:    s->btdev.device.class[0] = (class >>  0) & 0xff;
bt-hid.c:    s->btdev.device.class[1] = (class >>  8) & 0xff;
bt-hid.c:    s->btdev.device.class[2] = (class >> 16) & 0xff;
bt-hid.c:    return &s->btdev.device;
bt-hid.c:    USBDevice *dev = usb_create_simple(NULL /* FIXME */, "usb-kbd");
bt-l2cap.c:#include "qemu-common.h"
bt-l2cap.c:#include "qemu-timer.h"
bt-l2cap.c:    /* Signalling channel timers.  They exist per-request but we can make
bt-l2cap.c:        /* Only connection-oriented channels.  Note: if we allow the tx and
bt-l2cap.c:        /* Only flow-controlled, connection-oriented channels */
bt-l2cap.c:     * CLOSED           -> !cid[N]
bt-l2cap.c:     * WAIT_CONNECT     -> never occurs
bt-l2cap.c:     * WAIT_CONNECT_RSP -> never occurs
bt-l2cap.c:     * CONFIG           -> cid[N] && config < 3
bt-l2cap.c:     *   WAIT_CONFIG         -> never occurs, cid[N] && config == 0 && !config_r
bt-l2cap.c:     *   WAIT_SEND_CONFIG    -> never occurs, cid[N] && config == 1 && !config_r
bt-l2cap.c:     *   WAIT_CONFIG_REQ_RSP -> cid[N] && config == 0 && config_req_id
bt-l2cap.c:     *   WAIT_CONFIG_RSP     -> cid[N] && config == 1 && config_req_id
bt-l2cap.c:     *   WAIT_CONFIG_REQ     -> cid[N] && config == 2
bt-l2cap.c:     * OPEN             -> cid[N] && config == 3
bt-l2cap.c:     * WAIT_DISCONNECT  -> never occurs
bt-l2cap.c:    while (len --)
bt-l2cap.c:        for (i = 8; i; -- i)
bt-l2cap.c:    if (ch->mode != L2CAP_MODE_BASIC && ch->rexmit)
bt-l2cap.c:        qemu_mod_timer(ch->retransmission_timer);
bt-l2cap.c:        qemu_del_timer(ch->retransmission_timer);
bt-l2cap.c:    if (ch->mode != L2CAP_MODE_BASIC && !ch->rexmit)
bt-l2cap.c:        qemu_mod_timer(ch->monitor_timer);
bt-l2cap.c:        qemu_del_timer(ch->monitor_timer);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    hdr->code = L2CAP_COMMAND_REJ;
bt-l2cap.c:    hdr->ident = id;
bt-l2cap.c:    memcpy(&hdr->len, &len, sizeof(hdr->len));
bt-l2cap.c:    memcpy(&params->reason, &reason, sizeof(reason));
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    hdr->code = L2CAP_CONN_RSP;
bt-l2cap.c:    hdr->ident = l2cap->last_id;
bt-l2cap.c:    hdr->len = cpu_to_le16(L2CAP_CONN_RSP_SIZE);
bt-l2cap.c:    params->dcid = cpu_to_le16(dcid);
bt-l2cap.c:    params->scid = cpu_to_le16(scid);
bt-l2cap.c:    params->result = cpu_to_le16(result);
bt-l2cap.c:    params->status = cpu_to_le16(status);
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    l2cap->last_id = l2cap->next_id;
bt-l2cap.c:    l2cap->next_id = l2cap->next_id == 255 ? 1 : l2cap->next_id + 1;
bt-l2cap.c:    hdr->code = L2CAP_CONF_REQ;
bt-l2cap.c:    hdr->ident = l2cap->last_id;
bt-l2cap.c:    hdr->len = cpu_to_le16(L2CAP_CONF_REQ_SIZE(len));
bt-l2cap.c:    params->dcid = cpu_to_le16(dcid);
bt-l2cap.c:    params->flags = cpu_to_le16(flag);
bt-l2cap.c:        memcpy(params->data, data, len);
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    hdr->code = L2CAP_CONF_RSP;
bt-l2cap.c:    hdr->ident = l2cap->last_id;
bt-l2cap.c:    hdr->len = cpu_to_le16(L2CAP_CONF_RSP_SIZE(len));
bt-l2cap.c:    params->scid = cpu_to_le16(scid);
bt-l2cap.c:    params->flags = cpu_to_le16(flag);
bt-l2cap.c:    params->result = cpu_to_le16(result);
bt-l2cap.c:        memcpy(params->data, data, len);
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    hdr->code = L2CAP_DISCONN_RSP;
bt-l2cap.c:    hdr->ident = l2cap->last_id;
bt-l2cap.c:    hdr->len = cpu_to_le16(L2CAP_DISCONN_RSP_SIZE);
bt-l2cap.c:    params->dcid = cpu_to_le16(dcid);
bt-l2cap.c:    params->scid = cpu_to_le16(scid);
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    hdr->code = L2CAP_ECHO_RSP;
bt-l2cap.c:    hdr->ident = l2cap->last_id;
bt-l2cap.c:    hdr->len = cpu_to_le16(len);
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:    pkt = l2cap->signalling_ch.params.sdu_out(&l2cap->signalling_ch.params,
bt-l2cap.c:    hdr->code = L2CAP_INFO_RSP;
bt-l2cap.c:    hdr->ident = l2cap->last_id;
bt-l2cap.c:    hdr->len = cpu_to_le16(L2CAP_INFO_RSP_SIZE + len);
bt-l2cap.c:    params->type = cpu_to_le16(type);
bt-l2cap.c:    params->result = cpu_to_le16(result);
bt-l2cap.c:       memcpy(params->data, data, len);
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit(&l2cap->signalling_ch.params);
bt-l2cap.c:        if (!l2cap->cid[i])
bt-l2cap.c:    struct bt_l2cap_psm_s *ret = device->first_psm;
bt-l2cap.c:    while (ret && ret->psm != psm)
bt-l2cap.c:        ret = ret->next;
bt-l2cap.c:        psm_info = l2cap_psm(l2cap->dev, psm);
bt-l2cap.c:            /* Device supports this use-case.  */
bt-l2cap.c:            ch->params.sdu_out = l2cap_bframe_out;
bt-l2cap.c:            ch->params.sdu_submit = l2cap_bframe_submit;
bt-l2cap.c:            ch->frame_in = l2cap_bframe_in;
bt-l2cap.c:            ch->mps = 65536;
bt-l2cap.c:            ch->min_mtu = MAX(48, psm_info->min_mtu);
bt-l2cap.c:            ch->params.remote_mtu = MAX(672, ch->min_mtu);
bt-l2cap.c:            ch->remote_cid = source_cid;
bt-l2cap.c:            ch->mode = L2CAP_MODE_BASIC;
bt-l2cap.c:            ch->l2cap = l2cap;
bt-l2cap.c:            if (!psm_info->new_channel(l2cap->dev, &ch->params)) {
bt-l2cap.c:                l2cap->cid[cid] = ch;
bt-l2cap.c:        l2cap_command_reject_cid(l2cap, l2cap->last_id, L2CAP_REJ_CID_INVAL,
bt-l2cap.c:        ch = l2cap->cid[cid];
bt-l2cap.c:        if (ch->remote_cid != source_cid) {
bt-l2cap.c:        l2cap->cid[cid] = NULL;
bt-l2cap.c:        ch->params.close(ch->params.opaque);
bt-l2cap.c:    l2cap_configuration_request(l2cap, ch->remote_cid, 0, NULL, 0);
bt-l2cap.c:    ch->config_req_id = l2cap->last_id;
bt-l2cap.c:    ch->config &= ~L2CAP_CFG_INIT;
bt-l2cap.c:                        len < L2CAP_CONF_OPT_SIZE + opt->len) {
bt-l2cap.c:        data += L2CAP_CONF_OPT_SIZE + opt->len;
bt-l2cap.c:        len -= L2CAP_CONF_OPT_SIZE + opt->len;
bt-l2cap.c:        switch (opt->type & 0x7f) {
bt-l2cap.c:            if (opt->len != 2) {
bt-l2cap.c:            val = le16_to_cpup((void *) opt->val);
bt-l2cap.c:            if (val < ch->min_mtu) {
bt-l2cap.c:                cpu_to_le16w((void *) opt->val, ch->min_mtu);
bt-l2cap.c:            ch->params.remote_mtu = val;
bt-l2cap.c:            if (opt->len != 2) {
bt-l2cap.c:            val = le16_to_cpup((void *) opt->val);
bt-l2cap.c:                opt->val[0] = 0xff;
bt-l2cap.c:                opt->val[1] = 0xff;
bt-l2cap.c:            if (opt->len != L2CAP_CONF_OPT_QOS_SIZE) {
bt-l2cap.c:            qos = (void *) opt->val;
bt-l2cap.c:            val = qos->flags;
bt-l2cap.c:                qos->flags = 0;
bt-l2cap.c:            val = qos->service_type;
bt-l2cap.c:                qos->service_type = L2CAP_CONF_QOS_BEST_EFFORT;
bt-l2cap.c:                val = le32_to_cpu(qos->token_rate);
bt-l2cap.c:                    qos->token_rate = cpu_to_le32(0x100000);
bt-l2cap.c:                val = le32_to_cpu(qos->token_bucket_size);
bt-l2cap.c:                    qos->token_bucket_size = cpu_to_le32(65500);
bt-l2cap.c:                /* Any Peak bandwidth value is correct to return as-is */
bt-l2cap.c:                /* Any Access latency value is correct to return as-is */
bt-l2cap.c:                /* Any Delay variation value is correct to return as-is */
bt-l2cap.c:            if (opt->len != 9) {
bt-l2cap.c:            val = opt->val[0];
bt-l2cap.c:                ch->mode = val;
bt-l2cap.c:                ch->frame_in = l2cap_bframe_in;
bt-l2cap.c:                ch->mode = val;
bt-l2cap.c:                ch->frame_in = l2cap_iframe_in;
bt-l2cap.c:                val = opt->val[1];
bt-l2cap.c:                    opt->val[1] = 32;
bt-l2cap.c:                val = opt->val[2];
bt-l2cap.c:                    opt->val[2] = 1;
bt-l2cap.c:                /* Remote Retransmission time-out shouldn't affect local
bt-l2cap.c:                /* The Monitor time-out drives the local Monitor timer (?),
bt-l2cap.c:                val = (opt->val[6] << 8) | opt->val[5];
bt-l2cap.c:                    opt->val[5] = 100 & 0xff;
bt-l2cap.c:                    opt->val[6] = 100 >> 8;
bt-l2cap.c:                ch->monitor_timeout = val;
bt-l2cap.c:                val = (opt->val[8] << 8) | opt->val[7];
bt-l2cap.c:                if (val < ch->min_mtu) {
bt-l2cap.c:                    opt->val[7] = ch->min_mtu & 0xff;
bt-l2cap.c:                    opt->val[8] = ch->min_mtu >> 8;
bt-l2cap.c:                ch->mps = val;
bt-l2cap.c:            if (!(opt->type >> 7))
bt-l2cap.c:    l2cap_configuration_response(l2cap, ch->remote_cid,
bt-l2cap.c:    if (unlikely(cid >= L2CAP_CID_MAX || !l2cap->cid[cid])) {
bt-l2cap.c:        l2cap_command_reject_cid(l2cap, l2cap->last_id, L2CAP_REJ_CID_INVAL,
bt-l2cap.c:    ch = l2cap->cid[cid];
bt-l2cap.c:     * and on options-acceptable we go back to OPEN and otherwise to
bt-l2cap.c:    ch->config &= ~L2CAP_CFG_ACC;
bt-l2cap.c:        ch->config |= L2CAP_CFG_ACC;
bt-l2cap.c:    if (!(ch->config & L2CAP_CFG_INIT) && (ch->config & L2CAP_CFG_ACC) &&
bt-l2cap.c:                    !ch->config_req_id)
bt-l2cap.c:    if (unlikely(cid >= L2CAP_CID_MAX || !l2cap->cid[cid])) {
bt-l2cap.c:        l2cap_command_reject_cid(l2cap, l2cap->last_id, L2CAP_REJ_CID_INVAL,
bt-l2cap.c:    ch = l2cap->cid[cid];
bt-l2cap.c:    if (ch->config_req_id != l2cap->last_id)
bt-l2cap.c:    ch->config_req_id = 0;
bt-l2cap.c:            ch->config |= L2CAP_CFG_INIT;
bt-l2cap.c:    if (!(ch->config & L2CAP_CFG_INIT) && !ch->config_req_id)
bt-l2cap.c:        data[len ++] = l2cap->group_ch.mps & 0xff;
bt-l2cap.c:        data[len ++] = l2cap->group_ch.mps >> 8;
bt-l2cap.c:    if (!id || (id != l2cap->last_id && id != l2cap->next_id)) {
bt-l2cap.c:    l2cap->next_id = id;
bt-l2cap.c:    if (id == l2cap->next_id) {
bt-l2cap.c:        l2cap->last_id = l2cap->next_id;
bt-l2cap.c:        l2cap->next_id = l2cap->next_id == 255 ? 1 : l2cap->next_id + 1;
bt-l2cap.c:        /* TODO: Need to re-send the same response, without re-executing
bt-l2cap.c:                        le16_to_cpu(((l2cap_cmd_rej *) params)->reason));
bt-l2cap.c:                        le16_to_cpu(((l2cap_conn_req *) params)->psm),
bt-l2cap.c:                        le16_to_cpu(((l2cap_conn_req *) params)->scid));
bt-l2cap.c:                        le16_to_cpu(((l2cap_conf_req *) params)->flags) & 1,
bt-l2cap.c:                        le16_to_cpu(((l2cap_conf_req *) params)->dcid),
bt-l2cap.c:                        ((l2cap_conf_req *) params)->data,
bt-l2cap.c:                        len - L2CAP_CONF_REQ_SIZE(0));
bt-l2cap.c:                        le16_to_cpu(((l2cap_conf_rsp *) params)->result),
bt-l2cap.c:                        le16_to_cpu(((l2cap_conf_rsp *) params)->flags) & 1,
bt-l2cap.c:                        le16_to_cpu(((l2cap_conf_rsp *) params)->scid),
bt-l2cap.c:                        ((l2cap_conf_rsp *) params)->data,
bt-l2cap.c:                        len - L2CAP_CONF_RSP_SIZE(0)))
bt-l2cap.c:                        le16_to_cpu(((l2cap_disconn_req *) params)->dcid),
bt-l2cap.c:                        le16_to_cpu(((l2cap_disconn_req *) params)->scid));
bt-l2cap.c:        l2cap_info(l2cap, le16_to_cpu(((l2cap_info_req *) params)->type));
bt-l2cap.c:    ch->rexmit = enable;
bt-l2cap.c:        len -= L2CAP_CMD_HDR_SIZE;
bt-l2cap.c:        clen = le16_to_cpu(hdr->len);
bt-l2cap.c:            l2cap_command_reject(l2cap, hdr->ident,
bt-l2cap.c:        l2cap_command(l2cap, hdr->code, hdr->ident, data, clen);
bt-l2cap.c:        len -= clen;
bt-l2cap.c:    ch->params.sdu_in(ch->params.opaque, hdr->data, len);
bt-l2cap.c:    uint16_t fcs = le16_to_cpup((void *) (hdr->data + len - 2));
bt-l2cap.c:    if (l2cap_fcs16((const uint8_t *) hdr, L2CAP_HDR_SIZE + len - 2) != fcs)
bt-l2cap.c:    if ((hdr->data[0] >> 7) == ch->rexmit)
bt-l2cap.c:        l2cap_rexmit_enable(ch, !(hdr->data[0] >> 7));
bt-l2cap.c:    if (hdr->data[0] & 1) {
bt-l2cap.c:        return l2cap_sframe_in(ch, le16_to_cpup((void *) hdr->data));
bt-l2cap.c:    switch (hdr->data[1] >> 6) {	/* SAR */
bt-l2cap.c:        if (ch->len_total)
bt-l2cap.c:        if (len - 4 > ch->mps)
bt-l2cap.c:        return ch->params.sdu_in(ch->params.opaque, hdr->data + 2, len - 4);
bt-l2cap.c:        if (ch->len_total || len < 6)
bt-l2cap.c:        if (len - 6 > ch->mps)
bt-l2cap.c:        ch->len_total = le16_to_cpup((void *) (hdr->data + 2));
bt-l2cap.c:        if (len >= 6 + ch->len_total)
bt-l2cap.c:        ch->len_cur = len - 6;
bt-l2cap.c:        memcpy(ch->sdu, hdr->data + 4, ch->len_cur);
bt-l2cap.c:        if (!ch->len_total || ch->len_cur + len - 4 < ch->len_total)
bt-l2cap.c:        if (len - 4 > ch->mps)
bt-l2cap.c:        memcpy(ch->sdu + ch->len_cur, hdr->data + 2, len - 4);
bt-l2cap.c:        return ch->params.sdu_in(ch->params.opaque, ch->sdu, ch->len_total);
bt-l2cap.c:        if (!ch->len_total || ch->len_cur + len - 4 >= ch->len_total)
bt-l2cap.c:        if (len - 4 > ch->mps)
bt-l2cap.c:        memcpy(ch->sdu + ch->len_cur, hdr->data + 2, len - 4);
bt-l2cap.c:        ch->len_cur += len - 4;
bt-l2cap.c:        ch->len_cur = 0;
bt-l2cap.c:        ch->len_total = 0;
bt-l2cap.c:    uint16_t cid = le16_to_cpu(frame->cid);
bt-l2cap.c:    uint16_t len = le16_to_cpu(frame->len);
bt-l2cap.c:    if (unlikely(cid >= L2CAP_CID_MAX || !l2cap->cid[cid])) {
bt-l2cap.c:        fprintf(stderr, "%s: frame addressed to a non-existent L2CAP "
bt-l2cap.c:    l2cap->cid[cid]->frame_in(l2cap->cid[cid], cid, frame, len);
bt-l2cap.c:    const l2cap_hdr *hdr = (void *) l2cap->frame_in;
bt-l2cap.c:    if (unlikely(len + l2cap->frame_in_len > sizeof(l2cap->frame_in))) {
bt-l2cap.c:        if (l2cap->frame_in_len < sizeof(l2cap->frame_in)) {
bt-l2cap.c:            memcpy(l2cap->frame_in + l2cap->frame_in_len, data,
bt-l2cap.c:                            sizeof(l2cap->frame_in) - l2cap->frame_in_len);
bt-l2cap.c:            l2cap->frame_in_len = sizeof(l2cap->frame_in);
bt-l2cap.c:    memcpy(l2cap->frame_in + l2cap->frame_in_len, data, len);
bt-l2cap.c:    l2cap->frame_in_len += len;
bt-l2cap.c:        if (len >= L2CAP_HDR_SIZE + le16_to_cpu(hdr->len))
bt-l2cap.c:    l2cap_hdr *hdr = (void *) l2cap->frame_out;
bt-l2cap.c:    l2cap->frame_out_len = len + L2CAP_HDR_SIZE;
bt-l2cap.c:    hdr->cid = cpu_to_le16(cid);
bt-l2cap.c:    hdr->len = cpu_to_le16(len);
bt-l2cap.c:    return l2cap->frame_out + L2CAP_HDR_SIZE;
bt-l2cap.c:    (l2cap->role ?
bt-l2cap.c:     l2cap->link->slave->lmp_acl_data : l2cap->link->host->lmp_acl_resp)
bt-l2cap.c:            (l2cap->link, l2cap->frame_out, 1, l2cap->frame_out_len);
bt-l2cap.c:    if (len > chan->params.remote_mtu) {
bt-l2cap.c:        fprintf(stderr, "%s: B-Frame for CID %04x longer than %i octets.\n",
bt-l2cap.c:                        chan->remote_cid, chan->params.remote_mtu);
bt-l2cap.c:        exit(-1);
bt-l2cap.c:    return l2cap_pdu_out(chan->l2cap, chan->remote_cid, len);
bt-l2cap.c:    return l2cap_pdu_submit(chan->l2cap);
bt-l2cap.c:    if (len > chan->params.remote_mtu) {
bt-l2cap.c:         * I-Frame in a FIFO of I-Frames, local to the CID.  */
bt-l2cap.c:        /* TODO: add to the FIFO of I-Frames, local to the CID.  */
bt-l2cap.c:     * invidual I-Frames from the FIFO, but don't remove them from there.
bt-l2cap.c:     * Kick the appropriate timer until we get an S-Frame, and only then
bt-l2cap.c:     * remove from FIFO or resubmit and re-kick the timer if the timer
bt-l2cap.c:    l2cap->link = link;
bt-l2cap.c:    l2cap->role = role;
bt-l2cap.c:    l2cap->dev = (struct bt_l2cap_device_s *)
bt-l2cap.c:            (role ? link->host : link->slave);
bt-l2cap.c:    l2cap->next_id = 1;
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_in = l2cap_cframe_in;
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_out = l2cap_bframe_out;
bt-l2cap.c:    l2cap->signalling_ch.params.sdu_submit = l2cap_bframe_submit;
bt-l2cap.c:    l2cap->signalling_ch.params.opaque = l2cap;
bt-l2cap.c:    l2cap->signalling_ch.params.remote_mtu = 48;
bt-l2cap.c:    l2cap->signalling_ch.remote_cid = L2CAP_CID_SIGNALLING;
bt-l2cap.c:    l2cap->signalling_ch.frame_in = l2cap_bframe_in;
bt-l2cap.c:    l2cap->signalling_ch.mps = 65536;
bt-l2cap.c:    l2cap->signalling_ch.min_mtu = 48;
bt-l2cap.c:    l2cap->signalling_ch.mode = L2CAP_MODE_BASIC;
bt-l2cap.c:    l2cap->signalling_ch.l2cap = l2cap;
bt-l2cap.c:    l2cap->cid[L2CAP_CID_SIGNALLING] = &l2cap->signalling_ch;
bt-l2cap.c:    /* Establish the connection-less data channel */
bt-l2cap.c:    l2cap->group_ch.params.sdu_in = l2cap_gframe_in;
bt-l2cap.c:    l2cap->group_ch.params.opaque = l2cap;
bt-l2cap.c:    l2cap->group_ch.frame_in = l2cap_bframe_in;
bt-l2cap.c:    l2cap->group_ch.mps = 65533;
bt-l2cap.c:    l2cap->group_ch.l2cap = l2cap;
bt-l2cap.c:    l2cap->group_ch.remote_cid = L2CAP_CID_INVALID;
bt-l2cap.c:    l2cap->cid[L2CAP_CID_GROUP] = &l2cap->group_ch;
bt-l2cap.c:        if (l2cap->role)
bt-l2cap.c:            l2cap->dev->device.lmp_disconnect_slave(l2cap->link);
bt-l2cap.c:            /* l2cap->link is invalid from now on.  */
bt-l2cap.c:            l2cap->dev->device.lmp_disconnect_master(l2cap->link);
bt-l2cap.c:        if (l2cap->cid[cid]) {
bt-l2cap.c:            l2cap->cid[cid]->params.close(l2cap->cid[cid]->params.opaque);
bt-l2cap.c:            qemu_free(l2cap->cid[cid]);
bt-l2cap.c:    if (l2cap->role)
bt-l2cap.c:        qemu_free(l2cap->link);
bt-l2cap.c:    struct bt_l2cap_device_s *dev = (struct bt_l2cap_device_s *) link->slave;
bt-l2cap.c:    /* Always accept - we only get called if (dev->device->page_scan).  */
bt-l2cap.c:    l2cap->link.slave = &dev->device;
bt-l2cap.c:    l2cap->link.host = link->host;
bt-l2cap.c:    l2cap_init(&l2cap->l2cap, &l2cap->link, 0);
bt-l2cap.c:    link->host->reject_reason = 0;
bt-l2cap.c:    link->host->lmp_connection_complete(&l2cap->link);
bt-l2cap.c:    struct bt_l2cap_device_s *dev = (struct bt_l2cap_device_s *) link->host;
bt-l2cap.c:    if (dev->device.reject_reason) {
bt-l2cap.c:    link->acl_mode = acl_active;
bt-l2cap.c:    struct bt_l2cap_device_s *dev = (struct bt_l2cap_device_s *) link->host;
bt-l2cap.c:    l2cap_teardown(&l2cap->l2cap, 0);
bt-l2cap.c:        l2cap->l2cap.frame_in_len = 0;
bt-l2cap.c:    l2cap_pdu_in(&l2cap->l2cap, data, len);
bt-l2cap.c:    struct bt_l2cap_device_s *dev = (struct bt_l2cap_device_s *) link->host;
bt-l2cap.c:        l2cap->frame_in_len = 0;
bt-l2cap.c:    bt_device_init(&dev->device, net);
bt-l2cap.c:    dev->device.lmp_connection_request = l2cap_lmp_connection_request;
bt-l2cap.c:    dev->device.lmp_connection_complete = l2cap_lmp_connection_complete;
bt-l2cap.c:    dev->device.lmp_disconnect_master = l2cap_lmp_disconnect_host;
bt-l2cap.c:    dev->device.lmp_disconnect_slave = l2cap_lmp_disconnect_slave;
bt-l2cap.c:    dev->device.lmp_acl_data = l2cap_lmp_acl_data_slave;
bt-l2cap.c:    dev->device.lmp_acl_resp = l2cap_lmp_acl_data_host;
bt-l2cap.c:    dev->device.handle_destroy = l2cap_dummy_destroy;
bt-l2cap.c:    bt_device_done(&dev->device);
bt-l2cap.c:                        __FUNCTION__, psm, dev->device.lmp_name);
bt-l2cap.c:        exit(-1);
bt-l2cap.c:    new_psm->psm = psm;
bt-l2cap.c:    new_psm->min_mtu = min_mtu;
bt-l2cap.c:    new_psm->new_channel = new_channel;
bt-l2cap.c:    new_psm->next = dev->first_psm;
bt-l2cap.c:    dev->first_psm = new_psm;
bt-sdp.c:#include "qemu-common.h"
bt-sdp.c:        return -1;
bt-sdp.c:    (*left) --;
bt-sdp.c:            return -1;
bt-sdp.c:        (*left) --;
bt-sdp.c:            return -1;
bt-sdp.c:        (*left) -= 2;
bt-sdp.c:            return -1;
bt-sdp.c:        (*left) -= 4;
bt-sdp.c:    lo = record->uuid;
bt-sdp.c:    hi = record->uuids;
bt-sdp.c:#define MAX_RSP_PARAM_SIZE	(MAX_PDU_OUT_SIZE - PDU_HEADER_SIZE - \
bt-sdp.c:    for (i = 0; i < sdp->services; i ++)
bt-sdp.c:        if (sdp_uuid_match(&sdp->service_list[i], *req, datalen))
bt-sdp.c:            sdp->service_list[i].match = 1;
bt-sdp.c:    (*len) -= datalen;
bt-sdp.c:    for (i = 0; i < sdp->services; i ++)
bt-sdp.c:        sdp->service_list[i].match = 0;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= seqlen;
bt-sdp.c:                return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:    len -= 2;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= sizeof(int);
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:    for (i = 0; i < sdp->services; i ++)
bt-sdp.c:        if (sdp->service_list[i].match) {
bt-sdp.c:    rsp[2] = (end - start) >> 8;
bt-sdp.c:    rsp[3] = (end - start) & 0xff;
bt-sdp.c:        *len -= 3;
bt-sdp.c:        *len -= 5;
bt-sdp.c:    for (i = 0; i < record->attributes; i ++)
bt-sdp.c:        if (record->attribute_list[i].attribute_id >= start &&
bt-sdp.c:                        record->attribute_list[i].attribute_id <= end)
bt-sdp.c:            record->attribute_list[i].match = 1;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:    len -= 4;
bt-sdp.c:    if (handle < 0 || handle > sdp->services)
bt-sdp.c:        return -SDP_INVALID_RECORD_HANDLE;
bt-sdp.c:    record = &sdp->service_list[handle];
bt-sdp.c:    for (i = 0; i < record->attributes; i ++)
bt-sdp.c:        record->attribute_list[i].match = 0;
bt-sdp.c:    len -= 2;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= seqlen;
bt-sdp.c:                return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= sizeof(int);
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:    len = 3 - start;
bt-sdp.c:    for (i = 0; i < record->attributes; i ++)
bt-sdp.c:        if (record->attribute_list[i].match) {
bt-sdp.c:            if (len >= 0 && len + record->attribute_list[i].len < max) {
bt-sdp.c:                memcpy(lst + len, record->attribute_list[i].pair,
bt-sdp.c:                                record->attribute_list[i].len);
bt-sdp.c:                end = len + record->attribute_list[i].len;
bt-sdp.c:            len += record->attribute_list[i].len;
bt-sdp.c:       lst[1] = (len + start - 3) >> 8;
bt-sdp.c:       lst[2] = (len + start - 3) & 0xff;
bt-sdp.c:        *len -= 3;
bt-sdp.c:        *len -= 5;
bt-sdp.c:    for (i = 0; i < sdp->services; i ++)
bt-sdp.c:        if ((record = &sdp->service_list[i])->match)
bt-sdp.c:            for (j = 0; j < record->attributes; j ++)
bt-sdp.c:                if (record->attribute_list[j].attribute_id >= start &&
bt-sdp.c:                                record->attribute_list[j].attribute_id <= end)
bt-sdp.c:                    record->attribute_list[j].match = 1;
bt-sdp.c:    for (i = 0; i < sdp->services; i ++) {
bt-sdp.c:        sdp->service_list[i].match = 0;
bt-sdp.c:            for (j = 0; j < sdp->service_list[i].attributes; j ++)
bt-sdp.c:                sdp->service_list[i].attribute_list[j].match = 0;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= seqlen;
bt-sdp.c:                return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:    len -= 2;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= seqlen;
bt-sdp.c:                return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:            return -SDP_INVALID_SYNTAX;
bt-sdp.c:        len -= sizeof(int);
bt-sdp.c:        return -SDP_INVALID_SYNTAX;
bt-sdp.c:    len = 3 - start;
bt-sdp.c:    for (i = 0; i < sdp->services; i ++)
bt-sdp.c:        if ((record = &sdp->service_list[i])->match) {
bt-sdp.c:            for (j = 0; j < record->attributes; j ++)
bt-sdp.c:                if (record->attribute_list[j].match) {
bt-sdp.c:                        if (len + record->attribute_list[j].len < max) {
bt-sdp.c:                            memcpy(lst + len, record->attribute_list[j].pair,
bt-sdp.c:                                            record->attribute_list[j].len);
bt-sdp.c:                            end = len + record->attribute_list[j].len;
bt-sdp.c:                    len += record->attribute_list[j].len;
bt-sdp.c:                len -= 3;
bt-sdp.c:                lst[seqlen - 3] = SDP_DTYPE_SEQ | SDP_DSIZE_NEXT2;
bt-sdp.c:                lst[seqlen - 2] = (len - seqlen) >> 8;
bt-sdp.c:                lst[seqlen - 1] = (len - seqlen) & 0xff;
bt-sdp.c:    if (len == 3 - start)
bt-sdp.c:        len -= 3;
bt-sdp.c:       lst[1] = (len + start - 3) >> 8;
bt-sdp.c:       lst[2] = (len + start - 3) & 0xff;
bt-sdp.c:    uint8_t rsp[MAX_PDU_OUT_SIZE - PDU_HEADER_SIZE], *sdu_out;
bt-sdp.c:    len -= 5;
bt-sdp.c:        err = -rsp_len;
bt-sdp.c:    sdu_out = sdp->channel->sdu_out(sdp->channel, rsp_len + PDU_HEADER_SIZE);
bt-sdp.c:    sdp->channel->sdu_submit(sdp->channel);
bt-sdp.c:    for (i = 0; i < sdp->services; i ++) {
bt-sdp.c:        qemu_free(sdp->service_list[i].attribute_list->pair);
bt-sdp.c:        qemu_free(sdp->service_list[i].attribute_list);
bt-sdp.c:        qemu_free(sdp->service_list[i].uuid);
bt-sdp.c:    qemu_free(sdp->service_list);
bt-sdp.c:    int type = element->type & ~SDP_DSIZE_MASK;
bt-sdp.c:        return 1 + (1 << (element->type & SDP_DSIZE_MASK));
bt-sdp.c:        if (element->type & SDP_DSIZE_MASK) {
bt-sdp.c:            for (len = 0; element->value.str[len] |
bt-sdp.c:                            element->value.str[len + 1]; len ++);
bt-sdp.c:            return 2 + strlen(element->value.str);
bt-sdp.c:        exit(-1);
bt-sdp.c:    element = element->value.list;
bt-sdp.c:    while (element->type)
bt-sdp.c:        exit (-1);
bt-sdp.c:    int type = element->type & ~SDP_DSIZE_MASK;
bt-sdp.c:        data[len ++] = element->type;
bt-sdp.c:        if ((element->type & SDP_DSIZE_MASK) == SDP_DSIZE_1)
bt-sdp.c:            data[len ++] = (element->value.uint >>  0) & 0xff;
bt-sdp.c:        else if ((element->type & SDP_DSIZE_MASK) == SDP_DSIZE_2) {
bt-sdp.c:            data[len ++] = (element->value.uint >>  8) & 0xff;
bt-sdp.c:            data[len ++] = (element->value.uint >>  0) & 0xff;
bt-sdp.c:        } else if ((element->type & SDP_DSIZE_MASK) == SDP_DSIZE_4) {
bt-sdp.c:            data[len ++] = (element->value.uint >>  24) & 0xff;
bt-sdp.c:            data[len ++] = (element->value.uint >>  16) & 0xff;
bt-sdp.c:            data[len ++] = (element->value.uint >>  8) & 0xff;
bt-sdp.c:            data[len ++] = (element->value.uint >>  0) & 0xff;
bt-sdp.c:        *(*uuid) ++ = element->value.uint;
bt-sdp.c:        data[len ++] = element->type;
bt-sdp.c:        data[len ++] = (element->value.uint >>  24) & 0xff;
bt-sdp.c:        data[len ++] = (element->value.uint >>  16) & 0xff;
bt-sdp.c:        data[len ++] = (element->value.uint >>  8) & 0xff;
bt-sdp.c:        data[len ++] = (element->value.uint >>  0) & 0xff;
bt-sdp.c:        if (element->type & SDP_DSIZE_MASK)
bt-sdp.c:            for (len = 0; element->value.str[len] |
bt-sdp.c:                            element->value.str[len + 1]; len ++);
bt-sdp.c:            len = strlen(element->value.str);
bt-sdp.c:        memcpy(data + 2, element->value.str, data[1] = len);
bt-sdp.c:    element = element->value.list;
bt-sdp.c:    while (element->type)
bt-sdp.c:    data[1] = len - 2;
bt-sdp.c:    return (int) b->attribute_id - a->attribute_id;
bt-sdp.c:    return *a - *b;
bt-sdp.c:    record->uuids = 0;
bt-sdp.c:    while (def->attributes[record->attributes].data.type) {
bt-sdp.c:        len += sdp_attr_max_size(&def->attributes[record->attributes ++].data,
bt-sdp.c:                        &record->uuids);
bt-sdp.c:    record->uuids = 1 << ffs(record->uuids - 1);
bt-sdp.c:    record->attribute_list =
bt-sdp.c:            qemu_mallocz(record->attributes * sizeof(*record->attribute_list));
bt-sdp.c:    record->uuid =
bt-sdp.c:            qemu_mallocz(record->uuids * sizeof(*record->uuid));
bt-sdp.c:    record->attributes = 0;
bt-sdp.c:    uuid = record->uuid;
bt-sdp.c:    while (def->attributes[record->attributes].data.type) {
bt-sdp.c:        record->attribute_list[record->attributes].pair = data;
bt-sdp.c:        data[len ++] = def->attributes[record->attributes].id >> 8;
bt-sdp.c:        data[len ++] = def->attributes[record->attributes].id & 0xff;
bt-sdp.c:                        &def->attributes[record->attributes].data, &uuid);
bt-sdp.c:        if (def->attributes[record->attributes].id == SDP_ATTR_RECORD_HANDLE)
bt-sdp.c:            def->attributes[record->attributes].data.value.uint = handle;
bt-sdp.c:         * sdp->device.device->lmp_name.  */
bt-sdp.c:        record->attribute_list[record->attributes ++].len = len;
bt-sdp.c:    qsort(record->attribute_list, record->attributes,
bt-sdp.c:                    sizeof(*record->attribute_list),
bt-sdp.c:    qsort(record->uuid, record->uuids,
bt-sdp.c:                    sizeof(*record->uuid),
bt-sdp.c:    sdp->services = 0;
bt-sdp.c:    while (service[sdp->services])
bt-sdp.c:        sdp->services ++;
bt-sdp.c:    sdp->service_list =
bt-sdp.c:            qemu_mallocz(sdp->services * sizeof(*sdp->service_list));
bt-sdp.c:    sdp->services = 0;
bt-sdp.c:        sdp_service_record_build(&sdp->service_list[sdp->services],
bt-sdp.c:                        *service, sdp->services);
bt-sdp.c:        sdp->services ++;
bt-sdp.c:    ATTRIBUTE(DOC_URL,         URL("http://bellard.org/qemu/user-doc.html"))
bt-sdp.c:    /* TODO: extract from l2cap_device->device.class[0] */
bt-sdp.c:    /* TODO: extract from hid->usbdev->report_desc */
bt-sdp.c:    ATTRIBUTE(DOC_URL,         URL("http://bellard.org/qemu/user-doc.html"))
bt-sdp.c:    ATTRIBUTE(DOC_URL,         URL("http://bellard.org/qemu/user-doc.html"))
bt-sdp.c:    sdp->channel = params;
bt-sdp.c:    sdp->channel->opaque = sdp;
bt-sdp.c:    sdp->channel->close = bt_l2cap_sdp_close_ch;
bt-sdp.c:    sdp->channel->sdu_in = bt_l2cap_sdp_sdu_in;
cbus.c: * CBUS three-pin bus and the Retu / Betty / Tahvo / Vilma / Avilma /
cbus.c: * Based on reverse-engineering of a linux driver.
cbus.c:#include "qemu-common.h"
cbus.c:    if (s->slave[s->addr])
cbus.c:        s->slave[s->addr]->io(s->slave[s->addr]->opaque,
cbus.c:                        s->rw, s->reg, &s->val);
cbus.c:        hw_error("%s: bad slave address %i\n", __FUNCTION__, s->addr);
cbus.c:    switch (s->cycle) {
cbus.c:        s->addr = (s->val >> 6) & 7;
cbus.c:        s->rw =   (s->val >> 5) & 1;
cbus.c:        s->reg =  (s->val >> 0) & 0x1f;
cbus.c:        s->cycle = cbus_value;
cbus.c:        s->bit = 15;
cbus.c:        s->dir = !s->rw;
cbus.c:        s->val = 0;
cbus.c:        if (s->rw)
cbus.c:        if (!s->rw)
cbus.c:        s->cycle = cbus_address;
cbus.c:        s->bit = 8;
cbus.c:        s->dir = 1;
cbus.c:        s->val = 0;
cbus.c:    if (!s->sel && level && !s->clk) {
cbus.c:        if (s->dir)
cbus.c:            s->val |= s->dat << (s->bit --);
cbus.c:            qemu_set_irq(s->dat_out, (s->val >> (s->bit --)) & 1);
cbus.c:        if (s->bit < 0)
cbus.c:    s->clk = level;
cbus.c:    s->dat = level;
cbus.c:        s->dir = 1;
cbus.c:        s->bit = 8;
cbus.c:        s->val = 0;
cbus.c:    s->sel = level;
cbus.c:    s->dat_out = dat;
cbus.c:    s->cbus.clk = qemu_allocate_irqs(cbus_clk, s, 1)[0];
cbus.c:    s->cbus.dat = qemu_allocate_irqs(cbus_dat, s, 1)[0];
cbus.c:    s->cbus.sel = qemu_allocate_irqs(cbus_sel, s, 1)[0];
cbus.c:    s->sel = 1;
cbus.c:    s->clk = 0;
cbus.c:    s->dat = 0;
cbus.c:    return &s->cbus;
cbus.c:    s->slave[slave->addr] = slave;
cbus.c:    qemu_set_irq(s->irq, s->irqst & ~s->irqen);
cbus.c:        return 0x0215 | (s->is_vilma << 7);
cbus.c:    case RETU_REG_IDR:	/* TODO: Or is this ffs(s->irqst)?  */
cbus.c:        return s->irqst;
cbus.c:        return s->irqen;
cbus.c:        return s->rtc.cal;
cbus.c:        return (s->channel << 10) | s->result[s->channel];
cbus.c:        return s->sample;
cbus.c:        return s->cc[0];
cbus.c:        return s->cc[1];
cbus.c:        return s->status;
cbus.c:        s->irqst ^= val;
cbus.c:        s->irqen = val;
cbus.c:        s->rtc.cal = val;
cbus.c:        s->channel = (val >> 10) & 0xf;
cbus.c:        s->irqst |= 1 << retu_int_adcs;
cbus.c:        s->sample &= ~val;
cbus.c:        s->cc[0] = val;
cbus.c:        s->cc[1] = val;
cbus.c:        if (val == 0 && (s->cc[0] & 2))
cbus.c:    s->irq = irq;
cbus.c:    s->irqen = 0xffff;
cbus.c:    s->irqst = 0x0000;
cbus.c:    s->status = 0x0020;
cbus.c:    s->is_vilma = !!vilma;
cbus.c:    s->rtc.cal = 0x01;
cbus.c:    s->result[retu_adc_bsi] = 0x3c2;
cbus.c:    s->result[retu_adc_batt_temp] = 0x0fc;
cbus.c:    s->result[retu_adc_chg_volt] = 0x165;
cbus.c:    s->result[retu_adc_head_det] = 123;
cbus.c:    s->result[retu_adc_hook_det] = 1023;
cbus.c:    s->result[retu_adc_rf_gp] = 0x11;
cbus.c:    s->result[retu_adc_tx_det] = 0x11;
cbus.c:    s->result[retu_adc_batt_volt] = 0x250;
cbus.c:    s->result[retu_adc_sens] = 2;
cbus.c:    s->result[retu_adc_sens_temp] = 0x11;
cbus.c:    s->result[retu_adc_bbatt_volt] = 0x3d0;
cbus.c:    s->result[retu_adc_self_temp] = 0x330;
cbus.c:    s->cbus.opaque = s;
cbus.c:    s->cbus.io = retu_io;
cbus.c:    s->cbus.addr = 1;
cbus.c:    return &s->cbus;
cbus.c:    CBusRetu *s = (CBusRetu *) slave->opaque;
cbus.c:    s->irqst |= 1 << retu_int_pwr;
cbus.c:        s->status &= ~(1 << 5);
cbus.c:        s->status |= 1 << 5;
cbus.c:    CBusRetu *s = (CBusRetu *) slave->opaque;
cbus.c:    if ((s->cc[0] & 0x500) == 0x500) {	/* TODO: Which bits? */
cbus.c:        s->irqst |= 1 << retu_int_head;
cbus.c:        s->result[retu_adc_head_det] = 50;
cbus.c:        s->result[retu_adc_head_det] = 123;
cbus.c:    CBusRetu *s = (CBusRetu *) slave->opaque;
cbus.c:    if ((s->cc[0] & 0x500) == 0x500) {
cbus.c:        s->irqst |= 1 << retu_int_hook;
cbus.c:        s->result[retu_adc_hook_det] = 50;
cbus.c:        s->result[retu_adc_hook_det] = 123;
cbus.c:    qemu_set_irq(s->irq, s->irqst & ~s->irqen);
cbus.c:        return 0x0021 | (s->is_betty ? 0x0b00 : 0x0300);	/* 22 in N810 */
cbus.c:        return s->irqst;
cbus.c:        return s->irqen;
cbus.c:        return s->charger;
cbus.c:        return s->backlight;
cbus.c:        return s->usbr;
cbus.c:        return s->power;
cbus.c:        s->irqst ^= val;
cbus.c:        s->irqen = val;
cbus.c:        s->charger = val;
cbus.c:        if (s->backlight != (val & 0x7f)) {
cbus.c:            s->backlight = val & 0x7f;
cbus.c:                            __FUNCTION__, s->backlight);
cbus.c:        s->usbr = val;
cbus.c:        s->power = val;
cbus.c:    s->irq = irq;
cbus.c:    s->irqen = 0xffff;
cbus.c:    s->irqst = 0x0000;
cbus.c:    s->is_betty = !!betty;
cbus.c:    s->cbus.opaque = s;
cbus.c:    s->cbus.io = tahvo_io;
cbus.c:    s->cbus.addr = 2;
cbus.c:    return &s->cbus;
cdrom.c: * QEMU ATAPI CD-ROM Emulator
cdrom.c:#include "qemu-common.h"
cdrom.c:/* same toc as bochs. Return -1 if error or the toc length */
cdrom.c:        return -1;
cdrom.c:    len = q - buf;
cdrom.c:    cpu_to_be16wu((uint16_t *)buf, len - 2);
cdrom.c:    *q++ = 0xa0; /* lead-in */
cdrom.c:    *q++ = 0xa2; /* lead-out */
cdrom.c:    len = q - buf;
cdrom.c:    cpu_to_be16wu((uint16_t *)buf, len - 2);
cirrus_vga.c:#include "qemu-kvm.h"
cirrus_vga.c: *    - destination write mask support not complete (bits 5..7)
cirrus_vga.c: *    - optimize linear mappings
cirrus_vga.c: *    - optimize bitblt functions
cirrus_vga.c:// memory-mapped IO
cirrus_vga.c:#define ABS(a) ((signed)(a) > 0 ? a : -a)
cirrus_vga.c:            (s)->cirrus_blt_height * ABS((s)->cirrus_blt_dstpitch) \
cirrus_vga.c:                + ((s)->cirrus_blt_dstaddr & (s)->cirrus_addr_mask) > \
cirrus_vga.c:                    (s)->vga.vram_size \
cirrus_vga.c:            (s)->cirrus_blt_height * ABS((s)->cirrus_blt_srcpitch) \
cirrus_vga.c:                + ((s)->cirrus_blt_srcaddr & (s)->cirrus_addr_mask) > \
cirrus_vga.c:                    (s)->vga.vram_size \
cirrus_vga.c:    switch (s->cirrus_blt_pixelwidth) {
cirrus_vga.c:        s->cirrus_blt_fgcol = s->cirrus_shadow_gr1;
cirrus_vga.c:        color = s->cirrus_shadow_gr1 | (s->vga.gr[0x11] << 8);
cirrus_vga.c:        s->cirrus_blt_fgcol = le16_to_cpu(color);
cirrus_vga.c:        s->cirrus_blt_fgcol = s->cirrus_shadow_gr1 |
cirrus_vga.c:            (s->vga.gr[0x11] << 8) | (s->vga.gr[0x13] << 16);
cirrus_vga.c:        color = s->cirrus_shadow_gr1 | (s->vga.gr[0x11] << 8) |
cirrus_vga.c:            (s->vga.gr[0x13] << 16) | (s->vga.gr[0x15] << 24);
cirrus_vga.c:        s->cirrus_blt_fgcol = le32_to_cpu(color);
cirrus_vga.c:    switch (s->cirrus_blt_pixelwidth) {
cirrus_vga.c:        s->cirrus_blt_bgcol = s->cirrus_shadow_gr0;
cirrus_vga.c:        color = s->cirrus_shadow_gr0 | (s->vga.gr[0x10] << 8);
cirrus_vga.c:        s->cirrus_blt_bgcol = le16_to_cpu(color);
cirrus_vga.c:        s->cirrus_blt_bgcol = s->cirrus_shadow_gr0 |
cirrus_vga.c:            (s->vga.gr[0x10] << 8) | (s->vga.gr[0x12] << 16);
cirrus_vga.c:        color = s->cirrus_shadow_gr0 | (s->vga.gr[0x10] << 8) |
cirrus_vga.c:            (s->vga.gr[0x12] << 16) | (s->vga.gr[0x14] << 24);
cirrus_vga.c:        s->cirrus_blt_bgcol = le32_to_cpu(color);
cirrus_vga.c:	off_cur_end = (off_cur + bytesperline) & s->cirrus_addr_mask;
cirrus_vga.c:	    cpu_physical_memory_set_dirty(s->vga.vram_offset + off_cur);
cirrus_vga.c:    dst = s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask);
cirrus_vga.c:    (*s->cirrus_rop) (s, dst, src,
cirrus_vga.c:                      s->cirrus_blt_dstpitch, 0,
cirrus_vga.c:                      s->cirrus_blt_width, s->cirrus_blt_height);
cirrus_vga.c:    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,
cirrus_vga.c:                             s->cirrus_blt_dstpitch, s->cirrus_blt_width,
cirrus_vga.c:                             s->cirrus_blt_height);
cirrus_vga.c:    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),
cirrus_vga.c:             s->cirrus_blt_dstpitch,
cirrus_vga.c:             s->cirrus_blt_width, s->cirrus_blt_height);
cirrus_vga.c:    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,
cirrus_vga.c:			     s->cirrus_blt_dstpitch, s->cirrus_blt_width,
cirrus_vga.c:			     s->cirrus_blt_height);
cirrus_vga.c: *  bitblt (video-to-video)
cirrus_vga.c:					    s->vga.vram_ptr + ((s->cirrus_blt_srcaddr & ~7) &
cirrus_vga.c:                                            s->cirrus_addr_mask));
cirrus_vga.c:    depth = s->vga.get_bpp(&s->vga) / 8;
cirrus_vga.c:    s->vga.get_resolution(&s->vga, &width, &height);
cirrus_vga.c:    sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;
cirrus_vga.c:    sy = (src / ABS(s->cirrus_blt_srcpitch));
cirrus_vga.c:    dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;
cirrus_vga.c:    dy = (dst / ABS(s->cirrus_blt_dstpitch));
cirrus_vga.c:    if (s->cirrus_blt_dstpitch < 0) {
cirrus_vga.c:	sx -= (s->cirrus_blt_width / depth) - 1;
cirrus_vga.c:	dx -= (s->cirrus_blt_width / depth) - 1;
cirrus_vga.c:	sy -= s->cirrus_blt_height - 1;
cirrus_vga.c:	dy -= s->cirrus_blt_height - 1;
cirrus_vga.c:    if (*s->cirrus_rop != cirrus_bitblt_rop_fwd_src &&
cirrus_vga.c:	*s->cirrus_rop != cirrus_bitblt_rop_bkwd_src)
cirrus_vga.c:    (*s->cirrus_rop) (s, s->vga.vram_ptr +
cirrus_vga.c:		      (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),
cirrus_vga.c:		      s->vga.vram_ptr +
cirrus_vga.c:		      (s->cirrus_blt_srcaddr & s->cirrus_addr_mask),
cirrus_vga.c:		      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,
cirrus_vga.c:		      s->cirrus_blt_width, s->cirrus_blt_height);
cirrus_vga.c:	qemu_console_copy(s->vga.ds,
cirrus_vga.c:			  s->cirrus_blt_width / depth,
cirrus_vga.c:			  s->cirrus_blt_height);
cirrus_vga.c:    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,
cirrus_vga.c:				s->cirrus_blt_dstpitch, s->cirrus_blt_width,
cirrus_vga.c:				s->cirrus_blt_height);
cirrus_vga.c:    cirrus_do_copy(s, s->cirrus_blt_dstaddr - s->vga.start_addr,
cirrus_vga.c:            s->cirrus_blt_srcaddr - s->vga.start_addr,
cirrus_vga.c:            s->cirrus_blt_width, s->cirrus_blt_height);
cirrus_vga.c: *  bitblt (cpu-to-video)
cirrus_vga.c:    if (s->cirrus_srccounter > 0) {
cirrus_vga.c:        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {
cirrus_vga.c:            cirrus_bitblt_common_patterncopy(s, s->cirrus_bltbuf);
cirrus_vga.c:            s->cirrus_srccounter = 0;
cirrus_vga.c:                (*s->cirrus_rop)(s, s->vga.vram_ptr +
cirrus_vga.c:                                 (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),
cirrus_vga.c:                                  s->cirrus_bltbuf, 0, 0, s->cirrus_blt_width, 1);
cirrus_vga.c:                cirrus_invalidate_region(s, s->cirrus_blt_dstaddr, 0,
cirrus_vga.c:                                         s->cirrus_blt_width, 1);
cirrus_vga.c:                s->cirrus_blt_dstaddr += s->cirrus_blt_dstpitch;
cirrus_vga.c:                s->cirrus_srccounter -= s->cirrus_blt_srcpitch;
cirrus_vga.c:                if (s->cirrus_srccounter <= 0)
cirrus_vga.c:                end_ptr = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;
cirrus_vga.c:                copy_count = s->cirrus_srcptr_end - end_ptr;
cirrus_vga.c:                memmove(s->cirrus_bltbuf, end_ptr, copy_count);
cirrus_vga.c:                s->cirrus_srcptr = s->cirrus_bltbuf + copy_count;
cirrus_vga.c:                s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;
cirrus_vga.c:            } while (s->cirrus_srcptr >= s->cirrus_srcptr_end);
cirrus_vga.c:    s->vga.gr[0x31] &=
cirrus_vga.c:    need_update = s->cirrus_srcptr != &s->cirrus_bltbuf[0]
cirrus_vga.c:        || s->cirrus_srcptr_end != &s->cirrus_bltbuf[0];
cirrus_vga.c:    s->cirrus_srcptr = &s->cirrus_bltbuf[0];
cirrus_vga.c:    s->cirrus_srcptr_end = &s->cirrus_bltbuf[0];
cirrus_vga.c:    s->cirrus_srccounter = 0;
cirrus_vga.c:    s->cirrus_blt_mode &= ~CIRRUS_BLTMODE_MEMSYSSRC;
cirrus_vga.c:    s->cirrus_srcptr = &s->cirrus_bltbuf[0];
cirrus_vga.c:    s->cirrus_srcptr_end = &s->cirrus_bltbuf[0];
cirrus_vga.c:    if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {
cirrus_vga.c:	if (s->cirrus_blt_mode & CIRRUS_BLTMODE_COLOREXPAND) {
cirrus_vga.c:	    s->cirrus_blt_srcpitch = 8;
cirrus_vga.c:	    s->cirrus_blt_srcpitch = 8 * 8 * s->cirrus_blt_pixelwidth;
cirrus_vga.c:	s->cirrus_srccounter = s->cirrus_blt_srcpitch;
cirrus_vga.c:	if (s->cirrus_blt_mode & CIRRUS_BLTMODE_COLOREXPAND) {
cirrus_vga.c:            w = s->cirrus_blt_width / s->cirrus_blt_pixelwidth;
cirrus_vga.c:            if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_DWORDGRANULARITY)
cirrus_vga.c:                s->cirrus_blt_srcpitch = ((w + 31) >> 5);
cirrus_vga.c:                s->cirrus_blt_srcpitch = ((w + 7) >> 3);
cirrus_vga.c:	    s->cirrus_blt_srcpitch = (s->cirrus_blt_width + 3) & ~3;
cirrus_vga.c:        s->cirrus_srccounter = s->cirrus_blt_srcpitch * s->cirrus_blt_height;
cirrus_vga.c:    s->cirrus_srcptr = s->cirrus_bltbuf;
cirrus_vga.c:    s->cirrus_srcptr_end = s->cirrus_bltbuf + s->cirrus_blt_srcpitch;
cirrus_vga.c:    if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {
cirrus_vga.c:    s->vga.gr[0x31] |= CIRRUS_BLT_BUSY;
cirrus_vga.c:    s->cirrus_blt_width = (s->vga.gr[0x20] | (s->vga.gr[0x21] << 8)) + 1;
cirrus_vga.c:    s->cirrus_blt_height = (s->vga.gr[0x22] | (s->vga.gr[0x23] << 8)) + 1;
cirrus_vga.c:    s->cirrus_blt_dstpitch = (s->vga.gr[0x24] | (s->vga.gr[0x25] << 8));
cirrus_vga.c:    s->cirrus_blt_srcpitch = (s->vga.gr[0x26] | (s->vga.gr[0x27] << 8));
cirrus_vga.c:    s->cirrus_blt_dstaddr =
cirrus_vga.c:	(s->vga.gr[0x28] | (s->vga.gr[0x29] << 8) | (s->vga.gr[0x2a] << 16));
cirrus_vga.c:    s->cirrus_blt_srcaddr =
cirrus_vga.c:	(s->vga.gr[0x2c] | (s->vga.gr[0x2d] << 8) | (s->vga.gr[0x2e] << 16));
cirrus_vga.c:    s->cirrus_blt_mode = s->vga.gr[0x30];
cirrus_vga.c:    s->cirrus_blt_modeext = s->vga.gr[0x33];
cirrus_vga.c:    blt_rop = s->vga.gr[0x32];
cirrus_vga.c:           s->cirrus_blt_mode,
cirrus_vga.c:           s->cirrus_blt_modeext,
cirrus_vga.c:           s->cirrus_blt_width,
cirrus_vga.c:           s->cirrus_blt_height,
cirrus_vga.c:           s->cirrus_blt_dstpitch,
cirrus_vga.c:           s->cirrus_blt_srcpitch,
cirrus_vga.c:           s->cirrus_blt_dstaddr,
cirrus_vga.c:           s->cirrus_blt_srcaddr,
cirrus_vga.c:           s->vga.gr[0x2f]);
cirrus_vga.c:    switch (s->cirrus_blt_mode & CIRRUS_BLTMODE_PIXELWIDTHMASK) {
cirrus_vga.c:	s->cirrus_blt_pixelwidth = 1;
cirrus_vga.c:	s->cirrus_blt_pixelwidth = 2;
cirrus_vga.c:	s->cirrus_blt_pixelwidth = 3;
cirrus_vga.c:	s->cirrus_blt_pixelwidth = 4;
cirrus_vga.c:	printf("cirrus: bitblt - pixel width is unknown\n");
cirrus_vga.c:    s->cirrus_blt_mode &= ~CIRRUS_BLTMODE_PIXELWIDTHMASK;
cirrus_vga.c:    if ((s->
cirrus_vga.c:	printf("cirrus: bitblt - memory-to-memory copy is requested\n");
cirrus_vga.c:    if ((s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_SOLIDFILL) &&
cirrus_vga.c:        (s->cirrus_blt_mode & (CIRRUS_BLTMODE_MEMSYSDEST |
cirrus_vga.c:        if ((s->cirrus_blt_mode & (CIRRUS_BLTMODE_COLOREXPAND |
cirrus_vga.c:            if (s->cirrus_blt_mode & CIRRUS_BLTMODE_TRANSPARENTCOMP) {
cirrus_vga.c:                if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_COLOREXPINV)
cirrus_vga.c:                s->cirrus_rop = cirrus_colorexpand_transp[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:                s->cirrus_rop = cirrus_colorexpand[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:        } else if (s->cirrus_blt_mode & CIRRUS_BLTMODE_PATTERNCOPY) {
cirrus_vga.c:            if (s->cirrus_blt_mode & CIRRUS_BLTMODE_COLOREXPAND) {
cirrus_vga.c:                if (s->cirrus_blt_mode & CIRRUS_BLTMODE_TRANSPARENTCOMP) {
cirrus_vga.c:                    if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_COLOREXPINV)
cirrus_vga.c:                    s->cirrus_rop = cirrus_colorexpand_pattern_transp[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:                    s->cirrus_rop = cirrus_colorexpand_pattern[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:                s->cirrus_rop = cirrus_patternfill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:	    if (s->cirrus_blt_mode & CIRRUS_BLTMODE_TRANSPARENTCOMP) {
cirrus_vga.c:		if (s->cirrus_blt_pixelwidth > 2) {
cirrus_vga.c:		if (s->cirrus_blt_mode & CIRRUS_BLTMODE_BACKWARDS) {
cirrus_vga.c:		    s->cirrus_blt_dstpitch = -s->cirrus_blt_dstpitch;
cirrus_vga.c:		    s->cirrus_blt_srcpitch = -s->cirrus_blt_srcpitch;
cirrus_vga.c:		    s->cirrus_rop = cirrus_bkwd_transp_rop[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:		    s->cirrus_rop = cirrus_fwd_transp_rop[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];
cirrus_vga.c:		if (s->cirrus_blt_mode & CIRRUS_BLTMODE_BACKWARDS) {
cirrus_vga.c:		    s->cirrus_blt_dstpitch = -s->cirrus_blt_dstpitch;
cirrus_vga.c:		    s->cirrus_blt_srcpitch = -s->cirrus_blt_srcpitch;
cirrus_vga.c:		    s->cirrus_rop = cirrus_bkwd_rop[rop_to_index[blt_rop]];
cirrus_vga.c:		    s->cirrus_rop = cirrus_fwd_rop[rop_to_index[blt_rop]];
cirrus_vga.c:        if (s->cirrus_blt_mode & CIRRUS_BLTMODE_MEMSYSSRC) {
cirrus_vga.c:        } else if (s->cirrus_blt_mode & CIRRUS_BLTMODE_MEMSYSDEST) {
cirrus_vga.c:    old_value = s->vga.gr[0x31];
cirrus_vga.c:    s->vga.gr[0x31] = reg_value;
cirrus_vga.c:    line_offset = s->vga.cr[0x13]
cirrus_vga.c:	| ((s->vga.cr[0x1b] & 0x10) << 4);
cirrus_vga.c:    start_addr = (s->vga.cr[0x0c] << 8)
cirrus_vga.c:	| s->vga.cr[0x0d]
cirrus_vga.c:	| ((s->vga.cr[0x1b] & 0x01) << 16)
cirrus_vga.c:	| ((s->vga.cr[0x1b] & 0x0c) << 15)
cirrus_vga.c:	| ((s->vga.cr[0x1d] & 0x80) << 12);
cirrus_vga.c:    line_compare = s->vga.cr[0x18] |
cirrus_vga.c:        ((s->vga.cr[0x07] & 0x10) << 4) |
cirrus_vga.c:        ((s->vga.cr[0x09] & 0x40) << 3);
cirrus_vga.c:    switch (s->cirrus_hidden_dac_data & 0xf) {
cirrus_vga.c:	       (s->cirrus_hidden_dac_data & 0xf));
cirrus_vga.c:    if ((s->vga.sr[0x07] & 0x01) != 0) {
cirrus_vga.c:	switch (s->vga.sr[0x07] & CIRRUS_SR7_BPP_MASK) {
cirrus_vga.c:	    printf("cirrus: unknown bpp - sr7=%x\n", s->vga.sr[0x7]);
cirrus_vga.c:    width = (s->cr[0x01] + 1) * 8;
cirrus_vga.c:    height = s->cr[0x12] |
cirrus_vga.c:        ((s->cr[0x07] & 0x02) << 7) |
cirrus_vga.c:        ((s->cr[0x07] & 0x40) << 3);
cirrus_vga.c:    if (s->cr[0x1a] & 0x01)
cirrus_vga.c:    if ((s->vga.gr[0x0b] & 0x01) != 0)	/* dual bank */
cirrus_vga.c:	offset = s->vga.gr[0x09 + bank_index];
cirrus_vga.c:	offset = s->vga.gr[0x09];
cirrus_vga.c:    if ((s->vga.gr[0x0b] & 0x20) != 0)
cirrus_vga.c:    if (s->real_vram_size <= offset)
cirrus_vga.c:	limit = s->real_vram_size - offset;
cirrus_vga.c:    if (((s->vga.gr[0x0b] & 0x01) == 0) && (bank_index != 0)) {
cirrus_vga.c:	    limit -= 0x8000;
cirrus_vga.c:        if (s->vga.lfb_vram_mapped) {
cirrus_vga.c:	s->cirrus_bank_base[bank_index] = offset;
cirrus_vga.c:	s->cirrus_bank_limit[bank_index] = limit;
cirrus_vga.c:	s->cirrus_bank_base[bank_index] = 0;
cirrus_vga.c:	s->cirrus_bank_limit[bank_index] = 0;
cirrus_vga.c: *  I/O access between 0x3c4-0x3c5
cirrus_vga.c:    switch (s->vga.sr_index) {
cirrus_vga.c:	return s->vga.sr[s->vga.sr_index];
cirrus_vga.c:	return s->vga.sr[s->vga.sr_index];
cirrus_vga.c:	return s->vga.sr[0x10];
cirrus_vga.c:	return s->vga.sr[0x11];
cirrus_vga.c:	printf("cirrus: handled inport sr_index %02x\n", s->vga.sr_index);
cirrus_vga.c:	return s->vga.sr[s->vga.sr_index];
cirrus_vga.c:	printf("cirrus: inport sr_index %02x\n", s->vga.sr_index);
cirrus_vga.c:    switch (s->vga.sr_index) {
cirrus_vga.c:	s->vga.sr[s->vga.sr_index] = val & sr_mask[s->vga.sr_index];
cirrus_vga.c:	if (s->vga.sr_index == 1)
cirrus_vga.c:            s->vga.update_retrace_info(&s->vga);
cirrus_vga.c:	    s->vga.sr[s->vga.sr_index] = 0x12;
cirrus_vga.c:	    s->vga.sr[s->vga.sr_index] = 0x0f;
cirrus_vga.c:	s->vga.sr[0x10] = val;
cirrus_vga.c:	s->hw_cursor_x = (val << 3) | (s->vga.sr_index >> 5);
cirrus_vga.c:	s->vga.sr[0x11] = val;
cirrus_vga.c:	s->hw_cursor_y = (val << 3) | (s->vga.sr_index >> 5);
cirrus_vga.c:	s->vga.sr[s->vga.sr_index] = val;
cirrus_vga.c:	       s->vga.sr_index, val);
cirrus_vga.c:	s->vga.sr[s->vga.sr_index] = (s->vga.sr[s->vga.sr_index] & 0x38)
cirrus_vga.c:               s->vga.sr_index, val);
cirrus_vga.c:    if (++s->cirrus_hidden_dac_lockindex == 5) {
cirrus_vga.c:        s->cirrus_hidden_dac_lockindex = 0;
cirrus_vga.c:        return s->cirrus_hidden_dac_data;
cirrus_vga.c:    if (s->cirrus_hidden_dac_lockindex == 4) {
cirrus_vga.c:	s->cirrus_hidden_dac_data = reg_value;
cirrus_vga.c:    s->cirrus_hidden_dac_lockindex = 0;
cirrus_vga.c:    if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {
cirrus_vga.c:        val = s->cirrus_hidden_palette[(s->vga.dac_read_index & 0x0f) * 3 +
cirrus_vga.c:                                       s->vga.dac_sub_index];
cirrus_vga.c:        val = s->vga.palette[s->vga.dac_read_index * 3 + s->vga.dac_sub_index];
cirrus_vga.c:    if (++s->vga.dac_sub_index == 3) {
cirrus_vga.c:	s->vga.dac_sub_index = 0;
cirrus_vga.c:	s->vga.dac_read_index++;
cirrus_vga.c:    s->vga.dac_cache[s->vga.dac_sub_index] = reg_value;
cirrus_vga.c:    if (++s->vga.dac_sub_index == 3) {
cirrus_vga.c:        if ((s->vga.sr[0x12] & CIRRUS_CURSOR_HIDDENPEL)) {
cirrus_vga.c:            memcpy(&s->cirrus_hidden_palette[(s->vga.dac_write_index & 0x0f) * 3],
cirrus_vga.c:                   s->vga.dac_cache, 3);
cirrus_vga.c:            memcpy(&s->vga.palette[s->vga.dac_write_index * 3], s->vga.dac_cache, 3);
cirrus_vga.c:	s->vga.dac_sub_index = 0;
cirrus_vga.c:	s->vga.dac_write_index++;
cirrus_vga.c: *  I/O access between 0x3ce-0x3cf
cirrus_vga.c:        return s->cirrus_shadow_gr0;
cirrus_vga.c:        return s->cirrus_shadow_gr1;
cirrus_vga.c:        return s->vga.gr[s->vga.gr_index];
cirrus_vga.c:	return s->vga.gr[reg_index];
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & gr_mask[reg_index];
cirrus_vga.c:	s->cirrus_shadow_gr0 = reg_value;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & gr_mask[reg_index];
cirrus_vga.c:	s->cirrus_shadow_gr1 = reg_value;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & gr_mask[reg_index];
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & 0x7f;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & 0x1f;
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & 0x3f;
cirrus_vga.c:        if (s->vga.gr[0x31] & CIRRUS_BLT_AUTOSTART) {
cirrus_vga.c:	s->vga.gr[reg_index] = reg_value & 0x3f;
cirrus_vga.c: *  I/O access between 0x3d4-0x3d5
cirrus_vga.c:	return s->vga.cr[s->vga.cr_index];
cirrus_vga.c:        return (s->vga.ar_flip_flop << 7);
cirrus_vga.c:	return s->vga.cr[s->vga.cr_index];
cirrus_vga.c:	return s->vga.ar_index & 0x3f;
cirrus_vga.c:    switch (s->vga.cr_index) {
cirrus_vga.c:	/* handle CR0-7 protection */
cirrus_vga.c:	if ((s->vga.cr[0x11] & 0x80) && s->vga.cr_index <= 7) {
cirrus_vga.c:	    if (s->vga.cr_index == 7)
cirrus_vga.c:		s->vga.cr[7] = (s->vga.cr[7] & ~0x10) | (reg_value & 0x10);
cirrus_vga.c:	s->vga.cr[s->vga.cr_index] = reg_value;
cirrus_vga.c:	switch(s->vga.cr_index) {
cirrus_vga.c:	    s->vga.update_retrace_info(&s->vga);
cirrus_vga.c:	s->vga.cr[s->vga.cr_index] = reg_value;
cirrus_vga.c:	       s->vga.cr_index, reg_value);
cirrus_vga.c:               s->vga.cr_index, reg_value);
cirrus_vga.c: *  memory-mapped I/O (bitblt)
cirrus_vga.c:	printf("cirrus: mmio read - address 0x%04x\n", address);
cirrus_vga.c:	printf("cirrus: mmio write - addr 0x%04x val 0x%02x (ignored)\n",
cirrus_vga.c:    dst = s->vga.vram_ptr + (offset &= s->cirrus_addr_mask);
cirrus_vga.c:	    *dst = s->cirrus_shadow_gr1;
cirrus_vga.c:	    *dst = s->cirrus_shadow_gr0;
cirrus_vga.c:    cpu_physical_memory_set_dirty(s->vga.vram_offset + offset);
cirrus_vga.c:    cpu_physical_memory_set_dirty(s->vga.vram_offset + offset + 7);
cirrus_vga.c:    dst = s->vga.vram_ptr + (offset &= s->cirrus_addr_mask);
cirrus_vga.c:	    *dst = s->cirrus_shadow_gr1;
cirrus_vga.c:	    *(dst + 1) = s->vga.gr[0x11];
cirrus_vga.c:	    *dst = s->cirrus_shadow_gr0;
cirrus_vga.c:	    *(dst + 1) = s->vga.gr[0x10];
cirrus_vga.c:    cpu_physical_memory_set_dirty(s->vga.vram_offset + offset);
cirrus_vga.c:    cpu_physical_memory_set_dirty(s->vga.vram_offset + offset + 15);
cirrus_vga.c: *  memory access between 0xa0000-0xbffff
cirrus_vga.c:    if ((s->vga.sr[0x07] & 0x01) == 0) {
cirrus_vga.c:	if (bank_offset < s->cirrus_bank_limit[bank_index]) {
cirrus_vga.c:	    bank_offset += s->cirrus_bank_base[bank_index];
cirrus_vga.c:	    if ((s->vga.gr[0x0B] & 0x14) == 0x14) {
cirrus_vga.c:	    } else if (s->vga.gr[0x0B] & 0x02) {
cirrus_vga.c:	    bank_offset &= s->cirrus_addr_mask;
cirrus_vga.c:	    val = *(s->vga.vram_ptr + bank_offset);
cirrus_vga.c:	/* memory-mapped I/O */
cirrus_vga.c:	if ((s->vga.sr[0x17] & 0x44) == 0x04) {
cirrus_vga.c:    if ((s->vga.sr[0x07] & 0x01) == 0) {
cirrus_vga.c:	if (s->cirrus_srcptr != s->cirrus_srcptr_end) {
cirrus_vga.c:	    *s->cirrus_srcptr++ = (uint8_t) mem_value;
cirrus_vga.c:	    if (s->cirrus_srcptr >= s->cirrus_srcptr_end) {
cirrus_vga.c:	    if (bank_offset < s->cirrus_bank_limit[bank_index]) {
cirrus_vga.c:		bank_offset += s->cirrus_bank_base[bank_index];
cirrus_vga.c:		if ((s->vga.gr[0x0B] & 0x14) == 0x14) {
cirrus_vga.c:		} else if (s->vga.gr[0x0B] & 0x02) {
cirrus_vga.c:		bank_offset &= s->cirrus_addr_mask;
cirrus_vga.c:		mode = s->vga.gr[0x05] & 0x7;
cirrus_vga.c:		if (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {
cirrus_vga.c:		    *(s->vga.vram_ptr + bank_offset) = mem_value;
cirrus_vga.c:		    cpu_physical_memory_set_dirty(s->vga.vram_offset +
cirrus_vga.c:		    if ((s->vga.gr[0x0B] & 0x14) != 0x14) {
cirrus_vga.c:	/* memory-mapped I/O */
cirrus_vga.c:	if ((s->vga.sr[0x17] & 0x44) == 0x04) {
cirrus_vga.c:    if (s->last_hw_cursor_size) {
cirrus_vga.c:        vga_invalidate_scanlines(&s->vga,
cirrus_vga.c:                                 s->last_hw_cursor_y + s->last_hw_cursor_y_start,
cirrus_vga.c:                                 s->last_hw_cursor_y + s->last_hw_cursor_y_end);
cirrus_vga.c:    src = s->vga.vram_ptr + s->real_vram_size - 16 * 1024;
cirrus_vga.c:    if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE) {
cirrus_vga.c:        src += (s->vga.sr[0x13] & 0x3c) * 256;
cirrus_vga.c:        y_max = -1;
cirrus_vga.c:        src += (s->vga.sr[0x13] & 0x3f) * 256;
cirrus_vga.c:        y_max = -1;
cirrus_vga.c:        s->last_hw_cursor_y_start = 0;
cirrus_vga.c:        s->last_hw_cursor_y_end = 0;
cirrus_vga.c:        s->last_hw_cursor_y_start = y_min;
cirrus_vga.c:        s->last_hw_cursor_y_end = y_max + 1;
cirrus_vga.c:    if (!(s->vga.sr[0x12] & CIRRUS_CURSOR_SHOW)) {
cirrus_vga.c:        if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE)
cirrus_vga.c:    if (s->last_hw_cursor_size != size ||
cirrus_vga.c:        s->last_hw_cursor_x != s->hw_cursor_x ||
cirrus_vga.c:        s->last_hw_cursor_y != s->hw_cursor_y) {
cirrus_vga.c:        s->last_hw_cursor_size = size;
cirrus_vga.c:        s->last_hw_cursor_x = s->hw_cursor_x;
cirrus_vga.c:        s->last_hw_cursor_y = s->hw_cursor_y;
cirrus_vga.c:    if (!(s->vga.sr[0x12] & CIRRUS_CURSOR_SHOW))
cirrus_vga.c:    if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE) {
cirrus_vga.c:    if (scr_y < s->hw_cursor_y ||
cirrus_vga.c:        scr_y >= (s->hw_cursor_y + h))
cirrus_vga.c:    src = s->vga.vram_ptr + s->real_vram_size - 16 * 1024;
cirrus_vga.c:    if (s->vga.sr[0x12] & CIRRUS_CURSOR_LARGE) {
cirrus_vga.c:        src += (s->vga.sr[0x13] & 0x3c) * 256;
cirrus_vga.c:        src += (scr_y - s->hw_cursor_y) * 16;
cirrus_vga.c:        src += (s->vga.sr[0x13] & 0x3f) * 256;
cirrus_vga.c:        src += (scr_y - s->hw_cursor_y) * 4;
cirrus_vga.c:    x1 = s->hw_cursor_x;
cirrus_vga.c:    if (x1 >= s->vga.last_scr_width)
cirrus_vga.c:    x2 = s->hw_cursor_x + w;
cirrus_vga.c:    if (x2 > s->vga.last_scr_width)
cirrus_vga.c:        x2 = s->vga.last_scr_width;
cirrus_vga.c:    w = x2 - x1;
cirrus_vga.c:    palette = s->cirrus_hidden_palette;
cirrus_vga.c:    color0 = s->vga.rgb_to_pixel(c6_to_8(palette[0x0 * 3]),
cirrus_vga.c:    color1 = s->vga.rgb_to_pixel(c6_to_8(palette[0xf * 3]),
cirrus_vga.c:    bpp = ((ds_get_bits_per_pixel(s->vga.ds) + 7) >> 3);
cirrus_vga.c:    switch(ds_get_bits_per_pixel(s->vga.ds)) {
cirrus_vga.c:    addr &= s->cirrus_addr_mask;
cirrus_vga.c:    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&
cirrus_vga.c:        ((addr & s->linear_mmio_mask) == s->linear_mmio_mask)) {
cirrus_vga.c:	/* memory-mapped I/O */
cirrus_vga.c:	if ((s->vga.gr[0x0B] & 0x14) == 0x14) {
cirrus_vga.c:	} else if (s->vga.gr[0x0B] & 0x02) {
cirrus_vga.c:	addr &= s->cirrus_addr_mask;
cirrus_vga.c:	ret = *(s->vga.vram_ptr + addr);
cirrus_vga.c:    addr &= s->cirrus_addr_mask;
cirrus_vga.c:    if (((s->vga.sr[0x17] & 0x44) == 0x44) &&
cirrus_vga.c:        ((addr & s->linear_mmio_mask) ==  s->linear_mmio_mask)) {
cirrus_vga.c:	/* memory-mapped I/O */
cirrus_vga.c:    } else if (s->cirrus_srcptr != s->cirrus_srcptr_end) {
cirrus_vga.c:	*s->cirrus_srcptr++ = (uint8_t) val;
cirrus_vga.c:	if (s->cirrus_srcptr >= s->cirrus_srcptr_end) {
cirrus_vga.c:	if ((s->vga.gr[0x0B] & 0x14) == 0x14) {
cirrus_vga.c:	} else if (s->vga.gr[0x0B] & 0x02) {
cirrus_vga.c:	addr &= s->cirrus_addr_mask;
cirrus_vga.c:	mode = s->vga.gr[0x05] & 0x7;
cirrus_vga.c:	if (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {
cirrus_vga.c:	    *(s->vga.vram_ptr + addr) = (uint8_t) val;
cirrus_vga.c:	    cpu_physical_memory_set_dirty(s->vga.vram_offset + addr);
cirrus_vga.c:	    if ((s->vga.gr[0x0B] & 0x14) != 0x14) {
cirrus_vga.c:    if (s->cirrus_srcptr != s->cirrus_srcptr_end) {
cirrus_vga.c:	*s->cirrus_srcptr++ = (uint8_t) val;
cirrus_vga.c:	if (s->cirrus_srcptr >= s->cirrus_srcptr_end) {
cirrus_vga.c:    vga_dirty_log_stop(&s->vga);
cirrus_vga.c:    if (!s->vga.map_addr && s->vga.lfb_addr && s->vga.lfb_end) {
cirrus_vga.c:        s->vga.map_addr = s->vga.lfb_addr;
cirrus_vga.c:        s->vga.map_end = s->vga.lfb_end;
cirrus_vga.c:        cpu_register_physical_memory(s->vga.map_addr, s->vga.map_end - s->vga.map_addr, s->vga.vram_offset);
cirrus_vga.c:    if (!s->vga.map_addr)
cirrus_vga.c:    s->vga.lfb_vram_mapped = 0;
cirrus_vga.c:                                (s->vga.vram_offset + s->cirrus_bank_base[0]) | IO_MEM_UNASSIGNED);
cirrus_vga.c:                                (s->vga.vram_offset + s->cirrus_bank_base[1]) | IO_MEM_UNASSIGNED);
cirrus_vga.c:    if (!(s->cirrus_srcptr != s->cirrus_srcptr_end)
cirrus_vga.c:        && !((s->vga.sr[0x07] & 0x01) == 0)
cirrus_vga.c:        && !((s->vga.gr[0x0B] & 0x14) == 0x14)
cirrus_vga.c:        && !(s->vga.gr[0x0B] & 0x02)) {
cirrus_vga.c:        vga_dirty_log_stop(&s->vga);
cirrus_vga.c:                                    (s->vga.vram_offset + s->cirrus_bank_base[0]) | IO_MEM_RAM);
cirrus_vga.c:                                    (s->vga.vram_offset + s->cirrus_bank_base[1]) | IO_MEM_RAM);
cirrus_vga.c:        s->vga.lfb_vram_mapped = 1;
cirrus_vga.c:                                     s->vga.vga_io_memory);
cirrus_vga.c:    vga_dirty_log_start(&s->vga);
cirrus_vga.c:    vga_dirty_log_stop(&s->vga);
cirrus_vga.c:    if (s->vga.map_addr && s->vga.lfb_addr && s->vga.lfb_end) {
cirrus_vga.c:        s->vga.map_addr = s->vga.map_end = 0;
cirrus_vga.c:         cpu_register_physical_memory(s->vga.lfb_addr, s->vga.vram_size,
cirrus_vga.c:                                      s->cirrus_linear_io_addr);
cirrus_vga.c:                                 s->vga.vga_io_memory);
cirrus_vga.c:    vga_dirty_log_start(&s->vga);
cirrus_vga.c:    if ((s->vga.sr[0x17] & 0x44) == 0x44) {
cirrus_vga.c:    } else if (s->cirrus_srcptr != s->cirrus_srcptr_end) {
cirrus_vga.c:	if ((s->vga.gr[0x0B] & 0x14) == 0x14) {
cirrus_vga.c:	} else if (s->vga.gr[0x0B] & 0x02) {
cirrus_vga.c:	mode = s->vga.gr[0x05] & 0x7;
cirrus_vga.c:	if (mode < 4 || mode > 5 || ((s->vga.gr[0x0B] & 0x4) == 0)) {
cirrus_vga.c:    VGACommonState *s = &c->vga;
cirrus_vga.c:	    if (s->ar_flip_flop == 0) {
cirrus_vga.c:		val = s->ar_index;
cirrus_vga.c:	    index = s->ar_index & 0x1f;
cirrus_vga.c:		val = s->ar[index];
cirrus_vga.c:	    val = s->st00;
cirrus_vga.c:	    val = s->sr_index;
cirrus_vga.c:	    printf("vga: read SR%x = 0x%02x\n", s->sr_index, val);
cirrus_vga.c:	    val = s->dac_state;
cirrus_vga.c:	    val = s->dac_write_index;
cirrus_vga.c:	    c->cirrus_hidden_dac_lockindex = 0;
cirrus_vga.c:	    val = s->fcr;
cirrus_vga.c:	    val = s->msr;
cirrus_vga.c:	    val = s->gr_index;
cirrus_vga.c:	    val = cirrus_vga_read_gr(c, s->gr_index);
cirrus_vga.c:	    printf("vga: read GR%x = 0x%02x\n", s->gr_index, val);
cirrus_vga.c:	    val = s->cr_index;
cirrus_vga.c:            val = cirrus_vga_read_cr(c, s->cr_index);
cirrus_vga.c:	    printf("vga: read CR%x = 0x%02x\n", s->cr_index, val);
cirrus_vga.c:	    val = s->st01 = s->retrace(s);
cirrus_vga.c:	    s->ar_flip_flop = 0;
cirrus_vga.c:    VGACommonState *s = &c->vga;
cirrus_vga.c:	if (s->ar_flip_flop == 0) {
cirrus_vga.c:	    s->ar_index = val;
cirrus_vga.c:	    index = s->ar_index & 0x1f;
cirrus_vga.c:		s->ar[index] = val & 0x3f;
cirrus_vga.c:		s->ar[index] = val & ~0x10;
cirrus_vga.c:		s->ar[index] = val;
cirrus_vga.c:		s->ar[index] = val & ~0xc0;
cirrus_vga.c:		s->ar[index] = val & ~0xf0;
cirrus_vga.c:		s->ar[index] = val & ~0xf0;
cirrus_vga.c:	s->ar_flip_flop ^= 1;
cirrus_vga.c:	s->msr = val & ~0x10;
cirrus_vga.c:	s->update_retrace_info(s);
cirrus_vga.c:	s->sr_index = val;
cirrus_vga.c:	printf("vga: write SR%x = 0x%02x\n", s->sr_index, val);
cirrus_vga.c:	s->dac_read_index = val;
cirrus_vga.c:	s->dac_sub_index = 0;
cirrus_vga.c:	s->dac_state = 3;
cirrus_vga.c:	s->dac_write_index = val;
cirrus_vga.c:	s->dac_sub_index = 0;
cirrus_vga.c:	s->dac_state = 0;
cirrus_vga.c:	s->gr_index = val;
cirrus_vga.c:	printf("vga: write GR%x = 0x%02x\n", s->gr_index, val);
cirrus_vga.c:	cirrus_vga_write_gr(c, s->gr_index, val);
cirrus_vga.c:	s->cr_index = val;
cirrus_vga.c:	printf("vga: write CR%x = 0x%02x\n", s->cr_index, val);
cirrus_vga.c:	s->fcr = val & 0x10;
cirrus_vga.c: *  memory-mapped I/O access
cirrus_vga.c:    addr &= CIRRUS_PNPMMIO_SIZE - 1;
cirrus_vga.c:        return cirrus_mmio_blt_read(s, addr - 0x100);
cirrus_vga.c:    addr &= CIRRUS_PNPMMIO_SIZE - 1;
cirrus_vga.c:	cirrus_mmio_blt_write(s, addr - 0x100, val);
cirrus_vga.c:    s->vga.gr[0x00] = s->cirrus_shadow_gr0 & 0x0f;
cirrus_vga.c:    s->vga.gr[0x01] = s->cirrus_shadow_gr1 & 0x0f;
cirrus_vga.c:    s->vga.graphic_mode = -1;
cirrus_vga.c:        /* XXX: we do not save the bitblt state - we assume we do not save
cirrus_vga.c:    vga_common_reset(&s->vga);
cirrus_vga.c:    s->vga.sr[0x06] = 0x0f;
cirrus_vga.c:    if (s->device_id == CIRRUS_ID_CLGD5446) {
cirrus_vga.c:        s->vga.sr[0x1F] = 0x2d;		// MemClock
cirrus_vga.c:        s->vga.gr[0x18] = 0x0f;             // fastest memory configuration
cirrus_vga.c:        s->vga.sr[0x0f] = 0x98;
cirrus_vga.c:        s->vga.sr[0x17] = 0x20;
cirrus_vga.c:        s->vga.sr[0x15] = 0x04; /* memory size, 3=2MB, 4=4MB */
cirrus_vga.c:        s->vga.sr[0x1F] = 0x22;		// MemClock
cirrus_vga.c:        s->vga.sr[0x0F] = CIRRUS_MEMSIZE_2M;
cirrus_vga.c:        s->vga.sr[0x17] = s->bustype;
cirrus_vga.c:        s->vga.sr[0x15] = 0x03; /* memory size, 3=2MB, 4=4MB */
cirrus_vga.c:    s->vga.cr[0x27] = s->device_id;
cirrus_vga.c:    memset(s->vga.vram_ptr, 0xff, s->real_vram_size);
cirrus_vga.c:    s->cirrus_hidden_dac_lockindex = 5;
cirrus_vga.c:    s->cirrus_hidden_dac_data = 0;
cirrus_vga.c:        s->device_id = device_id;
cirrus_vga.c:            s->bustype = CIRRUS_BUSTYPE_PCI;
cirrus_vga.c:            s->bustype = CIRRUS_BUSTYPE_ISA;
cirrus_vga.c:    s->vga.vga_io_memory = cpu_register_io_memory(cirrus_vga_mem_read,
cirrus_vga.c:                                 s->vga.vga_io_memory);
cirrus_vga.c:    s->cirrus_linear_io_addr =
cirrus_vga.c:    s->cirrus_linear_bitblt_io_addr =
cirrus_vga.c:    /* I/O handler for memory-mapped I/O */
cirrus_vga.c:    s->cirrus_mmio_io_addr =
cirrus_vga.c:    s->real_vram_size =
cirrus_vga.c:        (s->device_id == CIRRUS_ID_CLGD5446) ? 4096 * 1024 : 2048 * 1024;
cirrus_vga.c:    /* XXX: s->vga.vram_size must be a power of two */
cirrus_vga.c:    s->cirrus_addr_mask = s->real_vram_size - 1;
cirrus_vga.c:    s->linear_mmio_mask = s->real_vram_size - 256;
cirrus_vga.c:    s->vga.get_bpp = cirrus_get_bpp;
cirrus_vga.c:    s->vga.get_offsets = cirrus_get_offsets;
cirrus_vga.c:    s->vga.get_resolution = cirrus_get_resolution;
cirrus_vga.c:    s->vga.cursor_invalidate = cirrus_cursor_invalidate;
cirrus_vga.c:    s->vga.cursor_draw_line = cirrus_cursor_draw_line;
cirrus_vga.c:    vga_common_init(&s->vga, VGA_RAM_SIZE);
cirrus_vga.c:    s->vga.ds = graphic_console_init(s->vga.update, s->vga.invalidate,
cirrus_vga.c:                                     s->vga.screen_dump, s->vga.text_update,
cirrus_vga.c:                                     &s->vga);
cirrus_vga.c:    /* XXX ISA-LFB support */
cirrus_vga.c:    CirrusVGAState *s = &DO_UPCAST(PCICirrusVGAState, dev, d)->cirrus_vga;
cirrus_vga.c:    vga_dirty_log_stop(&s->vga);
cirrus_vga.c:    cpu_register_physical_memory(addr, s->vga.vram_size,
cirrus_vga.c:				 s->cirrus_linear_io_addr);
cirrus_vga.c:				 s->cirrus_linear_bitblt_io_addr);
cirrus_vga.c:    s->vga.map_addr = s->vga.map_end = 0;
cirrus_vga.c:    s->vga.lfb_addr = addr & TARGET_PAGE_MASK;
cirrus_vga.c:    s->vga.lfb_end = ((addr + VGA_RAM_SIZE) + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK;
cirrus_vga.c:    if (s->vga.lfb_end < addr + VGA_RAM_SIZE)
cirrus_vga.c:        s->vga.lfb_end = addr + VGA_RAM_SIZE;
cirrus_vga.c:    vga_dirty_log_start(&s->vga);
cirrus_vga.c:    CirrusVGAState *s = &DO_UPCAST(PCICirrusVGAState, dev, d)->cirrus_vga;
cirrus_vga.c:				 s->cirrus_mmio_io_addr);
cirrus_vga.c:    CirrusVGAState *s = &pvs->cirrus_vga;
cirrus_vga.c:    vga_dirty_log_stop(&s->vga);
cirrus_vga.c:    if (s->vga.map_addr && d->io_regions[0].addr == PCI_BAR_UNMAPPED)
cirrus_vga.c:        s->vga.map_addr = 0;
cirrus_vga.c:    vga_dirty_log_start(&s->vga);
cirrus_vga.c:     CirrusVGAState *s = &d->cirrus_vga;
cirrus_vga.c:     uint8_t *pci_conf = d->dev.config;
cirrus_vga.c:     vga_common_init(&s->vga, VGA_RAM_SIZE);
cirrus_vga.c:     s->vga.ds = graphic_console_init(s->vga.update, s->vga.invalidate,
cirrus_vga.c:                                      s->vga.screen_dump, s->vga.text_update,
cirrus_vga.c:                                      &s->vga);
cirrus_vga.c:     /* memory #1 memory-mapped I/O */
cirrus_vga.c:     /* XXX: s->vga.vram_size must be a power of two */
cirrus_vga.c:    pci_create_simple(bus, -1, "cirrus-vga");
cirrus_vga.c:    .qdev.name    = "cirrus-vga",
cirrus_vga_rop2.h:    int skipleft = s->vga.gr[0x2f] & 0x1f;
cirrus_vga_rop2.h:    int skipleft = (s->vga.gr[0x2f] & 0x07) * (DEPTH / 8);
cirrus_vga_rop2.h:    pattern_y = s->cirrus_blt_srcaddr & 7;
cirrus_vga_rop2.h:    int dstskipleft = s->vga.gr[0x2f] & 0x1f;
cirrus_vga_rop2.h:    int srcskipleft = s->vga.gr[0x2f] & 0x07;
cirrus_vga_rop2.h:    if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_COLOREXPINV) {
cirrus_vga_rop2.h:        col = s->cirrus_blt_bgcol;
cirrus_vga_rop2.h:        col = s->cirrus_blt_fgcol;
cirrus_vga_rop2.h:    int srcskipleft = s->vga.gr[0x2f] & 0x07;
cirrus_vga_rop2.h:    colors[0] = s->cirrus_blt_bgcol;
cirrus_vga_rop2.h:    colors[1] = s->cirrus_blt_fgcol;
cirrus_vga_rop2.h:    int dstskipleft = s->vga.gr[0x2f] & 0x1f;
cirrus_vga_rop2.h:    int srcskipleft = s->vga.gr[0x2f] & 0x07;
cirrus_vga_rop2.h:    if (s->cirrus_blt_modeext & CIRRUS_BLTMODEEXT_COLOREXPINV) {
cirrus_vga_rop2.h:        col = s->cirrus_blt_bgcol;
cirrus_vga_rop2.h:        col = s->cirrus_blt_fgcol;
cirrus_vga_rop2.h:    pattern_y = s->cirrus_blt_srcaddr & 7;
cirrus_vga_rop2.h:        bitpos = 7 - srcskipleft;
cirrus_vga_rop2.h:            bitpos = (bitpos - 1) & 7;
cirrus_vga_rop2.h:    int srcskipleft = s->vga.gr[0x2f] & 0x07;
cirrus_vga_rop2.h:    colors[0] = s->cirrus_blt_bgcol;
cirrus_vga_rop2.h:    colors[1] = s->cirrus_blt_fgcol;
cirrus_vga_rop2.h:    pattern_y = s->cirrus_blt_srcaddr & 7;
cirrus_vga_rop2.h:        bitpos = 7 - srcskipleft;
cirrus_vga_rop2.h:            bitpos = (bitpos - 1) & 7;
cirrus_vga_rop2.h:    col = s->cirrus_blt_fgcol;
cirrus_vga_rop.h:    dstpitch -= bltwidth;
cirrus_vga_rop.h:    srcpitch -= bltwidth;
cirrus_vga_rop.h:            dst--;
cirrus_vga_rop.h:            src--;
cirrus_vga_rop.h:    dstpitch -= bltwidth;
cirrus_vga_rop.h:    srcpitch -= bltwidth;
cirrus_vga_rop.h:	    if (p != s->vga.gr[0x34]) *dst = p;
cirrus_vga_rop.h:	    if (p != s->vga.gr[0x34]) *dst = p;
cirrus_vga_rop.h:            dst--;
cirrus_vga_rop.h:            src--;
cirrus_vga_rop.h:    dstpitch -= bltwidth;
cirrus_vga_rop.h:    srcpitch -= bltwidth;
cirrus_vga_rop.h:	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
cirrus_vga_rop.h:	    p1 = *(dst-1);
cirrus_vga_rop.h:            ROP_OP(p1, *(src-1));
cirrus_vga_rop.h:	    if ((p1 != s->vga.gr[0x34]) || (p2 != s->vga.gr[0x35])) {
cirrus_vga_rop.h:		*(dst-1) = p1;
cirrus_vga_rop.h:            dst-=2;
cirrus_vga_rop.h:            src-=2;
cs4231a.c:#include "qemu-timer.h"
cs4231a.c:    { 8000, 16000, 27420, 32000,    -1,    -1, 48000, 9000 },
cs4231a.c:     -32124,-31100,-30076,-29052,-28028,-27004,-25980,-24956,
cs4231a.c:     -23932,-22908,-21884,-20860,-19836,-18812,-17788,-16764,
cs4231a.c:     -15996,-15484,-14972,-14460,-13948,-13436,-12924,-12412,
cs4231a.c:     -11900,-11388,-10876,-10364, -9852, -9340, -8828, -8316,
cs4231a.c:      -7932, -7676, -7420, -7164, -6908, -6652, -6396, -6140,
cs4231a.c:      -5884, -5628, -5372, -5116, -4860, -4604, -4348, -4092,
cs4231a.c:      -3900, -3772, -3644, -3516, -3388, -3260, -3132, -3004,
cs4231a.c:      -2876, -2748, -2620, -2492, -2364, -2236, -2108, -1980,
cs4231a.c:      -1884, -1820, -1756, -1692, -1628, -1564, -1500, -1436,
cs4231a.c:      -1372, -1308, -1244, -1180, -1116, -1052,  -988,  -924,
cs4231a.c:       -876,  -844,  -812,  -780,  -748,  -716,  -684,  -652,
cs4231a.c:       -620,  -588,  -556,  -524,  -492,  -460,  -428,  -396,
cs4231a.c:       -372,  -356,  -340,  -324,  -308,  -292,  -276,  -260,
cs4231a.c:       -244,  -228,  -212,  -196,  -180,  -164,  -148,  -132,
cs4231a.c:       -120,  -112,  -104,   -96,   -88,   -80,   -72,   -64,
cs4231a.c:        -56,   -48,   -40,   -32,   -24,   -16,    -8,     0,
cs4231a.c:     -5504, -5248, -6016, -5760, -4480, -4224, -4992, -4736,
cs4231a.c:     -7552, -7296, -8064, -7808, -6528, -6272, -7040, -6784,
cs4231a.c:     -2752, -2624, -3008, -2880, -2240, -2112, -2496, -2368,
cs4231a.c:     -3776, -3648, -4032, -3904, -3264, -3136, -3520, -3392,
cs4231a.c:     -22016,-20992,-24064,-23040,-17920,-16896,-19968,-18944,
cs4231a.c:     -30208,-29184,-32256,-31232,-26112,-25088,-28160,-27136,
cs4231a.c:     -11008,-10496,-12032,-11520,-8960, -8448, -9984, -9472,
cs4231a.c:     -15104,-14592,-16128,-15616,-13056,-12544,-14080,-13568,
cs4231a.c:     -344,  -328,  -376,  -360,  -280,  -264,  -312,  -296,
cs4231a.c:     -472,  -456,  -504,  -488,  -408,  -392,  -440,  -424,
cs4231a.c:     -88,   -72,   -120,  -104,  -24,   -8,    -56,   -40,
cs4231a.c:     -216,  -200,  -248,  -232,  -152,  -136,  -184,  -168,
cs4231a.c:     -1376, -1312, -1504, -1440, -1120, -1056, -1248, -1184,
cs4231a.c:     -1888, -1824, -2016, -1952, -1632, -1568, -1760, -1696,
cs4231a.c:     -688,  -656,  -752,  -720,  -560,  -528,  -624,  -592,
cs4231a.c:     -944,  -912,  -1008, -976,  -816,  -784,  -880,  -848,
cs4231a.c:    s->regs[Index_Address] = 0x40;
cs4231a.c:    s->regs[Index_Data]    = 0x00;
cs4231a.c:    s->regs[Status]        = 0x00;
cs4231a.c:    s->regs[PIO_Data]      = 0x00;
cs4231a.c:    s->dregs[Left_ADC_Input_Control]          = 0x00;
cs4231a.c:    s->dregs[Right_ADC_Input_Control]         = 0x00;
cs4231a.c:    s->dregs[Left_AUX1_Input_Control]         = 0x88;
cs4231a.c:    s->dregs[Right_AUX1_Input_Control]        = 0x88;
cs4231a.c:    s->dregs[Left_AUX2_Input_Control]         = 0x88;
cs4231a.c:    s->dregs[Right_AUX2_Input_Control]        = 0x88;
cs4231a.c:    s->dregs[Left_DAC_Output_Control]         = 0x80;
cs4231a.c:    s->dregs[Right_DAC_Output_Control]        = 0x80;
cs4231a.c:    s->dregs[FS_And_Playback_Data_Format]     = 0x00;
cs4231a.c:    s->dregs[Interface_Configuration]         = 0x08;
cs4231a.c:    s->dregs[Pin_Control]                     = 0x00;
cs4231a.c:    s->dregs[Error_Status_And_Initialization] = 0x00;
cs4231a.c:    s->dregs[MODE_And_ID]                     = 0x8a;
cs4231a.c:    s->dregs[Loopback_Control]                = 0x00;
cs4231a.c:    s->dregs[Playback_Upper_Base_Count]       = 0x00;
cs4231a.c:    s->dregs[Playback_Lower_Base_Count]       = 0x00;
cs4231a.c:    s->dregs[Alternate_Feature_Enable_I]      = 0x00;
cs4231a.c:    s->dregs[Alternate_Feature_Enable_II]     = 0x00;
cs4231a.c:    s->dregs[Left_Line_Input_Control]         = 0x88;
cs4231a.c:    s->dregs[Right_Line_Input_Control]        = 0x88;
cs4231a.c:    s->dregs[Timer_Low_Base]                  = 0x00;
cs4231a.c:    s->dregs[Timer_High_Base]                 = 0x00;
cs4231a.c:    s->dregs[RESERVED]                        = 0x00;
cs4231a.c:    s->dregs[Alternate_Feature_Enable_III]    = 0x00;
cs4231a.c:    s->dregs[Alternate_Feature_Status]        = 0x00;
cs4231a.c:    s->dregs[Version_Chip_ID]                 = 0xa0;
cs4231a.c:    s->dregs[Mono_Input_And_Output_Control]   = 0xa0;
cs4231a.c:    s->dregs[RESERVED_2]                      = 0x00;
cs4231a.c:    s->dregs[Capture_Data_Format]             = 0x00;
cs4231a.c:    s->dregs[RESERVED_3]                      = 0x00;
cs4231a.c:    s->dregs[Capture_Upper_Base_Count]        = 0x00;
cs4231a.c:    s->dregs[Capture_Lower_Base_Count]        = 0x00;
cs4231a.c:    s->audio_free = free;
cs4231a.c:    if (as.freq == -1) {
cs4231a.c:    s->tab = NULL;
cs4231a.c:    switch ((val >> 5) & ((s->dregs[MODE_And_ID] & MODE2) ? 7 : 3)) {
cs4231a.c:        s->shift = as.nchannels == 2;
cs4231a.c:        s->tab = MuLawDecompressTable;
cs4231a.c:        s->tab = ALawDecompressTable;
cs4231a.c:        s->shift = as.nchannels == 2;
cs4231a.c:        s->shift = as.nchannels;
cs4231a.c:    s->voice = AUD_open_out (
cs4231a.c:        &s->card,
cs4231a.c:        s->voice,
cs4231a.c:    if (s->dregs[Interface_Configuration] & PEN) {
cs4231a.c:        if (!s->dma_running) {
cs4231a.c:            DMA_hold_DREQ (s->dma);
cs4231a.c:            AUD_set_active_out (s->voice, 1);
cs4231a.c:            s->transferred = 0;
cs4231a.c:        s->dma_running = 1;
cs4231a.c:        if (s->dma_running) {
cs4231a.c:            DMA_release_DREQ (s->dma);
cs4231a.c:            AUD_set_active_out (s->voice, 0);
cs4231a.c:        s->dma_running = 0;
cs4231a.c:    if (s->dma_running) {
cs4231a.c:        DMA_release_DREQ (s->dma);
cs4231a.c:        AUD_set_active_out (s->voice, 0);
cs4231a.c:        ret = s->regs[saddr] & ~0x80;
cs4231a.c:        if (!(s->dregs[MODE_And_ID] & MODE2))
cs4231a.c:            iaddr = s->regs[Index_Address] & 0x0f;
cs4231a.c:            iaddr = s->regs[Index_Address] & 0x1f;
cs4231a.c:        ret = s->dregs[iaddr];
cs4231a.c:            if (s->aci_counter) {
cs4231a.c:                s->aci_counter -= 1;
cs4231a.c:        ret = s->regs[saddr];
cs4231a.c:    dolog ("read %d:%d -> %d\n", saddr, iaddr, ret);
cs4231a.c:        if (!(s->regs[Index_Address] & MCE) && (val & MCE)
cs4231a.c:            && (s->dregs[Interface_Configuration] & (3 << 3)))
cs4231a.c:            s->aci_counter = conf.aci_counter;
cs4231a.c:        s->regs[Index_Address] = val & ~(1 << 7);
cs4231a.c:        if (!(s->dregs[MODE_And_ID] & MODE2))
cs4231a.c:            iaddr = s->regs[Index_Address] & 0x0f;
cs4231a.c:            iaddr = s->regs[Index_Address] & 0x1f;
cs4231a.c:            if (s->regs[Index_Address] & MCE) {
cs4231a.c:                if (s->dregs[Alternate_Feature_Status] & PMCE) {
cs4231a.c:                    val = (val & ~0x0f) | (s->dregs[iaddr] & 0x0f);
cs4231a.c:                           s->regs[Index_Address],
cs4231a.c:                           s->dregs[Alternate_Feature_Status],
cs4231a.c:            s->dregs[iaddr] = val;
cs4231a.c:            s->dregs[iaddr] = val;
cs4231a.c:                if (!s->dma_running) {
cs4231a.c:                    cs_reset_voices (s, s->dregs[FS_And_Playback_Data_Format]);
cs4231a.c:                if (s->dma_running) {
cs4231a.c:                    DMA_release_DREQ (s->dma);
cs4231a.c:                    AUD_set_active_out (s->voice, 0);
cs4231a.c:                    s->dma_running = 0;
cs4231a.c:                s->dregs[iaddr] |= MODE2;
cs4231a.c:                s->dregs[iaddr] &= ~MODE2;
cs4231a.c:            s->dregs[iaddr] = val;
cs4231a.c:            if ((s->dregs[iaddr] & PI) && !(val & PI)) {
cs4231a.c:                qemu_irq_lower (s->pic);
cs4231a.c:                s->regs[Status] &= ~INT;
cs4231a.c:            s->dregs[iaddr] = val;
cs4231a.c:            s->dregs[iaddr] = val;
cs4231a.c:            s->dregs[iaddr] = val;
cs4231a.c:        if (s->regs[Status] & INT) {
cs4231a.c:            qemu_irq_lower (s->pic);
cs4231a.c:        s->regs[Status] &= ~INT;
cs4231a.c:        s->dregs[Alternate_Feature_Status] &= ~(PI | CI | TI);
cs4231a.c:        int left = dma_len - dma_pos;
cs4231a.c:        if (s->tab) {
cs4231a.c:                linbuf[i] = s->tab[tmpbuf[i]];
cs4231a.c:            copied = AUD_write (s->voice, linbuf, copied << 1);
cs4231a.c:            copied = AUD_write (s->voice, tmpbuf, copied);
cs4231a.c:        temp -= copied;
cs4231a.c:    int till = -1;
cs4231a.c:    copy = s->voice ? (s->audio_free >> (s->tab != NULL)) : dma_len;
cs4231a.c:    if (s->dregs[Pin_Control] & IEN) {
cs4231a.c:        till = (s->dregs[Playback_Lower_Base_Count]
cs4231a.c:            | (s->dregs[Playback_Upper_Base_Count] << 8)) << s->shift;
cs4231a.c:        till -= s->transferred;
cs4231a.c:    s->audio_free -= (written << (s->tab != NULL));
cs4231a.c:        s->regs[Status] |= INT;
cs4231a.c:        s->dregs[Alternate_Feature_Status] |= PI;
cs4231a.c:        s->transferred = 0;
cs4231a.c:        qemu_irq_raise (s->pic);
cs4231a.c:        s->transferred += written;
cs4231a.c:    if (s->dma_running) {
cs4231a.c:        DMA_release_DREQ (s->dma);
cs4231a.c:        AUD_set_active_out (s->voice, 0);
cs4231a.c:    s->dma_running = 0;
cs4231a.c:    if (s->dma_running && (s->dregs[Interface_Configuration] & PEN)) {
cs4231a.c:        s->dma_running = 0;
cs4231a.c:        cs_reset_voices (s, s->dregs[FS_And_Playback_Data_Format]);
cs4231a.c:    isa_init_irq (dev, &s->pic, s->irq);
cs4231a.c:        register_ioport_write (s->port + i, 1, 1, cs_write, s);
cs4231a.c:        register_ioport_read (s->port + i, 1, 1, cs_read, s);
cs4231a.c:    DMA_register_channel (s->dma, cs_dma_read, s);
cs4231a.c:    AUD_register_card ("cs4231a", &s->card);
cs4231.c:#define CS_MAXDREG (CS_DREGS - 1)
cs4231.c:#define CS_RAP(s) ((s)->regs[0] & CS_MAXDREG)
cs4231.c:    memset(s->regs, 0, CS_REGS * 4);
cs4231.c:    memset(s->dregs, 0, CS_DREGS);
cs4231.c:    s->dregs[12] = CS_CDC_VER;
cs4231.c:    s->dregs[25] = CS_VER;
cs4231.c:            ret = s->dregs[CS_RAP(s)];
cs4231.c:        ret = s->regs[saddr];
cs4231.c:    DPRINTF("write reg[%d]: 0x%8.8x -> 0x%8.8x\n", saddr, s->regs[saddr], val);
cs4231.c:        DPRINTF("write dreg[%d]: 0x%2.2x -> 0x%2.2x\n", CS_RAP(s),
cs4231.c:                s->dregs[CS_RAP(s)], val);
cs4231.c:            s->dregs[CS_RAP(s)] = val;
cs4231.c:            s->dregs[CS_RAP(s)] = val;
cs4231.c:            cs_reset(&s->busdev.qdev);
cs4231.c:        s->regs[saddr] = val;
cs4231.c:        s->regs[saddr] = val;
cs4231.c:    sysbus_init_irq(dev, &s->irq);
cuda.c: * Copyright (c) 2004-2007 Fabrice Bellard
cuda.c:#include "qemu-timer.h"
cuda.c:    uint8_t b;      /* B-side data */
cuda.c:    uint8_t a;      /* A-side data */
cuda.c:    uint8_t dirb;   /* B-side direction (1=output) */
cuda.c:    uint8_t dira;   /* A-side direction (1=output) */
cuda.c:    uint8_t anh;    /* A-side data, no handshake */
cuda.c:    if (s->ifr & s->ier & (SR_INT | T1_INT)) {
cuda.c:        qemu_irq_raise(s->irq);
cuda.c:        qemu_irq_lower(s->irq);
cuda.c:    d = muldiv64(qemu_get_clock(vm_clock) - s->load_time,
cuda.c:    if (s->index == 0) {
cuda.c:        /* the timer goes down from latch to -1 (period of latch + 2) */
cuda.c:        if (d <= (s->counter_value + 1)) {
cuda.c:            counter = (s->counter_value - d) & 0xffff;
cuda.c:            counter = (d - (s->counter_value + 1)) % (s->latch + 2);
cuda.c:            counter = (s->latch - counter) & 0xffff;
cuda.c:        counter = (s->counter_value - d) & 0xffff;
cuda.c:    CUDA_DPRINTF("T%d.counter=%d\n", 1 + (ti->timer == NULL), val);
cuda.c:    ti->load_time = qemu_get_clock(vm_clock);
cuda.c:    ti->counter_value = val;
cuda.c:    cuda_timer_update(s, ti, ti->load_time);
cuda.c:    d = muldiv64(current_time - s->load_time,
cuda.c:    /* the timer goes down from latch to -1 (period of latch + 2) */
cuda.c:    if (d <= (s->counter_value + 1)) {
cuda.c:        counter = (s->counter_value - d) & 0xffff;
cuda.c:        counter = (d - (s->counter_value + 1)) % (s->latch + 2);
cuda.c:        counter = (s->latch - counter) & 0xffff;
cuda.c:        next_time = d + s->latch + 1;
cuda.c:        next_time = d + s->latch + 2;
cuda.c:                 s->latch, d, next_time - d);
cuda.c:        s->load_time;
cuda.c:    if (!ti->timer)
cuda.c:    if ((s->acr & T1MODE) != T1MODE_CONT) {
cuda.c:        qemu_del_timer(ti->timer);
cuda.c:        ti->next_irq_time = get_next_irq_time(ti, current_time);
cuda.c:        qemu_mod_timer(ti->timer, ti->next_irq_time);
cuda.c:    CUDATimer *ti = &s->timers[0];
cuda.c:    cuda_timer_update(s, ti, ti->next_irq_time);
cuda.c:    s->ifr |= T1_INT;
cuda.c:        val = s->b;
cuda.c:        val = s->a;
cuda.c:        val = s->dirb;
cuda.c:        val = s->dira;
cuda.c:        val = get_counter(&s->timers[0]) & 0xff;
cuda.c:        s->ifr &= ~T1_INT;
cuda.c:        val = get_counter(&s->timers[0]) >> 8;
cuda.c:        val = s->timers[0].latch & 0xff;
cuda.c:        val = (s->timers[0].latch >> 8) & 0xff;
cuda.c:        val = get_counter(&s->timers[1]) & 0xff;
cuda.c:        s->ifr &= ~T2_INT;
cuda.c:        val = get_counter(&s->timers[1]) >> 8;
cuda.c:        val = s->sr;
cuda.c:        s->ifr &= ~SR_INT;
cuda.c:        val = s->acr;
cuda.c:        val = s->pcr;
cuda.c:        val = s->ifr;
cuda.c:        if (s->ifr & s->ier)
cuda.c:        val = s->ier | 0x80;
cuda.c:        val = s->anh;
cuda.c:        s->b = val;
cuda.c:        s->a = val;
cuda.c:        s->dirb = val;
cuda.c:        s->dira = val;
cuda.c:        s->timers[0].latch = (s->timers[0].latch & 0xff00) | val;
cuda.c:        cuda_timer_update(s, &s->timers[0], qemu_get_clock(vm_clock));
cuda.c:        s->timers[0].latch = (s->timers[0].latch & 0xff) | (val << 8);
cuda.c:        s->ifr &= ~T1_INT;
cuda.c:        set_counter(s, &s->timers[0], s->timers[0].latch);
cuda.c:        s->timers[0].latch = (s->timers[0].latch & 0xff00) | val;
cuda.c:        cuda_timer_update(s, &s->timers[0], qemu_get_clock(vm_clock));
cuda.c:        s->timers[0].latch = (s->timers[0].latch & 0xff) | (val << 8);
cuda.c:        s->ifr &= ~T1_INT;
cuda.c:        cuda_timer_update(s, &s->timers[0], qemu_get_clock(vm_clock));
cuda.c:        s->timers[1].latch = val;
cuda.c:        set_counter(s, &s->timers[1], val);
cuda.c:        set_counter(s, &s->timers[1], (val << 8) | s->timers[1].latch);
cuda.c:        s->sr = val;
cuda.c:        s->acr = val;
cuda.c:        cuda_timer_update(s, &s->timers[0], qemu_get_clock(vm_clock));
cuda.c:        s->pcr = val;
cuda.c:        s->ifr &= ~val;
cuda.c:            s->ier |= val & 0x7f;
cuda.c:            s->ier &= ~val;
cuda.c:        s->anh = val;
cuda.c:    if (!(s->b & TIP)) {
cuda.c:        if (s->acr & SR_OUT) {
cuda.c:            if ((s->b & (TACK | TIP)) != (s->last_b & (TACK | TIP))) {
cuda.c:                if (s->data_out_index < sizeof(s->data_out)) {
cuda.c:                    CUDA_DPRINTF("send: %02x\n", s->sr);
cuda.c:                    s->data_out[s->data_out_index++] = s->sr;
cuda.c:                    s->ifr |= SR_INT;
cuda.c:            if (s->data_in_index < s->data_in_size) {
cuda.c:                if ((s->b & (TACK | TIP)) != (s->last_b & (TACK | TIP))) {
cuda.c:                    s->sr = s->data_in[s->data_in_index++];
cuda.c:                    CUDA_DPRINTF("recv: %02x\n", s->sr);
cuda.c:                    if (s->data_in_index >= s->data_in_size) {
cuda.c:                        s->b = (s->b | TREQ);
cuda.c:                    s->ifr |= SR_INT;
cuda.c:        if ((s->last_b & TIP) && (s->b & TACK) != (s->last_b & TACK)) {
cuda.c:            if (s->b & TACK)
cuda.c:                s->b = (s->b | TREQ);
cuda.c:                s->b = (s->b & ~TREQ);
cuda.c:            s->ifr |= SR_INT;
cuda.c:            if (!(s->last_b & TIP)) {
cuda.c:                packet_received = (s->data_out_index > 0);
cuda.c:                s->ifr |= SR_INT;
cuda.c:            if (s->data_in_index < s->data_in_size) {
cuda.c:                s->b = (s->b & ~TREQ);
cuda.c:    s->last_acr = s->acr;
cuda.c:    s->last_b = s->b;
cuda.c:        len = s->data_out_index;
cuda.c:        s->data_out_index = 0;
cuda.c:        cuda_receive_packet_from_host(s, s->data_out, len);
cuda.c:    memcpy(s->data_in, data, len);
cuda.c:    s->data_in_size = len;
cuda.c:    s->data_in_index = 0;
cuda.c:    s->ifr |= SR_INT;
cuda.c:    qemu_mod_timer(s->adb_poll_timer,
cuda.c:        if (autopoll != s->autopoll) {
cuda.c:            s->autopoll = autopoll;
cuda.c:                qemu_mod_timer(s->adb_poll_timer,
cuda.c:                qemu_del_timer(s->adb_poll_timer);
cuda.c:        s->tick_offset = ti - (qemu_get_clock(vm_clock) / get_ticks_per_sec());
cuda.c:        ti = s->tick_offset + (qemu_get_clock(vm_clock) / get_ticks_per_sec());
cuda.c:            olen = adb_request(&adb_bus, obuf + 2, data + 1, len - 1);
cuda.c:                obuf[1] = -olen;
cuda.c:        cuda_receive_packet(s, data + 1, len - 1);
cuda.c:    qemu_put_be16s(f, &s->latch);
cuda.c:    qemu_put_be16s(f, &s->counter_value);
cuda.c:    qemu_put_sbe64s(f, &s->load_time);
cuda.c:    qemu_put_sbe64s(f, &s->next_irq_time);
cuda.c:    if (s->timer)
cuda.c:        qemu_put_timer(f, s->timer);
cuda.c:    qemu_put_ubyte(f, s->b);
cuda.c:    qemu_put_ubyte(f, s->a);
cuda.c:    qemu_put_ubyte(f, s->dirb);
cuda.c:    qemu_put_ubyte(f, s->dira);
cuda.c:    qemu_put_ubyte(f, s->sr);
cuda.c:    qemu_put_ubyte(f, s->acr);
cuda.c:    qemu_put_ubyte(f, s->pcr);
cuda.c:    qemu_put_ubyte(f, s->ifr);
cuda.c:    qemu_put_ubyte(f, s->ier);
cuda.c:    qemu_put_ubyte(f, s->anh);
cuda.c:    qemu_put_sbe32s(f, &s->data_in_size);
cuda.c:    qemu_put_sbe32s(f, &s->data_in_index);
cuda.c:    qemu_put_sbe32s(f, &s->data_out_index);
cuda.c:    qemu_put_ubyte(f, s->autopoll);
cuda.c:    qemu_put_buffer(f, s->data_in, sizeof(s->data_in));
cuda.c:    qemu_put_buffer(f, s->data_out, sizeof(s->data_out));
cuda.c:    qemu_put_be32s(f, &s->tick_offset);
cuda.c:    cuda_save_timer(f, &s->timers[0]);
cuda.c:    cuda_save_timer(f, &s->timers[1]);
cuda.c:    qemu_get_be16s(f, &s->latch);
cuda.c:    qemu_get_be16s(f, &s->counter_value);
cuda.c:    qemu_get_sbe64s(f, &s->load_time);
cuda.c:    qemu_get_sbe64s(f, &s->next_irq_time);
cuda.c:    if (s->timer)
cuda.c:        qemu_get_timer(f, s->timer);
cuda.c:        return -EINVAL;
cuda.c:    s->b = qemu_get_ubyte(f);
cuda.c:    s->a = qemu_get_ubyte(f);
cuda.c:    s->dirb = qemu_get_ubyte(f);
cuda.c:    s->dira = qemu_get_ubyte(f);
cuda.c:    s->sr = qemu_get_ubyte(f);
cuda.c:    s->acr = qemu_get_ubyte(f);
cuda.c:    s->pcr = qemu_get_ubyte(f);
cuda.c:    s->ifr = qemu_get_ubyte(f);
cuda.c:    s->ier = qemu_get_ubyte(f);
cuda.c:    s->anh = qemu_get_ubyte(f);
cuda.c:    qemu_get_sbe32s(f, &s->data_in_size);
cuda.c:    qemu_get_sbe32s(f, &s->data_in_index);
cuda.c:    qemu_get_sbe32s(f, &s->data_out_index);
cuda.c:    s->autopoll = qemu_get_ubyte(f);
cuda.c:    qemu_get_buffer(f, s->data_in, sizeof(s->data_in));
cuda.c:    qemu_get_buffer(f, s->data_out, sizeof(s->data_out));
cuda.c:    qemu_get_be32s(f, &s->tick_offset);
cuda.c:    cuda_load_timer(f, &s->timers[0]);
cuda.c:    cuda_load_timer(f, &s->timers[1]);
cuda.c:    s->b = 0;
cuda.c:    s->a = 0;
cuda.c:    s->dirb = 0;
cuda.c:    s->dira = 0;
cuda.c:    s->sr = 0;
cuda.c:    s->acr = 0;
cuda.c:    s->pcr = 0;
cuda.c:    s->ifr = 0;
cuda.c:    s->ier = 0;
cuda.c:    //    s->ier = T1_INT | SR_INT;
cuda.c:    s->anh = 0;
cuda.c:    s->data_in_size = 0;
cuda.c:    s->data_in_index = 0;
cuda.c:    s->data_out_index = 0;
cuda.c:    s->autopoll = 0;
cuda.c:    s->timers[0].latch = 0xffff;
cuda.c:    set_counter(s, &s->timers[0], 0xffff);
cuda.c:    s->timers[1].latch = 0;
cuda.c:    set_counter(s, &s->timers[1], 0xffff);
cuda.c:    s->irq = irq;
cuda.c:    s->timers[0].index = 0;
cuda.c:    s->timers[0].timer = qemu_new_timer(vm_clock, cuda_timer1, s);
cuda.c:    s->timers[1].index = 1;
cuda.c:    s->tick_offset = (uint32_t)mktimegm(&tm) + RTC_OFFSET;
cuda.c:    s->adb_poll_timer = qemu_new_timer(vm_clock, cuda_adb_poll, s);
cuda.c:    register_savevm("cuda", -1, 1, cuda_save, cuda_load, s);
device-assignment.c: * Place - Suite 330, Boston, MA 02111-1307 USA.
device-assignment.c: *  Copyright (C) 2008, IBM, Muli Ben-Yehuda (muli@il.ibm.com)
device-assignment.c:#include "qemu-kvm.h"
device-assignment.c:#include "device-assignment.h"
device-assignment.c:    return region->u.r_baseport + (addr - region->e_physbase);
device-assignment.c:	  r_pio, (int)r_access->e_physbase,
device-assignment.c:	  (unsigned long)r_access->u.r_baseport, value);
device-assignment.c:          r_pio, (int)r_access->e_physbase,
device-assignment.c:	  (unsigned long)r_access->u.r_baseport, value);
device-assignment.c:	  r_pio, (int)r_access->e_physbase,
device-assignment.c:          (unsigned long)r_access->u.r_baseport, value);
device-assignment.c:          r_pio, (int)r_access->e_physbase,
device-assignment.c:          (unsigned long)r_access->u.r_baseport, value);
device-assignment.c:          r_pio, (int)r_access->e_physbase,
device-assignment.c:	  (unsigned long)r_access->u.r_baseport, value);
device-assignment.c:          r_pio, (int)r_access->e_physbase,
device-assignment.c:          (unsigned long)r_access->u.r_baseport, value);
device-assignment.c:    AssignedDevRegion *region = &r_dev->v_addrs[region_num];
device-assignment.c:    PCIRegion *real_region = &r_dev->real_device.regions[region_num];
device-assignment.c:    pcibus_t old_ephys = region->e_physbase;
device-assignment.c:    pcibus_t old_esize = region->e_size;
device-assignment.c:    int first_map = (region->e_size == 0);
device-assignment.c:          e_phys, region->u.r_virtbase, type, e_size, region_num);
device-assignment.c:    region->e_physbase = e_phys;
device-assignment.c:    region->e_size = e_size;
device-assignment.c:        /* deal with MSI-X MMIO page */
device-assignment.c:        if (real_region->base_addr <= r_dev->msix_table_addr &&
device-assignment.c:                real_region->base_addr + real_region->size >=
device-assignment.c:                r_dev->msix_table_addr) {
device-assignment.c:            int offset = r_dev->msix_table_addr - real_region->base_addr;
device-assignment.c:            ret = munmap(region->u.r_virtbase + offset, TARGET_PAGE_SIZE);
device-assignment.c:                        region->u.r_virtbase + offset);
device-assignment.c:                    TARGET_PAGE_SIZE, r_dev->mmio_index);
device-assignment.c:                                    region->u.r_virtbase,
device-assignment.c:    AssignedDevRegion *region = &r_dev->v_addrs[region_num];
device-assignment.c:    int first_map = (region->e_size == 0);
device-assignment.c:    region->e_physbase = addr;
device-assignment.c:    region->e_size = size;
device-assignment.c:          addr, region->u.r_baseport, type, size, region_num);
device-assignment.c:	data->start_port = region->u.r_baseport;
device-assignment.c:	data->num = region->r_size;
device-assignment.c:	data->turn_on = 1;
device-assignment.c:	for (env = first_cpu; env; env = env->next_cpu)
device-assignment.c:                         (r_dev->v_addrs + region_num));
device-assignment.c:                         (r_dev->v_addrs + region_num));
device-assignment.c:                         (r_dev->v_addrs + region_num));
device-assignment.c:                          (r_dev->v_addrs + region_num));
device-assignment.c:                          (r_dev->v_addrs + region_num));
device-assignment.c:                          (r_dev->v_addrs + region_num));
device-assignment.c:    while (max_cap--) {
device-assignment.c:          ((d->devfn >> 3) & 0x1F), (d->devfn & 0x7),
device-assignment.c:        /* used for update-mappings (BAR emulation) */
device-assignment.c:          ((d->devfn >> 3) & 0x1F), (d->devfn & 0x7),
device-assignment.c:    fd = pci_dev->real_device.config_fd;
device-assignment.c:    if (address < 0x4 || (pci_dev->need_emulate_cmd && address == 0x4) ||
device-assignment.c:              (d->devfn >> 3) & 0x1F, (d->devfn & 0x7), address, val, len);
device-assignment.c:    fd = pci_dev->real_device.config_fd;
device-assignment.c:          (d->devfn >> 3) & 0x1F, (d->devfn & 0x7), address, val, len);
device-assignment.c:    if (!pci_dev->cap.available) {
device-assignment.c:        if (!cur_region->valid)
device-assignment.c:        pci_dev->v_addrs[i].num = i;
device-assignment.c:        if (cur_region->type & IORESOURCE_MEM) {
device-assignment.c:            int t = cur_region->type & IORESOURCE_PREFETCH
device-assignment.c:            if (cur_region->size & 0xFFF) {
device-assignment.c:                        i, (unsigned long long)cur_region->base_addr,
device-assignment.c:                        cur_region->size);
device-assignment.c:                return -1;
device-assignment.c:            pci_dev->v_addrs[i].e_physbase = cur_region->base_addr;
device-assignment.c:                pci_dev->v_addrs[i].u.r_virtbase =
device-assignment.c:                         (cur_region->size + 0xFFF) & 0xFFFFF000,
device-assignment.c:                pci_dev->v_addrs[i].u.r_virtbase =
device-assignment.c:                         (cur_region->size + 0xFFF) & 0xFFFFF000,
device-assignment.c:                         cur_region->resource_fd, (off_t) 0);
device-assignment.c:            if (pci_dev->v_addrs[i].u.r_virtbase == MAP_FAILED) {
device-assignment.c:                pci_dev->v_addrs[i].u.r_virtbase = NULL;
device-assignment.c:                        (uint32_t) (cur_region->base_addr));
device-assignment.c:                return -1;
device-assignment.c:                memset(pci_dev->v_addrs[i].u.r_virtbase, 0,
device-assignment.c:                       (cur_region->size + 0xFFF) & 0xFFFFF000);
device-assignment.c:                mprotect(pci_dev->v_addrs[PCI_ROM_SLOT].u.r_virtbase,
device-assignment.c:                         (cur_region->size + 0xFFF) & 0xFFFFF000, PROT_READ);
device-assignment.c:            pci_dev->v_addrs[i].r_size = cur_region->size;
device-assignment.c:            pci_dev->v_addrs[i].e_size = 0;
device-assignment.c:            pci_dev->v_addrs[i].u.r_virtbase +=
device-assignment.c:                (cur_region->base_addr & 0xFFF);
device-assignment.c:                             cur_region->size, t,
device-assignment.c:        pci_dev->v_addrs[i].e_physbase = cur_region->base_addr;
device-assignment.c:        pci_dev->v_addrs[i].u.r_baseport = cur_region->base_addr;
device-assignment.c:        pci_dev->v_addrs[i].r_size = cur_region->size;
device-assignment.c:        pci_dev->v_addrs[i].e_size = 0;
device-assignment.c:                         cur_region->size, PCI_BASE_ADDRESS_SPACE_IO,
device-assignment.c:        pci_dev->v_addrs[i].memory_index = 0;
device-assignment.c:    PCIDevRegions *dev = &pci_dev->real_device;
device-assignment.c:    dev->region_number = 0;
device-assignment.c:    if (fd == -1) {
device-assignment.c:    dev->config_fd = fd;
device-assignment.c:    r = read(fd, pci_dev->dev.config, pci_config_size(&pci_dev->dev));
device-assignment.c:        rp = dev->regions + r;
device-assignment.c:        rp->valid = 0;
device-assignment.c:        size = end - start + 1;
device-assignment.c:                if (fd == -1)
device-assignment.c:                rp->resource_fd = fd;
device-assignment.c:        rp->type = flags;
device-assignment.c:        rp->valid = 1;
device-assignment.c:        rp->base_addr = start;
device-assignment.c:        rp->size = size;
device-assignment.c:              r, rp->size, start, rp->type, rp->resource_fd);
device-assignment.c:	pci_dev->dev.config[0] = id & 0xff;
device-assignment.c:	pci_dev->dev.config[1] = (id & 0xff00) >> 8;
device-assignment.c:	pci_dev->dev.config[2] = id & 0xff;
device-assignment.c:	pci_dev->dev.config[3] = (id & 0xff00) >> 8;
device-assignment.c:	    pci_dev->need_emulate_cmd = 1;
device-assignment.c:	    pci_dev->need_emulate_cmd = 0;
device-assignment.c:    dev->region_number = r;
device-assignment.c:    for (i = 0; i < dev->irq_entries_nr; i++)
device-assignment.c:        kvm_del_routing_entry(kvm_context, &dev->entry[i]);
device-assignment.c:    free(dev->entry);
device-assignment.c:    dev->entry = NULL;
device-assignment.c:    dev->irq_entries_nr = 0;
device-assignment.c:        for (i = 0; i < dev->real_device.region_number; i++) {
device-assignment.c:            PCIRegion *pci_region = &dev->real_device.regions[i];
device-assignment.c:            AssignedDevRegion *region = &dev->v_addrs[i];
device-assignment.c:            if (!pci_region->valid)
device-assignment.c:            if (pci_region->type & IORESOURCE_IO) {
device-assignment.c:                kvm_remove_ioperm_data(region->u.r_baseport, region->r_size);
device-assignment.c:            } else if (pci_region->type & IORESOURCE_MEM) {
device-assignment.c:                if (region->e_size > 0)
device-assignment.c:                    kvm_destroy_phys_mem(kvm_context, region->e_physbase,
device-assignment.c:                                         TARGET_PAGE_ALIGN(region->e_size));
device-assignment.c:                if (region->u.r_virtbase) {
device-assignment.c:                    int ret = munmap(region->u.r_virtbase,
device-assignment.c:                                     (pci_region->size + 0xFFF) & 0xFFFFF000);
device-assignment.c:        if (dev->real_device.config_fd) {
device-assignment.c:            close(dev->real_device.config_fd);
device-assignment.c:            dev->real_device.config_fd = 0;
device-assignment.c:	calc_assigned_dev_id(dev->h_busnr, dev->h_devfn);
device-assignment.c:    assigned_dev_data.busnr = dev->h_busnr;
device-assignment.c:    assigned_dev_data.devfn = dev->h_devfn;
device-assignment.c:    if (dev->use_iommu) {
device-assignment.c:                    dev->dev.qdev.id);
device-assignment.c:            return -ENODEV;
device-assignment.c:    dev->use_iommu = 0;
device-assignment.c:                dev->dev.qdev.id, strerror(-r));
device-assignment.c:    if (pci_read_byte(dev->pdev, PCI_INTERRUPT_PIN) == 0)
device-assignment.c:    irq = pci_map_irq(&dev->dev, dev->intpin);
device-assignment.c:    irq = ipf_map_irq(&dev->dev, irq);
device-assignment.c:    if (dev->girq == irq)
device-assignment.c:        calc_assigned_dev_id(dev->h_busnr, dev->h_devfn);
device-assignment.c:    assigned_irq_data.host_irq = dev->real_device.irq;
device-assignment.c:    if (dev->irq_requested_type) {
device-assignment.c:        assigned_irq_data.flags = dev->irq_requested_type;
device-assignment.c:        /* -ENXIO means no assigned irq */
device-assignment.c:        if (r && r != -ENXIO)
device-assignment.c:    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSI)
device-assignment.c:                dev->dev.qdev.id, strerror(-r));
device-assignment.c:    dev->girq = irq;
device-assignment.c:    dev->irq_requested_type = assigned_irq_data.flags;
device-assignment.c:	calc_assigned_dev_id(dev->h_busnr, dev->h_devfn);
device-assignment.c:                dev->dev.qdev.id, strerror(-r));
device-assignment.c:        assigned_dev = adev->assigned_dev;
device-assignment.c:        if (pci_bus_num(assigned_dev->dev.bus) == pcibus &&
device-assignment.c:            PCI_SLOT(assigned_dev->dev.devfn) == slot)
device-assignment.c:            qdev_unplug(&dev->dev.qdev);
device-assignment.c:    uint8_t ctrl_byte = pci_dev->config[ctrl_pos];
device-assignment.c:        calc_assigned_dev_id(assigned_dev->h_busnr,
device-assignment.c:                (uint8_t)assigned_dev->h_devfn);
device-assignment.c:    if (assigned_dev->irq_requested_type) {
device-assignment.c:	    assigned_irq_data.flags = assigned_dev->irq_requested_type;
device-assignment.c:	    /* -ENXIO means no assigned irq */
device-assignment.c:	    if (r && r != -ENXIO)
device-assignment.c:        assigned_dev->entry = calloc(1, sizeof(struct kvm_irq_routing_entry));
device-assignment.c:        if (!assigned_dev->entry) {
device-assignment.c:        assigned_dev->entry->u.msi.address_lo =
device-assignment.c:                *(uint32_t *)(pci_dev->config + pci_dev->cap.start +
device-assignment.c:        assigned_dev->entry->u.msi.address_hi = 0;
device-assignment.c:        assigned_dev->entry->u.msi.data = *(uint16_t *)(pci_dev->config +
device-assignment.c:                pci_dev->cap.start + PCI_MSI_DATA_32);
device-assignment.c:        assigned_dev->entry->type = KVM_IRQ_ROUTING_MSI;
device-assignment.c:        assigned_dev->entry->gsi = r;
device-assignment.c:        kvm_add_routing_entry(kvm_context, assigned_dev->entry);
device-assignment.c:            assigned_dev->cap.state &= ~ASSIGNED_DEVICE_MSI_ENABLED;
device-assignment.c:	assigned_dev->irq_entries_nr = 1;
device-assignment.c:        assigned_irq_data.guest_irq = assigned_dev->entry->gsi;
device-assignment.c:        assigned_dev->irq_requested_type = assigned_irq_data.flags;
device-assignment.c:    void *va = adev->msix_table_page;
device-assignment.c:    if (adev->cap.available & ASSIGNED_DEVICE_CAP_MSI)
device-assignment.c:        pos = pci_dev->cap.start + PCI_CAPABILITY_CONFIG_MSI_LENGTH;
device-assignment.c:        pos = pci_dev->cap.start;
device-assignment.c:    entries_max_nr = pci_dev->config[pos + 2];
device-assignment.c:        fprintf(stderr, "MSI-X entry number is zero!\n");
device-assignment.c:        return -EINVAL;
device-assignment.c:    msix_nr.assigned_dev_id = calc_assigned_dev_id(adev->h_busnr,
device-assignment.c:                                          (uint8_t)adev->h_devfn);
device-assignment.c:        fprintf(stderr, "fail to set MSI-X entry number for MSIX! %s\n",
device-assignment.c:			strerror(-r));
device-assignment.c:    adev->irq_entries_nr = entries_nr;
device-assignment.c:    adev->entry = calloc(entries_nr, sizeof(struct kvm_irq_routing_entry));
device-assignment.c:    if (!adev->entry) {
device-assignment.c:        return -errno;
device-assignment.c:        adev->entry[entries_nr].gsi = r;
device-assignment.c:        adev->entry[entries_nr].type = KVM_IRQ_ROUTING_MSI;
device-assignment.c:        adev->entry[entries_nr].flags = 0;
device-assignment.c:        adev->entry[entries_nr].u.msi.address_lo = msg_addr;
device-assignment.c:        adev->entry[entries_nr].u.msi.address_hi = msg_upper_addr;
device-assignment.c:        adev->entry[entries_nr].u.msi.data = msg_data;
device-assignment.c:        DEBUG("MSI-X data 0x%x, MSI-X addr_lo 0x%x\n!", msg_data, msg_addr);
device-assignment.c:	kvm_add_routing_entry(kvm_context, &adev->entry[entries_nr]);
device-assignment.c:        msix_entry.gsi = adev->entry[entries_nr].gsi;
device-assignment.c:            fprintf(stderr, "fail to set MSI-X entry! %s\n", strerror(-r));
device-assignment.c:        DEBUG("MSI-X entry gsi 0x%x, entry %d\n!",
device-assignment.c:	    return -EINVAL;
device-assignment.c:    uint16_t *ctrl_word = (uint16_t *)(pci_dev->config + ctrl_pos);
device-assignment.c:            calc_assigned_dev_id(assigned_dev->h_busnr,
device-assignment.c:                    (uint8_t)assigned_dev->h_devfn);
device-assignment.c:    if (assigned_dev->irq_requested_type) {
device-assignment.c:        assigned_irq_data.flags = assigned_dev->irq_requested_type;
device-assignment.c:        /* -ENXIO means no assigned irq */
device-assignment.c:        if (r && r != -ENXIO)
device-assignment.c:        assigned_dev->irq_requested_type = assigned_irq_data.flags;
device-assignment.c:    unsigned int pos = pci_dev->cap.start, ctrl_pos;
device-assignment.c:    if (assigned_dev->cap.available & ASSIGNED_DEVICE_CAP_MSI) {
device-assignment.c:    if (assigned_dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {
device-assignment.c:            ctrl_pos--; /* control is word long */
device-assignment.c:    PCIRegion *pci_region = dev->real_device.regions;
device-assignment.c:    pci_dev->cap.length = 0;
device-assignment.c:    if (pci_find_cap_offset(dev->pdev, PCI_CAP_ID_MSI)) {
device-assignment.c:        dev->cap.available |= ASSIGNED_DEVICE_CAP_MSI;
device-assignment.c:        memset(&pci_dev->config[pci_dev->cap.start + pci_dev->cap.length],
device-assignment.c:        pci_dev->config[pci_dev->cap.start + pci_dev->cap.length] =
device-assignment.c:        pci_dev->cap.length += PCI_CAPABILITY_CONFIG_MSI_LENGTH;
device-assignment.c:    /* Expose MSI-X capability */
device-assignment.c:    if (pci_find_cap_offset(dev->pdev, PCI_CAP_ID_MSIX)) {
device-assignment.c:        dev->cap.available |= ASSIGNED_DEVICE_CAP_MSIX;
device-assignment.c:        memset(&pci_dev->config[pci_dev->cap.start + pci_dev->cap.length],
device-assignment.c:        pos = pci_find_cap_offset(dev->pdev, PCI_CAP_ID_MSIX);
device-assignment.c:        entry_nr = pci_read_word(dev->pdev, pos + 2) & PCI_MSIX_TABSIZE;
device-assignment.c:        pci_dev->config[pci_dev->cap.start + pci_dev->cap.length] = 0x11;
device-assignment.c:        pci_dev->config[pci_dev->cap.start +
device-assignment.c:                        pci_dev->cap.length + 2] = entry_nr;
device-assignment.c:        msix_table_entry = pci_read_long(dev->pdev, pos + PCI_MSIX_TABLE);
device-assignment.c:        *(uint32_t *)(pci_dev->config + pci_dev->cap.start +
device-assignment.c:                      pci_dev->cap.length + PCI_MSIX_TABLE) = msix_table_entry;
device-assignment.c:        *(uint32_t *)(pci_dev->config + pci_dev->cap.start +
device-assignment.c:                      pci_dev->cap.length + PCI_MSIX_PBA) =
device-assignment.c:                    pci_read_long(dev->pdev, pos + PCI_MSIX_PBA);
device-assignment.c:        dev->msix_table_addr = pci_region[bar_nr].base_addr + msix_table_entry;
device-assignment.c:            pci_dev->config[pci_dev->cap.start + next_cap_pt] =
device-assignment.c:                pci_dev->cap.start + pci_dev->cap.length;
device-assignment.c:        pci_dev->cap.length += PCI_CAPABILITY_CONFIG_MSIX_LENGTH;
device-assignment.c:    void *page = adev->msix_table_page;
device-assignment.c:    void *page = adev->msix_table_page;
device-assignment.c:    DEBUG("write to MSI-X entry table mmio offset 0x%lx, val 0x%lx\n",
device-assignment.c:    dev->msix_table_page = mmap(NULL, 0x1000,
device-assignment.c:    if (dev->msix_table_page == MAP_FAILED) {
device-assignment.c:        return -EFAULT;
device-assignment.c:    memset(dev->msix_table_page, 0, 0x1000);
device-assignment.c:    dev->mmio_index = cpu_register_io_memory(
device-assignment.c:    if (!dev->host.bus && !dev->host.dev && !dev->host.func) {
device-assignment.c:        qemu_error("pci-assign: error: no host device specified\n");
device-assignment.c:    if (get_real_device(dev, dev->host.bus, dev->host.dev, dev->host.func)) {
device-assignment.c:        qemu_error("pci-assign: Error: Couldn't get real device (%s)!\n",
device-assignment.c:                   dev->dev.qdev.id);
device-assignment.c:    if (assigned_dev_register_regions(dev->real_device.regions,
device-assignment.c:                                      dev->real_device.region_number,
device-assignment.c:    e_device = (dev->dev.devfn >> 3) & 0x1f;
device-assignment.c:    e_intx = dev->dev.config[0x3d] - 1;
device-assignment.c:    dev->intpin = e_intx;
device-assignment.c:    dev->run = 0;
device-assignment.c:    dev->girq = 0;
device-assignment.c:    dev->h_busnr = dev->host.bus;
device-assignment.c:    dev->h_devfn = PCI_DEVFN(dev->host.dev, dev->host.func);
device-assignment.c:    dev->pdev = pci_get_dev(pacc, 0, dev->host.bus, dev->host.dev, dev->host.func);
device-assignment.c:    /* intercept MSI-X entry page in the MMIO */
device-assignment.c:    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX)
device-assignment.c:    return -1;
device-assignment.c:    rc = pci_parse_host_devaddr(str, &ptr->bus, &ptr->dev, &ptr->func);
device-assignment.c:        return -1;
device-assignment.c:    return snprintf(dest, len, "%02x:%02x.%x", ptr->bus, ptr->dev, ptr->func);
device-assignment.c:    .name  = "pci-hostaddr",
device-assignment.c:    .type  = -1,
device-assignment.c:    .qdev.name    = "pci-assign",
device-assignment.c: * -pcidevice host=bus:dev.func[,dma=none][,name=Foo]
device-assignment.c: * -pcidevice host=00:13.0,dma=pvdma
device-assignment.c:    qemu_opt_set(opts, "driver", "pci-assign");
device-assignment.c:        if (strncmp((char *)rom->signature, "\x55\xaa", 2) ||
device-assignment.c:             (rom->rom_size == 0))
device-assignment.c:        size = rom->rom_size * 512;
device-assignment.c:                ((char *)rom + rom->pci_header_offset);
device-assignment.c:        if ((rom->pci_header_offset != 0) &&
device-assignment.c:             !strncmp((char *)pcih->signature, "PCIR", 4))
device-assignment.c:             dev->host.bus, dev->host.dev, dev->host.func);
device-assignment.c:    if (dev->v_addrs[PCI_ROM_SLOT].r_size >= size &&
device-assignment.c:        dev->v_addrs[PCI_ROM_SLOT].u.r_virtbase) {
device-assignment.c:        mprotect(dev->v_addrs[PCI_ROM_SLOT].u.r_virtbase,
device-assignment.c:        memcpy(dev->v_addrs[PCI_ROM_SLOT].u.r_virtbase,
device-assignment.c:        mprotect(dev->v_addrs[PCI_ROM_SLOT].u.r_virtbase,
device-assignment.c:    if (!dev->dev.qdev.hotplugged) {
device-assignment.c:        scan_option_rom(dev->dev.qdev.id, dev->dev.devfn, buf);
device-assignment.h: * Place - Suite 330, Boston, MA 02111-1307 USA.
device-assignment.h:#include "qemu-common.h"
device-assignment.h:#include "qemu-queue.h"
devices.h:/* usb-ohci.c */
dma.c: * Copyright (c) 2003-2004 Vassili Karpov (malc)
dma.c:static int channels[8] = {-1, 2, 3, 1, -1, -1, -1, 0};
dma.c:    if (-1 == ichan) {
dma.c:    d->regs[ichan].page = data;
dma.c:    if (-1 == ichan) {
dma.c:    d->regs[ichan].pageh = data;
dma.c:    if (-1 == ichan) {
dma.c:    return d->regs[ichan].page;
dma.c:    if (-1 == ichan) {
dma.c:    return d->regs[ichan].pageh;
dma.c:    r = d->regs + ichan;
dma.c:    r->now[ADDR] = r->base[ADDR] << d->dshift;
dma.c:    r->now[COUNT] = 0;
dma.c:    ff = d->flip_flop;
dma.c:    d->flip_flop = !ff;
dma.c:    iport = (nport >> d->dshift) & 0x0f;
dma.c:    r = d->regs + ichan;
dma.c:    dir = ((r->mode >> 5) & 1) ? -1 : 1;
dma.c:        val = (r->base[COUNT] << d->dshift) - r->now[COUNT];
dma.c:        val = r->now[ADDR] + r->now[COUNT] * dir;
dma.c:    ldebug ("read_chan %#x -> %d\n", iport, val);
dma.c:    return (val >> (d->dshift + (ff << 3))) & 0xff;
dma.c:    iport = (nport >> d->dshift) & 0x0f;
dma.c:    r = d->regs + ichan;
dma.c:        r->base[nreg] = (r->base[nreg] & 0xff) | ((data << 8) & 0xff00);
dma.c:        r->base[nreg] = (r->base[nreg] & 0xff00) | (data & 0xff);
dma.c:    iport = (nport >> d->dshift) & 0x0f;
dma.c:        d->command = data;
dma.c:            d->status |= 1 << (ichan + 4);
dma.c:            d->status &= ~(1 << (ichan + 4));
dma.c:        d->status &= ~(1 << ichan);
dma.c:            d->mask |= 1 << (data & 3);
dma.c:            d->mask &= ~(1 << (data & 3));
dma.c:            d->regs[ichan].mode = data;
dma.c:        d->flip_flop = 0;
dma.c:        d->flip_flop = 0;
dma.c:        d->mask = ~0;
dma.c:        d->status = 0;
dma.c:        d->command = 0;
dma.c:        d->mask = 0;
dma.c:        d->mask = data;
dma.c:    iport = (nport >> d->dshift) & 0x0f;
dma.c:        val = d->status;
dma.c:        d->status &= 0xf0;
dma.c:        val = d->mask;
dma.c:    dir = (r->mode >> 5) & 1;
dma.c:    opmode = (r->mode >> 6) & 3;
dma.c:    n = r->transfer_handler (r->opaque, ichan + (ncont << 2),
dma.c:                             r->now[COUNT], (r->base[COUNT] + 1) << ncont);
dma.c:    r->now[COUNT] = n;
dma.c:    ldebug ("dma_pos %d size %d\n", n, (r->base[COUNT] + 1) << ncont);
dma.c:            if ((0 == (d->mask & mask)) && (0 != (d->status & (mask << 4)))) {
dma.c:    r->transfer_handler = transfer_handler;
dma.c:    r->opaque = opaque;
dma.c:    target_phys_addr_t addr = ((r->pageh & 0x7f) << 24) | (r->page << 16) | r->now[ADDR];
dma.c:    if (r->mode & 0x20) {
dma.c:        cpu_physical_memory_read (addr - pos - len, buf, len);
dma.c:            uint8_t b = p[len - i - 1];
dma.c:    target_phys_addr_t addr = ((r->pageh & 0x7f) << 24) | (r->page << 16) | r->now[ADDR];
dma.c:    if (r->mode & 0x20) {
dma.c:        cpu_physical_memory_write (addr - pos - len, buf, len);
dma.c:            uint8_t b = p[len - i - 1];
dma.c:    write_cont (d, (0x0d << d->dshift), 0);
dma.c:    d->dshift = dshift;
dma.c:    for (i = 0; i < ARRAY_SIZE (d->regs); ++i) {
dma.c:        d->regs[i].transfer_handler = dma_phony_handler;
dma.c:              high_page_enable ? 0x480 : -1);
dma.c:              high_page_enable ? 0x488 : -1);
dp8393x.c: * Copyright (c) 2008-2009 Herve Poussineau
dp8393x.c:#include "qemu-timer.h"
dp8393x.c:    int level = (s->regs[SONIC_IMR] & s->regs[SONIC_ISR]) ? 1 : 0;
dp8393x.c:    if (level != s->irq_level) {
dp8393x.c:        s->irq_level = level;
dp8393x.c:            DPRINTF("raise irq, isr is 0x%04x\n", s->regs[SONIC_ISR]);
dp8393x.c:    qemu_set_irq(s->irq, level);
dp8393x.c:    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;
dp8393x.c:    while (s->regs[SONIC_CDC] & 0x1f) {
dp8393x.c:        s->memory_rw(s->mem_opaque,
dp8393x.c:            (s->regs[SONIC_URRA] << 16) | s->regs[SONIC_CDP],
dp8393x.c:        s->cam[index][0] = data[1 * width] & 0xff;
dp8393x.c:        s->cam[index][1] = data[1 * width] >> 8;
dp8393x.c:        s->cam[index][2] = data[2 * width] & 0xff;
dp8393x.c:        s->cam[index][3] = data[2 * width] >> 8;
dp8393x.c:        s->cam[index][4] = data[3 * width] & 0xff;
dp8393x.c:        s->cam[index][5] = data[3 * width] >> 8;
dp8393x.c:            s->cam[index][0], s->cam[index][1], s->cam[index][2],
dp8393x.c:            s->cam[index][3], s->cam[index][4], s->cam[index][5]);
dp8393x.c:        s->regs[SONIC_CDC]--;
dp8393x.c:        s->regs[SONIC_CDP] += size;
dp8393x.c:    s->memory_rw(s->mem_opaque,
dp8393x.c:        (s->regs[SONIC_URRA] << 16) | s->regs[SONIC_CDP],
dp8393x.c:    s->regs[SONIC_CE] = data[0 * width];
dp8393x.c:    DPRINTF("load cam done. cam enable mask 0x%04x\n", s->regs[SONIC_CE]);
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_LCAM;
dp8393x.c:    s->regs[SONIC_ISR] |= SONIC_ISR_LCD;
dp8393x.c:    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;
dp8393x.c:    s->memory_rw(s->mem_opaque,
dp8393x.c:        (s->regs[SONIC_URRA] << 16) | s->regs[SONIC_RRP],
dp8393x.c:    s->regs[SONIC_CRBA0] = data[0 * width];
dp8393x.c:    s->regs[SONIC_CRBA1] = data[1 * width];
dp8393x.c:    s->regs[SONIC_RBWC0] = data[2 * width];
dp8393x.c:    s->regs[SONIC_RBWC1] = data[3 * width];
dp8393x.c:        s->regs[SONIC_CRBA0], s->regs[SONIC_CRBA1],
dp8393x.c:        s->regs[SONIC_RBWC0], s->regs[SONIC_RBWC1]);
dp8393x.c:    s->regs[SONIC_RRP] += size;
dp8393x.c:    if (s->regs[SONIC_RRP] == s->regs[SONIC_REA]) {
dp8393x.c:        s->regs[SONIC_RRP] = s->regs[SONIC_RSA];
dp8393x.c:    if (s->regs[SONIC_RRP] == s->regs[SONIC_RWP])
dp8393x.c:        s->regs[SONIC_ISR] |= SONIC_ISR_RBE;
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_RRRA;
dp8393x.c:    qemu_del_timer(s->watchdog);
dp8393x.c:    s->regs[SONIC_CR] &= ~(SONIC_CR_LCAM | SONIC_CR_RRRA | SONIC_CR_TXP | SONIC_CR_HTX);
dp8393x.c:    s->regs[SONIC_CR] |= SONIC_CR_RST | SONIC_CR_RXDIS;
dp8393x.c:    if (s->regs[SONIC_CR] & SONIC_CR_STP) {
dp8393x.c:        qemu_del_timer(s->watchdog);
dp8393x.c:    ticks = s->regs[SONIC_WT1] << 16 | s->regs[SONIC_WT0];
dp8393x.c:    s->wt_last_update = qemu_get_clock(vm_clock);
dp8393x.c:    qemu_mod_timer(s->watchdog, s->wt_last_update + delay);
dp8393x.c:    if (s->regs[SONIC_CR] & SONIC_CR_STP) {
dp8393x.c:        qemu_del_timer(s->watchdog);
dp8393x.c:    elapsed = s->wt_last_update - qemu_get_clock(vm_clock);
dp8393x.c:    val = s->regs[SONIC_WT1] << 16 | s->regs[SONIC_WT0];
dp8393x.c:    val -= elapsed / 5000000;
dp8393x.c:    s->regs[SONIC_WT1] = (val >> 16) & 0xffff;
dp8393x.c:    s->regs[SONIC_WT0] = (val >> 0)  & 0xffff;
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_STP;
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_ST;
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_RXDIS;
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_RXEN;
dp8393x.c:    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;
dp8393x.c:                (s->regs[SONIC_UTDA] << 16) | s->regs[SONIC_CTDA]);
dp8393x.c:        s->regs[SONIC_TTDA] = s->regs[SONIC_CTDA];
dp8393x.c:        s->memory_rw(s->mem_opaque,
dp8393x.c:            ((s->regs[SONIC_UTDA] << 16) | s->regs[SONIC_TTDA]) + sizeof(uint16_t) * width,
dp8393x.c:        s->regs[SONIC_TCR] = data[0 * width] & 0xf000;
dp8393x.c:        s->regs[SONIC_TPS] = data[1 * width];
dp8393x.c:        s->regs[SONIC_TFC] = data[2 * width];
dp8393x.c:        s->regs[SONIC_TSA0] = data[3 * width];
dp8393x.c:        s->regs[SONIC_TSA1] = data[4 * width];
dp8393x.c:        s->regs[SONIC_TFS] = data[5 * width];
dp8393x.c:        if (s->regs[SONIC_TCR] & SONIC_TCR_PINT) {
dp8393x.c:            s->regs[SONIC_ISR] |= SONIC_ISR_PINT;
dp8393x.c:            s->regs[SONIC_ISR] &= ~SONIC_ISR_PINT;
dp8393x.c:        for (i = 0; i < s->regs[SONIC_TFC]; ) {
dp8393x.c:            len = s->regs[SONIC_TFS];
dp8393x.c:            if (tx_len + len > sizeof(s->tx_buffer)) {
dp8393x.c:                len = sizeof(s->tx_buffer) - tx_len;
dp8393x.c:            s->memory_rw(s->mem_opaque,
dp8393x.c:                (s->regs[SONIC_TSA1] << 16) | s->regs[SONIC_TSA0],
dp8393x.c:                &s->tx_buffer[tx_len], len, 0);
dp8393x.c:            if (i != s->regs[SONIC_TFC]) {
dp8393x.c:                s->memory_rw(s->mem_opaque,
dp8393x.c:                    ((s->regs[SONIC_UTDA] << 16) | s->regs[SONIC_TTDA]) + sizeof(uint16_t) * (4 + 3 * i) * width,
dp8393x.c:                s->regs[SONIC_TSA0] = data[0 * width];
dp8393x.c:                s->regs[SONIC_TSA1] = data[1 * width];
dp8393x.c:                s->regs[SONIC_TFS] = data[2 * width];
dp8393x.c:        if (!(s->regs[SONIC_TCR] & SONIC_TCR_CRCI)) {
dp8393x.c:            tx_len -= 4;
dp8393x.c:        if (s->regs[SONIC_RCR] & (SONIC_RCR_LB1 | SONIC_RCR_LB0)) {
dp8393x.c:            s->regs[SONIC_TCR] |= SONIC_TCR_CRSL;
dp8393x.c:            if (s->nic->nc.info->can_receive(&s->nic->nc)) {
dp8393x.c:                s->loopback_packet = 1;
dp8393x.c:                s->nic->nc.info->receive(&s->nic->nc, s->tx_buffer, tx_len);
dp8393x.c:            qemu_send_packet(&s->nic->nc, s->tx_buffer, tx_len);
dp8393x.c:        s->regs[SONIC_TCR] |= SONIC_TCR_PTX;
dp8393x.c:        data[0 * width] = s->regs[SONIC_TCR] & 0x0fff; /* status */
dp8393x.c:        s->memory_rw(s->mem_opaque,
dp8393x.c:            (s->regs[SONIC_UTDA] << 16) | s->regs[SONIC_TTDA],
dp8393x.c:        if (!(s->regs[SONIC_CR] & SONIC_CR_HTX)) {
dp8393x.c:            s->memory_rw(s->mem_opaque,
dp8393x.c:                ((s->regs[SONIC_UTDA] << 16) | s->regs[SONIC_TTDA]) + sizeof(uint16_t) * (4 + 3 * s->regs[SONIC_TFC]) * width,
dp8393x.c:            s->regs[SONIC_CTDA] = data[0 * width] & ~0x1;
dp8393x.c:    s->regs[SONIC_CR] &= ~SONIC_CR_TXP;
dp8393x.c:    s->regs[SONIC_ISR] |= SONIC_ISR_TXDN;
dp8393x.c:    if ((s->regs[SONIC_CR] & SONIC_CR_RST) && !(command & SONIC_CR_RST)) {
dp8393x.c:        s->regs[SONIC_CR] &= ~SONIC_CR_RST;
dp8393x.c:    s->regs[SONIC_CR] |= (command & SONIC_CR_MASK);
dp8393x.c:            val = s->regs[reg];
dp8393x.c:            if (s->regs[SONIC_CR] & SONIC_CR_RST) {
dp8393x.c:                val = s->cam[s->regs[SONIC_CEP] & 0xf][2* (SONIC_CAP0 - reg) + 1] << 8;
dp8393x.c:                val |= s->cam[s->regs[SONIC_CEP] & 0xf][2* (SONIC_CAP0 - reg)];
dp8393x.c:            val = s->regs[reg];
dp8393x.c:        /* Prevent write to read-only registers */
dp8393x.c:            if (s->regs[SONIC_CR] & SONIC_CR_RST) {
dp8393x.c:                s->regs[reg] = val & 0xbfff;
dp8393x.c:            if (s->regs[SONIC_CR] & SONIC_CR_RST) {
dp8393x.c:                s->regs[reg] = val & 0xf017;
dp8393x.c:            s->regs[reg] = val & 0xf000;
dp8393x.c:            s->regs[reg] = val & 0xffe0;
dp8393x.c:            s->regs[reg] = val & 0x7fff;
dp8393x.c:            val &= s->regs[reg];
dp8393x.c:            s->regs[reg] &= ~val;
dp8393x.c:            s->regs[reg] = val & 0xfffe;
dp8393x.c:            s->regs[reg] = val ^ 0xffff;
dp8393x.c:            s->regs[reg] = val;
dp8393x.c:    if (s->regs[SONIC_CR] & SONIC_CR_STP) {
dp8393x.c:    s->regs[SONIC_WT1] = 0xffff;
dp8393x.c:    s->regs[SONIC_WT0] = 0xffff;
dp8393x.c:    s->regs[SONIC_ISR] |= SONIC_ISR_TC;
dp8393x.c:    if ((addr & ((1 << s->it_shift) - 1)) != 0) {
dp8393x.c:    reg = addr >> s->it_shift;
dp8393x.c:    if ((addr & ((1 << s->it_shift) - 1)) != 0) {
dp8393x.c:    reg = addr >> s->it_shift;
dp8393x.c:    dp8393xState *s = DO_UPCAST(NICState, nc, nc)->opaque;
dp8393x.c:    if (!(s->regs[SONIC_CR] & SONIC_CR_RXEN))
dp8393x.c:    if (s->regs[SONIC_ISR] & SONIC_ISR_RBE)
dp8393x.c:    if (size < 64 - 4) {
dp8393x.c:        return (s->regs[SONIC_RCR] & SONIC_RCR_RNT) ? 0 : -1;
dp8393x.c:    if ((s->regs[SONIC_RCR] & SONIC_RCR_PRO) && (buf[0] & 1) == 0) {
dp8393x.c:    if ((s->regs[SONIC_RCR] & SONIC_RCR_AMC) && (buf[0] & 1) == 1) {
dp8393x.c:    if ((s->regs[SONIC_RCR] & SONIC_RCR_BRD) && !memcmp(buf, bcast, sizeof(bcast))) {
dp8393x.c:        if (s->regs[SONIC_CE] & (1 << i)) {
dp8393x.c:             if (!memcmp(buf, s->cam[i], sizeof(s->cam[i]))) {
dp8393x.c:    return -1;
dp8393x.c:    dp8393xState *s = DO_UPCAST(NICState, nc, nc)->opaque;
dp8393x.c:    width = (s->regs[SONIC_DCR] & SONIC_DCR_DW) ? 2 : 1;
dp8393x.c:    s->regs[SONIC_RCR] &= ~(SONIC_RCR_PRX | SONIC_RCR_LBK | SONIC_RCR_FAER |
dp8393x.c:        return -1;
dp8393x.c:    if (s->regs[SONIC_LLFA] & 0x1) {
dp8393x.c:        address = ((s->regs[SONIC_URDA] << 16) | s->regs[SONIC_CRDA]) + sizeof(uint16_t) * 5 * width;
dp8393x.c:        s->memory_rw(s->mem_opaque, address, (uint8_t*)data, size, 0);
dp8393x.c:            return -1;
dp8393x.c:            s->regs[SONIC_CRDA] = s->regs[SONIC_LLFA];
dp8393x.c:    s->regs[SONIC_TRBA1] = s->regs[SONIC_CRBA1];
dp8393x.c:    s->regs[SONIC_TRBA0] = s->regs[SONIC_CRBA0];
dp8393x.c:    DPRINTF("Receive packet at %08x\n", (s->regs[SONIC_CRBA1] << 16) | s->regs[SONIC_CRBA0]);
dp8393x.c:    address = (s->regs[SONIC_CRBA1] << 16) | s->regs[SONIC_CRBA0];
dp8393x.c:    s->memory_rw(s->mem_opaque, address, (uint8_t*)buf, rx_len, 1);
dp8393x.c:    s->memory_rw(s->mem_opaque, address, (uint8_t*)&checksum, 4, 1);
dp8393x.c:    s->regs[SONIC_CRBA1] = address >> 16;
dp8393x.c:    s->regs[SONIC_CRBA0] = address & 0xffff;
dp8393x.c:    available = (s->regs[SONIC_RBWC1] << 16) | s->regs[SONIC_RBWC0];
dp8393x.c:    available -= rx_len / 2;
dp8393x.c:    s->regs[SONIC_RBWC1] = available >> 16;
dp8393x.c:    s->regs[SONIC_RBWC0] = available & 0xffff;
dp8393x.c:    if (((s->regs[SONIC_RBWC1] << 16) | s->regs[SONIC_RBWC0]) < s->regs[SONIC_EOBC]) {
dp8393x.c:        s->regs[SONIC_RCR] |= SONIC_RCR_LPKT;
dp8393x.c:    s->regs[SONIC_RCR] |= packet_type;
dp8393x.c:    s->regs[SONIC_RCR] |= SONIC_RCR_PRX;
dp8393x.c:    if (s->loopback_packet) {
dp8393x.c:        s->regs[SONIC_RCR] |= SONIC_RCR_LBK;
dp8393x.c:        s->loopback_packet = 0;
dp8393x.c:    DPRINTF("Write status at %08x\n", (s->regs[SONIC_URDA] << 16) | s->regs[SONIC_CRDA]);
dp8393x.c:    data[0 * width] = s->regs[SONIC_RCR]; /* status */
dp8393x.c:    data[2 * width] = s->regs[SONIC_TRBA0]; /* pkt_ptr0 */
dp8393x.c:    data[3 * width] = s->regs[SONIC_TRBA1]; /* pkt_ptr1 */
dp8393x.c:    data[4 * width] = s->regs[SONIC_RSC]; /* seq_no */
dp8393x.c:    s->memory_rw(s->mem_opaque, (s->regs[SONIC_URDA] << 16) | s->regs[SONIC_CRDA], (uint8_t *)data, size, 1);
dp8393x.c:    s->memory_rw(s->mem_opaque,
dp8393x.c:        ((s->regs[SONIC_URDA] << 16) | s->regs[SONIC_CRDA]) + sizeof(uint16_t) * 5 * width,
dp8393x.c:    s->regs[SONIC_LLFA] = data[0 * width];
dp8393x.c:    if (s->regs[SONIC_LLFA] & 0x1) {
dp8393x.c:        s->regs[SONIC_ISR] |= SONIC_ISR_RDE;
dp8393x.c:        s->memory_rw(s->mem_opaque,
dp8393x.c:            ((s->regs[SONIC_URDA] << 16) | s->regs[SONIC_CRDA]) + sizeof(uint16_t) * 6 * width,
dp8393x.c:        s->regs[SONIC_CRDA] = s->regs[SONIC_LLFA];
dp8393x.c:        s->regs[SONIC_ISR] |= SONIC_ISR_PKTRX;
dp8393x.c:        s->regs[SONIC_RSC] = (s->regs[SONIC_RSC] & 0xff00) | (((s->regs[SONIC_RSC] & 0x00ff) + 1) & 0x00ff);
dp8393x.c:        if (s->regs[SONIC_RCR] & SONIC_RCR_LPKT) {
dp8393x.c:    qemu_del_timer(s->watchdog);
dp8393x.c:    s->regs[SONIC_CR] = SONIC_CR_RST | SONIC_CR_STP | SONIC_CR_RXDIS;
dp8393x.c:    s->regs[SONIC_DCR] &= ~(SONIC_DCR_EXBUS | SONIC_DCR_LBR);
dp8393x.c:    s->regs[SONIC_RCR] &= ~(SONIC_RCR_LB0 | SONIC_RCR_LB1 | SONIC_RCR_BRD | SONIC_RCR_RNT);
dp8393x.c:    s->regs[SONIC_TCR] |= SONIC_TCR_NCRS | SONIC_TCR_PTX;
dp8393x.c:    s->regs[SONIC_TCR] &= ~SONIC_TCR_BCM;
dp8393x.c:    s->regs[SONIC_IMR] = 0;
dp8393x.c:    s->regs[SONIC_ISR] = 0;
dp8393x.c:    s->regs[SONIC_DCR2] = 0;
dp8393x.c:    s->regs[SONIC_EOBC] = 0x02F8;
dp8393x.c:    s->regs[SONIC_RSC] = 0;
dp8393x.c:    s->regs[SONIC_CE] = 0;
dp8393x.c:    s->regs[SONIC_RSC] = 0;
dp8393x.c:    s->regs[SONIC_RCR] |= SONIC_RCR_CRS;
dp8393x.c:    dp8393xState *s = DO_UPCAST(NICState, nc, nc)->opaque;
dp8393x.c:    cpu_unregister_io_memory(s->mmio_index);
dp8393x.c:    qemu_del_timer(s->watchdog);
dp8393x.c:    qemu_free_timer(s->watchdog);
dp8393x.c:    s->mem_opaque = mem_opaque;
dp8393x.c:    s->memory_rw = memory_rw;
dp8393x.c:    s->it_shift = it_shift;
dp8393x.c:    s->irq = irq;
dp8393x.c:    s->watchdog = qemu_new_timer(vm_clock, dp8393x_watchdog, s);
dp8393x.c:    s->regs[SONIC_SR] = 0x0004; /* only revision recognized by Linux */
dp8393x.c:    memcpy(s->conf.macaddr.a, nd->macaddr, sizeof(s->conf.macaddr));
dp8393x.c:    s->conf.vlan = nd->vlan;
dp8393x.c:    s->conf.peer = nd->netdev;
dp8393x.c:    s->nic = qemu_new_nic(&net_dp83932_info, &s->conf, nd->model, nd->name, s);
dp8393x.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
dp8393x.c:    s->mmio_index = cpu_register_io_memory(dp8393x_read, dp8393x_write, s);
dp8393x.c:    cpu_register_physical_memory(base, 0x40 << it_shift, s->mmio_index);
ds1225y.c: * Copyright (c) 2007-2008 Herv Poussineau
ds1225y.c:    val = s->contents[addr];
ds1225y.c:    s->contents[addr] = val & 0xff;
ds1225y.c:    if (s->file) {
ds1225y.c:        qemu_fseek(s->file, addr, SEEK_SET);
ds1225y.c:        qemu_put_byte(s->file, (int)val);
ds1225y.c:        qemu_fflush(s->file);
ds1225y.c:    if (s->protection != 7) {
ds1225y.c:    s->chip_size = 0x2000; /* Fixed for ds1225y chip: 8 KiB */
ds1225y.c:    s->contents = qemu_mallocz(s->chip_size);
ds1225y.c:    s->protection = 7;
ds1225y.c:        qemu_get_buffer(file, s->contents, s->chip_size);
ds1225y.c:    s->file = qemu_fopen(filename, "wb");
ds1225y.c:    if (s->file) {
ds1225y.c:        qemu_put_buffer(s->file, s->contents, s->chip_size);
ds1225y.c:        qemu_fflush(s->file);
ds1225y.c:    cpu_register_physical_memory(mem_base, s->chip_size, mem_indexRW);
ds1225y.c:    cpu_register_physical_memory(mem_base + s->chip_size, s->chip_size, mem_indexRP);
ds1338.c:        qemu_get_timedate(&s->now, s->offset);
ds1338.c:        s->nvram[0] = to_bcd(s->now.tm_sec);
ds1338.c:        s->nvram[1] = to_bcd(s->now.tm_min);
ds1338.c:        if (s->nvram[2] & 0x40) {
ds1338.c:            s->nvram[2] = (to_bcd((s->now.tm_hour % 12)) + 1) | 0x40;
ds1338.c:            if (s->now.tm_hour >= 12) {
ds1338.c:                s->nvram[2] |= 0x20;
ds1338.c:            s->nvram[2] = to_bcd(s->now.tm_hour);
ds1338.c:        s->nvram[3] = to_bcd(s->now.tm_wday) + 1;
ds1338.c:        s->nvram[4] = to_bcd(s->now.tm_mday);
ds1338.c:        s->nvram[5] = to_bcd(s->now.tm_mon) + 1;
ds1338.c:        s->nvram[6] = to_bcd(s->now.tm_year - 100);
ds1338.c:        s->addr_byte = 1;
ds1338.c:    res  = s->nvram[s->ptr];
ds1338.c:    s->ptr = (s->ptr + 1) & 0xff;
ds1338.c:    if (s->addr_byte) {
ds1338.c:        s->ptr = data;
ds1338.c:        s->addr_byte = 0;
ds1338.c:    s->nvram[s->ptr - 8] = data;
ds1338.c:        qemu_get_timedate(&s->now, s->offset);
ds1338.c:            s->now.tm_sec = from_bcd(data & 0x7f);
ds1338.c:            s->now.tm_min = from_bcd(data & 0x7f);
ds1338.c:                    data = from_bcd(data & 0x1f) - 1;
ds1338.c:            s->now.tm_hour = data;
ds1338.c:            s->now.tm_wday = from_bcd(data & 7) - 1;
ds1338.c:            s->now.tm_mday = from_bcd(data & 0x3f);
ds1338.c:            s->now.tm_mon = from_bcd(data & 0x1f) - 1;
ds1338.c:            s->now.tm_year = from_bcd(data) + 100;
ds1338.c:        s->offset = qemu_timedate_diff(&s->now);
ds1338.c:    s->ptr = (s->ptr + 1) & 0xff;
dummy_m68k.c:    env->vbr = 0;
dummy_m68k.c:                                              ram_size - KERNEL_LOAD_ADDR);
dummy_m68k.c:    env->pc = entry;
e1000.c: * May need to specify additional MAC-to-PHY entries --
e1000.c:    s->mac_reg[ICR] = val;
e1000.c:    s->mac_reg[ICS] = val;
e1000.c:    qemu_set_irq(s->dev.irq[0], (s->mac_reg[IMS] & s->mac_reg[ICR]) != 0);
e1000.c:    DBGOUT(INTERRUPT, "set_ics %x, ICR %x, IMR %x\n", val, s->mac_reg[ICR],
e1000.c:        s->mac_reg[IMS]);
e1000.c:    set_interrupt_cause(s, 0, val | s->mac_reg[ICR]);
e1000.c:    s->mac_reg[CTRL] = val & ~E1000_CTRL_RST;
e1000.c:    s->mac_reg[RCTL] = val;
e1000.c:    s->rxbuf_size = rxbufsize(val);
e1000.c:    s->rxbuf_min_shift = ((val / E1000_RCTL_RDMTS_QUAT) & 3) + 1;
e1000.c:    DBGOUT(RX, "RCTL: %d, mac_reg[RCTL] = 0x%x\n", s->mac_reg[RDT],
e1000.c:           s->mac_reg[RCTL]);
e1000.c:        val = s->mac_reg[MDIC] | E1000_MDIC_ERROR;
e1000.c:            val = (val ^ data) | s->phy_reg[addr];
e1000.c:            s->phy_reg[addr] = data;
e1000.c:    s->mac_reg[MDIC] = val | E1000_MDIC_READY;
e1000.c:    uint32_t ret = E1000_EECD_PRES|E1000_EECD_GNT | s->eecd_state.old_eecd;
e1000.c:           s->eecd_state.bitnum_out, s->eecd_state.reading);
e1000.c:    if (!s->eecd_state.reading ||
e1000.c:        ((s->eeprom_data[(s->eecd_state.bitnum_out >> 4) & 0x3f] >>
e1000.c:          ((s->eecd_state.bitnum_out & 0xf) ^ 0xf))) & 1)
e1000.c:    uint32_t oldval = s->eecd_state.old_eecd;
e1000.c:    s->eecd_state.old_eecd = val & (E1000_EECD_SK | E1000_EECD_CS |
e1000.c:        s->eecd_state.bitnum_out++;
e1000.c:        memset(&s->eecd_state, 0, sizeof s->eecd_state);
e1000.c:        s->eecd_state.old_eecd = E1000_EECD_SK;
e1000.c:    s->eecd_state.val_in <<= 1;
e1000.c:        s->eecd_state.val_in |= 1;
e1000.c:    if (++s->eecd_state.bitnum_in == 9 && !s->eecd_state.reading) {
e1000.c:        s->eecd_state.bitnum_out = ((s->eecd_state.val_in & 0x3f)<<4)-1;
e1000.c:        s->eecd_state.reading = (((s->eecd_state.val_in >> 6) & 7) ==
e1000.c:           s->eecd_state.bitnum_in, s->eecd_state.bitnum_out,
e1000.c:           s->eecd_state.reading);
e1000.c:    unsigned int index, r = s->mac_reg[EERD] & ~E1000_EEPROM_RW_REG_START;
e1000.c:    if ((s->mac_reg[EERD] & E1000_EEPROM_RW_REG_START) == 0)
e1000.c:        return (s->mac_reg[EERD]);
e1000.c:    return ((s->eeprom_data[index] << E1000_EEPROM_RW_REG_DATA) |
e1000.c:    if (sloc < n-1) {
e1000.c:        sum = net_checksum_add(n-css, data+css);
e1000.c:    return ((s->mac_reg[CTRL] & E1000_CTRL_VME) != 0);
e1000.c:    return ((s->mac_reg[RCTL] & E1000_RCTL_VFE) != 0);
e1000.c:                le16_to_cpup((uint16_t *)(s->mac_reg + VET)));
e1000.c:    unsigned int frames = s->tx.tso_frames, css, sofar, n;
e1000.c:    struct e1000_tx *tp = &s->tx;
e1000.c:    if (tp->tse && tp->cptse) {
e1000.c:        css = tp->ipcss;
e1000.c:               frames, tp->size, css);
e1000.c:        if (tp->ip) {		// IPv4
e1000.c:            cpu_to_be16wu((uint16_t *)(tp->data+css+2),
e1000.c:                          tp->size - css);
e1000.c:            cpu_to_be16wu((uint16_t *)(tp->data+css+4),
e1000.c:                          be16_to_cpup((uint16_t *)(tp->data+css+4))+frames);
e1000.c:            cpu_to_be16wu((uint16_t *)(tp->data+css+4),
e1000.c:                          tp->size - css);
e1000.c:        css = tp->tucss;
e1000.c:        len = tp->size - css;
e1000.c:        DBGOUT(TXSUM, "tcp %d tucss %d len %d\n", tp->tcp, css, len);
e1000.c:        if (tp->tcp) {
e1000.c:            sofar = frames * tp->mss;
e1000.c:            cpu_to_be32wu((uint32_t *)(tp->data+css+4),	// seq
e1000.c:                be32_to_cpupu((uint32_t *)(tp->data+css+4))+sofar);
e1000.c:            if (tp->paylen - sofar > tp->mss)
e1000.c:                tp->data[css + 13] &= ~9;		// PSH, FIN
e1000.c:            cpu_to_be16wu((uint16_t *)(tp->data+css+4), len);
e1000.c:        if (tp->sum_needed & E1000_TXD_POPTS_TXSM) {
e1000.c:            // add pseudo-header length before checksum calculation
e1000.c:            sp = (uint16_t *)(tp->data + tp->tucso);
e1000.c:        tp->tso_frames++;
e1000.c:    if (tp->sum_needed & E1000_TXD_POPTS_TXSM)
e1000.c:        putsum(tp->data, tp->size, tp->tucso, tp->tucss, tp->tucse);
e1000.c:    if (tp->sum_needed & E1000_TXD_POPTS_IXSM)
e1000.c:        putsum(tp->data, tp->size, tp->ipcso, tp->ipcss, tp->ipcse);
e1000.c:    if (tp->vlan_needed) {
e1000.c:        memmove(tp->vlan, tp->data, 4);
e1000.c:        memmove(tp->data, tp->data + 4, 8);
e1000.c:        memcpy(tp->data + 8, tp->vlan_header, 4);
e1000.c:        qemu_send_packet(&s->nic->nc, tp->vlan, tp->size + 4);
e1000.c:        qemu_send_packet(&s->nic->nc, tp->data, tp->size);
e1000.c:    s->mac_reg[TPT]++;
e1000.c:    s->mac_reg[GPTC]++;
e1000.c:    n = s->mac_reg[TOTL];
e1000.c:    if ((s->mac_reg[TOTL] += s->tx.size) < n)
e1000.c:        s->mac_reg[TOTH]++;
e1000.c:    uint32_t txd_lower = le32_to_cpu(dp->lower.data);
e1000.c:    struct e1000_tx *tp = &s->tx;
e1000.c:        op = le32_to_cpu(xp->cmd_and_length);
e1000.c:        tp->ipcss = xp->lower_setup.ip_fields.ipcss;
e1000.c:        tp->ipcso = xp->lower_setup.ip_fields.ipcso;
e1000.c:        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);
e1000.c:        tp->tucss = xp->upper_setup.tcp_fields.tucss;
e1000.c:        tp->tucso = xp->upper_setup.tcp_fields.tucso;
e1000.c:        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);
e1000.c:        tp->paylen = op & 0xfffff;
e1000.c:        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;
e1000.c:        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);
e1000.c:        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;
e1000.c:        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;
e1000.c:        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;
e1000.c:        tp->tso_frames = 0;
e1000.c:        if (tp->tucso == 0) {	// this is probably wrong
e1000.c:            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);
e1000.c:        tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;
e1000.c:        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;
e1000.c:        tp->cptse = 0;
e1000.c:        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {
e1000.c:        tp->vlan_needed = 1;
e1000.c:        cpu_to_be16wu((uint16_t *)(tp->vlan_header),
e1000.c:                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));
e1000.c:        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),
e1000.c:                      le16_to_cpu(dp->upper.fields.special));
e1000.c:    addr = le64_to_cpu(dp->buffer_addr);
e1000.c:    if (tp->tse && tp->cptse) {
e1000.c:        hdr = tp->hdr_len;
e1000.c:        msh = hdr + tp->mss;
e1000.c:            if (tp->size + bytes > msh)
e1000.c:                bytes = msh - tp->size;
e1000.c:            cpu_physical_memory_read(addr, tp->data + tp->size, bytes);
e1000.c:            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)
e1000.c:                memmove(tp->header, tp->data, hdr);
e1000.c:            tp->size = sz;
e1000.c:                memmove(tp->data, tp->header, hdr);
e1000.c:                tp->size = hdr;
e1000.c:        } while (split_size -= bytes);
e1000.c:    } else if (!tp->tse && tp->cptse) {
e1000.c:        cpu_physical_memory_read(addr, tp->data + tp->size, split_size);
e1000.c:        tp->size += split_size;
e1000.c:    if (!(tp->tse && tp->cptse && tp->size < hdr))
e1000.c:    tp->tso_frames = 0;
e1000.c:    tp->sum_needed = 0;
e1000.c:    tp->vlan_needed = 0;
e1000.c:    tp->size = 0;
e1000.c:    tp->cptse = 0;
e1000.c:    uint32_t txd_upper, txd_lower = le32_to_cpu(dp->lower.data);
e1000.c:    txd_upper = (le32_to_cpu(dp->upper.data) | E1000_TXD_STAT_DD) &
e1000.c:    dp->upper.data = cpu_to_le32(txd_upper);
e1000.c:    cpu_physical_memory_write(base + ((char *)&dp->upper - (char *)dp),
e1000.c:                              (void *)&dp->upper, sizeof(dp->upper));
e1000.c:    uint32_t tdh_start = s->mac_reg[TDH], cause = E1000_ICS_TXQE;
e1000.c:    if (!(s->mac_reg[TCTL] & E1000_TCTL_EN)) {
e1000.c:    while (s->mac_reg[TDH] != s->mac_reg[TDT]) {
e1000.c:        base = ((uint64_t)s->mac_reg[TDBAH] << 32) + s->mac_reg[TDBAL] +
e1000.c:               sizeof(struct e1000_tx_desc) * s->mac_reg[TDH];
e1000.c:        DBGOUT(TX, "index %d: %p : %x %x\n", s->mac_reg[TDH],
e1000.c:        if (++s->mac_reg[TDH] * sizeof(desc) >= s->mac_reg[TDLEN])
e1000.c:            s->mac_reg[TDH] = 0;
e1000.c:        if (s->mac_reg[TDH] == tdh_start) {
e1000.c:                   tdh_start, s->mac_reg[TDT], s->mac_reg[TDLEN]);
e1000.c:    uint32_t f, rctl = s->mac_reg[RCTL], ra[2], *rp;
e1000.c:        uint32_t vfta = le32_to_cpup((uint32_t *)(s->mac_reg + VFTA) +
e1000.c:    for (rp = s->mac_reg + RA; rp < s->mac_reg + RA + 32; rp += 2) {
e1000.c:                   (int)(rp - s->mac_reg - RA)/2,
e1000.c:    if (s->mac_reg[MTA + (f >> 5)] & (1 << (f & 0x1f)))
e1000.c:           s->mac_reg[MTA + (f >> 5)]);
e1000.c:    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
e1000.c:    uint32_t old_status = s->mac_reg[STATUS];
e1000.c:    if (nc->link_down)
e1000.c:        s->mac_reg[STATUS] &= ~E1000_STATUS_LU;
e1000.c:        s->mac_reg[STATUS] |= E1000_STATUS_LU;
e1000.c:    if (s->mac_reg[STATUS] != old_status)
e1000.c:    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
e1000.c:    return (s->mac_reg[RCTL] & E1000_RCTL_EN);
e1000.c:    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
e1000.c:    if (!(s->mac_reg[RCTL] & E1000_RCTL_EN))
e1000.c:        return -1;
e1000.c:    if (size > s->rxbuf_size) {
e1000.c:               (unsigned long)size, s->rxbuf_size);
e1000.c:        return -1;
e1000.c:        size -= 4;
e1000.c:    rdh_start = s->mac_reg[RDH];
e1000.c:        if (s->mac_reg[RDH] == s->mac_reg[RDT] && s->check_rxov) {
e1000.c:            return -1;
e1000.c:        base = ((uint64_t)s->mac_reg[RDBAH] << 32) + s->mac_reg[RDBAL] +
e1000.c:               sizeof(desc) * s->mac_reg[RDH];
e1000.c:        if (++s->mac_reg[RDH] * sizeof(desc) >= s->mac_reg[RDLEN])
e1000.c:            s->mac_reg[RDH] = 0;
e1000.c:        s->check_rxov = 1;
e1000.c:        if (s->mac_reg[RDH] == rdh_start) {
e1000.c:                   rdh_start, s->mac_reg[RDT], s->mac_reg[RDLEN]);
e1000.c:            return -1;
e1000.c:    s->mac_reg[GPRC]++;
e1000.c:    s->mac_reg[TPR]++;
e1000.c:    n = s->mac_reg[TORL];
e1000.c:    if ((s->mac_reg[TORL] += size) < n)
e1000.c:        s->mac_reg[TORH]++;
e1000.c:    if ((rdt = s->mac_reg[RDT]) < s->mac_reg[RDH])
e1000.c:        rdt += s->mac_reg[RDLEN] / sizeof(desc);
e1000.c:    if (((rdt - s->mac_reg[RDH]) * sizeof(desc)) <= s->mac_reg[RDLEN] >>
e1000.c:        s->rxbuf_min_shift)
e1000.c:    return s->mac_reg[index];
e1000.c:    uint32_t ret = s->mac_reg[ICR];
e1000.c:    uint32_t ret = s->mac_reg[index];
e1000.c:    s->mac_reg[index] = 0;
e1000.c:    uint32_t ret = s->mac_reg[index];
e1000.c:    s->mac_reg[index] = 0;
e1000.c:    s->mac_reg[index-1] = 0;
e1000.c:    s->mac_reg[index] = val;
e1000.c:    s->check_rxov = 0;
e1000.c:    s->mac_reg[index] = val & 0xffff;
e1000.c:    s->mac_reg[index] = val & 0xffff;
e1000.c:    s->mac_reg[index] = val & 0xfff80;
e1000.c:    s->mac_reg[index] = val;
e1000.c:    s->mac_reg[TDT] &= 0xffff;
e1000.c:    set_interrupt_cause(s, 0, s->mac_reg[ICR] & ~val);
e1000.c:    s->mac_reg[IMS] &= ~val;
e1000.c:    s->mac_reg[IMS] |= val;
e1000.c:    cpu_register_physical_memory(addr, PNPMMIO_SIZE, d->mmio_index);
e1000.c:                                     excluded_regs[i + 1] -
e1000.c:                                     excluded_regs[i] - 4);
e1000.c:    E1000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
e1000.c:    s->nic = NULL;
e1000.c:    cpu_unregister_io_memory(d->mmio_index);
e1000.c:    qemu_del_vlan_client(&d->nic->nc);
e1000.c:    memset(d->phy_reg, 0, sizeof d->phy_reg);
e1000.c:    memmove(d->phy_reg, phy_reg_init, sizeof phy_reg_init);
e1000.c:    memset(d->mac_reg, 0, sizeof d->mac_reg);
e1000.c:    memmove(d->mac_reg, mac_reg_init, sizeof mac_reg_init);
e1000.c:    d->rxbuf_min_shift = 1;
e1000.c:    memset(&d->tx, 0, sizeof d->tx);
e1000.c:    pci_conf = d->dev.config;
e1000.c:    d->mmio_index = cpu_register_io_memory(e1000_mmio_read,
e1000.c:    memmove(d->eeprom_data, e1000_eeprom_template,
e1000.c:    qemu_macaddr_default_if_unset(&d->conf.macaddr);
e1000.c:    macaddr = d->conf.macaddr.a;
e1000.c:        d->eeprom_data[i] = (macaddr[2*i+1]<<8) | macaddr[2*i];
e1000.c:        checksum += d->eeprom_data[i];
e1000.c:    checksum = (uint16_t) EEPROM_SUM - checksum;
e1000.c:    d->eeprom_data[EEPROM_CHECKSUM_REG] = checksum;
e1000.c:    d->nic = qemu_new_nic(&net_e1000_info, &d->conf,
e1000.c:                          d->dev.qdev.info->name, d->dev.qdev.id, d);
e1000.c:    qemu_format_nic_info_str(&d->nic->nc, macaddr);
e1000.c:    .romfile    = "pxe-e1000.bin",
e1000_hw.h:  Copyright(c) 1999 - 2006 Intel Corporation.
e1000_hw.h:  e1000-devel Mailing List <e1000-devel@lists.sourceforge.net>
e1000_hw.h:  Intel Corporation, 5200 N.E. Elam Young Parkway, Hillsboro, OR 97124-6497
e1000_hw.h: * RW - register is both readable and writable
e1000_hw.h: * RO - register is read only
e1000_hw.h: * WO - register is write only
e1000_hw.h: * R/clr - register is read only and is cleared when read
e1000_hw.h: * A - register array
e1000_hw.h:#define E1000_CTRL     0x00000  /* Device Control - RW */
e1000_hw.h:#define E1000_CTRL_DUP 0x00004  /* Device Control Duplicate (Shadow) - RW */
e1000_hw.h:#define E1000_STATUS   0x00008  /* Device Status - RO */
e1000_hw.h:#define E1000_EECD     0x00010  /* EEPROM/Flash Control - RW */
e1000_hw.h:#define E1000_EERD     0x00014  /* EEPROM Read - RW */
e1000_hw.h:#define E1000_CTRL_EXT 0x00018  /* Extended Device Control - RW */
e1000_hw.h:#define E1000_FLA      0x0001C  /* Flash Access - RW */
e1000_hw.h:#define E1000_MDIC     0x00020  /* MDI Control - RW */
e1000_hw.h:#define E1000_SCTL     0x00024  /* SerDes Control - RW */
e1000_hw.h:#define E1000_FCAL     0x00028  /* Flow Control Address Low - RW */
e1000_hw.h:#define E1000_FCAH     0x0002C  /* Flow Control Address High -RW */
e1000_hw.h:#define E1000_FCT      0x00030  /* Flow Control Type - RW */
e1000_hw.h:#define E1000_VET      0x00038  /* VLAN Ether Type - RW */
e1000_hw.h:#define E1000_ICR      0x000C0  /* Interrupt Cause Read - R/clr */
e1000_hw.h:#define E1000_ITR      0x000C4  /* Interrupt Throttling Rate - RW */
e1000_hw.h:#define E1000_ICS      0x000C8  /* Interrupt Cause Set - WO */
e1000_hw.h:#define E1000_IMS      0x000D0  /* Interrupt Mask Set - RW */
e1000_hw.h:#define E1000_IMC      0x000D8  /* Interrupt Mask Clear - WO */
e1000_hw.h:#define E1000_RCTL     0x00100  /* RX Control - RW */
e1000_hw.h:#define E1000_RDTR1    0x02820  /* RX Delay Timer (1) - RW */
e1000_hw.h:#define E1000_RDBAL1   0x02900  /* RX Descriptor Base Address Low (1) - RW */
e1000_hw.h:#define E1000_RDBAH1   0x02904  /* RX Descriptor Base Address High (1) - RW */
e1000_hw.h:#define E1000_RDLEN1   0x02908  /* RX Descriptor Length (1) - RW */
e1000_hw.h:#define E1000_RDH1     0x02910  /* RX Descriptor Head (1) - RW */
e1000_hw.h:#define E1000_RDT1     0x02918  /* RX Descriptor Tail (1) - RW */
e1000_hw.h:#define E1000_FCTTV    0x00170  /* Flow Control Transmit Timer Value - RW */
e1000_hw.h:#define E1000_TXCW     0x00178  /* TX Configuration Word - RW */
e1000_hw.h:#define E1000_RXCW     0x00180  /* RX Configuration Word - RO */
e1000_hw.h:#define E1000_TCTL     0x00400  /* TX Control - RW */
e1000_hw.h:#define E1000_TCTL_EXT 0x00404  /* Extended TX Control - RW */
e1000_hw.h:#define E1000_TIPG     0x00410  /* TX Inter-packet gap -RW */
e1000_hw.h:#define E1000_TBT      0x00448  /* TX Burst Timer - RW */
e1000_hw.h:#define E1000_AIT      0x00458  /* Adaptive Interframe Spacing Throttle - RW */
e1000_hw.h:#define E1000_LEDCTL   0x00E00  /* LED Control - RW */
e1000_hw.h:#define E1000_PBA      0x01000  /* Packet Buffer Allocation - RW */
e1000_hw.h:#define E1000_EEWR     0x0102C  /* EEPROM Write Register - RW */
e1000_hw.h:#define E1000_ERT      0x02008  /* Early Rx Threshold - RW */
e1000_hw.h:#define E1000_FCRTL    0x02160  /* Flow Control Receive Threshold Low - RW */
e1000_hw.h:#define E1000_FCRTH    0x02168  /* Flow Control Receive Threshold High - RW */
e1000_hw.h:#define E1000_PSRCTL   0x02170  /* Packet Split Receive Control - RW */
e1000_hw.h:#define E1000_RDBAL    0x02800  /* RX Descriptor Base Address Low - RW */
e1000_hw.h:#define E1000_RDBAH    0x02804  /* RX Descriptor Base Address High - RW */
e1000_hw.h:#define E1000_RDLEN    0x02808  /* RX Descriptor Length - RW */
e1000_hw.h:#define E1000_RDH      0x02810  /* RX Descriptor Head - RW */
e1000_hw.h:#define E1000_RDT      0x02818  /* RX Descriptor Tail - RW */
e1000_hw.h:#define E1000_RDTR     0x02820  /* RX Delay Timer - RW */
e1000_hw.h:#define E1000_RDBAL0   E1000_RDBAL /* RX Desc Base Address Low (0) - RW */
e1000_hw.h:#define E1000_RDBAH0   E1000_RDBAH /* RX Desc Base Address High (0) - RW */
e1000_hw.h:#define E1000_RDLEN0   E1000_RDLEN /* RX Desc Length (0) - RW */
e1000_hw.h:#define E1000_RDH0     E1000_RDH   /* RX Desc Head (0) - RW */
e1000_hw.h:#define E1000_RDT0     E1000_RDT   /* RX Desc Tail (0) - RW */
e1000_hw.h:#define E1000_RDTR0    E1000_RDTR  /* RX Delay Timer (0) - RW */
e1000_hw.h:#define E1000_RXDCTL   0x02828  /* RX Descriptor Control queue 0 - RW */
e1000_hw.h:#define E1000_RXDCTL1  0x02928  /* RX Descriptor Control queue 1 - RW */
e1000_hw.h:#define E1000_RADV     0x0282C  /* RX Interrupt Absolute Delay Timer - RW */
e1000_hw.h:#define E1000_RSRPD    0x02C00  /* RX Small Packet Detect - RW */
e1000_hw.h:#define E1000_RAID     0x02C08  /* Receive Ack Interrupt Delay - RW */
e1000_hw.h:#define E1000_TXDMAC   0x03000  /* TX DMA Control - RW */
e1000_hw.h:#define E1000_TDFH     0x03410  /* TX Data FIFO Head - RW */
e1000_hw.h:#define E1000_TDFT     0x03418  /* TX Data FIFO Tail - RW */
e1000_hw.h:#define E1000_TDFHS    0x03420  /* TX Data FIFO Head Saved - RW */
e1000_hw.h:#define E1000_TDFTS    0x03428  /* TX Data FIFO Tail Saved - RW */
e1000_hw.h:#define E1000_TDFPC    0x03430  /* TX Data FIFO Packet Count - RW */
e1000_hw.h:#define E1000_TDBAL    0x03800  /* TX Descriptor Base Address Low - RW */
e1000_hw.h:#define E1000_TDBAH    0x03804  /* TX Descriptor Base Address High - RW */
e1000_hw.h:#define E1000_TDLEN    0x03808  /* TX Descriptor Length - RW */
e1000_hw.h:#define E1000_TDH      0x03810  /* TX Descriptor Head - RW */
e1000_hw.h:#define E1000_TDT      0x03818  /* TX Descripotr Tail - RW */
e1000_hw.h:#define E1000_TIDV     0x03820  /* TX Interrupt Delay Value - RW */
e1000_hw.h:#define E1000_TXDCTL   0x03828  /* TX Descriptor Control - RW */
e1000_hw.h:#define E1000_TADV     0x0382C  /* TX Interrupt Absolute Delay Val - RW */
e1000_hw.h:#define E1000_TSPMT    0x03830  /* TCP Segmentation PAD & Min Threshold - RW */
e1000_hw.h:#define E1000_TDBAL1   0x03900  /* TX Desc Base Address Low (1) - RW */
e1000_hw.h:#define E1000_TDBAH1   0x03904  /* TX Desc Base Address High (1) - RW */
e1000_hw.h:#define E1000_TDLEN1   0x03908  /* TX Desc Length (1) - RW */
e1000_hw.h:#define E1000_TDH1     0x03910  /* TX Desc Head (1) - RW */
e1000_hw.h:#define E1000_TDT1     0x03918  /* TX Desc Tail (1) - RW */
e1000_hw.h:#define E1000_TXDCTL1  0x03928  /* TX Descriptor Control (1) - RW */
e1000_hw.h:#define E1000_CRCERRS  0x04000  /* CRC Error Count - R/clr */
e1000_hw.h:#define E1000_ALGNERRC 0x04004  /* Alignment Error Count - R/clr */
e1000_hw.h:#define E1000_SYMERRS  0x04008  /* Symbol Error Count - R/clr */
e1000_hw.h:#define E1000_RXERRC   0x0400C  /* Receive Error Count - R/clr */
e1000_hw.h:#define E1000_MPC      0x04010  /* Missed Packet Count - R/clr */
e1000_hw.h:#define E1000_SCC      0x04014  /* Single Collision Count - R/clr */
e1000_hw.h:#define E1000_ECOL     0x04018  /* Excessive Collision Count - R/clr */
e1000_hw.h:#define E1000_MCC      0x0401C  /* Multiple Collision Count - R/clr */
e1000_hw.h:#define E1000_LATECOL  0x04020  /* Late Collision Count - R/clr */
e1000_hw.h:#define E1000_COLC     0x04028  /* Collision Count - R/clr */
e1000_hw.h:#define E1000_DC       0x04030  /* Defer Count - R/clr */
e1000_hw.h:#define E1000_TNCRS    0x04034  /* TX-No CRS - R/clr */
e1000_hw.h:#define E1000_SEC      0x04038  /* Sequence Error Count - R/clr */
e1000_hw.h:#define E1000_CEXTERR  0x0403C  /* Carrier Extension Error Count - R/clr */
e1000_hw.h:#define E1000_RLEC     0x04040  /* Receive Length Error Count - R/clr */
e1000_hw.h:#define E1000_XONRXC   0x04048  /* XON RX Count - R/clr */
e1000_hw.h:#define E1000_XONTXC   0x0404C  /* XON TX Count - R/clr */
e1000_hw.h:#define E1000_XOFFRXC  0x04050  /* XOFF RX Count - R/clr */
e1000_hw.h:#define E1000_XOFFTXC  0x04054  /* XOFF TX Count - R/clr */
e1000_hw.h:#define E1000_FCRUC    0x04058  /* Flow Control RX Unsupported Count- R/clr */
e1000_hw.h:#define E1000_PRC64    0x0405C  /* Packets RX (64 bytes) - R/clr */
e1000_hw.h:#define E1000_PRC127   0x04060  /* Packets RX (65-127 bytes) - R/clr */
e1000_hw.h:#define E1000_PRC255   0x04064  /* Packets RX (128-255 bytes) - R/clr */
e1000_hw.h:#define E1000_PRC511   0x04068  /* Packets RX (255-511 bytes) - R/clr */
e1000_hw.h:#define E1000_PRC1023  0x0406C  /* Packets RX (512-1023 bytes) - R/clr */
e1000_hw.h:#define E1000_PRC1522  0x04070  /* Packets RX (1024-1522 bytes) - R/clr */
e1000_hw.h:#define E1000_GPRC     0x04074  /* Good Packets RX Count - R/clr */
e1000_hw.h:#define E1000_BPRC     0x04078  /* Broadcast Packets RX Count - R/clr */
e1000_hw.h:#define E1000_MPRC     0x0407C  /* Multicast Packets RX Count - R/clr */
e1000_hw.h:#define E1000_GPTC     0x04080  /* Good Packets TX Count - R/clr */
e1000_hw.h:#define E1000_GORCL    0x04088  /* Good Octets RX Count Low - R/clr */
e1000_hw.h:#define E1000_GORCH    0x0408C  /* Good Octets RX Count High - R/clr */
e1000_hw.h:#define E1000_GOTCL    0x04090  /* Good Octets TX Count Low - R/clr */
e1000_hw.h:#define E1000_GOTCH    0x04094  /* Good Octets TX Count High - R/clr */
e1000_hw.h:#define E1000_RNBC     0x040A0  /* RX No Buffers Count - R/clr */
e1000_hw.h:#define E1000_RUC      0x040A4  /* RX Undersize Count - R/clr */
e1000_hw.h:#define E1000_RFC      0x040A8  /* RX Fragment Count - R/clr */
e1000_hw.h:#define E1000_ROC      0x040AC  /* RX Oversize Count - R/clr */
e1000_hw.h:#define E1000_RJC      0x040B0  /* RX Jabber Count - R/clr */
e1000_hw.h:#define E1000_MGTPRC   0x040B4  /* Management Packets RX Count - R/clr */
e1000_hw.h:#define E1000_MGTPDC   0x040B8  /* Management Packets Dropped Count - R/clr */
e1000_hw.h:#define E1000_MGTPTC   0x040BC  /* Management Packets TX Count - R/clr */
e1000_hw.h:#define E1000_TORL     0x040C0  /* Total Octets RX Low - R/clr */
e1000_hw.h:#define E1000_TORH     0x040C4  /* Total Octets RX High - R/clr */
e1000_hw.h:#define E1000_TOTL     0x040C8  /* Total Octets TX Low - R/clr */
e1000_hw.h:#define E1000_TOTH     0x040CC  /* Total Octets TX High - R/clr */
e1000_hw.h:#define E1000_TPR      0x040D0  /* Total Packets RX - R/clr */
e1000_hw.h:#define E1000_TPT      0x040D4  /* Total Packets TX - R/clr */
e1000_hw.h:#define E1000_PTC64    0x040D8  /* Packets TX (64 bytes) - R/clr */
e1000_hw.h:#define E1000_PTC127   0x040DC  /* Packets TX (65-127 bytes) - R/clr */
e1000_hw.h:#define E1000_PTC255   0x040E0  /* Packets TX (128-255 bytes) - R/clr */
e1000_hw.h:#define E1000_PTC511   0x040E4  /* Packets TX (256-511 bytes) - R/clr */
e1000_hw.h:#define E1000_PTC1023  0x040E8  /* Packets TX (512-1023 bytes) - R/clr */
e1000_hw.h:#define E1000_PTC1522  0x040EC  /* Packets TX (1024-1522 Bytes) - R/clr */
e1000_hw.h:#define E1000_MPTC     0x040F0  /* Multicast Packets TX Count - R/clr */
e1000_hw.h:#define E1000_BPTC     0x040F4  /* Broadcast Packets TX Count - R/clr */
e1000_hw.h:#define E1000_TSCTC    0x040F8  /* TCP Segmentation Context TX - R/clr */
e1000_hw.h:#define E1000_TSCTFC   0x040FC  /* TCP Segmentation Context TX Fail - R/clr */
e1000_hw.h:#define E1000_RXCSUM   0x05000  /* RX Checksum Control - RW */
e1000_hw.h:#define E1000_MTA      0x05200  /* Multicast Table Array - RW Array */
e1000_hw.h:#define E1000_RA       0x05400  /* Receive Address - RW Array */
e1000_hw.h:#define E1000_VFTA     0x05600  /* VLAN Filter Table Array - RW Array */
e1000_hw.h:#define E1000_WUC      0x05800  /* Wakeup Control - RW */
e1000_hw.h:#define E1000_WUFC     0x05808  /* Wakeup Filter Control - RW */
e1000_hw.h:#define E1000_WUS      0x05810  /* Wakeup Status - RO */
e1000_hw.h:#define E1000_MANC     0x05820  /* Management Control - RW */
e1000_hw.h:#define E1000_IPAV     0x05838  /* IP Address Valid - RW */
e1000_hw.h:#define E1000_IP4AT    0x05840  /* IPv4 Address Table - RW Array */
e1000_hw.h:#define E1000_IP6AT    0x05880  /* IPv6 Address Table - RW Array */
e1000_hw.h:#define E1000_WUPL     0x05900  /* Wakeup Packet Length - RW */
e1000_hw.h:#define E1000_WUPM     0x05A00  /* Wakeup Packet Memory - RO A */
e1000_hw.h:#define E1000_FFLT     0x05F00  /* Flexible Filter Length Table - RW Array */
e1000_hw.h:#define E1000_FFMT     0x09000  /* Flexible Filter Mask Table - RW Array */
e1000_hw.h:#define E1000_FFVT     0x09800  /* Flexible Filter Value Table - RW Array */
e1000_hw.h:#define E1000_KUMCTRLSTA 0x00034 /* MAC-PHY interface - RW */
e1000_hw.h:#define E1000_MDPHYA     0x0003C  /* PHY address - RW */
e1000_hw.h:#define E1000_MANC2H     0x05860  /* Managment Control To Host - RW */
e1000_hw.h:#define E1000_SW_FW_SYNC 0x05B5C /* Software-Firmware Synchronization - RW */
e1000_hw.h:#define E1000_GCR       0x05B00 /* PCI-Ex Control */
e1000_hw.h:#define E1000_GSCL_1    0x05B10 /* PCI-Ex Statistic Control #1 */
e1000_hw.h:#define E1000_GSCL_2    0x05B14 /* PCI-Ex Statistic Control #2 */
e1000_hw.h:#define E1000_GSCL_3    0x05B18 /* PCI-Ex Statistic Control #3 */
e1000_hw.h:#define E1000_GSCL_4    0x05B1C /* PCI-Ex Statistic Control #4 */
e1000_hw.h:#define E1000_CPUVEC    0x02C10 /* CPU Vector Register - RW */
e1000_hw.h:#define E1000_MRQC      0x05818 /* Multiple Receive Control - RW */
e1000_hw.h:#define E1000_RETA      0x05C00 /* Redirection Table - RW Array */
e1000_hw.h:#define E1000_RSSRK     0x05C80 /* RSS Random Key - RW Array */
e1000_hw.h:#define PHY_1000T_CTRL   0x09 /* 1000Base-T Control Reg */
e1000_hw.h:#define PHY_1000T_STATUS 0x0A /* 1000Base-T Status Reg */
e1000_hw.h:#define MAX_PHY_REG_ADDRESS        0x1F  /* 5 bit address bus (0-0x1F) */
e1000_hw.h:#define E1000_CTRL_ASDE     0x00000020  /* Auto-speed detect enable */
e1000_hw.h:#define E1000_CTRL_ILOS     0x00000080  /* Invert Loss-Of Signal */
e1000_hw.h:#define E1000_STATUS_PCIX_MODE  0x00002000      /* PCI-X mode */
e1000_hw.h:#define E1000_STATUS_PCIX_SPEED 0x0000C000      /* PCI-X bus speed */
e1000_hw.h:                                         * (0-small, 1-large) */
e1000_hw.h:#define E1000_EECD_TYPE      0x00002000 /* EEPROM Type (1-SPI, 0-Microwire) */
e1000_hw.h:/* EEPROM Commands - Microwire */
e1000_hw.h:#define E1000_TCTL_RTLC   0x01000000    /* Re-transmit on late collision */
e1000_hw.h:#define E1000_TCTL_NRTU   0x02000000    /* No Re-transmit on underrun */
e1000_hw.h:#define E1000_RXD_STAT_PIF      0x80    /* passed in-exact filter */
e1000_hw.h:#define E1000_MANC_SMBUS_EN      0x00000001 /* SMBus Enabled - RO */
e1000_hw.h:#define E1000_MANC_ASF_EN        0x00000002 /* ASF Enabled - RO */
e1000_hw.h:#define E1000_MANC_R_ON_FORCE    0x00000004 /* Reset on Force TCO - RO */
ecc.c: * Calculate Error-correcting Codes. Used by NAND Flash controllers
ecc.c: * Pre-calculated 256-way 1 byte column parity.  Table borrowed from Linux.
ecc.c:    s->cp ^= idx & 0x3f;
ecc.c:        s->lp[0] ^= ~s->count;
ecc.c:        s->lp[1] ^= s->count;
ecc.c:    s->count ++;
ecc.c:    s->lp[0] = 0x0000;
ecc.c:    s->lp[1] = 0x0000;
ecc.c:    s->cp = 0x00;
ecc.c:    s->count = 0;
ecc.c:    qemu_put_8s(f, &s->cp);
ecc.c:    qemu_put_be16s(f, &s->lp[0]);
ecc.c:    qemu_put_be16s(f, &s->lp[1]);
ecc.c:    qemu_put_be16s(f, &s->count);
ecc.c:    qemu_get_8s(f, &s->cp);
ecc.c:    qemu_get_be16s(f, &s->lp[0]);
ecc.c:    qemu_get_be16s(f, &s->lp[1]);
ecc.c:    qemu_get_be16s(f, &s->count);
eccmemctl.c: * MCC (version 0, implementation 0) SS-600MP
eccmemctl.c: * EMC (version 0, implementation 1) SS-10
eccmemctl.c: * SMC (version 0, implementation 2) SS-10SX and SS-20
eccmemctl.c: * "Sun-4M System Architecture (revision 2.0) by Chuck Narad", 950-1373-01,
eccmemctl.c:#define ECC_MFAR0_PADDR 0x0000000f     /* PA[32-35] */
eccmemctl.c:#define ECC_MFAR0_VADDR 0x003fc000     /* VA[12-19] (superset bits) */
eccmemctl.c:#define ECC_DIAG_MASK  (ECC_DIAG_SIZE - 1)
eccmemctl.c:        if (s->version == ECC_MCC)
eccmemctl.c:            s->regs[ECC_MER] = (val & ECC_MER_MASK_0);
eccmemctl.c:        else if (s->version == ECC_EMC)
eccmemctl.c:            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_1);
eccmemctl.c:        else if (s->version == ECC_SMC)
eccmemctl.c:            s->regs[ECC_MER] = s->version | (val & ECC_MER_MASK_2);
eccmemctl.c:        s->regs[ECC_MDR] =  val & ECC_MDR_MASK;
eccmemctl.c:        s->regs[ECC_MFSR] =  val;
eccmemctl.c:        qemu_irq_lower(s->irq);
eccmemctl.c:        s->regs[ECC_VCR] =  val;
eccmemctl.c:        s->regs[ECC_DR] =  val;
eccmemctl.c:        s->regs[ECC_ECR0] =  val;
eccmemctl.c:        s->regs[ECC_ECR0] =  val;
eccmemctl.c:        ret = s->regs[ECC_MER];
eccmemctl.c:        ret = s->regs[ECC_MDR];
eccmemctl.c:        ret = s->regs[ECC_MFSR];
eccmemctl.c:        ret = s->regs[ECC_VCR];
eccmemctl.c:        ret = s->regs[ECC_MFAR0];
eccmemctl.c:        ret = s->regs[ECC_MFAR1];
eccmemctl.c:        ret = s->regs[ECC_DR];
eccmemctl.c:        ret = s->regs[ECC_ECR0];
eccmemctl.c:        ret = s->regs[ECC_ECR0];
eccmemctl.c:    s->diag[addr & ECC_DIAG_MASK] = val;
eccmemctl.c:    uint32_t ret = s->diag[(int)addr];
eccmemctl.c:    if (s->version == ECC_MCC)
eccmemctl.c:        s->regs[ECC_MER] &= ECC_MER_REU;
eccmemctl.c:        s->regs[ECC_MER] &= (ECC_MER_VER | ECC_MER_IMPL | ECC_MER_MRR |
eccmemctl.c:    s->regs[ECC_MDR] = 0x20;
eccmemctl.c:    s->regs[ECC_MFSR] = 0;
eccmemctl.c:    s->regs[ECC_VCR] = 0;
eccmemctl.c:    s->regs[ECC_MFAR0] = 0x07c00000;
eccmemctl.c:    s->regs[ECC_MFAR1] = 0;
eccmemctl.c:    s->regs[ECC_DR] = 0;
eccmemctl.c:    s->regs[ECC_ECR0] = 0;
eccmemctl.c:    s->regs[ECC_ECR1] = 0;
eccmemctl.c:    sysbus_init_irq(dev, &s->irq);
eccmemctl.c:    s->regs[0] = s->version;
eccmemctl.c:    if (s->version == ECC_MCC) { // SS-600MP only
eccmemctl.c:        DEFINE_PROP_HEX32("version", ECCState, version, -1),
eepro100.c: * Copyright (c) 2006-2007 Stefan Weil
eepro100.c: *      non-i386 platforms
eepro100.c:#define logout(fmt, ...) fprintf(stderr, "EE100\t%-24s" fmt, __func__, ## __VA_ARGS__)
eepro100.c:#define BITS(n, m) (((0xffffffffU << (31 - n)) >> (31 - n + m)) << m)
eepro100.c:    /* Statistical counters. Also used for wake-up packet (i82559). */
eepro100.c:    /* MDI Registers 0 - 6, 7 */
eepro100.c:    /* MDI Registers 8 - 15 */
eepro100.c:    /* MDI Registers 16 - 31 */
eepro100.c:    while (size-- > 0) {
eepro100.c:    if (s->int_stat) {
eepro100.c:        qemu_irq_lower(s->dev.irq[0]);
eepro100.c:        s->int_stat = 0;
eepro100.c:    if (!s->int_stat) {
eepro100.c:        qemu_irq_raise(s->dev.irq[0]);
eepro100.c:        s->int_stat = 1;
eepro100.c:    s->scb_stat &= ~s->mem[SCBAck];
eepro100.c:    s->mem[SCBAck] = s->scb_stat;
eepro100.c:    if (s->scb_stat == 0) {
eepro100.c:    uint8_t mask = ~s->mem[SCBIntmask];
eepro100.c:    s->mem[SCBAck] |= stat;
eepro100.c:    stat = s->scb_stat = s->mem[SCBAck];
eepro100.c:    //~ stat &= (~s->mem[SCBIntmask] | 0x0xf);
eepro100.c:    } else if (s->int_stat) {
eepro100.c:    uint32_t device = s->device;
eepro100.c:    uint8_t *pci_conf = s->dev.config;
eepro100.c:    /* BIST (built-in self test) */
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 76;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 76;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:        s->stats_size = 80;
eepro100.c:        s->has_extended_tcb_support = 1;
eepro100.c:    s->configuration[6] |= BIT(5);
eepro100.c:    if (s->stats_size == 80) {
eepro100.c:        if (s->configuration[6] & BIT(2)) {
eepro100.c:            assert(s->configuration[6] & BIT(5));
eepro100.c:            if (s->configuration[6] & BIT(5)) {
eepro100.c:                s->stats_size = 64;
eepro100.c:                s->stats_size = 76;
eepro100.c:        if (s->configuration[6] & BIT(5)) {
eepro100.c:            s->stats_size = 64;
eepro100.c:    assert(s->stats_size > 0 && s->stats_size <= sizeof(s->statistics));
eepro100.c:    uint16_t *eeprom_contents = eeprom93xx_data(s->eeprom);
eepro100.c:    //~ eeprom93xx_reset(s->eeprom);
eepro100.c:    memcpy(eeprom_contents, s->conf.macaddr.a, 6);
eepro100.c:    if (s->device == i82557B || s->device == i82557C)
eepro100.c:    for (i = 0; i < EEPROM_SIZE - 1; i++) {
eepro100.c:    eeprom_contents[EEPROM_SIZE - 1] = 0xbaba - sum;
eepro100.c:    TRACE(EEPROM, logout("checksum=0x%04x\n", eeprom_contents[EEPROM_SIZE - 1]));
eepro100.c:    memset(s->mem, 0, sizeof(s->mem));
eepro100.c:    memcpy(&s->mem[SCBCtrlMDI], &val, sizeof(val));
eepro100.c:    assert(sizeof(s->mdimem) == sizeof(eepro100_mdi_default));
eepro100.c:    memcpy(&s->mdimem[0], &eepro100_mdi_default[0], sizeof(s->mdimem));
eepro100.c:    uint16_t val = s->status;
eepro100.c:    s->status = val;
eepro100.c:    return ((s->mem[SCBStatus] >> 6) & 0x03);
eepro100.c:    s->mem[SCBStatus] = (s->mem[SCBStatus] & 0x3f) + (state << 6);
eepro100.c:    return ((s->mem[SCBStatus] >> 2) & 0x0f);
eepro100.c:    s->mem[SCBStatus] = (s->mem[SCBStatus] & 0xc3) + (state << 2);
eepro100.c:    cpu_physical_memory_write(s->statsaddr,
eepro100.c:                              (uint8_t *) & s->statistics, s->stats_size);
eepro100.c:    stl_le_phys(s->statsaddr + 0, s->statistics.tx_good_frames);
eepro100.c:    stl_le_phys(s->statsaddr + 36, s->statistics.rx_good_frames);
eepro100.c:    stl_le_phys(s->statsaddr + 48, s->statistics.rx_resource_errors);
eepro100.c:    stl_le_phys(s->statsaddr + 60, s->statistics.rx_short_frame_errors);
eepro100.c:    //~ stw_le_phys(s->statsaddr + 76, s->statistics.xmt_tco_frames);
eepro100.c:    //~ stw_le_phys(s->statsaddr + 78, s->statistics.rcv_tco_frames);
eepro100.c:        uint32_t cb_address = s->cu_base + s->cu_offset;
eepro100.c:        s->cu_offset = le32_to_cpu(tx.link);
eepro100.c:            cpu_physical_memory_read(cb_address + 8, &s->conf.macaddr.a[0], 6);
eepro100.c:            TRACE(OTHER, logout("macaddr: %s\n", nic_dump(&s->macaddr[0], 6)));
eepro100.c:            cpu_physical_memory_read(cb_address + 8, &s->configuration[0],
eepro100.c:                                     sizeof(s->configuration));
eepro100.c:            TRACE(OTHER, logout("configuration: %s\n", nic_dump(&s->configuration[0], 16)));
eepro100.c:                tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);
eepro100.c:                if (s->has_extended_tcb_support && !(s->configuration[6] & BIT(4))) {
eepro100.c:                        tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);
eepro100.c:                    tx_buffer_size = MIN(tx_buffer_size, sizeof(buf) - size);
eepro100.c:            qemu_send_packet(&s->nic->nc, buf, size);
eepro100.c:            s->statistics.tx_good_frames++;
eepro100.c:        s->cu_offset = s->pointer;
eepro100.c:        s->statsaddr = s->pointer;
eepro100.c:        stl_le_phys(s->statsaddr + s->stats_size, 0xa005);
eepro100.c:        s->cu_base = s->pointer;
eepro100.c:        stl_le_phys(s->statsaddr + s->stats_size, 0xa007);
eepro100.c:        memset(&s->statistics, 0, sizeof(s->statistics));
eepro100.c:        s->ru_offset = s->pointer;
eepro100.c:        s->ru_base = s->pointer;
eepro100.c:    s->mem[SCBCmd] = 0;
eepro100.c:    memcpy(&val, &s->mem[SCBeeprom], sizeof(val));
eepro100.c:    if (eeprom93xx_read(s->eeprom)) {
eepro100.c:    //~ val = SET_MASKED(val, 0x31, eeprom->value);
eepro100.c:    s->pointer = le32_to_cpu(val);
eepro100.c:    "Auto-Negotiation Advertisement",
eepro100.c:    "Auto-Negotiation Link Partner Ability",
eepro100.c:    "Auto-Negotiation Expansion"
eepro100.c:    memcpy(&val, &s->mem[0x10], sizeof(val));
eepro100.c:                    s->mdimem[0] = eepro100_mdi_default[0];
eepro100.c:                    s->mdimem[1] = eepro100_mdi_default[1];
eepro100.c:                    data = s->mdimem[reg];
eepro100.c:                data = s->mdimem[reg];
eepro100.c:            case 4:            /* Auto-Negotiation Advertisement Register */
eepro100.c:            case 5:            /* Auto-Negotiation Link Partner Ability Register */
eepro100.c:            case 6:            /* Auto-Negotiation Expansion Register */
eepro100.c:            s->mdimem[reg] = data;
eepro100.c:                    s->mdimem[0] = eepro100_mdi_default[0];
eepro100.c:                    s->mdimem[1] = eepro100_mdi_default[1];
eepro100.c:                s->mdimem[reg] |= 0x0020;
eepro100.c:            case 4:            /* Auto-Negotiation Advertisement Register */
eepro100.c:            case 5:            /* Auto-Negotiation Link Partner Ability Register */
eepro100.c:                s->mdimem[reg] = 0x41fe;
eepro100.c:            case 6:            /* Auto-Negotiation Expansion Register */
eepro100.c:                s->mdimem[reg] = 0x0001;
eepro100.c:            data = s->mdimem[reg];
eepro100.c:        s->mem[SCBAck] |= 0x08;
eepro100.c:    memcpy(&s->mem[0x10], &val, sizeof(val));
eepro100.c:    if (addr <= sizeof(s->mem) - sizeof(val)) {
eepro100.c:        memcpy(&val, &s->mem[addr], sizeof(val));
eepro100.c:    if (addr <= sizeof(s->mem) - sizeof(val)) {
eepro100.c:        memcpy(&val, &s->mem[addr], sizeof(val));
eepro100.c:    if (addr <= sizeof(s->mem) - sizeof(val)) {
eepro100.c:        memcpy(&val, &s->mem[addr], sizeof(val));
eepro100.c:    if (addr <= sizeof(s->mem) - sizeof(val)) {
eepro100.c:        memcpy(&s->mem[addr], &val, sizeof(val));
eepro100.c:        eepro100_write_eeprom(s->eeprom, val);
eepro100.c:    if (addr <= sizeof(s->mem) - sizeof(val)) {
eepro100.c:        memcpy(&s->mem[addr], &val, sizeof(val));
eepro100.c:        eepro100_write_eeprom(s->eeprom, val);
eepro100.c:    if (addr <= sizeof(s->mem) - sizeof(val)) {
eepro100.c:        memcpy(&s->mem[addr], &val, sizeof(val));
eepro100.c:    return eepro100_read1(s, addr - s->region[1]);
eepro100.c:    return eepro100_read2(s, addr - s->region[1]);
eepro100.c:    return eepro100_read4(s, addr - s->region[1]);
eepro100.c:    eepro100_write1(s, addr - s->region[1], val);
eepro100.c:    eepro100_write2(s, addr - s->region[1], val);
eepro100.c:    eepro100_write4(s, addr - s->region[1], val);
eepro100.c:    s->region[region_num] = addr;
eepro100.c:        cpu_register_physical_memory(addr, size, s->mmio_index);
eepro100.c:        s->region[region_num] = addr;
eepro100.c:    EEPRO100State *s = DO_UPCAST(NICState, nc, nc)->opaque;
eepro100.c:     * - Magic packets should set bit 30 in power management driver register.
eepro100.c:     * - Interesting packets should set bit 29 in power management driver register.
eepro100.c:    EEPRO100State *s = DO_UPCAST(NICState, nc, nc)->opaque;
eepro100.c:    if (s->configuration[20] & BIT(6)) {
eepro100.c:        return -1;
eepro100.c:    if (s->configuration[8] & 0x80) {
eepro100.c:        return -1;
eepro100.c:    } else if (size < 64 && (s->configuration[7] & 1)) {
eepro100.c:        s->statistics.rx_short_frame_errors++;
eepro100.c:        //~ return -1;
eepro100.c:    } else if ((size > MAX_ETH_FRAME_SIZE + 4) && !(s->configuration[18] & 8)) {
eepro100.c:        return -1;
eepro100.c:    } else if (memcmp(buf, s->conf.macaddr.a, 6) == 0) {       // !!!
eepro100.c:        if (s->configuration[21] & BIT(3)) {
eepro100.c:        if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7)))) {
eepro100.c:    } else if (s->configuration[15] & 1) {
eepro100.c:        s->statistics.rx_resource_errors++;
eepro100.c:        return -1;
eepro100.c:    cpu_physical_memory_read(s->ru_base + s->ru_offset, (uint8_t *) & rx,
eepro100.c:    stw_phys(s->ru_base + s->ru_offset + offsetof(eepro100_rx_t, status),
eepro100.c:    stw_phys(s->ru_base + s->ru_offset + offsetof(eepro100_rx_t, count), size);
eepro100.c:    if (s->configuration[18] & 4) {
eepro100.c:        return -1;
eepro100.c:    //~ assert(!(s->configuration[17] & 1));
eepro100.c:    cpu_physical_memory_write(s->ru_base + s->ru_offset +
eepro100.c:    s->statistics.rx_good_frames++;
eepro100.c:    s->ru_offset = le32_to_cpu(rx.link);
eepro100.c:    EEPRO100State *s = DO_UPCAST(NICState, nc, nc)->opaque;
eepro100.c:    s->nic = NULL;
eepro100.c:    cpu_unregister_io_memory(s->mmio_index);
eepro100.c:    vmstate_unregister(s->vmstate, s);
eepro100.c:    eeprom93xx_free(s->eeprom);
eepro100.c:    qemu_del_vlan_client(&s->nic->nc);
eepro100.c:    s->device = device;
eepro100.c:    s->eeprom = eeprom93xx_new(EEPROM_SIZE);
eepro100.c:    /* Handler for memory-mapped I/O */
eepro100.c:    s->mmio_index =
eepro100.c:    pci_register_bar(&s->dev, 0, PCI_MEM_SIZE,
eepro100.c:    pci_register_bar(&s->dev, 1, PCI_IO_SIZE, PCI_BASE_ADDRESS_SPACE_IO,
eepro100.c:    pci_register_bar(&s->dev, 2, PCI_FLASH_SIZE, PCI_BASE_ADDRESS_SPACE_MEMORY,
eepro100.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
eepro100.c:    logout("macaddr: %s\n", nic_dump(&s->macaddr[0], 6));
eepro100.c:    assert(s->region[1] == 0);
eepro100.c:    s->nic = qemu_new_nic(&net_eepro100_info, &s->conf,
eepro100.c:                          pci_dev->qdev.info->name, pci_dev->qdev.id, s);
eepro100.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
eepro100.c:    TRACE(OTHER, logout("%s\n", s->nic->nc.info_str));
eepro100.c:    s->vmstate = qemu_malloc(sizeof(vmstate_eepro100));
eepro100.c:    memcpy(s->vmstate, &vmstate_eepro100, sizeof(vmstate_eepro100));
eepro100.c:    s->vmstate->name = s->nic->nc.model;
eepro100.c:    vmstate_register(-1, s->vmstate, s);
eepro100.c:    if (!pci_dev->qdev.hotplugged) {
eepro100.c:            snprintf(fname, sizeof(fname), "pxe-%s.bin", s->nic->nc.model);
eeprom93xx.c: * Copyright (c) 2006-2007 Stefan Weil
eeprom93xx.c: * NMC93C06 256-Bit (16 x 16)
eeprom93xx.c: * NMC93C46 1024-Bit (64 x 16)
eeprom93xx.c: * eeprom93xx_new   - add a new EEPROM (with 16, 64 or 256 words)
eeprom93xx.c: * eeprom93xx_free  - destroy EEPROM
eeprom93xx.c: * eeprom93xx_read  - read data from the EEPROM
eeprom93xx.c: * eeprom93xx_write - write data to the EEPROM
eeprom93xx.c: * eeprom93xx_data  - get EEPROM data array for external manipulation
eeprom93xx.c: * - No emulation of EEPROM timings.
eeprom93xx.c:#define logout(fmt, ...) fprintf(stderr, "EEPROM\t%-24s" fmt, __func__, ## __VA_ARGS__)
eeprom93xx.c:    uint8_t tick = eeprom->tick;
eeprom93xx.c:    uint8_t eedo = eeprom->eedo;
eeprom93xx.c:    uint16_t address = eeprom->address;
eeprom93xx.c:    uint8_t command = eeprom->command;
eeprom93xx.c:    if (! eeprom->eecs && eecs) {
eeprom93xx.c:    } else if (eeprom->eecs && ! eecs) {
eeprom93xx.c:        if (eeprom->writeable) {
eeprom93xx.c:            uint8_t subcommand = address >> (eeprom->addrbits - 2);
eeprom93xx.c:                for (address = 0; address < eeprom->size; address++) {
eeprom93xx.c:                    eeprom->contents[address] = 0xffff;
eeprom93xx.c:                eeprom->contents[address] = 0xffff;
eeprom93xx.c:            } else if (tick >= 2 + 2 + eeprom->addrbits + 16) {
eeprom93xx.c:                    eeprom->contents[address] &= eeprom->data;
eeprom93xx.c:                    for (address = 0; address < eeprom->size; address++) {
eeprom93xx.c:                        eeprom->contents[address] &= eeprom->data;
eeprom93xx.c:    } else if (eecs && ! eeprom->eesk && eesk) {
eeprom93xx.c:        } else if (tick < 2 + 2 + eeprom->addrbits) {
eeprom93xx.c:            if (tick == 2 + 2 + eeprom->addrbits) {
eeprom93xx.c:                       opstring[command], address, eeprom->contents[address]);
eeprom93xx.c:                address = address % eeprom->size;
eeprom93xx.c:                    switch (address >> (eeprom->addrbits - 2)) {
eeprom93xx.c:                            eeprom->writeable = 0;
eeprom93xx.c:                            eeprom->writeable = 1;
eeprom93xx.c:                    eeprom->data = eeprom->contents[address];
eeprom93xx.c:        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {
eeprom93xx.c:                eedo = ((eeprom->data & 0x8000) != 0);
eeprom93xx.c:            eeprom->data <<= 1;
eeprom93xx.c:            eeprom->data += eedi;
eeprom93xx.c:    eeprom->tick = tick;
eeprom93xx.c:    eeprom->eecs = eecs;
eeprom93xx.c:    eeprom->eesk = eesk;
eeprom93xx.c:    eeprom->eedo = eedo;
eeprom93xx.c:    eeprom->address = address;
eeprom93xx.c:    eeprom->command = command;
eeprom93xx.c:    logout("CS=%u DO=%u\n", eeprom->eecs, eeprom->eedo);
eeprom93xx.c:    return (eeprom->eedo);
eeprom93xx.c:    eeprom->tick = 0;
eeprom93xx.c:    eeprom->command = 0;
eeprom93xx.c:    eeprom->size = nwords;
eeprom93xx.c:    eeprom->addrbits = addrbits;
eeprom93xx.c:    eeprom->eedo = 1;
eeprom93xx.c:    return &eeprom->contents[0];
eeprom93xx.h: * Copyright (c) 2006-2007 Stefan Weil
elf_ops.h:    bswap16s(&ehdr->e_type);			/* Object file type */
elf_ops.h:    bswap16s(&ehdr->e_machine);		/* Architecture */
elf_ops.h:    bswap32s(&ehdr->e_version);		/* Object file version */
elf_ops.h:    bswapSZs(&ehdr->e_entry);		/* Entry point virtual address */
elf_ops.h:    bswapSZs(&ehdr->e_phoff);		/* Program header table file offset */
elf_ops.h:    bswapSZs(&ehdr->e_shoff);		/* Section header table file offset */
elf_ops.h:    bswap32s(&ehdr->e_flags);		/* Processor-specific flags */
elf_ops.h:    bswap16s(&ehdr->e_ehsize);		/* ELF header size in bytes */
elf_ops.h:    bswap16s(&ehdr->e_phentsize);		/* Program header table entry size */
elf_ops.h:    bswap16s(&ehdr->e_phnum);		/* Program header table entry count */
elf_ops.h:    bswap16s(&ehdr->e_shentsize);		/* Section header table entry size */
elf_ops.h:    bswap16s(&ehdr->e_shnum);		/* Section header table entry count */
elf_ops.h:    bswap16s(&ehdr->e_shstrndx);		/* Section header string table index */
elf_ops.h:    bswap32s(&phdr->p_type);			/* Segment type */
elf_ops.h:    bswapSZs(&phdr->p_offset);		/* Segment file offset */
elf_ops.h:    bswapSZs(&phdr->p_vaddr);		/* Segment virtual address */
elf_ops.h:    bswapSZs(&phdr->p_paddr);		/* Segment physical address */
elf_ops.h:    bswapSZs(&phdr->p_filesz);		/* Segment size in file */
elf_ops.h:    bswapSZs(&phdr->p_memsz);		/* Segment size in memory */
elf_ops.h:    bswap32s(&phdr->p_flags);		/* Segment flags */
elf_ops.h:    bswapSZs(&phdr->p_align);		/* Segment alignment */
elf_ops.h:    bswap32s(&shdr->sh_name);
elf_ops.h:    bswap32s(&shdr->sh_type);
elf_ops.h:    bswapSZs(&shdr->sh_flags);
elf_ops.h:    bswapSZs(&shdr->sh_addr);
elf_ops.h:    bswapSZs(&shdr->sh_offset);
elf_ops.h:    bswapSZs(&shdr->sh_size);
elf_ops.h:    bswap32s(&shdr->sh_link);
elf_ops.h:    bswap32s(&shdr->sh_info);
elf_ops.h:    bswapSZs(&shdr->sh_addralign);
elf_ops.h:    bswapSZs(&shdr->sh_entsize);
elf_ops.h:    bswap32s(&sym->st_name);
elf_ops.h:    bswapSZs(&sym->st_value);
elf_ops.h:    bswapSZs(&sym->st_size);
elf_ops.h:    bswap16s(&sym->st_shndx);
elf_ops.h:    if (key->st_value < sym->st_value) {
elf_ops.h:        result = -1;
elf_ops.h:    } else if (key->st_value >= sym->st_value + sym->st_size) {
elf_ops.h:    struct elf_sym *syms = glue(s->disas_symtab.elf, SZ);
elf_ops.h:    sym = bsearch(&key, syms, s->disas_num_syms, sizeof(*syms), glue(symfind, SZ));
elf_ops.h:        return s->disas_strtab + sym->st_name;
elf_ops.h:    return (sym0->st_value < sym1->st_value)
elf_ops.h:        ? -1
elf_ops.h:        : ((sym0->st_value > sym1->st_value) ? 1 : 0);
elf_ops.h:    shdr_table = load_at(fd, ehdr->e_shoff,
elf_ops.h:                         sizeof(struct elf_shdr) * ehdr->e_shnum);
elf_ops.h:        return -1;
elf_ops.h:        for (i = 0; i < ehdr->e_shnum; i++) {
elf_ops.h:    symtab = glue(find_section, SZ)(shdr_table, ehdr->e_shnum, SHT_SYMTAB);
elf_ops.h:    syms = load_at(fd, symtab->sh_offset, symtab->sh_size);
elf_ops.h:    nsyms = symtab->sh_size / sizeof(struct elf_sym);
elf_ops.h:            nsyms--;
elf_ops.h:    if (symtab->sh_link >= ehdr->e_shnum)
elf_ops.h:    strtab = &shdr_table[symtab->sh_link];
elf_ops.h:    str = load_at(fd, strtab->sh_offset, strtab->sh_size);
elf_ops.h:    s->lookup_symbol = glue(lookup_symbol, SZ);
elf_ops.h:    glue(s->disas_symtab.elf, SZ) = syms;
elf_ops.h:    s->disas_num_syms = nsyms;
elf_ops.h:    s->disas_strtab = str;
elf_ops.h:    s->next = syminfos;
elf_ops.h:    return -1;
elf_ops.h:    uint64_t addr, low = (uint64_t)-1, high = 0;
elf_ops.h:        if (ph->p_type == PT_LOAD) {
elf_ops.h:            mem_size = ph->p_memsz;
elf_ops.h:            if (ph->p_filesz > 0) {
elf_ops.h:                if (lseek(fd, ph->p_offset, SEEK_SET) < 0)
elf_ops.h:                if (read(fd, data, ph->p_filesz) != ph->p_filesz)
elf_ops.h:            addr = ph->p_paddr + address_offset;
elf_ops.h:    return -1;
es1370.c:  Copyright (C) 1998-2001, 2003 Thomas Sailer (t.sailer@alumni.ethz.ch)
es1370.c:#define DAC2_SRTODIV(x) (((1411200+(x)/2)/(x))-2)
es1370.c:    AUD_log ("es1370", "ctl - PCLKDIV %d(DAC2 freq %d), freq %d,%s\n",
es1370.c:        s->status = new_status | STAT_INTR;
es1370.c:        s->status = new_status & ~STAT_INTR;
es1370.c:    qemu_set_irq (s->dev.irq[0], !!level);
es1370.c:    s->ctl = 1;
es1370.c:    s->status = 0x60;
es1370.c:    s->mempage = 0;
es1370.c:    s->codec = 0;
es1370.c:    s->sctl = 0;
es1370.c:        struct chan *d = &s->chan[i];
es1370.c:        d->scount = 0;
es1370.c:        d->leftover = 0;
es1370.c:            AUD_close_in (&s->card, s->adc_voice);
es1370.c:            s->adc_voice = NULL;
es1370.c:            AUD_close_out (&s->card, s->dac_voice[i]);
es1370.c:            s->dac_voice[i] = NULL;
es1370.c:    qemu_irq_lower (s->dev.irq[0]);
es1370.c:    uint32_t new_status = s->status;
es1370.c:    if (!(sctl & SCTRL_P1INTEN) && (s->sctl & SCTRL_P1INTEN)) {
es1370.c:    if (!(sctl & SCTRL_P2INTEN) && (s->sctl & SCTRL_P2INTEN)) {
es1370.c:    if (!(sctl & SCTRL_R1INTEN) && (s->sctl & SCTRL_R1INTEN)) {
es1370.c:    if (new_status != s->status) {
es1370.c:    *old_freq = dac1_samplerate[(s->ctl & CTRL_WTSRSEL) >> CTRL_SH_WTSRSEL];
es1370.c:    old_pclkdiv = (s->ctl & CTRL_PCLKDIV) >> CTRL_SH_PCLKDIV;
es1370.c:        struct chan *d = &s->chan[i];
es1370.c:        new_fmt = (sctl & b->sctl_fmt) >> b->sctl_sh_fmt;
es1370.c:        old_fmt = (s->sctl & b->sctl_fmt) >> b->sctl_sh_fmt;
es1370.c:        b->calc_freq (s, ctl, &old_freq, &new_freq);
es1370.c:            d->shift = (new_fmt & 1) + (new_fmt >> 1);
es1370.c:                    d->shift);
es1370.c:                    s->adc_voice =
es1370.c:                            &s->card,
es1370.c:                            s->adc_voice,
es1370.c:                    s->dac_voice[i] =
es1370.c:                            &s->card,
es1370.c:                            s->dac_voice[i],
es1370.c:        if (((ctl ^ s->ctl) & b->ctl_en)
es1370.c:            || ((sctl ^ s->sctl) & b->sctl_pause)) {
es1370.c:            int on = (ctl & b->ctl_en) && !(sctl & b->sctl_pause);
es1370.c:                AUD_set_active_in (s->adc_voice, on);
es1370.c:                AUD_set_active_out (s->dac_voice[i], on);
es1370.c:    s->ctl = ctl;
es1370.c:    s->sctl = sctl;
es1370.c:        addr |= s->mempage << 8;
es1370.c:        shift = (addr - ES1370_REG_CONTROL) << 3;
es1370.c:        val = (s->ctl & ~mask) | ((val & 0xff) << shift);
es1370.c:        es1370_update_voices (s, val, s->sctl);
es1370.c:        s->mempage = val;
es1370.c:        shift = (addr - ES1370_REG_SERIAL_CONTROL) << 3;
es1370.c:        val = (s->sctl & ~mask) | ((val & 0xff) << shift);
es1370.c:        es1370_update_voices (s, s->ctl, val);
es1370.c:        lwarn ("writeb %#x <- %#x\n", addr, val);
es1370.c:    struct chan *d = &s->chan[0];
es1370.c:        s->codec = val;
es1370.c:        val = (s->ctl & ~mask) | ((val & 0xffff) << shift);
es1370.c:        es1370_update_voices (s, val, s->sctl);
es1370.c:        d->scount = (d->scount & ~0xffff) | (val & 0xffff);
es1370.c:        lwarn ("writew %#x <- %#x\n", addr, val);
es1370.c:    struct chan *d = &s->chan[0];
es1370.c:        es1370_update_voices (s, val, s->sctl);
es1370.c:        s->mempage = val & 0xf;
es1370.c:        es1370_update_voices (s, s->ctl, val);
es1370.c:        d->scount = (val & 0xffff) | (d->scount & ~0xffff);
es1370.c:                d - &s->chan[0], val >> 16, (val & 0xffff));
es1370.c:        d->frame_addr = val;
es1370.c:        ldebug ("chan %d frame address %#x\n", d - &s->chan[0], val);
es1370.c:        d->frame_cnt = val;
es1370.c:        d->leftover = 0;
es1370.c:                d - &s->chan[0], val >> 16, val & 0xffff);
es1370.c:        lwarn ("writel %#x <- %#x\n", addr, val);
es1370.c:        val = s->mempage;
es1370.c:        val = s->ctl >> ((addr - ES1370_REG_CONTROL) << 3);
es1370.c:        val = s->status >> ((addr - ES1370_REG_STATUS) << 3);
es1370.c:        lwarn ("readb %#x -> %#x\n", addr, val);
es1370.c:    struct chan *d = &s->chan[0];
es1370.c:        val = d->scount >> 16;
es1370.c:        val = d->frame_cnt & 0xffff;
es1370.c:        val = d->frame_cnt >> 16;
es1370.c:        lwarn ("readw %#x -> %#x\n", addr, val);
es1370.c:    struct chan *d = &s->chan[0];
es1370.c:        val = s->ctl;
es1370.c:        val = s->status;
es1370.c:        val = s->mempage;
es1370.c:        val = s->codec;
es1370.c:        val = s->sctl;
es1370.c:        val = d->scount;
es1370.c:            uint32_t curr_count = d->scount >> 16;
es1370.c:            uint32_t count = d->scount & 0xffff;
es1370.c:            curr_count <<= d->shift;
es1370.c:            count <<= d->shift;
es1370.c:        val = d->frame_cnt;
es1370.c:            uint32_t size = ((d->frame_cnt & 0xffff) + 1) << 2;
es1370.c:            uint32_t curr = ((d->frame_cnt >> 16) + 1) << 2;
es1370.c:        val = d->frame_addr;
es1370.c:        lwarn ("readl %#x -> %#x\n", addr, val);
es1370.c:    uint32_t addr = d->frame_addr;
es1370.c:    int sc = d->scount & 0xffff;
es1370.c:    int csc = d->scount >> 16;
es1370.c:    int csc_bytes = (csc + 1) << d->shift;
es1370.c:    int cnt = d->frame_cnt >> 16;
es1370.c:    int size = d->frame_cnt & 0xffff;
es1370.c:    int left = ((size - cnt + 1) << 2) + d->leftover;
es1370.c:    int index = d - &s->chan[0];
es1370.c:    addr += (cnt << 2) + d->leftover;
es1370.c:            acquired = AUD_read (s->adc_voice, tmpbuf, to_copy);
es1370.c:            temp -= acquired;
es1370.c:        SWVoiceOut *voice = s->dac_voice[index];
es1370.c:            temp -= copied;
es1370.c:        d->scount = sc | (sc << 16);
es1370.c:                (sc + 1) << d->shift,
es1370.c:        d->scount = sc | (((csc_bytes - transfered - 1) >> d->shift) << 16);
es1370.c:    cnt += (transfered + d->leftover) >> 2;
es1370.c:    if (s->sctl & loop_sel) {
es1370.c:        d->frame_cnt = size;
es1370.c:        if ((uint32_t) cnt <= d->frame_cnt)
es1370.c:            d->frame_cnt |= cnt << 16;
es1370.c:    d->leftover = (transfered + d->leftover) & 3;
es1370.c:    uint32_t new_status = s->status;
es1370.c:    struct chan *d = &s->chan[chan];
es1370.c:    if (!(s->ctl & b->ctl_en) || (s->sctl & b->sctl_pause)) {
es1370.c:    max_bytes &= ~((1 << d->shift) - 1);
es1370.c:    es1370_transfer_audio (s, d, b->sctl_loopsel, max_bytes, &irq);
es1370.c:        if (s->sctl & b->sctl_inten) {
es1370.c:            new_status |= b->stat_int;
es1370.c:    if (new_status != s->status) {
es1370.c:            if (s->adc_voice) {
es1370.c:                AUD_close_in (&s->card, s->adc_voice);
es1370.c:                s->adc_voice = NULL;
es1370.c:            if (s->dac_voice[i]) {
es1370.c:                AUD_close_out (&s->card, s->dac_voice[i]);
es1370.c:                s->dac_voice[i] = NULL;
es1370.c:    ctl = s->ctl;
es1370.c:    sctl = s->sctl;
es1370.c:    s->ctl = 0;
es1370.c:    s->sctl = 0;
es1370.c:    uint8_t *c = s->dev.config;
es1370.c:    pci_register_bar (&s->dev, 0, 256, PCI_BASE_ADDRESS_SPACE_IO, es1370_map);
es1370.c:    AUD_register_card ("es1370", &s->card);
es1370.c:    pci_create_simple (bus, -1, "ES1370");
escc.c: * Copyright (c) 2003-2005 Fabrice Bellard
escc.c:#include "qemu-char.h"
escc.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C105.txt
escc.c: *  2006-Aug-10  Igor Kovalenko :   Renamed KBDQueue to SERIOQueue, implemented
escc.c:#define CHN_C(s) ((s)->chn == chn_b? 'b' : 'a')
escc.c:    SERIOQueue *q = &s->queue;
escc.c:    q->rptr = q->wptr = q->count = 0;
escc.c:    SERIOQueue *q = &s->queue;
escc.c:    if (q->count >= SERIO_QUEUE_SIZE)
escc.c:    q->data[q->wptr] = b;
escc.c:    if (++q->wptr == SERIO_QUEUE_SIZE)
escc.c:        q->wptr = 0;
escc.c:    q->count++;
escc.c:    SERIOQueue *q = &s->queue;
escc.c:    if (q->count == 0) {
escc.c:        val = q->data[q->rptr];
escc.c:        if (++q->rptr == SERIO_QUEUE_SIZE)
escc.c:            q->rptr = 0;
escc.c:        q->count--;
escc.c:    if (q->count > 0)
escc.c:    if ((((s->wregs[W_INTR] & INTR_TXINT) && s->txint == 1) ||
escc.c:         ((((s->wregs[W_INTR] & INTR_RXMODEMSK) == INTR_RXINT1ST) ||
escc.c:           ((s->wregs[W_INTR] & INTR_RXMODEMSK) == INTR_RXINTALL)) &&
escc.c:          s->rxint == 1) || // rx ints enabled, pending
escc.c:         ((s->wregs[W_EXTINT] & EXTINT_BRKINT) &&
escc.c:          (s->rregs[R_STATUS] & STATUS_BRK)))) { // break int e&p
escc.c:    irq |= escc_update_irq_chn(s->otherchn);
escc.c:    qemu_set_irq(s->irq, irq);
escc.c:    s->reg = 0;
escc.c:        s->rregs[i] = 0;
escc.c:        s->wregs[i] = 0;
escc.c:    s->wregs[W_TXCTRL1] = TXCTRL1_1STOP; // 1X divisor, 1 stop bit, no parity
escc.c:    s->wregs[W_MINTR] = MINTR_RST_ALL;
escc.c:    s->wregs[W_CLOCK] = CLOCK_TRXC; // Synch mode tx clock = TRxC
escc.c:    s->wregs[W_MISC2] = MISC2_PLLDIS; // PLL disabled
escc.c:    s->wregs[W_EXTINT] = EXTINT_DCD | EXTINT_SYNCINT | EXTINT_CTSINT |
escc.c:    if (s->disabled)
escc.c:        s->rregs[R_STATUS] = STATUS_TXEMPTY | STATUS_DCD | STATUS_SYNC |
escc.c:        s->rregs[R_STATUS] = STATUS_TXEMPTY | STATUS_TXUNDRN;
escc.c:    s->rregs[R_SPEC] = SPEC_BITS8 | SPEC_ALLSENT;
escc.c:    s->rx = s->tx = 0;
escc.c:    s->rxint = s->txint = 0;
escc.c:    s->rxint_under_svc = s->txint_under_svc = 0;
escc.c:    s->e0_mode = s->led_mode = s->caps_lock_mode = s->num_lock_mode = 0;
escc.c:    escc_reset_chn(&s->chn[0]);
escc.c:    escc_reset_chn(&s->chn[1]);
escc.c:    s->rxint = 1;
escc.c:    if (!s->txint_under_svc) {
escc.c:        s->rxint_under_svc = 1;
escc.c:        if (s->chn == chn_a) {
escc.c:            if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:                s->otherchn->rregs[R_IVEC] = IVEC_HIRXINTA;
escc.c:                s->otherchn->rregs[R_IVEC] = IVEC_LORXINTA;
escc.c:            if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:                s->rregs[R_IVEC] = IVEC_HIRXINTB;
escc.c:                s->rregs[R_IVEC] = IVEC_LORXINTB;
escc.c:    if (s->chn == chn_a)
escc.c:        s->rregs[R_INTR] |= INTR_RXINTA;
escc.c:        s->otherchn->rregs[R_INTR] |= INTR_RXINTB;
escc.c:    s->txint = 1;
escc.c:    if (!s->rxint_under_svc) {
escc.c:        s->txint_under_svc = 1;
escc.c:        if (s->chn == chn_a) {
escc.c:            if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:                s->otherchn->rregs[R_IVEC] = IVEC_HITXINTA;
escc.c:                s->otherchn->rregs[R_IVEC] = IVEC_LOTXINTA;
escc.c:            s->rregs[R_IVEC] = IVEC_TXINTB;
escc.c:    if (s->chn == chn_a)
escc.c:        s->rregs[R_INTR] |= INTR_TXINTA;
escc.c:        s->otherchn->rregs[R_INTR] |= INTR_TXINTB;
escc.c:    s->rxint = 0;
escc.c:    s->rxint_under_svc = 0;
escc.c:    if (s->chn == chn_a) {
escc.c:        if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:            s->otherchn->rregs[R_IVEC] = IVEC_HINOINT;
escc.c:            s->otherchn->rregs[R_IVEC] = IVEC_LONOINT;
escc.c:        s->rregs[R_INTR] &= ~INTR_RXINTA;
escc.c:        if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:            s->rregs[R_IVEC] = IVEC_HINOINT;
escc.c:            s->rregs[R_IVEC] = IVEC_LONOINT;
escc.c:        s->otherchn->rregs[R_INTR] &= ~INTR_RXINTB;
escc.c:    if (s->txint)
escc.c:    s->txint = 0;
escc.c:    s->txint_under_svc = 0;
escc.c:    if (s->chn == chn_a) {
escc.c:        if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:            s->otherchn->rregs[R_IVEC] = IVEC_HINOINT;
escc.c:            s->otherchn->rregs[R_IVEC] = IVEC_LONOINT;
escc.c:        s->rregs[R_INTR] &= ~INTR_TXINTA;
escc.c:        if (s->wregs[W_MINTR] & MINTR_STATUSHI)
escc.c:            s->rregs[R_IVEC] = IVEC_HINOINT;
escc.c:            s->rregs[R_IVEC] = IVEC_LONOINT;
escc.c:        s->otherchn->rregs[R_INTR] &= ~INTR_TXINTB;
escc.c:    if (s->rxint)
escc.c:    if (!s->chr || s->type != ser)
escc.c:    if (s->wregs[W_TXCTRL1] & TXCTRL1_PAREN) {
escc.c:        if (s->wregs[W_TXCTRL1] & TXCTRL1_PAREV)
escc.c:    if ((s->wregs[W_TXCTRL1] & TXCTRL1_STPMSK) == TXCTRL1_2STOP)
escc.c:    switch (s->wregs[W_TXCTRL2] & TXCTRL2_BITMSK) {
escc.c:    speed = s->clock / ((s->wregs[W_BRGLO] | (s->wregs[W_BRGHI] << 8)) + 2);
escc.c:    switch (s->wregs[W_TXCTRL1] & TXCTRL1_CLKMSK) {
escc.c:    qemu_chr_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);
escc.c:    saddr = (addr >> serial->it_shift) & 1;
escc.c:    channel = (addr >> (serial->it_shift + 1)) & 1;
escc.c:    s = &serial->chn[channel];
escc.c:        SER_DPRINTF("Write channel %c, reg[%d] = %2.2x\n", CHN_C(s), s->reg,
escc.c:        switch (s->reg) {
escc.c:                if (s->rxint_under_svc)
escc.c:                else if (s->txint_under_svc)
escc.c:            s->wregs[s->reg] = val;
escc.c:            s->wregs[s->reg] = val;
escc.c:            s->wregs[s->reg] = val;
escc.c:            s->rregs[s->reg] = val;
escc.c:                escc_reset_chn(&serial->chn[0]);
escc.c:                escc_reset_chn(&serial->chn[1]);
escc.c:                escc_reset(&serial->busdev.qdev);
escc.c:        if (s->reg == 0)
escc.c:            s->reg = newreg;
escc.c:            s->reg = 0;
escc.c:        s->tx = val;
escc.c:        if (s->wregs[W_TXCTRL2] & TXCTRL2_TXEN) { // tx enabled
escc.c:            if (s->chr)
escc.c:                qemu_chr_write(s->chr, &s->tx, 1);
escc.c:            else if (s->type == kbd && !s->disabled) {
escc.c:        s->rregs[R_STATUS] |= STATUS_TXEMPTY; // Tx buffer empty
escc.c:        s->rregs[R_SPEC] |= SPEC_ALLSENT; // All sent
escc.c:    saddr = (addr >> serial->it_shift) & 1;
escc.c:    channel = (addr >> (serial->it_shift + 1)) & 1;
escc.c:    s = &serial->chn[channel];
escc.c:        SER_DPRINTF("Read channel %c, reg[%d] = %2.2x\n", CHN_C(s), s->reg,
escc.c:                    s->rregs[s->reg]);
escc.c:        ret = s->rregs[s->reg];
escc.c:        s->reg = 0;
escc.c:        s->rregs[R_STATUS] &= ~STATUS_RXAV;
escc.c:        if (s->type == kbd || s->type == mouse)
escc.c:            ret = s->rx;
escc.c:        if (s->chr)
escc.c:            qemu_chr_accept_input(s->chr);
escc.c:    if (((s->wregs[W_RXCTRL] & RXCTRL_RXEN) == 0) // Rx not enabled
escc.c:        || ((s->rregs[R_STATUS] & STATUS_RXAV) == STATUS_RXAV))
escc.c:    s->rregs[R_STATUS] |= STATUS_RXAV;
escc.c:    s->rx = ch;
escc.c:    s->rregs[R_STATUS] |= STATUS_BRK;
escc.c:    return d->mmio_index;
escc.c:        s->caps_lock_mode ^= 1;
escc.c:        if (s->caps_lock_mode == 2)
escc.c:        s->num_lock_mode ^= 1;
escc.c:        if (s->num_lock_mode == 2)
escc.c:        s->caps_lock_mode ^= 2;
escc.c:        if (s->caps_lock_mode == 3)
escc.c:        s->num_lock_mode ^= 2;
escc.c:        if (s->num_lock_mode == 3)
escc.c:        s->e0_mode = 1;
escc.c:    if (s->e0_mode) {
escc.c:        s->e0_mode = 0;
escc.c:    if (s->led_mode) { // Ignore led byte
escc.c:        s->led_mode = 0;
escc.c:        s->led_mode = 1;
escc.c:    else if (ch < -127)
escc.c:        ch = -127;
escc.c:    ch = -dy;
escc.c:    else if (ch < -127)
escc.c:        ch = -127;
escc.c:    s->chn[0].disabled = s->disabled;
escc.c:    s->chn[1].disabled = s->disabled;
escc.c:        sysbus_init_irq(dev, &s->chn[i].irq);
escc.c:        s->chn[i].chn = 1 - i;
escc.c:        s->chn[i].clock = s->frequency / 2;
escc.c:        if (s->chn[i].chr) {
escc.c:            qemu_chr_add_handlers(s->chn[i].chr, serial_can_receive,
escc.c:                                  serial_receive1, serial_event, &s->chn[i]);
escc.c:    s->chn[0].otherchn = &s->chn[1];
escc.c:    s->chn[1].otherchn = &s->chn[0];
escc.c:    sysbus_init_mmio(dev, ESCC_SIZE << s->it_shift, io);
escc.c:    s->mmio_index = io;
escc.c:    if (s->chn[0].type == mouse) {
escc.c:        qemu_add_mouse_event_handler(sunmouse_event, &s->chn[0], 0,
escc.c:    if (s->chn[1].type == kbd) {
escc.c:        qemu_add_kbd_event_handler(sunkbd_event, &s->chn[1]);
esp.c: * Copyright (c) 2005-2006 Fabrice Bellard
esp.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C100.txt
esp.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR53C9X.txt
esp.c:    if (!(s->rregs[ESP_RSTAT] & STAT_INT)) {
esp.c:        s->rregs[ESP_RSTAT] |= STAT_INT;
esp.c:        qemu_irq_raise(s->irq);
esp.c:    if (s->rregs[ESP_RSTAT] & STAT_INT) {
esp.c:        s->rregs[ESP_RSTAT] &= ~STAT_INT;
esp.c:        qemu_irq_lower(s->irq);
esp.c:    target = s->wregs[ESP_WBUSID] & BUSID_DID;
esp.c:    if (s->dma) {
esp.c:        dmalen = s->rregs[ESP_TCLO] | (s->rregs[ESP_TCMID] << 8);
esp.c:        s->dma_memory_read(s->dma_opaque, buf, dmalen);
esp.c:        dmalen = s->ti_size;
esp.c:        memcpy(buf, s->ti_buf, dmalen);
esp.c:    s->ti_size = 0;
esp.c:    s->ti_rptr = 0;
esp.c:    s->ti_wptr = 0;
esp.c:    if (s->current_dev) {
esp.c:        s->current_dev->info->cancel_io(s->current_dev, 0);
esp.c:        s->async_len = 0;
esp.c:    if (target >= ESP_MAX_DEVS || !s->bus.devs[target]) {
esp.c:        s->rregs[ESP_RSTAT] = 0;
esp.c:        s->rregs[ESP_RINTR] = INTR_DC;
esp.c:        s->rregs[ESP_RSEQ] = SEQ_0;
esp.c:    s->current_dev = s->bus.devs[target];
esp.c:    datalen = s->current_dev->info->send_command(s->current_dev, 0, buf, lun);
esp.c:    s->ti_size = datalen;
esp.c:        s->rregs[ESP_RSTAT] = STAT_TC;
esp.c:        s->dma_left = 0;
esp.c:        s->dma_counter = 0;
esp.c:            s->rregs[ESP_RSTAT] |= STAT_DI;
esp.c:            s->current_dev->info->read_data(s->current_dev, 0);
esp.c:            s->rregs[ESP_RSTAT] |= STAT_DO;
esp.c:            s->current_dev->info->write_data(s->current_dev, 0);
esp.c:    s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;
esp.c:    s->rregs[ESP_RSEQ] = SEQ_CD;
esp.c:    s->cmdlen = get_cmd(s, s->cmdbuf);
esp.c:    if (s->cmdlen) {
esp.c:        DPRINTF("Set ATN & Stop: cmdlen %d\n", s->cmdlen);
esp.c:        s->do_cmd = 1;
esp.c:        s->rregs[ESP_RSTAT] = STAT_TC | STAT_CD;
esp.c:        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;
esp.c:        s->rregs[ESP_RSEQ] = SEQ_CD;
esp.c:    DPRINTF("Transfer status (sense=%d)\n", s->sense);
esp.c:    s->ti_buf[0] = s->sense;
esp.c:    s->ti_buf[1] = 0;
esp.c:    if (s->dma) {
esp.c:        s->dma_memory_write(s->dma_opaque, s->ti_buf, 2);
esp.c:        s->rregs[ESP_RSTAT] = STAT_TC | STAT_ST;
esp.c:        s->rregs[ESP_RINTR] = INTR_BS | INTR_FC;
esp.c:        s->rregs[ESP_RSEQ] = SEQ_CD;
esp.c:        s->ti_size = 2;
esp.c:        s->ti_rptr = 0;
esp.c:        s->ti_wptr = 0;
esp.c:        s->rregs[ESP_RFLAGS] = 2;
esp.c:    s->rregs[ESP_RSTAT] |= STAT_TC;
esp.c:    s->rregs[ESP_RINTR] = INTR_BS;
esp.c:    s->rregs[ESP_RSEQ] = 0;
esp.c:    s->rregs[ESP_RFLAGS] = 0;
esp.c:    s->rregs[ESP_TCLO] = 0;
esp.c:    s->rregs[ESP_TCMID] = 0;
esp.c:    to_device = (s->ti_size < 0);
esp.c:    len = s->dma_left;
esp.c:    if (s->do_cmd) {
esp.c:        DPRINTF("command len %d + %d\n", s->cmdlen, len);
esp.c:        s->dma_memory_read(s->dma_opaque, &s->cmdbuf[s->cmdlen], len);
esp.c:        s->ti_size = 0;
esp.c:        s->cmdlen = 0;
esp.c:        s->do_cmd = 0;
esp.c:        do_cmd(s, s->cmdbuf);
esp.c:    if (s->async_len == 0) {
esp.c:    if (len > s->async_len) {
esp.c:        len = s->async_len;
esp.c:        s->dma_memory_read(s->dma_opaque, s->async_buf, len);
esp.c:        s->dma_memory_write(s->dma_opaque, s->async_buf, len);
esp.c:    s->dma_left -= len;
esp.c:    s->async_buf += len;
esp.c:    s->async_len -= len;
esp.c:        s->ti_size += len;
esp.c:        s->ti_size -= len;
esp.c:    if (s->async_len == 0) {
esp.c:            s->current_dev->info->write_data(s->current_dev, 0);
esp.c:            s->current_dev->info->read_data(s->current_dev, 0);
esp.c:            if (s->dma_left == 0 && s->ti_size > 0) {
esp.c:    ESPState *s = DO_UPCAST(ESPState, busdev.qdev, bus->qbus.parent);
esp.c:        if (s->ti_size != 0)
esp.c:        s->ti_size = 0;
esp.c:        s->dma_left = 0;
esp.c:        s->async_len = 0;
esp.c:        s->sense = arg;
esp.c:        s->rregs[ESP_RSTAT] = STAT_ST;
esp.c:        s->current_dev = NULL;
esp.c:        DPRINTF("transfer %d/%d\n", s->dma_left, s->ti_size);
esp.c:        s->async_len = arg;
esp.c:        s->async_buf = s->current_dev->info->get_buf(s->current_dev, 0);
esp.c:        if (s->dma_left) {
esp.c:        } else if (s->dma_counter != 0 && s->ti_size <= 0) {
esp.c:    dmalen = s->rregs[ESP_TCLO] | (s->rregs[ESP_TCMID] << 8);
esp.c:    s->dma_counter = dmalen;
esp.c:    if (s->do_cmd)
esp.c:    else if (s->ti_size < 0)
esp.c:        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;
esp.c:        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;
esp.c:    if (s->dma) {
esp.c:        s->dma_left = minlen;
esp.c:        s->rregs[ESP_RSTAT] &= ~STAT_TC;
esp.c:    } else if (s->do_cmd) {
esp.c:        DPRINTF("command len %d\n", s->cmdlen);
esp.c:        s->ti_size = 0;
esp.c:        s->cmdlen = 0;
esp.c:        s->do_cmd = 0;
esp.c:        do_cmd(s, s->cmdbuf);
esp.c:    memset(s->rregs, 0, ESP_REGS);
esp.c:    memset(s->wregs, 0, ESP_REGS);
esp.c:    s->rregs[ESP_TCHI] = TCHI_FAS100A; // Indicate fas100a
esp.c:    s->ti_size = 0;
esp.c:    s->ti_rptr = 0;
esp.c:    s->ti_wptr = 0;
esp.c:    s->dma = 0;
esp.c:    s->do_cmd = 0;
esp.c:    s->rregs[ESP_CFG1] = 7;
esp.c:    saddr = addr >> s->it_shift;
esp.c:    DPRINTF("read reg[%d]: 0x%2.2x\n", saddr, s->rregs[saddr]);
esp.c:        if (s->ti_size > 0) {
esp.c:            s->ti_size--;
esp.c:            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {
esp.c:                s->rregs[ESP_FIFO] = 0;
esp.c:                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];
esp.c:        if (s->ti_size == 0) {
esp.c:            s->ti_rptr = 0;
esp.c:            s->ti_wptr = 0;
esp.c:        old_val = s->rregs[ESP_RINTR];
esp.c:        s->rregs[ESP_RINTR] = 0;
esp.c:        s->rregs[ESP_RSTAT] &= ~STAT_TC;
esp.c:        s->rregs[ESP_RSEQ] = SEQ_CD;
esp.c:    return s->rregs[saddr];
esp.c:    saddr = addr >> s->it_shift;
esp.c:    DPRINTF("write reg[%d]: 0x%2.2x -> 0x%2.2x\n", saddr, s->wregs[saddr],
esp.c:        s->rregs[ESP_RSTAT] &= ~STAT_TC;
esp.c:        if (s->do_cmd) {
esp.c:            s->cmdbuf[s->cmdlen++] = val & 0xff;
esp.c:        } else if (s->ti_size == TI_BUFSZ - 1) {
esp.c:            s->ti_size++;
esp.c:            s->ti_buf[s->ti_wptr++] = val & 0xff;
esp.c:        s->rregs[saddr] = val;
esp.c:            s->dma = 1;
esp.c:            s->rregs[ESP_TCLO] = s->wregs[ESP_TCLO];
esp.c:            s->rregs[ESP_TCMID] = s->wregs[ESP_TCMID];
esp.c:            s->dma = 0;
esp.c:            //s->ti_size = 0;
esp.c:            s->rregs[ESP_RINTR] = INTR_FC;
esp.c:            s->rregs[ESP_RSEQ] = 0;
esp.c:            s->rregs[ESP_RFLAGS] = 0;
esp.c:            esp_reset(&s->busdev.qdev);
esp.c:            s->rregs[ESP_RINTR] = INTR_RST;
esp.c:            if (!(s->wregs[ESP_CFG1] & CFG1_RESREPT)) {
esp.c:            s->rregs[ESP_RINTR] = INTR_FC;
esp.c:            s->rregs[ESP_RSTAT] |= STAT_MI;
esp.c:            s->rregs[ESP_RINTR] = INTR_DC;
esp.c:            s->rregs[ESP_RSEQ] = 0;
esp.c:            s->rregs[ESP_RFLAGS] = 0;
esp.c:            s->rregs[ESP_RSTAT] = STAT_TC;
esp.c:            s->rregs[ESP_RINTR] = INTR_FC;
esp.c:            s->rregs[ESP_RSEQ] = 0;
esp.c:            s->rregs[ESP_RINTR] = 0;
esp.c:        s->rregs[saddr] = val;
esp.c:        s->rregs[saddr] = val;
esp.c:    s->wregs[saddr] = val;
esp.c:    esp->dma_memory_read = dma_memory_read;
esp.c:    esp->dma_memory_write = dma_memory_write;
esp.c:    esp->dma_opaque = dma_opaque;
esp.c:    esp->it_shift = it_shift;
esp.c:    sysbus_init_irq(dev, &s->irq);
esp.c:    assert(s->it_shift != -1);
esp.c:    sysbus_init_mmio(dev, ESP_REGS << s->it_shift, esp_io_memory);
esp.c:    qdev_init_gpio_in(&dev->qdev, parent_esp_reset, 1);
esp.c:    scsi_bus_new(&s->bus, &dev->qdev, 0, ESP_MAX_DEVS, esp_command_complete);
esp.c:    scsi_bus_legacy_handle_cmdline(&s->bus);
etraxfs.c:    env->pc = bootstrap_pc;
etraxfs.c:    /* The ETRAX-FS has 128Kb on chip ram, the docs refer to it as the 
etraxfs.c:                          dinfo ? dinfo->bdrv : NULL, (64 * 1024),
etraxfs.c:    qdev_prop_set_ptr(dev, "interrupt_vector", &env->interrupt_vector);
etraxfs.c:        /* Boots a kernel elf binary, os/linux-2.6/vmlinux from the axis 
etraxfs.c:        kernel_size = load_elf(kernel_filename, -0x80000000LL,
etraxfs.c:            env->regs[9] = 0x40004000 + kernel_size;
etraxfs.c:        env->regs[8] = 0x56902387; /* RAM init magic.  */
etraxfs.c:            env->regs[10] = 0x87109563;
etraxfs.c:            env->regs[11] = 0x40000000;
etraxfs.c:            pstrcpy_targphys("cmdline", env->regs[11], 256, kernel_cmdline);
etraxfs.c:    env->pc = bootstrap_pc;
etraxfs.c:    printf ("pc =%x\n", env->pc);
etraxfs_dma.c:#include "qemu-common.h"
etraxfs_dma.c:// ------------------------------------------------------------ dma_descr_group
etraxfs_dma.c:// ---------------------------------------------------------- dma_descr_context
etraxfs_dma.c:// ------------------------------------------------------------- dma_descr_data
etraxfs_dma.c:	return ctrl->channels[c].regs[reg];
etraxfs_dma.c:		&& ctrl->channels[c].client;
etraxfs_dma.c:				  (void *) &ctrl->channels[c].current_g, 
etraxfs_dma.c:				  sizeof ctrl->channels[c].current_g);
etraxfs_dma.c:	printf("next=%x\n", c->next);
etraxfs_dma.c:	printf("saved_data=%x\n", c->saved_data);
etraxfs_dma.c:	printf("saved_data_buf=%x\n", c->saved_data_buf);
etraxfs_dma.c:	printf("eol=%x\n", (uint32_t) c->eol);
etraxfs_dma.c:	printf("next=%x\n", d->next);
etraxfs_dma.c:	printf("buf=%x\n", d->buf);
etraxfs_dma.c:	printf("after=%x\n", d->after);
etraxfs_dma.c:	printf("intr=%x\n", (uint32_t) d->intr);
etraxfs_dma.c:	printf("out_eop=%x\n", (uint32_t) d->out_eop);
etraxfs_dma.c:	printf("in_eop=%x\n", (uint32_t) d->in_eop);
etraxfs_dma.c:	printf("eol=%x\n", (uint32_t) d->eol);
etraxfs_dma.c:				  (void *) &ctrl->channels[c].current_c, 
etraxfs_dma.c:				  sizeof ctrl->channels[c].current_c);
etraxfs_dma.c:	D(dump_c(c, &ctrl->channels[c].current_c));
etraxfs_dma.c:	ctrl->channels[c].regs[RW_SAVED_DATA] =
etraxfs_dma.c:		(uint32_t)(unsigned long)ctrl->channels[c].current_c.saved_data;
etraxfs_dma.c:	ctrl->channels[c].regs[RW_SAVED_DATA_BUF] =
etraxfs_dma.c:		(uint32_t)(unsigned long)ctrl->channels[c].current_c.saved_data_buf;
etraxfs_dma.c:				  (void *) &ctrl->channels[c].current_d, 
etraxfs_dma.c:				  sizeof ctrl->channels[c].current_d);
etraxfs_dma.c:	D(dump_d(c, &ctrl->channels[c].current_d));
etraxfs_dma.c:	ctrl->channels[c].regs[RW_DATA] = addr;
etraxfs_dma.c:	D(dump_d(c, &ctrl->channels[c].current_d));
etraxfs_dma.c:				  (void *) &ctrl->channels[c].current_c,
etraxfs_dma.c:				  sizeof ctrl->channels[c].current_c);
etraxfs_dma.c:				  (void *) &ctrl->channels[c].current_d, 
etraxfs_dma.c:				  sizeof ctrl->channels[c].current_d);
etraxfs_dma.c:	if (ctrl->channels[c].client)
etraxfs_dma.c:		ctrl->channels[c].eol = 0;
etraxfs_dma.c:		ctrl->channels[c].state = RUNNING;
etraxfs_dma.c:		if (!ctrl->channels[c].input)
etraxfs_dma.c:        qemu_bh_schedule_idle(ctrl->bh);
etraxfs_dma.c:	    || ctrl->channels[c].state != RUNNING
etraxfs_dma.c:	    || !ctrl->channels[c].current_d.eol) {
etraxfs_dma.c:			 c, ctrl->channels[c].state,
etraxfs_dma.c:			 ctrl->channels[c].eol));
etraxfs_dma.c:		D(dump_d(c, &ctrl->channels[c].current_d));
etraxfs_dma.c:	if (!ctrl->channels[c].current_d.eol && ctrl->channels[c].eol) {
etraxfs_dma.c:			 ctrl->channels[c].current_d.next));
etraxfs_dma.c:		ctrl->channels[c].regs[RW_SAVED_DATA] =
etraxfs_dma.c:			(uint32_t)(unsigned long)ctrl->channels[c].current_d.next;
etraxfs_dma.c:		ctrl->channels[c].regs[RW_SAVED_DATA_BUF] =
etraxfs_dma.c:			(uint32_t)(unsigned long)ctrl->channels[c].current_d.buf;
etraxfs_dma.c:	ctrl->channels[c].regs[RW_SAVED_DATA_BUF] =
etraxfs_dma.c:		(uint32_t)(unsigned long)ctrl->channels[c].current_d.buf;
etraxfs_dma.c:	unsigned int cmd = v & ((1 << 10) - 1);
etraxfs_dma.c:        ctrl->channels[c].regs[R_INTR] &=
etraxfs_dma.c:		~(ctrl->channels[c].regs[RW_ACK_INTR]);
etraxfs_dma.c:        ctrl->channels[c].regs[R_MASKED_INTR] =
etraxfs_dma.c:		ctrl->channels[c].regs[R_INTR]
etraxfs_dma.c:		& ctrl->channels[c].regs[RW_INTR_MASK];
etraxfs_dma.c:		 ctrl->channels[c].regs[R_MASKED_INTR]));
etraxfs_dma.c:        qemu_set_irq(ctrl->channels[c].irq,
etraxfs_dma.c:		     !!ctrl->channels[c].regs[R_MASKED_INTR]);
etraxfs_dma.c:	if (ctrl->channels[c].eol)
etraxfs_dma.c:			 (uint32_t)ctrl->channels[c].current_d.buf,
etraxfs_dma.c:			 (uint32_t)ctrl->channels[c].current_d.after));
etraxfs_dma.c:			ctrl->channels[c].current_d.after;
etraxfs_dma.c:		len -= saved_data_buf;
etraxfs_dma.c:		if (ctrl->channels[c].client->client.push)
etraxfs_dma.c:			ctrl->channels[c].client->client.push(
etraxfs_dma.c:				ctrl->channels[c].client->client.opaque,
etraxfs_dma.c:				ctrl->channels[c].current_d.after) {
etraxfs_dma.c:			if (ctrl->channels[c].current_d.out_eop) {
etraxfs_dma.c:			if (ctrl->channels[c].current_d.intr) {
etraxfs_dma.c:					len, ctrl->channels[c].current_d.eol));
etraxfs_dma.c:				ctrl->channels[c].regs[R_INTR] |= (1 << 2);
etraxfs_dma.c:			if (ctrl->channels[c].current_d.eol) {
etraxfs_dma.c:				ctrl->channels[c].eol = 1;
etraxfs_dma.c:				ctrl->channels[c].current_c.dis = 1;
etraxfs_dma.c:				ctrl->channels[c].regs[RW_SAVED_DATA] =
etraxfs_dma.c:					(uint32_t)(unsigned long)ctrl->
etraxfs_dma.c:					ctrl->channels[c].current_d.buf;
etraxfs_dma.c:			ctrl->channels[c].regs[RW_SAVED_DATA_BUF] =
etraxfs_dma.c:			D(dump_d(c, &ctrl->channels[c].current_d));
etraxfs_dma.c:		ctrl->channels[c].regs[RW_SAVED_DATA_BUF] = saved_data_buf;
etraxfs_dma.c:	} while (!ctrl->channels[c].eol);
etraxfs_dma.c:	if (ctrl->channels[c].eol == 1)
etraxfs_dma.c:	len = (uint32_t)(unsigned long)ctrl->channels[c].current_d.after;
etraxfs_dma.c:	len -= saved_data_buf;
etraxfs_dma.c:	    (uint32_t)(unsigned long)ctrl->channels[c].current_d.after
etraxfs_dma.c:		uint32_t r_intr = ctrl->channels[c].regs[R_INTR];
etraxfs_dma.c:			 ctrl->channels[c].current_d.after
etraxfs_dma.c:			 - ctrl->channels[c].current_d.buf));
etraxfs_dma.c:		ctrl->channels[c].current_d.after = saved_data_buf;
etraxfs_dma.c:		if (ctrl->channels[c].current_d.intr) {
etraxfs_dma.c:			ctrl->channels[c].regs[R_INTR] |= 3;
etraxfs_dma.c:			ctrl->channels[c].current_d.in_eop = 1;
etraxfs_dma.c:			ctrl->channels[c].regs[R_INTR] |= 8;
etraxfs_dma.c:		if (r_intr != ctrl->channels[c].regs[R_INTR])
etraxfs_dma.c:		D(dump_d(c, &ctrl->channels[c].current_d));
etraxfs_dma.c:		if (ctrl->channels[c].current_d.eol) {
etraxfs_dma.c:			ctrl->channels[c].eol = 1;
etraxfs_dma.c:			ctrl->channels[c].current_c.dis = 1;
etraxfs_dma.c:			ctrl->channels[c].regs[RW_SAVED_DATA] =
etraxfs_dma.c:				(uint32_t)(unsigned long)ctrl->
etraxfs_dma.c:				ctrl->channels[c].current_d.buf;
etraxfs_dma.c:	ctrl->channels[c].regs[RW_SAVED_DATA_BUF] = saved_data_buf;
etraxfs_dma.c:	if (ctrl->channels[c].client->client.pull) {
etraxfs_dma.c:		ctrl->channels[c].client->client.pull(
etraxfs_dma.c:			ctrl->channels[c].client->client.opaque);
etraxfs_dma.c:			r = ctrl->channels[c].state & 7;
etraxfs_dma.c:			r |= ctrl->channels[c].eol << 5;
etraxfs_dma.c:			r |= ctrl->channels[c].stream_cmd_src << 8;
etraxfs_dma.c:			r = ctrl->channels[c].regs[addr];
etraxfs_dma.c:	if ((ctrl->channels[c].regs[RW_CFG] & 1) != 3) {
etraxfs_dma.c:		if (ctrl->channels[c].regs[RW_CFG] & 2)
etraxfs_dma.c:			ctrl->channels[c].state = STOPPED;
etraxfs_dma.c:		if (!(ctrl->channels[c].regs[RW_CFG] & 1))
etraxfs_dma.c:			ctrl->channels[c].state = RST;
etraxfs_dma.c:			ctrl->channels[c].regs[addr] = value;
etraxfs_dma.c:			ctrl->channels[c].regs[addr] = value;
etraxfs_dma.c:			ctrl->channels[c].regs[addr] = value;
etraxfs_dma.c:			ctrl->channels[c].regs[addr] = value;
etraxfs_dma.c:			ctrl->channels[c].regs[addr] = value;
etraxfs_dma.c:				ctrl->channels[c].regs[RW_ACK_INTR] = 0;
etraxfs_dma.c:			ctrl->channels[c].regs[addr] = value;
etraxfs_dma.c:	     i < ctrl->nr_channels;
etraxfs_dma.c:		if (ctrl->channels[i].state == RUNNING)
etraxfs_dma.c:			if (ctrl->channels[i].input) {
etraxfs_dma.c:	return channel_in_process(client->ctrl, client->channel, 
etraxfs_dma.c:	ctrl->channels[c].irq = *line;
etraxfs_dma.c:	ctrl->channels[c].input = input;
etraxfs_dma.c:	cl->ctrl = ctrl;
etraxfs_dma.c:	cl->channel = c;
etraxfs_dma.c:	ctrl->channels[c].client = cl;
etraxfs_dma.c:        qemu_bh_schedule_idle(etraxfs_dmac->bh);
etraxfs_dma.c:        ctrl->bh = qemu_bh_new(DMA_run, ctrl);
etraxfs_dma.c:	ctrl->nr_channels = nr_channels;
etraxfs_dma.c:	ctrl->channels = qemu_mallocz(sizeof ctrl->channels[0] * nr_channels);
etraxfs_dma.c:	ctrl->map = cpu_register_io_memory(dma_read, dma_write, ctrl);
etraxfs_dma.c:	cpu_register_physical_memory(base, nr_channels * 0x2000, ctrl->map);
etraxfs_eth.c:#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
etraxfs_eth.c:#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
etraxfs_eth.c:#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
etraxfs_eth.c:#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
etraxfs_eth.c:			if (!phy->link)
etraxfs_eth.c:			r |= phy->regs[4] & (15 << 5);
etraxfs_eth.c:			if (!phy->link)
etraxfs_eth.c:			speed_100 = !!(phy->regs[4] & ADVERTISE_100HALF);
etraxfs_eth.c:			speed_100 |= !!(phy->regs[4] & ADVERTISE_100FULL);
etraxfs_eth.c:			duplex = !!(phy->regs[4] & ADVERTISE_100FULL);
etraxfs_eth.c:			duplex |= !!(phy->regs[4] & ADVERTISE_10FULL);
etraxfs_eth.c:			r = phy->regs[regnum];
etraxfs_eth.c:			phy->regs[regnum] = data;
etraxfs_eth.c:	phy->regs[0] = 0x3100;
etraxfs_eth.c:	phy->regs[2] = 0x0300;
etraxfs_eth.c:	phy->regs[3] = 0xe400;
etraxfs_eth.c:	phy->regs[4] = 0x01E1;
etraxfs_eth.c:	phy->link = 1;
etraxfs_eth.c:	phy->read = tdk_read;
etraxfs_eth.c:	phy->write = tdk_write;
etraxfs_eth.c:	bus->devs[addr & 0x1f] = phy;
etraxfs_eth.c:	bus->devs[addr & 0x1f] = NULL;	
etraxfs_eth.c:	phy = bus->devs[bus->addr];
etraxfs_eth.c:	if (phy && phy->read)
etraxfs_eth.c:		bus->data = phy->read(phy, bus->req);
etraxfs_eth.c:		bus->data = 0xffff;
etraxfs_eth.c:	phy = bus->devs[bus->addr];
etraxfs_eth.c:	if (phy && phy->write)
etraxfs_eth.c:		phy->write(phy, bus->req, bus->data);
etraxfs_eth.c:	bus->cnt++;
etraxfs_eth.c:		bus->mdc, bus->mdio, bus->state, bus->cnt, bus->drive));
etraxfs_eth.c:	if (bus->mdc)
etraxfs_eth.c:		printf("%d", bus->mdio);
etraxfs_eth.c:	switch (bus->state)
etraxfs_eth.c:			if (bus->mdc) {
etraxfs_eth.c:				if (bus->cnt >= (32 * 2) && !bus->mdio) {
etraxfs_eth.c:					bus->cnt = 0;
etraxfs_eth.c:					bus->state = SOF;
etraxfs_eth.c:					bus->data = 0;
etraxfs_eth.c:			if (bus->mdc) {
etraxfs_eth.c:				if (bus->mdio != 1)
etraxfs_eth.c:				if (bus->cnt == 1*2) {
etraxfs_eth.c:					bus->cnt = 0;
etraxfs_eth.c:					bus->opc = 0;
etraxfs_eth.c:					bus->state = OPC;
etraxfs_eth.c:			if (bus->mdc) {
etraxfs_eth.c:				bus->opc <<= 1;
etraxfs_eth.c:				bus->opc |= bus->mdio & 1;
etraxfs_eth.c:				if (bus->cnt == 2*2) {
etraxfs_eth.c:					bus->cnt = 0;
etraxfs_eth.c:					bus->addr = 0;
etraxfs_eth.c:					bus->state = ADDR;
etraxfs_eth.c:			if (bus->mdc) {
etraxfs_eth.c:				bus->addr <<= 1;
etraxfs_eth.c:				bus->addr |= bus->mdio & 1;
etraxfs_eth.c:				if (bus->cnt == 5*2) {
etraxfs_eth.c:					bus->cnt = 0;
etraxfs_eth.c:					bus->req = 0;
etraxfs_eth.c:					bus->state = REQ;
etraxfs_eth.c:			if (bus->mdc) {
etraxfs_eth.c:				bus->req <<= 1;
etraxfs_eth.c:				bus->req |= bus->mdio & 1;
etraxfs_eth.c:				if (bus->cnt == 5*2) {
etraxfs_eth.c:					bus->cnt = 0;
etraxfs_eth.c:					bus->state = TURNAROUND;
etraxfs_eth.c:			if (bus->mdc && bus->cnt == 2*2) {
etraxfs_eth.c:				bus->mdio = 0;
etraxfs_eth.c:				bus->cnt = 0;
etraxfs_eth.c:				if (bus->opc == 2) {
etraxfs_eth.c:					bus->drive = 1;
etraxfs_eth.c:					bus->mdio = bus->data & 1;
etraxfs_eth.c:				bus->state = DATA;
etraxfs_eth.c:			if (!bus->mdc) {
etraxfs_eth.c:				if (bus->drive) {
etraxfs_eth.c:					bus->mdio = !!(bus->data & (1 << 15));
etraxfs_eth.c:					bus->data <<= 1;
etraxfs_eth.c:				if (!bus->drive) {
etraxfs_eth.c:					bus->data <<= 1;
etraxfs_eth.c:					bus->data |= bus->mdio;
etraxfs_eth.c:				if (bus->cnt == 16 * 2) {
etraxfs_eth.c:					bus->cnt = 0;
etraxfs_eth.c:					bus->state = PREAMBLE;
etraxfs_eth.c:					if (!bus->drive)
etraxfs_eth.c:					bus->drive = 0;
etraxfs_eth.c:/* ETRAX-FS Ethernet MAC block starts here.  */
etraxfs_eth.c:	phy = eth->mdio_bus.devs[eth->phyaddr];
etraxfs_eth.c:	phy_duplex = !!(phy->read(phy, 18) & (1 << 11));
etraxfs_eth.c:	mac_duplex = !!(eth->regs[RW_REC_CTRL] & 128);
etraxfs_eth.c:	if (eth->regs[RW_GEN_CTRL] & 1) {
etraxfs_eth.c:		if (new_mm != eth->duplex_mismatch) {
etraxfs_eth.c:		eth->duplex_mismatch = new_mm;
etraxfs_eth.c:			r = eth->mdio_bus.mdio & 1;
etraxfs_eth.c:		r = eth->regs[addr];
etraxfs_eth.c:	eth->macaddr[ma][i++] = eth->regs[reg];
etraxfs_eth.c:	eth->macaddr[ma][i++] = eth->regs[reg] >> 8;
etraxfs_eth.c:	eth->macaddr[ma][i++] = eth->regs[reg] >> 16;
etraxfs_eth.c:	eth->macaddr[ma][i++] = eth->regs[reg] >> 24;
etraxfs_eth.c:	eth->macaddr[ma][i++] = eth->regs[reg + 1];
etraxfs_eth.c:	eth->macaddr[ma][i++] = eth->regs[reg + 1] >> 8;
etraxfs_eth.c:		 eth->macaddr[ma][0], eth->macaddr[ma][1],
etraxfs_eth.c:		 eth->macaddr[ma][2], eth->macaddr[ma][3],
etraxfs_eth.c:		 eth->macaddr[ma][4], eth->macaddr[ma][5]));
etraxfs_eth.c:			eth->regs[addr] = value;
etraxfs_eth.c:			eth->regs[addr] = value;
etraxfs_eth.c:				eth->mdio_bus.mdio = value & 1;
etraxfs_eth.c:			if (eth->mdio_bus.mdc != (value & 4)) {
etraxfs_eth.c:				mdio_cycle(&eth->mdio_bus);
etraxfs_eth.c:			eth->mdio_bus.mdc = !!(value & 4);
etraxfs_eth.c:			eth->regs[addr] = value;
etraxfs_eth.c:			eth->regs[addr] = value;
etraxfs_eth.c:	int m_individual = eth->regs[RW_REC_CTRL] & 4;
etraxfs_eth.c:		match = eth->regs[RW_GA_HI] & (1 << (hsh - 32));
etraxfs_eth.c:		match = eth->regs[RW_GA_LO] & (1 << hsh);
etraxfs_eth.c:		 eth->regs[RW_GA_HI], eth->regs[RW_GA_LO], match));
etraxfs_eth.c:	struct fs_eth *eth = DO_UPCAST(NICState, nc, nc)->opaque;
etraxfs_eth.c:	int use_ma0 = eth->regs[RW_REC_CTRL] & 1;
etraxfs_eth.c:	int use_ma1 = eth->regs[RW_REC_CTRL] & 2;
etraxfs_eth.c:	int r_bcast = eth->regs[RW_REC_CTRL] & 8;
etraxfs_eth.c:		return -1;
etraxfs_eth.c:	if ((!use_ma0 || memcmp(buf, eth->macaddr[0], 6))
etraxfs_eth.c:	    && (!use_ma1 || memcmp(buf, eth->macaddr[1], 6))
etraxfs_eth.c:	etraxfs_dmac_input(eth->dma_in, (void *)buf, size + 4, 1);
etraxfs_eth.c:	qemu_send_packet(&eth->nic->nc, buf, len);
etraxfs_eth.c:	struct fs_eth *eth = DO_UPCAST(NICState, nc, nc)->opaque;
etraxfs_eth.c:	D(printf("%s %d\n", __func__, nc->link_down));
etraxfs_eth.c:	eth->phy.link = !nc->link_down;
etraxfs_eth.c:	struct fs_eth *eth = DO_UPCAST(NICState, nc, nc)->opaque;
etraxfs_eth.c:        cpu_unregister_io_memory(eth->ethregs);
etraxfs_eth.c:        qemu_free(eth->dma_out);
etraxfs_eth.c:	eth->dma_out = dma;
etraxfs_eth.c:	eth->dma_in = dma + 1;
etraxfs_eth.c:	eth->phyaddr = phyaddr & 0x1f;
etraxfs_eth.c:	tdk_init(&eth->phy);
etraxfs_eth.c:	mdio_attach(&eth->mdio_bus, &eth->phy, eth->phyaddr);
etraxfs_eth.c:	eth->ethregs = cpu_register_io_memory(eth_read, eth_write, eth);
etraxfs_eth.c:	cpu_register_physical_memory (base, 0x5c, eth->ethregs);
etraxfs_eth.c:	memcpy(eth->conf.macaddr.a, nd->macaddr, sizeof(nd->macaddr));
etraxfs_eth.c:	eth->conf.vlan = nd->vlan;
etraxfs_eth.c:	eth->conf.peer = nd->netdev;
etraxfs_eth.c:	eth->nic = qemu_new_nic(&net_etraxfs_info, &eth->conf,
etraxfs_eth.c:				nd->model, nd->name, eth);
etraxfs_pic.c:    fs->regs[R_R_MASKED_VECT] = fs->regs[R_R_VECT] & fs->regs[R_RW_MASK];
etraxfs_pic.c:    if (fs->regs[R_R_MASKED_VECT]) {
etraxfs_pic.c:        uint32_t mv = fs->regs[R_R_MASKED_VECT];
etraxfs_pic.c:    if (fs->interrupt_vector) {
etraxfs_pic.c:        *(uint32_t*)(fs->interrupt_vector) = vector;
etraxfs_pic.c:    qemu_set_irq(fs->parent_irq, !!vector);
etraxfs_pic.c:    rval = fs->regs[addr >> 2];
etraxfs_pic.c:        fs->regs[R_RW_MASK] = value;
etraxfs_pic.c:        fs->regs[R_R_NMI] |= mask;
etraxfs_pic.c:        fs->regs[R_R_NMI] &= ~mask;
etraxfs_pic.c:    qemu_set_irq(fs->parent_nmi, !!fs->regs[R_R_NMI]);
etraxfs_pic.c:    irq -= 1;
etraxfs_pic.c:    fs->regs[R_R_VECT] &= ~(1 << irq);
etraxfs_pic.c:    fs->regs[R_R_VECT] |= (!!level << irq);
etraxfs_pic.c:    qdev_init_gpio_in(&dev->qdev, irq_handler, 32);
etraxfs_pic.c:    sysbus_init_irq(dev, &s->parent_irq);
etraxfs_pic.c:    sysbus_init_irq(dev, &s->parent_nmi);
etraxfs_ser.c:#include "qemu-char.h"
etraxfs_ser.c:    s->regs[R_INTR] &= ~(s->regs[RW_ACK_INTR]);
etraxfs_ser.c:    s->regs[R_MASKED_INTR] = s->regs[R_INTR] & s->regs[RW_INTR_MASK];
etraxfs_ser.c:    qemu_set_irq(s->irq, !!s->regs[R_MASKED_INTR]);
etraxfs_ser.c:    s->regs[RW_ACK_INTR] = 0;
etraxfs_ser.c:    D(CPUState *env = s->env);
etraxfs_ser.c:            r = s->regs[RS_STAT_DIN];
etraxfs_ser.c:            r = s->regs[addr];
etraxfs_ser.c:            /* Read side-effect: clear dav.  */
etraxfs_ser.c:            s->regs[addr] &= ~(1 << STAT_DAV);
etraxfs_ser.c:            r = s->regs[addr];
etraxfs_ser.c:    D(CPUState *env = s->env);
etraxfs_ser.c:            qemu_chr_write(s->chr, &ch, 1);
etraxfs_ser.c:            s->regs[R_INTR] |= 1;
etraxfs_ser.c:            s->pending_tx = 1;
etraxfs_ser.c:            s->regs[addr] = value;
etraxfs_ser.c:            s->regs[addr] = value;
etraxfs_ser.c:            if (s->pending_tx && (s->regs[addr] & 1)) {
etraxfs_ser.c:                s->regs[R_INTR] |= 1;
etraxfs_ser.c:                s->pending_tx = 0;
etraxfs_ser.c:                s->regs[addr] &= ~1;
etraxfs_ser.c:            s->regs[addr] = value;
etraxfs_ser.c:    s->regs[R_INTR] |= 8;
etraxfs_ser.c:    s->regs[RS_STAT_DIN] &= ~0xff;
etraxfs_ser.c:    s->regs[RS_STAT_DIN] |= (buf[0] & 0xff);
etraxfs_ser.c:    s->regs[RS_STAT_DIN] |= (1 << STAT_DAV); /* dav.  */
etraxfs_ser.c:    r = s->regs[RW_REC_CTRL] & 1;
etraxfs_ser.c:    r |= !(s->regs[R_INTR] & 8);
etraxfs_ser.c:    s->regs[RS_STAT_DIN] |= (1 << STAT_TR_RDY);
etraxfs_ser.c:    s->regs[RS_STAT_DIN] |= (1 << STAT_TR_IDLE);
etraxfs_ser.c:    sysbus_init_irq(dev, &s->irq);
etraxfs_ser.c:    s->chr = qdev_init_chardev(&dev->qdev);
etraxfs_ser.c:    if (s->chr)
etraxfs_ser.c:        qemu_chr_add_handlers(s->chr,
etraxfs_timer.c:#include "qemu-timer.h"
etraxfs_timer.c:        r = ptimer_get_count(t->ptimer_t0);
etraxfs_timer.c:        r = ptimer_get_count(t->ptimer_t1);
etraxfs_timer.c:        r = t->rw_intr_mask;
etraxfs_timer.c:        r = t->r_intr & t->rw_intr_mask;
etraxfs_timer.c:        ctrl = t->rw_tmr0_ctrl;
etraxfs_timer.c:        div = t->rw_tmr0_div;
etraxfs_timer.c:        timer = t->ptimer_t0;
etraxfs_timer.c:        ctrl = t->rw_tmr1_ctrl;
etraxfs_timer.c:        div = t->rw_tmr1_div;
etraxfs_timer.c:        timer = t->ptimer_t1;
etraxfs_timer.c:    t->r_intr &= ~(t->rw_ack_intr);
etraxfs_timer.c:    t->r_masked_intr = t->r_intr & t->rw_intr_mask;
etraxfs_timer.c:    D(printf("%s: masked_intr=%x\n", __func__, t->r_masked_intr));
etraxfs_timer.c:    qemu_set_irq(t->irq, !!t->r_masked_intr);
etraxfs_timer.c:    t->r_intr |= 1;
etraxfs_timer.c:    t->r_intr |= 2;
etraxfs_timer.c:    if (t->wd_hits == 0) {
etraxfs_timer.c:        ptimer_set_count(t->ptimer_wd, 10);
etraxfs_timer.c:        ptimer_run(t->ptimer_wd, 1);
etraxfs_timer.c:        qemu_irq_raise(t->nmi);
etraxfs_timer.c:    t->wd_hits++;
etraxfs_timer.c:    unsigned int wd_en = t->rw_wd_ctrl & (1 << 8);
etraxfs_timer.c:    unsigned int wd_key = t->rw_wd_ctrl >> 9;
etraxfs_timer.c:    unsigned int wd_cnt = t->rw_wd_ctrl & 511;
etraxfs_timer.c:    unsigned int new_key = value >> 9 & ((1 << 7) - 1);
etraxfs_timer.c:    wd_key = ~wd_key & ((1 << 7) - 1);
etraxfs_timer.c:    if (t->wd_hits)
etraxfs_timer.c:        qemu_irq_lower(t->nmi);
etraxfs_timer.c:    t->wd_hits = 0;
etraxfs_timer.c:    ptimer_set_freq(t->ptimer_wd, 760);
etraxfs_timer.c:    ptimer_set_count(t->ptimer_wd, wd_cnt);
etraxfs_timer.c:        ptimer_run(t->ptimer_wd, 1);
etraxfs_timer.c:        ptimer_stop(t->ptimer_wd);
etraxfs_timer.c:    t->rw_wd_ctrl = value;
etraxfs_timer.c:            t->rw_tmr0_div = value;
etraxfs_timer.c:            t->rw_tmr0_ctrl = value;
etraxfs_timer.c:            t->rw_tmr1_div = value;
etraxfs_timer.c:            t->rw_tmr1_ctrl = value;
etraxfs_timer.c:            t->rw_intr_mask = value;
etraxfs_timer.c:            t->rw_ack_intr = value;
etraxfs_timer.c:            t->rw_ack_intr = 0;
etraxfs_timer.c:    ptimer_stop(t->ptimer_t0);
etraxfs_timer.c:    ptimer_stop(t->ptimer_t1);
etraxfs_timer.c:    ptimer_stop(t->ptimer_wd);
etraxfs_timer.c:    t->rw_wd_ctrl = 0;
etraxfs_timer.c:    t->r_intr = 0;
etraxfs_timer.c:    t->rw_intr_mask = 0;
etraxfs_timer.c:    qemu_irq_lower(t->irq);
etraxfs_timer.c:    t->bh_t0 = qemu_bh_new(timer0_hit, t);
etraxfs_timer.c:    t->bh_t1 = qemu_bh_new(timer1_hit, t);
etraxfs_timer.c:    t->bh_wd = qemu_bh_new(watchdog_hit, t);
etraxfs_timer.c:    t->ptimer_t0 = ptimer_init(t->bh_t0);
etraxfs_timer.c:    t->ptimer_t1 = ptimer_init(t->bh_t1);
etraxfs_timer.c:    t->ptimer_wd = ptimer_init(t->bh_wd);
etraxfs_timer.c:    sysbus_init_irq(dev, &t->irq);
etraxfs_timer.c:    sysbus_init_irq(dev, &t->nmi);
extboot.c: * the COPYING file in the top-level directory.
fdc.c:#include "qemu-timer.h"
fdc.c:#include "qdev-addr.h"
fdc.c:#define GET_CUR_DRV(fdctrl) ((fdctrl)->cur_drv)
fdc.c:#define SET_CUR_DRV(fdctrl, drive) ((fdctrl)->cur_drv = (drive))
fdc.c:    uint8_t ro;               /* Is read-only           */
fdc.c:    drv->bs = drv->dinfo ? drv->dinfo->bdrv : NULL;
fdc.c:    drv->drive = FDRIVE_DRV_NONE;
fdc.c:    drv->perpendicular = 0;
fdc.c:    drv->last_sect = 0;
fdc.c:    drv->max_track = 0;
fdc.c:    return (((track * 2) + head) * last_sect) + sect - 1;
fdc.c:    return _fd_sector(drv->head, drv->track, drv->sect, drv->last_sect);
fdc.c:    if (track > drv->max_track ||
fdc.c:        (head != 0 && (drv->flags & FDISK_DBL_SIDES) == 0)) {
fdc.c:                       (drv->flags & FDISK_DBL_SIDES) == 0 ? 0 : 1,
fdc.c:                       drv->max_track, drv->last_sect);
fdc.c:    if (sect > drv->last_sect) {
fdc.c:                       (drv->flags & FDISK_DBL_SIDES) == 0 ? 0 : 1,
fdc.c:                       drv->max_track, drv->last_sect);
fdc.c:    sector = _fd_sector(head, track, sect, drv->last_sect);
fdc.c:                         head, track, sect, 1, drv->max_track, drv->last_sect);
fdc.c:        drv->head = head;
fdc.c:        if (drv->track != track)
fdc.c:        drv->track = track;
fdc.c:        drv->sect = sect;
fdc.c:    drv->head = 0;
fdc.c:    drv->track = 0;
fdc.c:    drv->sect = 1;
fdc.c:    { FDRIVE_DRV_NONE, FDRIVE_DISK_NONE, -1, -1, 0, NULL, },
fdc.c:    if (drv->bs != NULL && bdrv_is_inserted(drv->bs)) {
fdc.c:        ro = bdrv_is_read_only(drv->bs);
fdc.c:        bdrv_get_geometry_hint(drv->bs, &nb_heads, &max_track, &last_sect);
fdc.c:                           nb_heads - 1, max_track, last_sect);
fdc.c:            bdrv_get_geometry(drv->bs, &nb_sectors);
fdc.c:            match = -1;
fdc.c:            first_match = -1;
fdc.c:                if (parse->drive == FDRIVE_DRV_NONE)
fdc.c:                if (drv->drive == parse->drive ||
fdc.c:                    drv->drive == FDRIVE_DRV_NONE) {
fdc.c:                    size = (parse->max_head + 1) * parse->max_track *
fdc.c:                        parse->last_sect;
fdc.c:                    if (first_match == -1)
fdc.c:            if (match == -1) {
fdc.c:                if (first_match == -1)
fdc.c:            nb_heads = parse->max_head + 1;
fdc.c:            max_track = parse->max_track;
fdc.c:            last_sect = parse->last_sect;
fdc.c:            drv->drive = parse->drive;
fdc.c:            FLOPPY_DPRINTF("%s floppy disk (%d h %d t %d s) %s\n", parse->str,
fdc.c:            drv->flags &= ~FDISK_DBL_SIDES;
fdc.c:            drv->flags |= FDISK_DBL_SIDES;
fdc.c:        drv->max_track = max_track;
fdc.c:        drv->last_sect = last_sect;
fdc.c:        drv->ro = ro;
fdc.c:        drv->last_sect = 0;
fdc.c:        drv->max_track = 0;
fdc.c:        drv->flags &= ~FDISK_DBL_SIDES;
fdc.c:    FD_CONFIG_PRETRK = 0xff, /* Pre-compensation set to track 0 */
fdc.c:        retval = (uint32_t)(-1);
fdc.c:    s->dor_vmstate = s->dor | GET_CUR_DRV(s);
fdc.c:    SET_CUR_DRV(s, s->dor_vmstate & FD_DOR_SELMASK);
fdc.c:    s->dor = s->dor_vmstate & ~FD_DOR_SELMASK;
fdc.c:    fdctrl_t *s = &sys->state;
fdc.c:    fdctrl_t *s = &isa->state;
fdc.c:    return fdctrl->drives[drive_num].drive;
fdc.c:    if (!(fdctrl->sra & FD_SRA_INTPEND))
fdc.c:    qemu_set_irq(fdctrl->irq, 0);
fdc.c:    fdctrl->sra &= ~FD_SRA_INTPEND;
fdc.c:    if (fdctrl->sun4m && (fdctrl->msr & FD_MSR_CMDBUSY)) {
fdc.c:        fdctrl->msr &= ~FD_MSR_CMDBUSY;
fdc.c:        fdctrl->msr |= FD_MSR_RQM | FD_MSR_DIO;
fdc.c:        fdctrl->status0 = status0;
fdc.c:    if (!(fdctrl->sra & FD_SRA_INTPEND)) {
fdc.c:        qemu_set_irq(fdctrl->irq, 1);
fdc.c:        fdctrl->sra |= FD_SRA_INTPEND;
fdc.c:    fdctrl->reset_sensei = 0;
fdc.c:    fdctrl->status0 = status0;
fdc.c:    FLOPPY_DPRINTF("Set interrupt status to 0x%02x\n", fdctrl->status0);
fdc.c:    fdctrl->sra = 0;
fdc.c:    fdctrl->srb = 0xc0;
fdc.c:    if (!fdctrl->drives[1].bs)
fdc.c:        fdctrl->sra |= FD_SRA_nDRV2;
fdc.c:    fdctrl->cur_drv = 0;
fdc.c:    fdctrl->dor = FD_DOR_nRESET;
fdc.c:    fdctrl->dor |= (fdctrl->dma_chann != -1) ? FD_DOR_DMAEN : 0;
fdc.c:    fdctrl->msr = FD_MSR_RQM;
fdc.c:    fdctrl->data_pos = 0;
fdc.c:    fdctrl->data_len = 0;
fdc.c:    fdctrl->data_state = 0;
fdc.c:    fdctrl->data_dir = FD_DIR_WRITE;
fdc.c:        fd_recalibrate(&fdctrl->drives[i]);
fdc.c:        fdctrl->reset_sensei = FD_RESET_SENSEI_COUNT;
fdc.c:    return &fdctrl->drives[(fdctrl->tdr & FD_TDR_BOOTSEL) >> 2];
fdc.c:    if ((fdctrl->tdr & FD_TDR_BOOTSEL) < (1 << 2))
fdc.c:        return &fdctrl->drives[1];
fdc.c:        return &fdctrl->drives[0];
fdc.c:    if ((fdctrl->tdr & FD_TDR_BOOTSEL) < (2 << 2))
fdc.c:        return &fdctrl->drives[2];
fdc.c:        return &fdctrl->drives[1];
fdc.c:    if ((fdctrl->tdr & FD_TDR_BOOTSEL) < (3 << 2))
fdc.c:        return &fdctrl->drives[3];
fdc.c:        return &fdctrl->drives[2];
fdc.c:    switch (fdctrl->cur_drv) {
fdc.c:/* Status A register : 0x00 (read-only) */
fdc.c:    uint32_t retval = fdctrl->sra;
fdc.c:/* Status B register : 0x01 (read-only) */
fdc.c:    uint32_t retval = fdctrl->srb;
fdc.c:    uint32_t retval = fdctrl->dor;
fdc.c:    retval |= fdctrl->cur_drv;
fdc.c:        fdctrl->srb |= FD_SRB_MTR0;
fdc.c:        fdctrl->srb &= ~FD_SRB_MTR0;
fdc.c:        fdctrl->srb |= FD_SRB_MTR1;
fdc.c:        fdctrl->srb &= ~FD_SRB_MTR1;
fdc.c:        fdctrl->srb |= FD_SRB_DR0;
fdc.c:        fdctrl->srb &= ~FD_SRB_DR0;
fdc.c:        if (fdctrl->dor & FD_DOR_nRESET) {
fdc.c:        if (!(fdctrl->dor & FD_DOR_nRESET)) {
fdc.c:            fdctrl->dsr &= ~FD_DSR_PWRDOWN;
fdc.c:    fdctrl->cur_drv = value & FD_DOR_SELMASK;
fdc.c:    fdctrl->dor = value;
fdc.c:    uint32_t retval = fdctrl->tdr;
fdc.c:    if (!(fdctrl->dor & FD_DOR_nRESET)) {
fdc.c:    fdctrl->tdr = value & FD_TDR_BOOTSEL;
fdc.c:    uint32_t retval = fdctrl->msr;
fdc.c:    fdctrl->dsr &= ~FD_DSR_PWRDOWN;
fdc.c:    fdctrl->dor |= FD_DOR_nRESET;
fdc.c:    if (fdctrl->sun4m) {
fdc.c:    if (!(fdctrl->dor & FD_DOR_nRESET)) {
fdc.c:        fdctrl->dor &= ~FD_DOR_nRESET;
fdc.c:        fdctrl->dor |= FD_DOR_nRESET;
fdc.c:    fdctrl->dsr = value;
fdc.c:    if (!drv->bs)
fdc.c:    ret = bdrv_media_changed(drv->bs);
fdc.c:/* Digital input register : 0x07 (read-only) */
fdc.c:    fdctrl->data_dir = FD_DIR_WRITE;
fdc.c:    fdctrl->data_pos = 0;
fdc.c:    fdctrl->msr &= ~(FD_MSR_CMDBUSY | FD_MSR_DIO);
fdc.c:    fdctrl->data_dir = FD_DIR_READ;
fdc.c:    fdctrl->data_len = fifo_len;
fdc.c:    fdctrl->data_pos = 0;
fdc.c:    fdctrl->msr |= FD_MSR_CMDBUSY | FD_MSR_RQM | FD_MSR_DIO;
fdc.c:    FLOPPY_ERROR("unimplemented command 0x%02x\n", fdctrl->fifo[0]);
fdc.c:    fdctrl->fifo[0] = FD_SR0_INVCMD;
fdc.c:                   cur_drv->head, cur_drv->track, cur_drv->sect,
fdc.c:    /* XXX: cur_drv->sect >= cur_drv->last_sect should be an
fdc.c:    if (cur_drv->sect >= cur_drv->last_sect ||
fdc.c:        cur_drv->sect == fdctrl->eot) {
fdc.c:        cur_drv->sect = 1;
fdc.c:        if (FD_MULTI_TRACK(fdctrl->data_state)) {
fdc.c:            if (cur_drv->head == 0 &&
fdc.c:                (cur_drv->flags & FDISK_DBL_SIDES) != 0) {
fdc.c:                cur_drv->head = 1;
fdc.c:                cur_drv->head = 0;
fdc.c:                cur_drv->track++;
fdc.c:                if ((cur_drv->flags & FDISK_DBL_SIDES) == 0)
fdc.c:            cur_drv->track++;
fdc.c:                       cur_drv->head, cur_drv->track,
fdc.c:                       cur_drv->sect, fd_sector(cur_drv));
fdc.c:        cur_drv->sect++;
fdc.c:                   status0 | (cur_drv->head << 2) | GET_CUR_DRV(fdctrl));
fdc.c:    fdctrl->fifo[0] = status0 | (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
fdc.c:    fdctrl->fifo[1] = status1;
fdc.c:    fdctrl->fifo[2] = status2;
fdc.c:    fdctrl->fifo[3] = cur_drv->track;
fdc.c:    fdctrl->fifo[4] = cur_drv->head;
fdc.c:    fdctrl->fifo[5] = cur_drv->sect;
fdc.c:    fdctrl->fifo[6] = FD_SECTOR_SC;
fdc.c:    fdctrl->data_dir = FD_DIR_READ;
fdc.c:    if (!(fdctrl->msr & FD_MSR_NONDMA)) {
fdc.c:        DMA_release_DREQ(fdctrl->dma_chann);
fdc.c:    fdctrl->msr |= FD_MSR_RQM | FD_MSR_DIO;
fdc.c:    fdctrl->msr &= ~FD_MSR_NONDMA;
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    kt = fdctrl->fifo[2];
fdc.c:    kh = fdctrl->fifo[3];
fdc.c:    ks = fdctrl->fifo[4];
fdc.c:                   _fd_sector(kh, kt, ks, cur_drv->last_sect));
fdc.c:    switch (fd_seek(cur_drv, kh, kt, ks, fdctrl->config & FD_CONFIG_EIS)) {
fdc.c:        fdctrl->fifo[3] = kt;
fdc.c:        fdctrl->fifo[4] = kh;
fdc.c:        fdctrl->fifo[5] = ks;
fdc.c:        fdctrl->fifo[3] = kt;
fdc.c:        fdctrl->fifo[4] = kh;
fdc.c:        fdctrl->fifo[5] = ks;
fdc.c:        fdctrl->fifo[3] = kt;
fdc.c:        fdctrl->fifo[4] = kh;
fdc.c:        fdctrl->fifo[5] = ks;
fdc.c:    fdctrl->data_dir = direction;
fdc.c:    fdctrl->data_pos = 0;
fdc.c:    fdctrl->msr |= FD_MSR_CMDBUSY;
fdc.c:    if (fdctrl->fifo[0] & 0x80)
fdc.c:        fdctrl->data_state |= FD_STATE_MULTI;
fdc.c:        fdctrl->data_state &= ~FD_STATE_MULTI;
fdc.c:        fdctrl->data_state |= FD_STATE_SEEK;
fdc.c:        fdctrl->data_state &= ~FD_STATE_SEEK;
fdc.c:    if (fdctrl->fifo[5] == 00) {
fdc.c:        fdctrl->data_len = fdctrl->fifo[8];
fdc.c:        fdctrl->data_len = 128 << (fdctrl->fifo[5] > 7 ? 7 : fdctrl->fifo[5]);
fdc.c:        tmp = (fdctrl->fifo[6] - ks + 1);
fdc.c:        if (fdctrl->fifo[0] & 0x80)
fdc.c:            tmp += fdctrl->fifo[6];
fdc.c:        fdctrl->data_len *= tmp;
fdc.c:    fdctrl->eot = fdctrl->fifo[6];
fdc.c:    if (fdctrl->dor & FD_DOR_DMAEN) {
fdc.c:        dma_mode = DMA_get_channel_mode(fdctrl->dma_chann);
fdc.c:        FLOPPY_DPRINTF("dma_mode=%d direction=%d (%d - %d)\n",
fdc.c:                       (128 << fdctrl->fifo[5]) *
fdc.c:                       (cur_drv->last_sect - ks + 1), fdctrl->data_len);
fdc.c:            fdctrl->msr &= ~FD_MSR_RQM;
fdc.c:            DMA_hold_DREQ(fdctrl->dma_chann);
fdc.c:            DMA_schedule(fdctrl->dma_chann);
fdc.c:    FLOPPY_DPRINTF("start non-DMA transfer\n");
fdc.c:    fdctrl->msr |= FD_MSR_NONDMA;
fdc.c:        fdctrl->msr |= FD_MSR_DIO;
fdc.c:    if (fdctrl->msr & FD_MSR_RQM) {
fdc.c:    if (fdctrl->data_dir == FD_DIR_SCANE || fdctrl->data_dir == FD_DIR_SCANL ||
fdc.c:        fdctrl->data_dir == FD_DIR_SCANH)
fdc.c:    if (dma_len > fdctrl->data_len)
fdc.c:        dma_len = fdctrl->data_len;
fdc.c:    if (cur_drv->bs == NULL) {
fdc.c:        if (fdctrl->data_dir == FD_DIR_WRITE)
fdc.c:    rel_pos = fdctrl->data_pos % FD_SECTOR_LEN;
fdc.c:    for (start_pos = fdctrl->data_pos; fdctrl->data_pos < dma_len;) {
fdc.c:        len = dma_len - fdctrl->data_pos;
fdc.c:            len = FD_SECTOR_LEN - rel_pos;
fdc.c:                       "(%d-0x%08x 0x%08x)\n", len, dma_len, fdctrl->data_pos,
fdc.c:                       fdctrl->data_len, GET_CUR_DRV(fdctrl), cur_drv->head,
fdc.c:                       cur_drv->track, cur_drv->sect, fd_sector(cur_drv),
fdc.c:        if (fdctrl->data_dir != FD_DIR_WRITE ||
fdc.c:            if (bdrv_read(cur_drv->bs, fd_sector(cur_drv),
fdc.c:                          fdctrl->fifo, 1) < 0) {
fdc.c:                memset(fdctrl->fifo, 0, FD_SECTOR_LEN);
fdc.c:        switch (fdctrl->data_dir) {
fdc.c:            DMA_write_memory (nchan, fdctrl->fifo + rel_pos,
fdc.c:                              fdctrl->data_pos, len);
fdc.c:            DMA_read_memory (nchan, fdctrl->fifo + rel_pos,
fdc.c:                             fdctrl->data_pos, len);
fdc.c:            if (bdrv_write(cur_drv->bs, fd_sector(cur_drv),
fdc.c:                           fdctrl->fifo, 1) < 0) {
fdc.c:                DMA_read_memory (nchan, tmpbuf, fdctrl->data_pos, len);
fdc.c:                ret = memcmp(tmpbuf, fdctrl->fifo + rel_pos, len);
fdc.c:                if ((ret < 0 && fdctrl->data_dir == FD_DIR_SCANL) ||
fdc.c:                    (ret > 0 && fdctrl->data_dir == FD_DIR_SCANH)) {
fdc.c:        fdctrl->data_pos += len;
fdc.c:        rel_pos = fdctrl->data_pos % FD_SECTOR_LEN;
fdc.c:    len = fdctrl->data_pos - start_pos;
fdc.c:                   fdctrl->data_pos, len, fdctrl->data_len);
fdc.c:    if (fdctrl->data_dir == FD_DIR_SCANE ||
fdc.c:        fdctrl->data_dir == FD_DIR_SCANL ||
fdc.c:        fdctrl->data_dir == FD_DIR_SCANH)
fdc.c:    if (FD_DID_SEEK(fdctrl->data_state))
fdc.c:    fdctrl->data_len -= len;
fdc.c:    fdctrl->dsr &= ~FD_DSR_PWRDOWN;
fdc.c:    if (!(fdctrl->msr & FD_MSR_RQM) || !(fdctrl->msr & FD_MSR_DIO)) {
fdc.c:    pos = fdctrl->data_pos;
fdc.c:    if (fdctrl->msr & FD_MSR_NONDMA) {
fdc.c:            if (fdctrl->data_pos != 0)
fdc.c:            if (bdrv_read(cur_drv->bs, fd_sector(cur_drv), fdctrl->fifo, 1) < 0) {
fdc.c:                memset(fdctrl->fifo, 0, FD_SECTOR_LEN);
fdc.c:    retval = fdctrl->fifo[pos];
fdc.c:    if (++fdctrl->data_pos == fdctrl->data_len) {
fdc.c:        fdctrl->data_pos = 0;
fdc.c:        if (fdctrl->msr & FD_MSR_NONDMA) {
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    kt = fdctrl->fifo[6];
fdc.c:    kh = fdctrl->fifo[7];
fdc.c:    ks = fdctrl->fifo[8];
fdc.c:                   _fd_sector(kh, kt, ks, cur_drv->last_sect));
fdc.c:    switch (fd_seek(cur_drv, kh, kt, ks, fdctrl->config & FD_CONFIG_EIS)) {
fdc.c:        fdctrl->fifo[3] = kt;
fdc.c:        fdctrl->fifo[4] = kh;
fdc.c:        fdctrl->fifo[5] = ks;
fdc.c:        fdctrl->fifo[3] = kt;
fdc.c:        fdctrl->fifo[4] = kh;
fdc.c:        fdctrl->fifo[5] = ks;
fdc.c:        fdctrl->fifo[3] = kt;
fdc.c:        fdctrl->fifo[4] = kh;
fdc.c:        fdctrl->fifo[5] = ks;
fdc.c:        fdctrl->data_state |= FD_STATE_SEEK;
fdc.c:    memset(fdctrl->fifo, 0, FD_SECTOR_LEN);
fdc.c:    if (cur_drv->bs == NULL ||
fdc.c:        bdrv_write(cur_drv->bs, fd_sector(cur_drv), fdctrl->fifo, 1) < 0) {
fdc.c:        if (cur_drv->sect == cur_drv->last_sect) {
fdc.c:            fdctrl->data_state &= ~FD_STATE_FORMAT;
fdc.c:            if (FD_DID_SEEK(fdctrl->data_state))
fdc.c:            fdctrl->data_pos = 0;
fdc.c:            fdctrl->data_len = 4;
fdc.c:    fdctrl->lock = (fdctrl->fifo[0] & 0x80) ? 1 : 0;
fdc.c:    fdctrl->fifo[0] = fdctrl->lock << 4;
fdc.c:    fdctrl_set_fifo(fdctrl, 1, fdctrl->lock);
fdc.c:    fdctrl->fifo[0] = drv0(fdctrl)->track;
fdc.c:    fdctrl->fifo[1] = drv1(fdctrl)->track;
fdc.c:    fdctrl->fifo[2] = drv2(fdctrl)->track;
fdc.c:    fdctrl->fifo[3] = drv3(fdctrl)->track;
fdc.c:    fdctrl->fifo[2] = 0;
fdc.c:    fdctrl->fifo[3] = 0;
fdc.c:    fdctrl->fifo[4] = fdctrl->timer0;
fdc.c:    fdctrl->fifo[5] = (fdctrl->timer1 << 1) | (fdctrl->dor & FD_DOR_DMAEN ? 1 : 0);
fdc.c:    fdctrl->fifo[6] = cur_drv->last_sect;
fdc.c:    fdctrl->fifo[7] = (fdctrl->lock << 7) |
fdc.c:        (cur_drv->perpendicular << 2);
fdc.c:    fdctrl->fifo[8] = fdctrl->config;
fdc.c:    fdctrl->fifo[9] = fdctrl->precomp_trk;
fdc.c:    fdctrl->fifo[0] = fdctrl->version;
fdc.c:    fdctrl->fifo[0] = 0x41; /* Stepping 1 */
fdc.c:    drv0(fdctrl)->track = fdctrl->fifo[3];
fdc.c:    drv1(fdctrl)->track = fdctrl->fifo[4];
fdc.c:    drv2(fdctrl)->track = fdctrl->fifo[5];
fdc.c:    drv3(fdctrl)->track = fdctrl->fifo[6];
fdc.c:    fdctrl->timer0 = fdctrl->fifo[7];
fdc.c:    fdctrl->timer1 = fdctrl->fifo[8];
fdc.c:    cur_drv->last_sect = fdctrl->fifo[9];
fdc.c:    fdctrl->lock = fdctrl->fifo[10] >> 7;
fdc.c:    cur_drv->perpendicular = (fdctrl->fifo[10] >> 2) & 0xF;
fdc.c:    fdctrl->config = fdctrl->fifo[11];
fdc.c:    fdctrl->precomp_trk = fdctrl->fifo[12];
fdc.c:    fdctrl->pwrd = fdctrl->fifo[13];
fdc.c:    fdctrl->fifo[0] = 0;
fdc.c:    fdctrl->fifo[1] = 0;
fdc.c:    fdctrl->fifo[2] = drv0(fdctrl)->track;
fdc.c:    fdctrl->fifo[3] = drv1(fdctrl)->track;
fdc.c:    fdctrl->fifo[4] = drv2(fdctrl)->track;
fdc.c:    fdctrl->fifo[5] = drv3(fdctrl)->track;
fdc.c:    fdctrl->fifo[4] = 0;
fdc.c:    fdctrl->fifo[5] = 0;
fdc.c:    fdctrl->fifo[6] = fdctrl->timer0;
fdc.c:    fdctrl->fifo[7] = fdctrl->timer1;
fdc.c:    fdctrl->fifo[8] = cur_drv->last_sect;
fdc.c:    fdctrl->fifo[9] = (fdctrl->lock << 7) |
fdc.c:        (cur_drv->perpendicular << 2);
fdc.c:    fdctrl->fifo[10] = fdctrl->config;
fdc.c:    fdctrl->fifo[11] = fdctrl->precomp_trk;
fdc.c:    fdctrl->fifo[12] = fdctrl->pwrd;
fdc.c:    fdctrl->fifo[13] = 0;
fdc.c:    fdctrl->fifo[14] = 0;
fdc.c:    cur_drv->head = (fdctrl->fifo[1] >> 2) & 1;
fdc.c:    qemu_mod_timer(fdctrl->result_timer,
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    fdctrl->data_state |= FD_STATE_FORMAT;
fdc.c:    if (fdctrl->fifo[0] & 0x80)
fdc.c:        fdctrl->data_state |= FD_STATE_MULTI;
fdc.c:        fdctrl->data_state &= ~FD_STATE_MULTI;
fdc.c:    fdctrl->data_state &= ~FD_STATE_SEEK;
fdc.c:    cur_drv->bps =
fdc.c:        fdctrl->fifo[2] > 7 ? 16384 : 128 << fdctrl->fifo[2];
fdc.c:    cur_drv->last_sect =
fdc.c:        cur_drv->flags & FDISK_DBL_SIDES ? fdctrl->fifo[3] :
fdc.c:        fdctrl->fifo[3] / 2;
fdc.c:    cur_drv->last_sect = fdctrl->fifo[3];
fdc.c:    fdctrl->data_state &= ~FD_STATE_FORMAT;
fdc.c:    fdctrl->timer0 = (fdctrl->fifo[1] >> 4) & 0xF;
fdc.c:    fdctrl->timer1 = fdctrl->fifo[2] >> 1;
fdc.c:    if (fdctrl->fifo[2] & 1)
fdc.c:        fdctrl->dor &= ~FD_DOR_DMAEN;
fdc.c:        fdctrl->dor |= FD_DOR_DMAEN;
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    cur_drv->head = (fdctrl->fifo[1] >> 2) & 1;
fdc.c:    fdctrl->fifo[0] = (cur_drv->ro << 6) |
fdc.c:        (cur_drv->track == 0 ? 0x10 : 0x00) |
fdc.c:        (cur_drv->head << 2) |
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    if(fdctrl->reset_sensei > 0) {
fdc.c:        fdctrl->fifo[0] =
fdc.c:            FD_SR0_RDYCHG + FD_RESET_SENSEI_COUNT - fdctrl->reset_sensei;
fdc.c:        fdctrl->reset_sensei--;
fdc.c:        fdctrl->fifo[0] =
fdc.c:            FD_SR0_SEEK | (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
fdc.c:    fdctrl->fifo[1] = cur_drv->track;
fdc.c:    fdctrl->status0 = FD_SR0_RDYCHG;
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    if (fdctrl->fifo[2] > cur_drv->max_track) {
fdc.c:        cur_drv->track = fdctrl->fifo[2];
fdc.c:    if (fdctrl->fifo[1] & 0x80)
fdc.c:        cur_drv->perpendicular = fdctrl->fifo[1] & 0x7;
fdc.c:    fdctrl->config = fdctrl->fifo[2];
fdc.c:    fdctrl->precomp_trk =  fdctrl->fifo[3];
fdc.c:    fdctrl->pwrd = fdctrl->fifo[1];
fdc.c:    fdctrl->fifo[0] = fdctrl->fifo[1];
fdc.c:    if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x80) {
fdc.c:        if (fdctrl->fifo[fdctrl->data_pos - 1] & 0x40) {
fdc.c:            fdctrl->fifo[0] = fdctrl->fifo[1];
fdc.c:            fdctrl->fifo[2] = 0;
fdc.c:            fdctrl->fifo[3] = 0;
fdc.c:    } else if (fdctrl->data_len > 7) {
fdc.c:        fdctrl->fifo[0] = 0x80 |
fdc.c:            (cur_drv->head << 2) | GET_CUR_DRV(fdctrl);
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    if (fdctrl->fifo[2] + cur_drv->track >= cur_drv->max_track) {
fdc.c:        cur_drv->track = cur_drv->max_track - 1;
fdc.c:        cur_drv->track += fdctrl->fifo[2];
fdc.c:    SET_CUR_DRV(fdctrl, fdctrl->fifo[1] & FD_DOR_SELMASK);
fdc.c:    if (fdctrl->fifo[2] > cur_drv->track) {
fdc.c:        cur_drv->track = 0;
fdc.c:        cur_drv->track -= fdctrl->fifo[2];
fdc.c:    if (!(fdctrl->dor & FD_DOR_nRESET)) {
fdc.c:    if (!(fdctrl->msr & FD_MSR_RQM) || (fdctrl->msr & FD_MSR_DIO)) {
fdc.c:    fdctrl->dsr &= ~FD_DSR_PWRDOWN;
fdc.c:    if (fdctrl->msr & FD_MSR_NONDMA) {
fdc.c:        pos = fdctrl->data_pos++;
fdc.c:        fdctrl->fifo[pos] = value;
fdc.c:        if (pos == FD_SECTOR_LEN - 1 ||
fdc.c:            fdctrl->data_pos == fdctrl->data_len) {
fdc.c:            if (bdrv_write(cur_drv->bs, fd_sector(cur_drv), fdctrl->fifo, 1) < 0) {
fdc.c:        if (fdctrl->data_pos == fdctrl->data_len)
fdc.c:    if (fdctrl->data_pos == 0) {
fdc.c:        fdctrl->data_len = handlers[pos].parameters + 1;
fdc.c:    fdctrl->fifo[fdctrl->data_pos++] = value;
fdc.c:    if (fdctrl->data_pos == fdctrl->data_len) {
fdc.c:        if (fdctrl->data_state & FD_STATE_FORMAT) {
fdc.c:        pos = command_to_handler[fdctrl->fifo[0] & 0xff];
fdc.c:    if (cur_drv->last_sect != 0) {
fdc.c:        cur_drv->sect = (cur_drv->sect % cur_drv->last_sect) + 1;
fdc.c:        fd_init(&fdctrl->drives[i]);
fdc.c:        fd_revalidate(&fdctrl->drives[i]);
fdc.c:    dev = isa_create("isa-fdc");
fdc.c:    qdev_prop_set_drive(&dev->qdev, "driveA", fds[0]);
fdc.c:    qdev_prop_set_drive(&dev->qdev, "driveB", fds[1]);
fdc.c:    if (qdev_init(&dev->qdev) < 0)
fdc.c:    return &(DO_UPCAST(fdctrl_isabus_t, busdev, dev)->state);
fdc.c:    dev = qdev_create(NULL, "sysbus-fdc");
fdc.c:    fdctrl = &sys->state;
fdc.c:    fdctrl->dma_chann = dma_chann; /* FIXME */
fdc.c:    sysbus_connect_irq(&sys->busdev, 0, irq);
fdc.c:    sysbus_mmio_map(&sys->busdev, 0, mmio_base);
fdc.c:    fdctrl = &sys->state;
fdc.c:    sysbus_connect_irq(&sys->busdev, 0, irq);
fdc.c:    sysbus_mmio_map(&sys->busdev, 0, io_base);
fdc.c:        for (i = ARRAY_SIZE(handlers) - 1; i >= 0; i--) {
fdc.c:    fdctrl->fifo = qemu_memalign(512, FD_SECTOR_LEN);
fdc.c:    fdctrl->fifo_size = 512;
fdc.c:    fdctrl->result_timer = qemu_new_timer(vm_clock,
fdc.c:    fdctrl->version = 0x90; /* Intel 82078 controller */
fdc.c:    fdctrl->config = FD_CONFIG_EIS | FD_CONFIG_EFIFO; /* Implicit seek, polling & FIFO enabled */
fdc.c:    fdctrl->num_floppies = MAX_FD;
fdc.c:    if (fdctrl->dma_chann != -1)
fdc.c:        DMA_register_channel(fdctrl->dma_chann, &fdctrl_transfer_handler, fdctrl);
fdc.c:    fdctrl_t *fdctrl = &isa->state;
fdc.c:    isa_init_irq(&isa->busdev, &fdctrl->irq, isairq);
fdc.c:    fdctrl->dma_chann = dma_chann;
fdc.c:    fdctrl_t *fdctrl = &sys->state;
fdc.c:    sysbus_init_irq(dev, &fdctrl->irq);
fdc.c:    qdev_init_gpio_in(&dev->qdev, fdctrl_handle_tc, 1);
fdc.c:    fdctrl->dma_chann = -1;
fdc.c:    fdctrl_t *fdctrl = &(FROM_SYSBUS(fdctrl_sysbus_t, dev)->state);
fdc.c:    sysbus_init_irq(dev, &fdctrl->irq);
fdc.c:    qdev_init_gpio_in(&dev->qdev, fdctrl_handle_tc, 1);
fdc.c:    fdctrl->sun4m = 1;
fdc.c:    .qdev.name  = "isa-fdc",
fdc.c:    .qdev.name  = "sysbus-fdc",
firmware_abi.h:    header->len = cpu_to_be16(size >> 4);
firmware_abi.h:    header->checksum = sum & 0xff;
firmware_abi.h:/* from http://www.squirrel.com/squirrel/sun-nvram-hostid.faq.html */
firmware_abi.h:    header->type = 1;
firmware_abi.h:    header->machine_id = machine_id & 0xff;
firmware_abi.h:    memcpy(&header->macaddr, macaddr, 6);
firmware_abi.h:    header->checksum = tmp;
fmopl.c:** File: fmopl.c -- software implementation of FM sound generator
fmopl.c:/* -------------------- for debug --------------------- */
fmopl.c:/* -------------------- preliminary define section --------------------- */
fmopl.c:#define DELTAT_MIXING_LEVEL (1) /* DELTA-T ADPCM MIXING LEVEL */
fmopl.c:#define FREQ_RATE   (1<<(FREQ_BITS-20))
fmopl.c:#define OPL_OUTSB   (TL_BITS+3-16)		/* OPL output final shift 16bit */
fmopl.c:#define OPL_MINOUT (-0x8000<<OPL_OUTSB)
fmopl.c:/* -------------------- quality selection --------------------- */
fmopl.c:#define VIB_SHIFT (32-9)
fmopl.c:#define AMS_SHIFT (32-9)
fmopl.c:/* -------------------- local defines , macros --------------------- */
fmopl.c:/* -------------------- tables --------------------- */
fmopl.c:	 0, 2, 4, 1, 3, 5,-1,-1,
fmopl.c:	 6, 8,10, 7, 9,11,-1,-1,
fmopl.c:	12,14,16,13,15,17,-1,-1,
fmopl.c:	-1,-1,-1,-1,-1,-1,-1,-1
fmopl.c:/* 0 - 15: 0, 3, 6, 9,12,15,18,21,24,27,30,33,36,39,42,93 (dB)*/
fmopl.c:/* TL_TABLE[ TL_MAX to TL_MAX+TL_MAX-1 ] : minus section */
fmopl.c:/* -------------------- static state --------------------- */
fmopl.c:/* --------------------- subroutines  --------------------- */
fmopl.c:	OPL->status |= flag;
fmopl.c:	if(!(OPL->status & 0x80))
fmopl.c:		if(OPL->status & OPL->statusmask)
fmopl.c:			OPL->status |= 0x80;
fmopl.c:			if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,1);
fmopl.c:	OPL->status &=~flag;
fmopl.c:	if((OPL->status & 0x80))
fmopl.c:		if (!(OPL->status & OPL->statusmask) )
fmopl.c:			OPL->status &= 0x7f;
fmopl.c:			if(OPL->IRQHandler) (OPL->IRQHandler)(OPL->IRQParam,0);
fmopl.c:	OPL->statusmask = flag;
fmopl.c:/* ----- key on  ----- */
fmopl.c:	SLOT->Cnt = 0;
fmopl.c:	SLOT->evm = ENV_MOD_AR;
fmopl.c:	SLOT->evs = SLOT->evsa;
fmopl.c:	SLOT->evc = EG_AST;
fmopl.c:	SLOT->eve = EG_AED;
fmopl.c:/* ----- key off ----- */
fmopl.c:	if( SLOT->evm > ENV_MOD_RR)
fmopl.c:		SLOT->evm = ENV_MOD_RR;
fmopl.c:		if( !(SLOT->evc&EG_DST) )
fmopl.c:			//SLOT->evc = (ENV_CURVE[SLOT->evc>>ENV_BITS]<<ENV_BITS) + EG_DST;
fmopl.c:			SLOT->evc = EG_DST;
fmopl.c:		SLOT->eve = EG_DED;
fmopl.c:		SLOT->evs = SLOT->evsr;
fmopl.c:/* ---------- calcrate Envelope Generator & Phase Generator ---------- */
fmopl.c:	if( (SLOT->evc+=SLOT->evs) >= SLOT->eve )
fmopl.c:		switch( SLOT->evm ){
fmopl.c:		case ENV_MOD_AR: /* ATTACK -> DECAY1 */
fmopl.c:			SLOT->evm = ENV_MOD_DR;
fmopl.c:			SLOT->evc = EG_DST;
fmopl.c:			SLOT->eve = SLOT->SL;
fmopl.c:			SLOT->evs = SLOT->evsd;
fmopl.c:		case ENV_MOD_DR: /* DECAY -> SL or RR */
fmopl.c:			SLOT->evc = SLOT->SL;
fmopl.c:			SLOT->eve = EG_DED;
fmopl.c:			if(SLOT->eg_typ)
fmopl.c:				SLOT->evs = 0;
fmopl.c:				SLOT->evm = ENV_MOD_RR;
fmopl.c:				SLOT->evs = SLOT->evsr;
fmopl.c:		case ENV_MOD_RR: /* RR -> OFF */
fmopl.c:			SLOT->evc = EG_OFF;
fmopl.c:			SLOT->eve = EG_OFF+1;
fmopl.c:			SLOT->evs = 0;
fmopl.c:	return SLOT->TLL+ENV_CURVE[SLOT->evc>>ENV_BITS]+(SLOT->ams ? ams : 0);
fmopl.c:	CH->connect1 = CH->CON ? carrier : &feedback2;
fmopl.c:	CH->connect2 = carrier;
fmopl.c:/* ---------- frequency counter for operater update ---------- */
fmopl.c:	SLOT->Incr = CH->fc * SLOT->mul;
fmopl.c:	ksr = CH->kcode >> SLOT->KSR;
fmopl.c:	if( SLOT->ksr != ksr )
fmopl.c:		SLOT->ksr = ksr;
fmopl.c:		SLOT->evsa = SLOT->AR[ksr];
fmopl.c:		SLOT->evsd = SLOT->DR[ksr];
fmopl.c:		SLOT->evsr = SLOT->RR[ksr];
fmopl.c:	SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
fmopl.c:/* set multi,am,vib,EG-TYP,KSR,mul */
fmopl.c:	OPL_CH   *CH   = &OPL->P_CH[slot/2];
fmopl.c:	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
fmopl.c:	SLOT->mul    = MUL_TABLE[v&0x0f];
fmopl.c:	SLOT->KSR    = (v&0x10) ? 0 : 2;
fmopl.c:	SLOT->eg_typ = (v&0x20)>>5;
fmopl.c:	SLOT->vib    = (v&0x40);
fmopl.c:	SLOT->ams    = (v&0x80);
fmopl.c:	OPL_CH   *CH   = &OPL->P_CH[slot/2];
fmopl.c:	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
fmopl.c:	SLOT->ksl = ksl ? 3-ksl : 31;
fmopl.c:	SLOT->TL  = (v&0x3f)*(0.75/EG_STEP); /* 0.75db step */
fmopl.c:	if( !(OPL->mode&0x80) )
fmopl.c:		SLOT->TLL = SLOT->TL + (CH->ksl_base>>SLOT->ksl);
fmopl.c:	OPL_CH   *CH   = &OPL->P_CH[slot/2];
fmopl.c:	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
fmopl.c:	SLOT->AR = ar ? &OPL->AR_TABLE[ar<<2] : RATE_0;
fmopl.c:	SLOT->evsa = SLOT->AR[SLOT->ksr];
fmopl.c:	if( SLOT->evm == ENV_MOD_AR ) SLOT->evs = SLOT->evsa;
fmopl.c:	SLOT->DR = dr ? &OPL->DR_TABLE[dr<<2] : RATE_0;
fmopl.c:	SLOT->evsd = SLOT->DR[SLOT->ksr];
fmopl.c:	if( SLOT->evm == ENV_MOD_DR ) SLOT->evs = SLOT->evsd;
fmopl.c:	OPL_CH   *CH   = &OPL->P_CH[slot/2];
fmopl.c:	OPL_SLOT *SLOT = &CH->SLOT[slot&1];
fmopl.c:	SLOT->SL = SL_TABLE[sl];
fmopl.c:	if( SLOT->evm == ENV_MOD_DR ) SLOT->eve = SLOT->SL;
fmopl.c:	SLOT->RR = &OPL->DR_TABLE[rr<<2];
fmopl.c:	SLOT->evsr = SLOT->RR[SLOT->ksr];
fmopl.c:	if( SLOT->evm == ENV_MOD_RR ) SLOT->evs = SLOT->evsr;
fmopl.c:#define OP_OUT(slot,env,con)   slot->wavetable[((slot->Cnt+con)/(0x1000000/SIN_ENT))&(SIN_ENT-1)][env]
fmopl.c:/* ---------- calcrate one of channel ---------- */
fmopl.c:	SLOT = &CH->SLOT[SLOT1];
fmopl.c:	if( env_out < EG_ENT-1 )
fmopl.c:		if(SLOT->vib) SLOT->Cnt += (SLOT->Incr*vib/VIB_RATE);
fmopl.c:		else          SLOT->Cnt += SLOT->Incr;
fmopl.c:		if(CH->FB)
fmopl.c:			int feedback1 = (CH->op1_out[0]+CH->op1_out[1])>>CH->FB;
fmopl.c:			CH->op1_out[1] = CH->op1_out[0];
fmopl.c:			*CH->connect1 += CH->op1_out[0] = OP_OUT(SLOT,env_out,feedback1);
fmopl.c:			*CH->connect1 += OP_OUT(SLOT,env_out,0);
fmopl.c:		CH->op1_out[1] = CH->op1_out[0];
fmopl.c:		CH->op1_out[0] = 0;
fmopl.c:	SLOT = &CH->SLOT[SLOT2];
fmopl.c:	if( env_out < EG_ENT-1 )
fmopl.c:		if(SLOT->vib) SLOT->Cnt += (SLOT->Incr*vib/VIB_RATE);
fmopl.c:		else          SLOT->Cnt += SLOT->Incr;
fmopl.c:/* ---------- calcrate rythm block ---------- */
fmopl.c:	if( env_out < EG_ENT-1 )
fmopl.c:		if(SLOT->vib) SLOT->Cnt += (SLOT->Incr*vib/VIB_RATE);
fmopl.c:		else          SLOT->Cnt += SLOT->Incr;
fmopl.c:	if( env_out < EG_ENT-1 )
fmopl.c:		if(SLOT->vib) SLOT->Cnt += (SLOT->Incr*vib/VIB_RATE);
fmopl.c:		else          SLOT->Cnt += SLOT->Incr;
fmopl.c:	if(SLOT7_1->vib) SLOT7_1->Cnt += (2*SLOT7_1->Incr*vib/VIB_RATE);
fmopl.c:	else             SLOT7_1->Cnt += 2*SLOT7_1->Incr;
fmopl.c:	if(SLOT7_2->vib) SLOT7_2->Cnt += ((CH[7].fc*8)*vib/VIB_RATE);
fmopl.c:	else             SLOT7_2->Cnt += (CH[7].fc*8);
fmopl.c:	if(SLOT8_1->vib) SLOT8_1->Cnt += (SLOT8_1->Incr*vib/VIB_RATE);
fmopl.c:	else             SLOT8_1->Cnt += SLOT8_1->Incr;
fmopl.c:	if(SLOT8_2->vib) SLOT8_2->Cnt += ((CH[8].fc*48)*vib/VIB_RATE);
fmopl.c:	else             SLOT8_2->Cnt += (CH[8].fc*48);
fmopl.c:	if( env_sd < EG_ENT-1 )
fmopl.c:	if( env_tam < EG_ENT-1 )
fmopl.c:	/* TOP-CY */
fmopl.c:	if( env_top < EG_ENT-1 )
fmopl.c:	if( env_hh  < EG_ENT-1 )
fmopl.c:/* ----------- initialize time tabls ----------- */
fmopl.c:	for (i = 0;i < 4;i++) OPL->AR_TABLE[i] = OPL->DR_TABLE[i] = 0;
fmopl.c:		rate  = OPL->freqbase;						/* frequency rate */
fmopl.c:		if( i < 60 ) rate *= 1.0+(i&3)*0.25;		/* b0-1 : x1 , x1.25 , x1.5 , x1.75 */
fmopl.c:		rate *= 1<<((i>>2)-1);						/* b2-5 : shift bit */
fmopl.c:		OPL->AR_TABLE[i] = rate / ARRATE;
fmopl.c:		OPL->DR_TABLE[i] = rate / DRRATE;
fmopl.c:		OPL->AR_TABLE[i] = EG_AED-1;
fmopl.c:		OPL->DR_TABLE[i] = OPL->DR_TABLE[60];
fmopl.c:			((double)(EG_ENT<<ENV_BITS) / OPL->AR_TABLE[i]) * (1000.0 / OPL->rate),
fmopl.c:			((double)(EG_ENT<<ENV_BITS) / OPL->DR_TABLE[i]) * (1000.0 / OPL->rate) ));
fmopl.c:/* ---------- generic table initialize ---------- */
fmopl.c:	for (t = 0;t < EG_ENT-1 ;t++){
fmopl.c:		rate = ((1<<TL_BITS)-1)/pow(10,EG_STEP*t/20);	/* dB -> voltage */
fmopl.c:		TL_TABLE[TL_MAX+t] = -TL_TABLE[t];
fmopl.c:	for ( t = EG_ENT-1; t < TL_MAX ;t++){
fmopl.c:	SIN_TABLE[0] = SIN_TABLE[SIN_ENT/2]         = &TL_TABLE[EG_ENT-1];
fmopl.c:        /* degree 0   -  90    , degree 180 -  90 : plus section */
fmopl.c:		SIN_TABLE[          s] = SIN_TABLE[SIN_ENT/2-s] = &TL_TABLE[j];
fmopl.c:        /* degree 180 - 270    , degree 360 - 270 : minus section */
fmopl.c:		SIN_TABLE[SIN_ENT/2+s] = SIN_TABLE[SIN_ENT  -s] = &TL_TABLE[TL_MAX+j];
fmopl.c:	/* envelope counter -> envelope output table */
fmopl.c:		pom = pow( ((double)(EG_ENT-1-i)/EG_ENT) , 8 ) * EG_ENT;
fmopl.c:		/* if( pom >= EG_ENT ) pom = EG_ENT-1; */
fmopl.c:	ENV_CURVE[EG_OFF>>ENV_BITS]= EG_ENT-1;
fmopl.c:		pom = (double)VIB_RATE*0.06*sin(2*PI*i/VIB_ENT); /* +-100sect step */
fmopl.c:		VIB_TABLE[i]         = VIB_RATE + (pom*0.07); /* +- 7cent */
fmopl.c:		VIB_TABLE[VIB_ENT+i] = VIB_RATE + (pom*0.14); /* +-14cent */
fmopl.c:	OPL_SLOT *slot1 = &CH->SLOT[SLOT1];
fmopl.c:	OPL_SLOT *slot2 = &CH->SLOT[SLOT2];
fmopl.c:	slot1->TLL = slot1->TL + (CH->ksl_base>>slot1->ksl);
fmopl.c:	slot1->TLL = slot1->TL + (CH->ksl_base>>slot1->ksl);
fmopl.c:	CH->op1_out[0] = CH->op1_out[1] = 0;
fmopl.c:/* ---------- opl initialize ---------- */
fmopl.c:	OPL->freqbase = (OPL->rate) ? ((double)OPL->clock / OPL->rate) / 72  : 0;
fmopl.c:	OPL->TimerBase = 1.0/((double)OPL->clock / 72.0 );
fmopl.c:	/* make fnumber -> increment counter table */
fmopl.c:		OPL->FN_TABLE[fn] = OPL->freqbase * fn * FREQ_RATE * (1<<7) / 2;
fmopl.c:	OPL->amsIncr = OPL->rate ? (double)AMS_ENT*(1<<AMS_SHIFT) / OPL->rate * 3.7 * ((double)OPL->clock/3600000) : 0;
fmopl.c:	OPL->vibIncr = OPL->rate ? (double)VIB_ENT*(1<<VIB_SHIFT) / OPL->rate * 6.4 * ((double)OPL->clock/3600000) : 0;
fmopl.c:/* ---------- write a OPL registers ---------- */
fmopl.c:	case 0x00: /* 00-1f:controll */
fmopl.c:			if(OPL->type&OPL_TYPE_WAVESEL)
fmopl.c:				OPL->wavesel = v&0x20;
fmopl.c:				if(!OPL->wavesel)
fmopl.c:					for(c=0;c<OPL->max_ch;c++)
fmopl.c:						OPL->P_CH[c].SLOT[SLOT1].wavetable = &SIN_TABLE[0];
fmopl.c:						OPL->P_CH[c].SLOT[SLOT2].wavetable = &SIN_TABLE[0];
fmopl.c:			OPL->T[0] = (256-v)*4;
fmopl.c:			OPL->T[1] = (256-v)*16;
fmopl.c:				if(OPL->st[1] != st2)
fmopl.c:					double interval = st2 ? (double)OPL->T[1]*OPL->TimerBase : 0.0;
fmopl.c:					OPL->st[1] = st2;
fmopl.c:					if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+1,interval);
fmopl.c:				if(OPL->st[0] != st1)
fmopl.c:					double interval = st1 ? (double)OPL->T[0]*OPL->TimerBase : 0.0;
fmopl.c:					OPL->st[0] = st1;
fmopl.c:					if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+0,interval);
fmopl.c:			if(OPL->type&OPL_TYPE_KEYBOARD)
fmopl.c:				if(OPL->keyboardhandler_w)
fmopl.c:					OPL->keyboardhandler_w(OPL->keyboard_param,v);
fmopl.c:		case 0x07:	/* DELTA-T controll : START,REC,MEMDATA,REPT,SPOFF,x,x,RST */
fmopl.c:			if(OPL->type&OPL_TYPE_ADPCM)
fmopl.c:				YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);
fmopl.c:		case 0x08:	/* MODE,DELTA-T : CSM,NOTESEL,x,x,smpl,da/ad,64k,rom */
fmopl.c:			OPL->mode = v;
fmopl.c:			v&=0x1f;	/* for DELTA-T unit */
fmopl.c:		case 0x10: 		/* DELTA-N    */
fmopl.c:		case 0x11: 		/* DELTA-N    */
fmopl.c:		case 0x12: 		/* EG-CTRL    */
fmopl.c:			if(OPL->type&OPL_TYPE_ADPCM)
fmopl.c:				YM_DELTAT_ADPCM_Write(OPL->deltat,r-0x07,v);
fmopl.c:			if(OPL->type&OPL_TYPE_IO)
fmopl.c:				OPL->portDirection = v&0x0f;
fmopl.c:			if(OPL->type&OPL_TYPE_IO)
fmopl.c:				OPL->portLatch = v;
fmopl.c:				if(OPL->porthandler_w)
fmopl.c:					OPL->porthandler_w(OPL->port_param,v&OPL->portDirection);
fmopl.c:		if(slot == -1) return;
fmopl.c:		if(slot == -1) return;
fmopl.c:		if(slot == -1) return;
fmopl.c:		if(slot == -1) return;
fmopl.c:			UINT8 rkey = OPL->rythm^v;
fmopl.c:			OPL->ams_table = &AMS_TABLE[v&0x80 ? AMS_ENT : 0];
fmopl.c:			OPL->vib_table = &VIB_TABLE[v&0x40 ? VIB_ENT : 0];
fmopl.c:			OPL->rythm  = v&0x3f;
fmopl.c:			if(OPL->rythm&0x20)
fmopl.c:						OPL->P_CH[6].op1_out[0] = OPL->P_CH[6].op1_out[1] = 0;
fmopl.c:						OPL_KEYON(&OPL->P_CH[6].SLOT[SLOT1]);
fmopl.c:						OPL_KEYON(&OPL->P_CH[6].SLOT[SLOT2]);
fmopl.c:						OPL_KEYOFF(&OPL->P_CH[6].SLOT[SLOT1]);
fmopl.c:						OPL_KEYOFF(&OPL->P_CH[6].SLOT[SLOT2]);
fmopl.c:					if(v&0x08) OPL_KEYON(&OPL->P_CH[7].SLOT[SLOT2]);
fmopl.c:					else       OPL_KEYOFF(&OPL->P_CH[7].SLOT[SLOT2]);
fmopl.c:					if(v&0x04) OPL_KEYON(&OPL->P_CH[8].SLOT[SLOT1]);
fmopl.c:					else       OPL_KEYOFF(&OPL->P_CH[8].SLOT[SLOT1]);
fmopl.c:				/* TOP-CY key on/off */
fmopl.c:					if(v&0x02) OPL_KEYON(&OPL->P_CH[8].SLOT[SLOT2]);
fmopl.c:					else       OPL_KEYOFF(&OPL->P_CH[8].SLOT[SLOT2]);
fmopl.c:					if(v&0x01) OPL_KEYON(&OPL->P_CH[7].SLOT[SLOT1]);
fmopl.c:					else       OPL_KEYOFF(&OPL->P_CH[7].SLOT[SLOT1]);
fmopl.c:		CH = &OPL->P_CH[r&0x0f];
fmopl.c:		{	/* a0-a8 */
fmopl.c:			block_fnum  = (CH->block_fnum&0x1f00) | v;
fmopl.c:		{	/* b0-b8 */
fmopl.c:			block_fnum = ((v&0x1f)<<8) | (CH->block_fnum&0xff);
fmopl.c:			if(CH->keyon != keyon)
fmopl.c:				if( (CH->keyon=keyon) )
fmopl.c:					CH->op1_out[0] = CH->op1_out[1] = 0;
fmopl.c:					OPL_KEYON(&CH->SLOT[SLOT1]);
fmopl.c:					OPL_KEYON(&CH->SLOT[SLOT2]);
fmopl.c:					OPL_KEYOFF(&CH->SLOT[SLOT1]);
fmopl.c:					OPL_KEYOFF(&CH->SLOT[SLOT2]);
fmopl.c:		if(CH->block_fnum != block_fnum)
fmopl.c:			int blockRv = 7-(block_fnum>>10);
fmopl.c:			CH->block_fnum = block_fnum;
fmopl.c:			CH->ksl_base = KSL_TABLE[block_fnum>>6];
fmopl.c:			CH->fc = OPL->FN_TABLE[fnum]>>blockRv;
fmopl.c:			CH->kcode = CH->block_fnum>>9;
fmopl.c:			if( (OPL->mode&0x40) && CH->block_fnum&0x100) CH->kcode |=1;
fmopl.c:			CALC_FCSLOT(CH,&CH->SLOT[SLOT1]);
fmopl.c:			CALC_FCSLOT(CH,&CH->SLOT[SLOT2]);
fmopl.c:		CH = &OPL->P_CH[r&0x0f];
fmopl.c:		CH->FB   = feedback ? (8+1) - feedback : 0;
fmopl.c:		CH->CON = v&1;
fmopl.c:		if(slot == -1) return;
fmopl.c:		CH = &OPL->P_CH[slot/2];
fmopl.c:		if(OPL->wavesel)
fmopl.c:			CH->SLOT[slot&1].wavetable = &SIN_TABLE[(v&0x03)*SIN_ENT];
fmopl.c:		num_lock--;
fmopl.c:		return -1;
fmopl.c:	if(num_lock) num_lock--;
fmopl.c:/* ---------- update one of chip ----------- */
fmopl.c:	UINT32 amsCnt  = OPL->amsCnt;
fmopl.c:	UINT32 vibCnt  = OPL->vibCnt;
fmopl.c:	UINT8 rythm = OPL->rythm&0x20;
fmopl.c:		S_CH = OPL->P_CH;
fmopl.c:		amsIncr = OPL->amsIncr;
fmopl.c:		vibIncr = OPL->vibIncr;
fmopl.c:		ams_table = OPL->ams_table;
fmopl.c:		vib_table = OPL->vib_table;
fmopl.c:	OPL->amsCnt = amsCnt;
fmopl.c:	OPL->vibCnt = vibCnt;
fmopl.c:	UINT32 amsCnt  = OPL->amsCnt;
fmopl.c:	UINT32 vibCnt  = OPL->vibCnt;
fmopl.c:	UINT8 rythm = OPL->rythm&0x20;
fmopl.c:	YM_DELTAT *DELTAT = OPL->deltat;
fmopl.c:	/* setup DELTA-T unit */
fmopl.c:		S_CH = OPL->P_CH;
fmopl.c:		amsIncr = OPL->amsIncr;
fmopl.c:		vibIncr = OPL->vibIncr;
fmopl.c:		ams_table = OPL->ams_table;
fmopl.c:		vib_table = OPL->vib_table;
fmopl.c:		if( DELTAT->portstate )
fmopl.c:	OPL->amsCnt = amsCnt;
fmopl.c:	OPL->vibCnt = vibCnt;
fmopl.c:	if( !DELTAT->portstate )
fmopl.c:		OPL->status &= 0xfe;
fmopl.c:/* ---------- reset one of chip ---------- */
fmopl.c:	OPL->mode   = 0;	/* normal mode */
fmopl.c:	for(i = 0xff ; i >= 0x20 ; i-- ) OPLWriteReg(OPL,i,0);
fmopl.c:	for( c = 0 ; c < OPL->max_ch ; c++ )
fmopl.c:		OPL_CH *CH = &OPL->P_CH[c];
fmopl.c:		/* OPL->P_CH[c].PAN = OPN_CENTER; */
fmopl.c:			CH->SLOT[s].wavetable = &SIN_TABLE[0];
fmopl.c:			/* CH->SLOT[s].evm = ENV_MOD_RR; */
fmopl.c:			CH->SLOT[s].evc = EG_OFF;
fmopl.c:			CH->SLOT[s].eve = EG_OFF+1;
fmopl.c:			CH->SLOT[s].evs = 0;
fmopl.c:	if(OPL->type&OPL_TYPE_ADPCM)
fmopl.c:		YM_DELTAT *DELTAT = OPL->deltat;
fmopl.c:		DELTAT->freqbase = OPL->freqbase;
fmopl.c:		DELTAT->output_pointer = outd;
fmopl.c:		DELTAT->portshift = 5;
fmopl.c:		DELTAT->output_range = DELTAT_MIXING_LEVEL<<TL_BITS;
fmopl.c:/* ----------  Create one of vietual YM3812 ----------       */
fmopl.c:	if( OPL_LockTable() ==-1) return NULL;
fmopl.c:	OPL->P_CH  = (OPL_CH *)ptr; ptr+=sizeof(OPL_CH)*max_ch;
fmopl.c:	if(type&OPL_TYPE_ADPCM) OPL->deltat = (YM_DELTAT *)ptr; ptr+=sizeof(YM_DELTAT);
fmopl.c:	OPL->type  = type;
fmopl.c:	OPL->clock = clock;
fmopl.c:	OPL->rate  = rate;
fmopl.c:	OPL->max_ch = max_ch;
fmopl.c:/* ----------  Destroy one of vietual YM3812 ----------       */
fmopl.c:/* ----------  Option handlers ----------       */
fmopl.c:	OPL->TimerHandler   = TimerHandler;
fmopl.c:	OPL->TimerParam = channelOffset;
fmopl.c:	OPL->IRQHandler     = IRQHandler;
fmopl.c:	OPL->IRQParam = param;
fmopl.c:	OPL->UpdateHandler = UpdateHandler;
fmopl.c:	OPL->UpdateParam = param;
fmopl.c:	OPL->porthandler_w = PortHandler_w;
fmopl.c:	OPL->porthandler_r = PortHandler_r;
fmopl.c:	OPL->port_param = param;
fmopl.c:	OPL->keyboardhandler_w = KeyboardHandler_w;
fmopl.c:	OPL->keyboardhandler_r = KeyboardHandler_r;
fmopl.c:	OPL->keyboard_param = param;
fmopl.c:/* ---------- YM3812 I/O interface ---------- */
fmopl.c:		OPL->address = v & 0xff;
fmopl.c:		if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);
fmopl.c:		fprintf(opl_dbg_fp,"%c%c%c",0x10+opl_dbg_chip,OPL->address,v);
fmopl.c:		OPLWriteReg(OPL,OPL->address,v);
fmopl.c:	return OPL->status>>7;
fmopl.c:		return OPL->status & (OPL->statusmask|0x80);
fmopl.c:	switch(OPL->address)
fmopl.c:		if(OPL->type&OPL_TYPE_KEYBOARD)
fmopl.c:			if(OPL->keyboardhandler_r)
fmopl.c:				return OPL->keyboardhandler_r(OPL->keyboard_param);
fmopl.c:	case 0x0f: /* ADPCM-DATA  */
fmopl.c:		if(OPL->type&OPL_TYPE_IO)
fmopl.c:			if(OPL->porthandler_r)
fmopl.c:				return OPL->porthandler_r(OPL->port_param);
fmopl.c:	case 0x1a: /* PCM-DATA    */
fmopl.c:		if( OPL->mode & 0x80 )
fmopl.c:			if(OPL->UpdateHandler) OPL->UpdateHandler(OPL->UpdateParam,0);
fmopl.c:				CSMKeyControll( &OPL->P_CH[ch] );
fmopl.c:	if (OPL->TimerHandler) (OPL->TimerHandler)(OPL->TimerParam+c,(double)OPL->T[c]*OPL->TimerBase);
fmopl.c:	return OPL->status>>7;
fmopl.h:/* --- select emulation chips --- */
fmopl.h:/* --- system optimize --- */
fmopl.h:#define OPL_TYPE_ADPCM     0x02  /* DELTA-T ADPCM unit */
fmopl.h:/* ---------- OPL one of slot  ---------- */
fmopl.h:/* ---------- OPL one of channel  ---------- */
fmopl.h:	/* Delta-T ADPCM unit (Y8950) */
fmopl.h:	YM_DELTAT *deltat;			/* DELTA-T ADPCM       */
fmopl.h:	UINT32 FN_TABLE[1024];  /* fnumber -> increment counter */
fmopl.h:/* ---------- Generic interface section ---------- */
framebuffer.c:   - Do something similar for framebuffers with local ram
framebuffer.c:   - Handle rotation here instead of hacking dest_pitch
framebuffer.c:   - Use common pixel conversion routines instead of per-device drawfn
framebuffer.c:   - Remove all DisplayState knowledge from devices.
framebuffer.c:    *first_row = -1;
framebuffer.c:    pd2 = cpu_get_physical_page_desc(base + src_len - 1);
framebuffer.c:    if (((pd + src_len - 1) & TARGET_PAGE_MASK) != (pd2 & TARGET_PAGE_MASK)) {
framebuffer.c:        dest -= dest_col_pitch * (cols - 1);
framebuffer.c:    first = -1;
framebuffer.c:            if (first == -1)
fw_cfg.c:    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);
fw_cfg.c:    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];
fw_cfg.c:    if (s->cur_entry & FW_CFG_WRITE_CHANNEL && s->cur_offset < e->len) {
fw_cfg.c:        e->data[s->cur_offset++] = value;
fw_cfg.c:        if (s->cur_offset == e->len) {
fw_cfg.c:            e->callback(e->callback_opaque, e->data);
fw_cfg.c:            s->cur_offset = 0;
fw_cfg.c:    s->cur_offset = 0;
fw_cfg.c:        s->cur_entry = FW_CFG_INVALID;
fw_cfg.c:        s->cur_entry = key;
fw_cfg.c:    int arch = !!(s->cur_entry & FW_CFG_ARCH_LOCAL);
fw_cfg.c:    FWCfgEntry *e = &s->entries[arch][s->cur_entry & FW_CFG_ENTRY_MASK];
fw_cfg.c:    if (s->cur_entry == FW_CFG_INVALID || !e->data || s->cur_offset >= e->len)
fw_cfg.c:        ret = e->data[s->cur_offset++];
fw_cfg.c:    s->entries[arch][key].data = data;
fw_cfg.c:    s->entries[arch][key].len = len;
fw_cfg.c:    s->entries[arch][key].data = data;
fw_cfg.c:    s->entries[arch][key].len = len;
fw_cfg.c:    s->entries[arch][key].callback_opaque = callback_opaque;
fw_cfg.c:    s->entries[arch][key].callback = callback;
fw_cfg.c:    if (!s->files) {
fw_cfg.c:        s->files = qemu_mallocz(dsize);
fw_cfg.c:        fw_cfg_add_bytes(s, FW_CFG_FILE_DIR, (uint8_t*)s->files, dsize);
fw_cfg.c:    index = be32_to_cpu(s->files->count);
fw_cfg.c:    snprintf(s->files->f[index].name, sizeof(s->files->f[index].name),
fw_cfg.c:        if (strcmp(s->files->f[index].name, s->files->f[i].name) == 0) {
fw_cfg.c:                           s->files->f[index].name);
fw_cfg.c:    s->files->f[index].size   = cpu_to_be32(len);
fw_cfg.c:    s->files->f[index].select = cpu_to_be16(FW_CFG_FILE_FIRST + index);
fw_cfg.c:                   index, s->files->f[index].name, len);
fw_cfg.c:    s->files->count = cpu_to_be32(index+1);
fw_cfg.c:    vmstate_register(-1, &vmstate_fw_cfg, s);
g364fb.c: * Copyright (c) 2007-2009 Herve Poussineau
g364fb.c:    cpu_physical_memory_reset_dirty(page_min, page_max + TARGET_PAGE_SIZE - 1,
g364fb.c:    switch (ds_get_bits_per_pixel(s->ds)) {
g364fb.c:            BADF("unknown host depth %d\n", ds_get_bits_per_pixel(s->ds));
g364fb.c:    page = s->vram_offset;
g364fb.c:    page_min = (ram_addr_t)-1;
g364fb.c:    xmin = s->width;
g364fb.c:    ymin = s->height;
g364fb.c:    if (!(s->ctla & CTLA_NO_CURSOR)) {
g364fb.c:        xcursor = s->cursor_position >> 12;
g364fb.c:        ycursor = s->cursor_position & 0xfff;
g364fb.c:        xcursor = ycursor = -65;
g364fb.c:    vram = s->vram + s->top_of_screen;
g364fb.c:    data_display = dd = ds_get_data(s->ds);
g364fb.c:    while (y < s->height) {
g364fb.c:            if (page_min == (ram_addr_t)-1)
g364fb.c:                    int xdiff = x - xcursor;
g364fb.c:                    uint16_t curs = s->cursor[(y - ycursor) * 8 + xdiff / 8];
g364fb.c:                            s->color_palette[index][0],
g364fb.c:                            s->color_palette[index][1],
g364fb.c:                            s->color_palette[index][2]);
g364fb.c:                        index = op - 1;
g364fb.c:                            s->cursor_palette[index][0],
g364fb.c:                            s->cursor_palette[index][1],
g364fb.c:                            s->cursor_palette[index][2]);
g364fb.c:                        s->color_palette[index][0],
g364fb.c:                        s->color_palette[index][1],
g364fb.c:                        s->color_palette[index][2]);
g364fb.c:                if (x == s->width) {
g364fb.c:                    xmax = s->width - 1;
g364fb.c:                    if (y == s->height) {
g364fb.c:                        ymax = s->height - 1;
g364fb.c:                    data_display = dd = data_display + ds_get_linesize(s->ds);
g364fb.c:            if (page_min != (ram_addr_t)-1) {
g364fb.c:                page_min = (ram_addr_t)-1;
g364fb.c:                dpy_update(s->ds, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
g364fb.c:                xmin = s->width;
g364fb.c:                ymin = s->height;
g364fb.c:            dy = x / s->width;
g364fb.c:            x = x % s->width;
g364fb.c:            data_display += dy * ds_get_linesize(s->ds);
g364fb.c:    if (page_min != (ram_addr_t)-1) {
g364fb.c:        dpy_update(s->ds, xmin, ymin, xmax - xmin + 1, ymax - ymin + 1);
g364fb.c:    if (s->blanked) {
g364fb.c:    w = s->width * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);
g364fb.c:    d = ds_get_data(s->ds);
g364fb.c:    for (i = 0; i < s->height; i++) {
g364fb.c:        d += ds_get_linesize(s->ds);
g364fb.c:    dpy_update(s->ds, 0, 0, s->width, s->height);
g364fb.c:    s->blanked = 1;
g364fb.c:    if (s->width == 0 || s->height == 0)
g364fb.c:    if (s->width != ds_get_width(s->ds) || s->height != ds_get_height(s->ds)) {
g364fb.c:        qemu_console_resize(s->ds, s->width, s->height);
g364fb.c:    if (s->ctla & CTLA_FORCE_BLANK) {
g364fb.c:    } else if (s->depth == 8) {
g364fb.c:        BADF("unknown guest depth %d\n", s->depth);
g364fb.c:    qemu_irq_raise(s->irq);
g364fb.c:    s->blanked = 0;
g364fb.c:    for (i = 0; i < s->vram_size; i += TARGET_PAGE_SIZE) {
g364fb.c:        cpu_physical_memory_set_dirty(s->vram_offset + i);
g364fb.c:    qemu_irq_lower(s->irq);
g364fb.c:    memset(s->color_palette, 0, sizeof(s->color_palette));
g364fb.c:    memset(s->cursor_palette, 0, sizeof(s->cursor_palette));
g364fb.c:    memset(s->cursor, 0, sizeof(s->cursor));
g364fb.c:    s->cursor_position = 0;
g364fb.c:    s->ctla = 0;
g364fb.c:    s->top_of_screen = 0;
g364fb.c:    s->width = s->height = 0;
g364fb.c:    memset(s->vram, 0, s->vram_size);
g364fb.c:    if (s->depth != 8) {
g364fb.c:        BADF("unknown guest depth %d\n", s->depth);
g364fb.c:    if (s->ctla & CTLA_FORCE_BLANK) {
g364fb.c:            s->width, s->height);
g364fb.c:        for (y = 0; y < s->height; y++)
g364fb.c:            for (x = 0; x < s->width; x++)
g364fb.c:        data_buffer = s->vram + s->top_of_screen;
g364fb.c:            s->width, s->height, 255);
g364fb.c:        for (y = 0; y < s->height; y++)
g364fb.c:            for (x = 0; x < s->width; x++, data_buffer++) {
g364fb.c:                fputc(s->color_palette[index][0], f);
g364fb.c:                fputc(s->color_palette[index][1], f);
g364fb.c:                fputc(s->color_palette[index][2], f);
g364fb.c:        int idx = (addr - REG_CURS_PAT) >> 3;
g364fb.c:        val = s->cursor[idx];
g364fb.c:        int idx = (addr - REG_CURS_PAL) >> 3;
g364fb.c:        val = ((uint32_t)s->cursor_palette[idx][0] << 16);
g364fb.c:        val |= ((uint32_t)s->cursor_palette[idx][1] << 8);
g364fb.c:        val |= ((uint32_t)s->cursor_palette[idx][2] << 0);
g364fb.c:                val = s->width / 4;
g364fb.c:                val = s->height * 2;
g364fb.c:                val = s->ctla;
g364fb.c:    s->depth = depths[(s->ctla & 0x00700000) >> 20];
g364fb.c:    ymin = s->cursor_position & 0xfff;
g364fb.c:    ymax = MIN(s->height, ymin + 64);
g364fb.c:    start = ymin * ds_get_linesize(s->ds);
g364fb.c:    end = (ymax + 1) * ds_get_linesize(s->ds);
g364fb.c:        cpu_physical_memory_set_dirty(s->vram_offset + i);
g364fb.c:        int idx = (addr - REG_CLR_PAL) >> 3;
g364fb.c:        s->color_palette[idx][0] = (val >> 16) & 0xff;
g364fb.c:        s->color_palette[idx][1] = (val >> 8) & 0xff;
g364fb.c:        s->color_palette[idx][2] = val & 0xff;
g364fb.c:        int idx = (addr - REG_CURS_PAT) >> 3;
g364fb.c:        s->cursor[idx] = val;
g364fb.c:        int idx = (addr - REG_CURS_PAL) >> 3;
g364fb.c:        s->cursor_palette[idx][0] = (val >> 16) & 0xff;
g364fb.c:        s->cursor_palette[idx][1] = (val >> 8) & 0xff;
g364fb.c:        s->cursor_palette[idx][2] = val & 0xff;
g364fb.c:            case REG_ID: /* Card identifier; read-only */
g364fb.c:                s->top_of_screen = val;
g364fb.c:                s->width = val * 4;
g364fb.c:                s->height = val / 2;
g364fb.c:                s->ctla = val;
g364fb.c:                s->cursor_position = val;
g364fb.c:    qemu_irq_lower(s->irq);
g364fb.c:        return -EINVAL;
g364fb.c:    if (vram_size < s->vram_size)
g364fb.c:        return -EINVAL;
g364fb.c:    qemu_get_buffer(f, s->vram, s->vram_size);
g364fb.c:        qemu_get_buffer(f, s->color_palette[i], 3);
g364fb.c:        qemu_get_buffer(f, s->cursor_palette[i], 3);
g364fb.c:    qemu_get_buffer(f, (uint8_t *)s->cursor, sizeof(s->cursor));
g364fb.c:    s->cursor_position = qemu_get_be32(f);
g364fb.c:    s->ctla = qemu_get_be32(f);
g364fb.c:    s->top_of_screen = qemu_get_be32(f);
g364fb.c:    s->width = qemu_get_be32(f);
g364fb.c:    s->height = qemu_get_be32(f);
g364fb.c:    qemu_put_be32(f, s->vram_size);
g364fb.c:    qemu_put_buffer(f, s->vram, s->vram_size);
g364fb.c:        qemu_put_buffer(f, s->color_palette[i], 3);
g364fb.c:        qemu_put_buffer(f, s->cursor_palette[i], 3);
g364fb.c:    qemu_put_buffer(f, (uint8_t *)s->cursor, sizeof(s->cursor));
g364fb.c:    qemu_put_be32(f, s->cursor_position);
g364fb.c:    qemu_put_be32(f, s->ctla);
g364fb.c:    qemu_put_be32(f, s->top_of_screen);
g364fb.c:    qemu_put_be32(f, s->width);
g364fb.c:    qemu_put_be32(f, s->height);
g364fb.c:    s->vram_size = 8 * 1024 * 1024;
g364fb.c:    s->vram_offset = qemu_ram_alloc(s->vram_size);
g364fb.c:    s->vram = qemu_get_ram_ptr(s->vram_offset);
g364fb.c:    s->irq = irq;
g364fb.c:    s->ds = graphic_console_init(g364fb_update_display,
g364fb.c:    cpu_register_physical_memory(vram_base, s->vram_size, s->vram_offset);
grackle_pci.c: * Copyright (c) 2006-2007 Fabrice Bellard
grackle_pci.c:    return (irq_num + (pci_dev->devfn >> 3)) & 3;
grackle_pci.c:        return -EINVAL;
grackle_pci.c:    d->host_state.bus = pci_register_bus(&d->busdev.qdev, "pci",
grackle_pci.c:    pci_create_simple(d->host_state.bus, 0, "grackle");
grackle_pci.c:    return d->host_state.bus;
grackle_pci.c:    pci_mem_config = pci_host_conf_register_mmio(&s->host_state);
grackle_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
grackle_pci.c:                    &s->host_state);
grackle_pci.c:    qemu_register_reset(pci_grackle_reset, &s->host_state);
grackle_pci.c:    pci_mem_config = pci_host_conf_register_mmio(&s->host_state);
grackle_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
grackle_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MOTOROLA);
grackle_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MOTOROLA_MPC106);
grackle_pci.c:    d->config[0x08] = 0x00; // revision
grackle_pci.c:    d->config[0x09] = 0x01;
grackle_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
grackle_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
grackle_pci.c:    /* PCI2PCI bridge same values as PearPC - check this */
grackle_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_DEC);
grackle_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_DEC_21154);
grackle_pci.c:    d->config[0x08] = 0x02; // revision
grackle_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
grackle_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_BRIDGE; // header_type
grackle_pci.c:    d->config[0x18] = 0x0;  // primary_bus
grackle_pci.c:    d->config[0x19] = 0x1;  // secondary_bus
grackle_pci.c:    d->config[0x1a] = 0x1;  // subordinate_bus
grackle_pci.c:    d->config[0x1c] = 0x10; // io_base
grackle_pci.c:    d->config[0x1d] = 0x20; // io_limit
grackle_pci.c:    d->config[0x20] = 0x80; // memory_base
grackle_pci.c:    d->config[0x21] = 0x80;
grackle_pci.c:    d->config[0x22] = 0x90; // memory_limit
grackle_pci.c:    d->config[0x23] = 0x80;
grackle_pci.c:    d->config[0x24] = 0x00; // prefetchable_memory_base
grackle_pci.c:    d->config[0x25] = 0x84;
grackle_pci.c:    d->config[0x26] = 0x00; // prefetchable_memory_limit
grackle_pci.c:    d->config[0x27] = 0x85;
grackle_pci.c:    .qdev.name = "dec-21154",
grackle_pci.c:    sysbus_register_dev("dec-21154", sizeof(GrackleState),
gt64xxx.c:#define GT_CPUERR_DATALO    	(0x128 >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_CPUERR_DATAHI    	(0x130 >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_CPUERR_PARITY    	(0x138 >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_ECC_ERRDATALO	(0x480 >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_ECC_ERRDATAHI	(0x484 >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_ECC_MEM		(0x488 >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_ECC_CALC		(0x48c >> 2)		/* GT-64120A only  */
gt64xxx.c:#define GT_ECC_ERRADDR		(0x490 >> 2)		/* GT-64120A only  */
gt64xxx.c:/* XXX: Hardcoded values for Malta: 0x1e000000 - 0x1f100000
gt64xxx.c:                                    0x1fc00000 - 0x1fd00000  */
gt64xxx.c:    *length = end - begin;
gt64xxx.c:    target_phys_addr_t start = s->regs[GT_ISD] << 21;
gt64xxx.c:    if (s->ISD_length)
gt64xxx.c:        cpu_register_physical_memory(s->ISD_start, s->ISD_length,
gt64xxx.c:    dprintf("ISD: %x@%x -> %x@%x, %x\n", s->ISD_length, s->ISD_start,
gt64xxx.c:            length, start, s->ISD_handle);
gt64xxx.c:    s->ISD_start = start;
gt64xxx.c:    s->ISD_length = length;
gt64xxx.c:    cpu_register_physical_memory(s->ISD_start, s->ISD_length, s->ISD_handle);
gt64xxx.c:    if ((s->regs[GT_PCI0IOLD] & 0x7f) <= s->regs[GT_PCI0IOHD])
gt64xxx.c:      if (s->PCI0IO_length)
gt64xxx.c:        cpu_register_physical_memory(s->PCI0IO_start, s->PCI0IO_length, IO_MEM_UNASSIGNED);
gt64xxx.c:      s->PCI0IO_start = s->regs[GT_PCI0IOLD] << 21;
gt64xxx.c:      s->PCI0IO_length = ((s->regs[GT_PCI0IOHD] + 1) - (s->regs[GT_PCI0IOLD] & 0x7f)) << 21;
gt64xxx.c:      isa_mem_base = s->PCI0IO_start;
gt64xxx.c:      isa_mmio_init(s->PCI0IO_start, s->PCI0IO_length);
gt64xxx.c:    if (!(s->regs[GT_CPU] & 0x00001000))
gt64xxx.c:        s->regs[GT_CPU] = val;
gt64xxx.c:	/* Read-only register as only one GT64xxx is present on the CPU bus */
gt64xxx.c:        s->regs[GT_PCI0IOLD]    = val & 0x00007fff;
gt64xxx.c:        s->regs[GT_PCI0IOREMAP] = val & 0x000007ff;
gt64xxx.c:        s->regs[GT_PCI0M0LD]    = val & 0x00007fff;
gt64xxx.c:        s->regs[GT_PCI0M0REMAP] = val & 0x000007ff;
gt64xxx.c:        s->regs[GT_PCI0M1LD]    = val & 0x00007fff;
gt64xxx.c:        s->regs[GT_PCI0M1REMAP] = val & 0x000007ff;
gt64xxx.c:        s->regs[GT_PCI1IOLD]    = val & 0x00007fff;
gt64xxx.c:        s->regs[GT_PCI1IOREMAP] = val & 0x000007ff;
gt64xxx.c:        s->regs[GT_PCI1M0LD]    = val & 0x00007fff;
gt64xxx.c:        s->regs[GT_PCI1M0REMAP] = val & 0x000007ff;
gt64xxx.c:        s->regs[GT_PCI1M1LD]    = val & 0x00007fff;
gt64xxx.c:        s->regs[GT_PCI1M1REMAP] = val & 0x000007ff;
gt64xxx.c:        s->regs[saddr] = val & 0x0000007f;
gt64xxx.c:        s->regs[saddr] = val & 0x0000007f;
gt64xxx.c:        s->regs[saddr] = val & 0x00007fff;
gt64xxx.c:        s->regs[saddr] = val & 0x000007ff;
gt64xxx.c:	/* Read-only registers, do nothing */
gt64xxx.c:	/* Read-only registers, do nothing */
gt64xxx.c:        s->regs[saddr] = val;
gt64xxx.c:        /* Read-only registers, do nothing */
gt64xxx.c:        s->regs[saddr] = val & 0x0401fc0f;
gt64xxx.c:        s->pci->config_reg = val & 0x80fffffc;
gt64xxx.c:        if (!(s->regs[GT_PCI0_CMD] & 1) && (s->pci->config_reg & 0x00fff800))
gt64xxx.c:        if (s->pci->config_reg & (1u << 31))
gt64xxx.c:            pci_data_write(s->pci->bus, s->pci->config_reg, val, 4);
gt64xxx.c:        s->regs[saddr] = ~(~(s->regs[saddr]) | ~(val & 0xfffffffe));
gt64xxx.c:        s->regs[saddr] |= !!(s->regs[saddr] & 0xfffffffe);
gt64xxx.c:        s->regs[saddr] = val & 0x3c3ffffe;
gt64xxx.c:        s->regs[saddr] = val & 0x03fffffe;
gt64xxx.c:        s->regs[saddr] = val & 0x0000003f;
gt64xxx.c:        s->regs[saddr] = val;
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->pci->config_reg;
gt64xxx.c:        if (!(s->pci->config_reg & (1 << 31)))
gt64xxx.c:            val = pci_data_read(s->pci->bus, s->pci->config_reg, 4);
gt64xxx.c:        if (!(s->regs[GT_PCI0_CMD] & 1) && (s->pci->config_reg & 0x00fff800))
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:        val = s->regs[saddr];
gt64xxx.c:    if (!(s->regs[GT_CPU] & 0x00001000))
gt64xxx.c:    slot = (pci_dev->devfn >> 3);
gt64xxx.c:        return ((slot - 18) + irq_num) & 0x03;
gt64xxx.c:    pic_irq = piix4_dev->config[0x60 + irq_num];
gt64xxx.c:            if (pic_irq == piix4_dev->config[0x60 + i])
gt64xxx.c:    s->regs[GT_CPU]           = 0x00000000;
gt64xxx.c:    s->regs[GT_CPU]           = 0x00001000;
gt64xxx.c:    s->regs[GT_MULTI]         = 0x00000003;
gt64xxx.c:    s->regs[GT_SCS10LD]       = 0x00000000;
gt64xxx.c:    s->regs[GT_SCS10HD]       = 0x00000007;
gt64xxx.c:    s->regs[GT_SCS32LD]       = 0x00000008;
gt64xxx.c:    s->regs[GT_SCS32HD]       = 0x0000000f;
gt64xxx.c:    s->regs[GT_CS20LD]        = 0x000000e0;
gt64xxx.c:    s->regs[GT_CS20HD]        = 0x00000070;
gt64xxx.c:    s->regs[GT_CS3BOOTLD]     = 0x000000f8;
gt64xxx.c:    s->regs[GT_CS3BOOTHD]     = 0x0000007f;
gt64xxx.c:    s->regs[GT_PCI0IOLD]      = 0x00000080;
gt64xxx.c:    s->regs[GT_PCI0IOHD]      = 0x0000000f;
gt64xxx.c:    s->regs[GT_PCI0M0LD]      = 0x00000090;
gt64xxx.c:    s->regs[GT_PCI0M0HD]      = 0x0000001f;
gt64xxx.c:    s->regs[GT_ISD]           = 0x000000a0;
gt64xxx.c:    s->regs[GT_PCI0M1LD]      = 0x00000790;
gt64xxx.c:    s->regs[GT_PCI0M1HD]      = 0x0000001f;
gt64xxx.c:    s->regs[GT_PCI1IOLD]      = 0x00000100;
gt64xxx.c:    s->regs[GT_PCI1IOHD]      = 0x0000000f;
gt64xxx.c:    s->regs[GT_PCI1M0LD]      = 0x00000110;
gt64xxx.c:    s->regs[GT_PCI1M0HD]      = 0x0000001f;
gt64xxx.c:    s->regs[GT_PCI1M1LD]      = 0x00000120;
gt64xxx.c:    s->regs[GT_PCI1M1HD]      = 0x0000002f;
gt64xxx.c:    s->regs[GT_SCS10AR]       = 0x00000000;
gt64xxx.c:    s->regs[GT_SCS32AR]       = 0x00000008;
gt64xxx.c:    s->regs[GT_CS20R]         = 0x000000e0;
gt64xxx.c:    s->regs[GT_CS3BOOTR]      = 0x000000f8;
gt64xxx.c:    s->regs[GT_PCI0IOREMAP]   = 0x00000080;
gt64xxx.c:    s->regs[GT_PCI0M0REMAP]   = 0x00000090;
gt64xxx.c:    s->regs[GT_PCI0M1REMAP]   = 0x00000790;
gt64xxx.c:    s->regs[GT_PCI1IOREMAP]   = 0x00000100;
gt64xxx.c:    s->regs[GT_PCI1M0REMAP]   = 0x00000110;
gt64xxx.c:    s->regs[GT_PCI1M1REMAP]   = 0x00000120;
gt64xxx.c:    s->regs[GT_CPUERR_ADDRLO] = 0x00000000;
gt64xxx.c:    s->regs[GT_CPUERR_ADDRHI] = 0x00000000;
gt64xxx.c:    s->regs[GT_CPUERR_DATALO] = 0xffffffff;
gt64xxx.c:    s->regs[GT_CPUERR_DATAHI] = 0xffffffff;
gt64xxx.c:    s->regs[GT_CPUERR_PARITY] = 0x000000ff;
gt64xxx.c:    s->regs[GT_PCI0SYNC]      = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI1SYNC]      = 0x00000000;
gt64xxx.c:    s->regs[GT_SCS0LD]        = 0x00000000;
gt64xxx.c:    s->regs[GT_SCS0HD]        = 0x00000007;
gt64xxx.c:    s->regs[GT_SCS1LD]        = 0x00000008;
gt64xxx.c:    s->regs[GT_SCS1HD]        = 0x0000000f;
gt64xxx.c:    s->regs[GT_SCS2LD]        = 0x00000010;
gt64xxx.c:    s->regs[GT_SCS2HD]        = 0x00000017;
gt64xxx.c:    s->regs[GT_SCS3LD]        = 0x00000018;
gt64xxx.c:    s->regs[GT_SCS3HD]        = 0x0000001f;
gt64xxx.c:    s->regs[GT_CS0LD]         = 0x000000c0;
gt64xxx.c:    s->regs[GT_CS0HD]         = 0x000000c7;
gt64xxx.c:    s->regs[GT_CS1LD]         = 0x000000c8;
gt64xxx.c:    s->regs[GT_CS1HD]         = 0x000000cf;
gt64xxx.c:    s->regs[GT_CS2LD]         = 0x000000d0;
gt64xxx.c:    s->regs[GT_CS2HD]         = 0x000000df;
gt64xxx.c:    s->regs[GT_CS3LD]         = 0x000000f0;
gt64xxx.c:    s->regs[GT_CS3HD]         = 0x000000fb;
gt64xxx.c:    s->regs[GT_BOOTLD]        = 0x000000fc;
gt64xxx.c:    s->regs[GT_BOOTHD]        = 0x000000ff;
gt64xxx.c:    s->regs[GT_ADERR]         = 0xffffffff;
gt64xxx.c:    s->regs[GT_SDRAM_CFG]     = 0x00000200;
gt64xxx.c:    s->regs[GT_SDRAM_OPMODE]  = 0x00000000;
gt64xxx.c:    s->regs[GT_SDRAM_BM]      = 0x00000007;
gt64xxx.c:    s->regs[GT_SDRAM_ADDRDECODE] = 0x00000002;
gt64xxx.c:    s->regs[GT_SDRAM_B0]      = 0x00000005;
gt64xxx.c:    s->regs[GT_SDRAM_B1]      = 0x00000005;
gt64xxx.c:    s->regs[GT_SDRAM_B2]      = 0x00000005;
gt64xxx.c:    s->regs[GT_SDRAM_B3]      = 0x00000005;
gt64xxx.c:    s->regs[GT_ECC_ERRDATALO] = 0x00000000;
gt64xxx.c:    s->regs[GT_ECC_ERRDATAHI] = 0x00000000;
gt64xxx.c:    s->regs[GT_ECC_MEM]       = 0x00000000;
gt64xxx.c:    s->regs[GT_ECC_CALC]      = 0x00000000;
gt64xxx.c:    s->regs[GT_ECC_ERRADDR]   = 0x00000000;
gt64xxx.c:    s->regs[GT_DEV_B0]        = 0x386fffff;
gt64xxx.c:    s->regs[GT_DEV_B1]        = 0x386fffff;
gt64xxx.c:    s->regs[GT_DEV_B2]        = 0x386fffff;
gt64xxx.c:    s->regs[GT_DEV_B3]        = 0x386fffff;
gt64xxx.c:    s->regs[GT_DEV_BOOT]      = 0x146fffff;
gt64xxx.c:    s->regs[GT_TC0]           = 0xffffffff;
gt64xxx.c:    s->regs[GT_TC1]           = 0x00ffffff;
gt64xxx.c:    s->regs[GT_TC2]           = 0x00ffffff;
gt64xxx.c:    s->regs[GT_TC3]           = 0x00ffffff;
gt64xxx.c:    s->regs[GT_TC_CONTROL]    = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_CMD]      = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_CMD]      = 0x00010001;
gt64xxx.c:    s->regs[GT_PCI0_TOR]      = 0x0000070f;
gt64xxx.c:    s->regs[GT_PCI0_BS_SCS10] = 0x00fff000;
gt64xxx.c:    s->regs[GT_PCI0_BS_SCS32] = 0x00fff000;
gt64xxx.c:    s->regs[GT_PCI0_BS_CS20]  = 0x01fff000;
gt64xxx.c:    s->regs[GT_PCI0_BS_CS3BT] = 0x00fff000;
gt64xxx.c:    s->regs[GT_PCI1_IACK]     = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_IACK]     = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_BARE]     = 0x0000000f;
gt64xxx.c:    s->regs[GT_PCI0_PREFMBR]  = 0x00000040;
gt64xxx.c:    s->regs[GT_PCI0_SCS10_BAR] = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_SCS32_BAR] = 0x01000000;
gt64xxx.c:    s->regs[GT_PCI0_CS20_BAR] = 0x1c000000;
gt64xxx.c:    s->regs[GT_PCI0_CS3BT_BAR] = 0x1f000000;
gt64xxx.c:    s->regs[GT_PCI0_SSCS10_BAR] = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_SSCS32_BAR] = 0x01000000;
gt64xxx.c:    s->regs[GT_PCI0_SCS3BT_BAR] = 0x1f000000;
gt64xxx.c:    s->regs[GT_PCI1_CMD]      = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI1_CMD]      = 0x00010001;
gt64xxx.c:    s->regs[GT_PCI1_TOR]      = 0x0000070f;
gt64xxx.c:    s->regs[GT_PCI1_BS_SCS10] = 0x00fff000;
gt64xxx.c:    s->regs[GT_PCI1_BS_SCS32] = 0x00fff000;
gt64xxx.c:    s->regs[GT_PCI1_BS_CS20]  = 0x01fff000;
gt64xxx.c:    s->regs[GT_PCI1_BS_CS3BT] = 0x00fff000;
gt64xxx.c:    s->regs[GT_PCI1_BARE]     = 0x0000000f;
gt64xxx.c:    s->regs[GT_PCI1_PREFMBR]  = 0x00000040;
gt64xxx.c:    s->regs[GT_PCI1_SCS10_BAR] = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI1_SCS32_BAR] = 0x01000000;
gt64xxx.c:    s->regs[GT_PCI1_CS20_BAR] = 0x1c000000;
gt64xxx.c:    s->regs[GT_PCI1_CS3BT_BAR] = 0x1f000000;
gt64xxx.c:    s->regs[GT_PCI1_SSCS10_BAR] = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI1_SSCS32_BAR] = 0x01000000;
gt64xxx.c:    s->regs[GT_PCI1_SCS3BT_BAR] = 0x1f000000;
gt64xxx.c:    s->regs[GT_PCI1_CFGADDR]  = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI1_CFGDATA]  = 0x00000000;
gt64xxx.c:    s->regs[GT_PCI0_CFGADDR]  = 0x00000000;
gt64xxx.c:        return -EINVAL;
gt64xxx.c:    s->pci = qemu_mallocz(sizeof(GT64120PCIState));
gt64xxx.c:    s->pci->bus = pci_register_bus(NULL, "pci",
gt64xxx.c:    s->ISD_handle = cpu_register_io_memory(gt64120_read, gt64120_write, s);
gt64xxx.c:    d = pci_register_device(s->pci->bus, "GT64120 PCI Bus", sizeof(PCIDevice),
gt64xxx.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MARVELL);
gt64xxx.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MARVELL_GT6412X);
gt64xxx.c:    d->config[0x04] = 0x00;
gt64xxx.c:    d->config[0x05] = 0x00;
gt64xxx.c:    d->config[0x06] = 0x80;
gt64xxx.c:    d->config[0x07] = 0x02;
gt64xxx.c:    d->config[0x08] = 0x10;
gt64xxx.c:    d->config[0x09] = 0x00;
gt64xxx.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
gt64xxx.c:    d->config[0x10] = 0x08;
gt64xxx.c:    d->config[0x14] = 0x08;
gt64xxx.c:    d->config[0x17] = 0x01;
gt64xxx.c:    d->config[0x1B] = 0x1c;
gt64xxx.c:    d->config[0x1F] = 0x1f;
gt64xxx.c:    d->config[0x23] = 0x14;
gt64xxx.c:    d->config[0x24] = 0x01;
gt64xxx.c:    d->config[0x27] = 0x14;
gt64xxx.c:    d->config[0x3D] = 0x01;
gt64xxx.c:    return s->pci->bus;
gumstix.c: * # dd of=flash bs=1k conv=notrunc if=u-boot.bin
gumstix.c: * # qemu-system-arm -M connex -pflash flash -monitor null -nographic
gumstix.c: * # dd of=flash bs=1k conv=notrunc if=u-boot.bin
gumstix.c: * # qemu-system-arm -M verdex -pflash flash -monitor null -nographic -m 289
gumstix.c:            dinfo->bdrv, sector_len, connex_rom / sector_len,
gumstix.c:    cpu->env->regs[15] = 0x00000000;
gumstix.c:                    pxa2xx_gpio_in_get(cpu->gpio)[36]);
gumstix.c:    cpu = pxa270_init(verdex_ram, cpu_model ?: "pxa270-c0");
gumstix.c:            dinfo->bdrv, sector_len, verdex_rom / sector_len,
gumstix.c:    cpu->env->regs[15] = 0x00000000;
gumstix.c:                    pxa2xx_gpio_in_get(cpu->gpio)[99]);
gus.c: * Copyright (c) 2002-2005 Vassili Karpov (malc)
gus.c:    return gus_read (&s->emu, nport, 1);
gus.c:    return gus_read (&s->emu, nport, 2);
gus.c:    gus_write (&s->emu, nport, 1, val);
gus.c:    gus_write (&s->emu, nport, 2, val);
gus.c:    int pos = s->pos;
gus.c:        nbytes = samples << s->shift;
gus.c:            s->voice,
gus.c:            s->mixbuf + (pos << (s->shift - 1)),
gus.c:            wsampl = wbytes >> s->shift;
gus.c:            samples -= wsampl;
gus.c:            pos = (pos + wsampl) % s->samples;
gus.c:    samples = free >> s->shift;
gus.c:    to_play = audio_MIN (samples, s->left);
gus.c:        s->left -= written;
gus.c:        to_play -= written;
gus.c:        samples -= written;
gus.c:    samples = audio_MIN (samples, s->samples);
gus.c:        gus_mixvoices (&s->emu, s->freq, samples, s->mixbuf);
gus.c:            samples -= written;
gus.c:    s->left = samples;
gus.c:    gus_irqgen (&s->emu, muldiv64 (net, 1000000, s->freq));
gus.c:    GUSState *s = emu->opaque;
gus.c:    /* qemu_irq_lower (s->pic); */
gus.c:    qemu_irq_raise (s->pic);
gus.c:    s->irqs += n;
gus.c:    ldebug ("irqrequest %d %d %d\n", hwirq, n, s->irqs);
gus.c:    GUSState *s = emu->opaque;
gus.c:    ldebug ("irqclear %d %d\n", hwirq, s->irqs);
gus.c:    qemu_irq_lower (s->pic);
gus.c:    s->irqs -= 1;
gus.c:    if (s->irqs > 0) {
gus.c:        qemu_irq_raise (s->pic[hwirq]);
gus.c:    ldebug ("dma request %d\n", der->gusdma);
gus.c:    DMA_hold_DREQ (der->gusdma);
gus.c:    int pos = dma_pos, mode, left = dma_len - dma_pos;
gus.c:    mode = DMA_get_channel_mode (s->emu.gusdma);
gus.c:        gus_dma_transferdata (&s->emu, tmpbuf, copied, left == copied);
gus.c:        left -= copied;
gus.c:        DMA_release_DREQ (s->emu.gusdma);
gus.c:    AUD_register_card ("gus", &s->card);
gus.c:    as.freq = s->freq;
gus.c:    s->voice = AUD_open_out (
gus.c:        &s->card,
gus.c:    if (!s->voice) {
gus.c:        AUD_remove_card (&s->card);
gus.c:        return -1;
gus.c:    s->shift = 2;
gus.c:    s->samples = AUD_get_buffer_size_out (s->voice) >> s->shift;
gus.c:    s->mixbuf = qemu_mallocz (s->samples << s->shift);
gus.c:    register_ioport_write (s->port, 1, 1, gus_writeb, s);
gus.c:    register_ioport_write (s->port, 1, 2, gus_writew, s);
gus.c:    register_ioport_read ((s->port + 0x100) & 0xf00, 1, 1, gus_readb, s);
gus.c:    register_ioport_read ((s->port + 0x100) & 0xf00, 1, 2, gus_readw, s);
gus.c:    register_ioport_write (s->port + 6, 10, 1, gus_writeb, s);
gus.c:    register_ioport_write (s->port + 6, 10, 2, gus_writew, s);
gus.c:    register_ioport_read (s->port + 6, 10, 1, gus_readb, s);
gus.c:    register_ioport_read (s->port + 6, 10, 2, gus_readw, s);
gus.c:    register_ioport_write (s->port + 0x100, 8, 1, gus_writeb, s);
gus.c:    register_ioport_write (s->port + 0x100, 8, 2, gus_writew, s);
gus.c:    register_ioport_read (s->port + 0x100, 8, 1, gus_readb, s);
gus.c:    register_ioport_read (s->port + 0x100, 8, 2, gus_readw, s);
gus.c:    DMA_register_channel (s->emu.gusdma, GUS_read_DMA, s);
gus.c:    s->emu.himemaddr = s->himem;
gus.c:    s->emu.gusdatapos = s->emu.himemaddr + 1024 * 1024 + 32;
gus.c:    s->emu.opaque = s;
gus.c:    isa_init_irq (dev, &s->pic, s->emu.gusirq);
gus.c:    AUD_set_active_out (s->voice, 1);
gusemu.h: * GUSEMU32 - API
gusemu.h: * Copyright (C) 2000-2007 Tibor "TS" Schtz
gusemu.h: GUSbyte *gusdatapos; /* (gusdataend-gusdata) bytes used for storing emulated GF1/mixer register states (32*32+4 bytes in initial GUSemu32 version) */
gusemu.h:/* NMI is defined as hwirq=-1 (not supported (yet?)) */
gusemu.h:void GUS_irqclear(  GUSEmuState *state, int hwirq); /* used by gus_write() only - can be left empty for mixer functions */
gusemu.h:void GUS_dmarequest(GUSEmuState *state);            /* used by gus_write() only - can be left empty for mixer functions */
gusemu.h:/* -dma_count is actually count-1 */
gusemu.h:/* -before and during a transfer, DREQ is set and TC cleared */
gusemu.h:/* -when calling gus_dma_transferdata(), TC is only set true for call transfering the last byte */
gusemu.h:/* -after the last transfer, DREQ is cleared and TC is set */
gusemu_hal.c: * GUSEMU32 - bus interface part
gusemu_hal.c: * Copyright (C) 2000-2007 Tibor "TS" Schtz
gusemu_hal.c:    gusptr = state->gusdatapos;
gusemu_hal.c:            /* case 1-5:                        */ /* general purpose emulation regs  */
gusemu_hal.c:        /* case 0x20D:                   */ /* SB2xD is write only -> 2xE writes to it*/
gusemu_hal.c:            GUS_irqrequest(state, state->gusirq, 1);
gusemu_hal.c:            if (state->gusdma >= 4)
gusemu_hal.c:                    GUS_irqclear(state, state->gusirq);
gusemu_hal.c:            /* 48h: samp freq - write only */
gusemu_hal.c:            /* (pseudo IRQ-FIFO is processed during a gus_write(0x3X3,0x8f)) */
gusemu_hal.c:            adr = state->himemaddr + (GUSregd(GUSDRAMPOS24bit) & 0xfffff);
gusemu_hal.c:    gusptr = state->gusdatapos;
gusemu_hal.c:        if (GUSregb(GUS45TimerCtrl) & 0x20) /* SB IRQ enabled? -> set 2x6IRQ bit */
gusemu_hal.c:            GUS_irqrequest(state, state->gusirq, 1);
gusemu_hal.c:                GUSregb(TimerStatus2x8) &= 0x1f; /* AdLib IRQ reset? -> clear maskable adl. timer int regs */
gusemu_hal.c:                GUS_irqrequest(state, state->gusirq, 1);
gusemu_hal.c:            /* case 1-4: general purpose emulation regs */
gusemu_hal.c:                GUS_irqclear(state, state->gusirq);
gusemu_hal.c:            GUSregb(TimerStatus2x8) |= 0x10; /* SB IRQ enabled? -> set 2xCIRQ bit */
gusemu_hal.c:            GUS_irqrequest(state, state->gusirq, 1);
gusemu_hal.c:                            GUS_irqclear(state, state->gusirq);
gusemu_hal.c:                            GUS_irqclear(state, state->gusirq);
gusemu_hal.c:                    GUSregb(TimerStatus2x8) &= 0xe7;    /* sb IRQ dis? -> clear 2x8/2xC sb IRQ flags */
gusemu_hal.c:                    GUSregb(TimerStatus2x8) &= 0xfe;    /* adlib data IRQ dis? -> clear 2x8 adlib IRQ flag */
gusemu_hal.c:                    GUSregw(TimerIRQs)--;
gusemu_hal.c:                        GUSregw(BusyTimerIRQs)--;
gusemu_hal.c:                            GUS_irqrequest(state, state->gusirq, GUSregw(TimerIRQs));
gusemu_hal.c:                    GUSregb(TimerStatus2x8) &= 0xfb; /* clear non-maskable timer1 bit */
gusemu_hal.c:                    GUSregb(TimerStatus2x8) &= 0xfd; /* clear non-maskable timer2 bit */
gusemu_hal.c:                    GUS_irqclear(state, state->gusirq);
gusemu_hal.c:                    GUS_irqclear(state, state->gusirq);
gusemu_hal.c:            adr = state->himemaddr + (GUSregd(GUSDRAMPOS24bit) & 0xfffff);
gusemu_hal.c: * GUSemu also uses this register to support byte-granular transfers for better compatibility
gusemu_hal.c:    gusptr = state->gusdatapos;
gusemu_hal.c:        if (state->gusdma >= 4)
gusemu_hal.c:        destaddr = (char *) state->himemaddr + offset; /* wavetable RAM adress */
gusemu_hal.c:    if (GUSregb(GUS41DMACtrl) & 0x02)   /* direction, 0 := sysram->gusram */
gusemu_hal.c:    for (; count > 0; count--)
gusemu_hal.c:        if (state->gusdma >= 4)
gusemu_hal.c:            GUS_irqrequest(state, state->gusirq, 1);
gusemu_mixer.c: * GUSEMU32 - mixing engine (similar to Interwave GF1 compatibility)
gusemu_mixer.c: * Copyright (C) 2000-2007 Tibor "TS" Schtz
gusemu_mixer.c:    gusptr = state->gusdatapos;
gusemu_mixer.c:        if (!(GUSvoice(wVSRControl) & GUSvoice(wVSRVolRampControl) & 0x100)) /* neither voice nor volume calculation active - save some time here ;) */
gusemu_mixer.c:                VoiceIncrement    = -VoiceIncrement;    /* reverse playback */
gusemu_mixer.c:                VolumeIncrement32 = -VolumeIncrement32; /* reverse ramping */
gusemu_mixer.c:                    adr = (GUSchar *) state->himemaddr + offset;
gusemu_mixer.c:                    adr = (GUSchar *) state->himemaddr + offset;
gusemu_mixer.c:                Volume = ((((Volume32 >> (4 + 5)) & 0xff) + 256) << (Volume32 >> ((4 + 8) + 5))) / 512; /* semi-logarithmic volume, +5 due to additional precision */
gusemu_mixer.c:                sample1 = (((sample1 * Volume) >> 16) * (512 - (CurrPos % 512))) / 512;
gusemu_mixer.c:                            GUSvoice(wVSRVolRampControl) |= 0x8000;     /* volramp IRQ enabled? -> IRQ wait flag */
gusemu_mixer.c:                                VolumeIncrement32 = -VolumeIncrement32;
gusemu_mixer.c:                            GUSvoice(wVSRControl) |= 0x8000;       /* voice IRQ enabled -> IRQ wait flag */
gusemu_mixer.c:                                VoiceIncrement = -VoiceIncrement;
gusemu_mixer.c:                *(bufferpos + 2 * sample + 1) += (GUSsample) ((sample1 * (15 - PanningPos)) >> 4); /* left */
gusemu_mixer.c:    gusptr = state->gusdatapos;
gusemu_mixer.c:        unsigned int    timer1fraction = state->timer1fraction;
gusemu_mixer.c:        newtimerirqs          = (elapsed_time + timer1fraction) / (80 * (256 - GUSregb(GUS46Counter1)));
gusemu_mixer.c:        state->timer1fraction = (elapsed_time + timer1fraction) % (80 * (256 - GUSregb(GUS46Counter1)));
gusemu_mixer.c:        unsigned int timer2fraction = state->timer2fraction;
gusemu_mixer.c:        newtimerirqs          = (elapsed_time + timer2fraction) / (320 * (256 - GUSregb(GUS47Counter2)));
gusemu_mixer.c:        state->timer2fraction = (elapsed_time + timer2fraction) % (320 * (256 - GUSregb(GUS47Counter2)));
gusemu_mixer.c:        GUSregw(BusyTimerIRQs) = GUS_irqrequest(state, state->gusirq, requestedIRQs);
gustate.h: * GUSEMU32 - persistent GUS register state
gustate.h: * Copyright (C) 2000-2007 Tibor "TS" Schtz
heathrow_pic.c: * Copyright (c) 2005-2007 Fabrice Bellard
heathrow_pic.c:    return (pic->events | (pic->levels & pic->level_triggered)) & pic->mask;
heathrow_pic.c:    if (check_irq(&s->pics[0]) || check_irq(&s->pics[1])) {
heathrow_pic.c:        qemu_irq_raise(s->irqs[0]);
heathrow_pic.c:        qemu_irq_lower(s->irqs[0]);
heathrow_pic.c:    n = ((addr & 0xfff) - 0x10) >> 4;
heathrow_pic.c:    pic = &s->pics[n];
heathrow_pic.c:        pic->mask = value;
heathrow_pic.c:        value &= ~pic->level_triggered;
heathrow_pic.c:        pic->events &= ~value;
heathrow_pic.c:    n = ((addr & 0xfff) - 0x10) >> 4;
heathrow_pic.c:        pic = &s->pics[n];
heathrow_pic.c:            value = pic->events;
heathrow_pic.c:            value = pic->mask;
heathrow_pic.c:            value = pic->levels;
heathrow_pic.c:    pic = &s->pics[1 - (num >> 5)];
heathrow_pic.c:        pic->events |= irq_bit & ~pic->level_triggered;
heathrow_pic.c:        pic->levels |= irq_bit;
heathrow_pic.c:        pic->levels &= ~irq_bit;
heathrow_pic.c:    qemu_put_be32s(f, &s->events);
heathrow_pic.c:    qemu_put_be32s(f, &s->mask);
heathrow_pic.c:    qemu_put_be32s(f, &s->levels);
heathrow_pic.c:    qemu_put_be32s(f, &s->level_triggered);
heathrow_pic.c:    heathrow_pic_save_one(f, &s->pics[0]);
heathrow_pic.c:    heathrow_pic_save_one(f, &s->pics[1]);
heathrow_pic.c:    qemu_get_be32s(f, &s->events);
heathrow_pic.c:    qemu_get_be32s(f, &s->mask);
heathrow_pic.c:    qemu_get_be32s(f, &s->levels);
heathrow_pic.c:    qemu_get_be32s(f, &s->level_triggered);
heathrow_pic.c:        return -EINVAL;
heathrow_pic.c:    heathrow_pic_load_one(f, &s->pics[0]);
heathrow_pic.c:    heathrow_pic_load_one(f, &s->pics[1]);
heathrow_pic.c:    heathrow_pic_reset_one(&s->pics[0]);
heathrow_pic.c:    heathrow_pic_reset_one(&s->pics[1]);
heathrow_pic.c:    s->pics[0].level_triggered = 0;
heathrow_pic.c:    s->pics[1].level_triggered = 0x1ff00000;
heathrow_pic.c:    s->irqs = irqs[0];
heathrow_pic.c:    register_savevm("heathrow_pic", -1, 1, heathrow_pic_save,
hpet.c:#include "qemu-timer.h"
hpet.c:        return hpet_statep->config & HPET_CFG_LEGACY;
hpet.c:    route = (timer->config & HPET_TN_INT_ROUTE_MASK) >> HPET_TN_INT_ROUTE_SHIFT;
hpet.c:    return hpet_statep->config & HPET_CFG_ENABLE;
hpet.c:    return t->config & HPET_TN_PERIODIC;
hpet.c:    return t->config & HPET_TN_ENABLE;
hpet.c:    return ((int32_t)(b) - (int32_t)(a) < 0);
hpet.c:    return ((int64_t)(b) - (int64_t)(a) < 0);
hpet.c:    ticks = ns_to_ticks(qemu_get_clock(vm_clock) + hpet_statep->hpet_offset);
hpet.c:    if (t->config & HPET_TN_32BIT) {
hpet.c:        cmp = (uint32_t)t->cmp;
hpet.c:        diff = cmp - (uint32_t)current;
hpet.c:        cmp = t->cmp;
hpet.c:        diff = cmp - current;
hpet.c:    if (timer->tn <= 1 && hpet_in_legacy_mode()) {
hpet.c:         * timer0 be routed to IRQ0 in NON-APIC or IRQ2 in the I/O APIC,
hpet.c:         * timer1 be routed to IRQ8 in NON-APIC or IRQ8 in the I/O APIC.
hpet.c:        if (timer->tn == 0) {
hpet.c:            irq=timer->state->irqs[0];
hpet.c:            irq=timer->state->irqs[8];
hpet.c:        irq=timer->state->irqs[route];
hpet.c:    s->hpet_counter = hpet_get_ticks();
hpet.c:    s->hpet_offset = ticks_to_ns(s->hpet_counter) - qemu_get_clock(vm_clock);
hpet.c:    uint64_t period = t->period;
hpet.c:        if (t->config & HPET_TN_32BIT) {
hpet.c:            while (hpet_time_after(cur_tick, t->cmp))
hpet.c:                t->cmp = (uint32_t)(t->cmp + t->period);
hpet.c:            while (hpet_time_after64(cur_tick, t->cmp))
hpet.c:                t->cmp += period;
hpet.c:        qemu_mod_timer(t->qemu_timer, qemu_get_clock(vm_clock)
hpet.c:    } else if (t->config & HPET_TN_32BIT && !timer_is_periodic(t)) {
hpet.c:        if (t->wrap_flag) {
hpet.c:            qemu_mod_timer(t->qemu_timer, qemu_get_clock(vm_clock)
hpet.c:            t->wrap_flag = 0;
hpet.c:    t->wrap_flag = 0;
hpet.c:    /* hpet spec says in one-shot 32-bit mode, generate an interrupt when
hpet.c:    if (t->config & HPET_TN_32BIT && !timer_is_periodic(t)) {
hpet.c:        wrap_diff = 0xffffffff - (uint32_t)cur_tick;
hpet.c:            t->wrap_flag = 1;
hpet.c:    qemu_mod_timer(t->qemu_timer, qemu_get_clock(vm_clock)
hpet.c:    qemu_del_timer(t->qemu_timer);
hpet.c:        uint8_t timer_id = (addr - 0x100) / 0x20;
hpet.c:        if (timer_id > HPET_NUM_TIMERS - 1) {
hpet.c:        HPETTimer *timer = &s->timer[timer_id];
hpet.c:        switch ((addr - 0x100) % 0x20) {
hpet.c:                return timer->config;
hpet.c:                return timer->config >> 32;
hpet.c:                return timer->cmp;
hpet.c:                return timer->cmp >> 32;
hpet.c:                return timer->fsb >> 32;
hpet.c:                return s->capability;
hpet.c:                return s->capability >> 32;
hpet.c:                return s->config;
hpet.c:                    cur_tick = s->hpet_counter;
hpet.c:                    cur_tick = s->hpet_counter;
hpet.c:                return s->isr;
hpet.c:        uint8_t timer_id = (addr - 0x100) / 0x20;
hpet.c:        HPETTimer *timer = &s->timer[timer_id];
hpet.c:        switch ((addr - 0x100) % 0x20) {
hpet.c:                timer->config = (timer->config & 0xffffffff00000000ULL) | val;
hpet.c:                    timer->cmp = (uint32_t)timer->cmp;
hpet.c:                    timer->period = (uint32_t)timer->period;
hpet.c:                    printf("qemu: level-triggered hpet not supported\n");
hpet.c:                    exit (-1);
hpet.c:                if (timer->config & HPET_TN_32BIT)
hpet.c:                           (timer->config & HPET_TN_SETVAL))
hpet.c:                    timer->cmp = (timer->cmp & 0xffffffff00000000ULL)
hpet.c:                    new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;
hpet.c:                    timer->period = (timer->period & 0xffffffff00000000ULL)
hpet.c:                timer->config &= ~HPET_TN_SETVAL;
hpet.c:                           (timer->config & HPET_TN_SETVAL))
hpet.c:                    timer->cmp = (timer->cmp & 0xffffffffULL)
hpet.c:                    new_val &= (timer->config
hpet.c:                    timer->period = (timer->period & 0xffffffffULL)
hpet.c:                timer->config &= ~HPET_TN_SETVAL;
hpet.c:                s->config = (s->config & 0xffffffff00000000ULL) | val;
hpet.c:                    s->hpet_offset = ticks_to_ns(s->hpet_counter)
hpet.c:                                     - qemu_get_clock(vm_clock);
hpet.c:                        if ((&s->timer[i])->cmp != ~0ULL)
hpet.c:                            hpet_set_timer(&s->timer[i]);
hpet.c:                    s->hpet_counter = hpet_get_ticks();
hpet.c:                        hpet_del_timer(&s->timer[i]);
hpet.c:                /* FIXME: need to handle level-triggered interrupts */
hpet.c:               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)
hpet.c:               dprintf("qemu: HPET counter written. ctr = %#x -> %" PRIx64 "\n",
hpet.c:                        value, s->hpet_counter);
hpet.c:               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)
hpet.c:               dprintf("qemu: HPET counter + 4 written. ctr = %#x -> %" PRIx64 "\n",
hpet.c:                        value, s->hpet_counter);
hpet.c:        HPETTimer *timer = &s->timer[i];
hpet.c:        timer->tn = i;
hpet.c:        timer->cmp = ~0ULL;
hpet.c:        timer->config =  HPET_TN_PERIODIC_CAP | HPET_TN_SIZE_CAP;
hpet.c:        timer->config |=  0x00000004ULL << 32;
hpet.c:        timer->state = s;
hpet.c:        timer->period = 0ULL;
hpet.c:        timer->wrap_flag = 0;
hpet.c:    s->hpet_counter = 0ULL;
hpet.c:    s->hpet_offset = 0ULL;
hpet.c:    /* 64-bit main counter; 3 timers supported; LegacyReplacementRoute. */
hpet.c:    s->capability = 0x8086a201ULL;
hpet.c:    s->capability |= ((HPET_CLK_PERIOD) << 32);
hpet.c:    s->config = 0ULL;
hpet.c:    s->irqs = irq;
hpet.c:        HPETTimer *timer = &s->timer[i];
hpet.c:        timer->qemu_timer = qemu_new_timer(vm_clock, hpet_timer, timer);
hpet.c:    vmstate_register(-1, &vmstate_hpet, s);
hpet_emul.h: * the COPYING file in the top-level directory.
hpet_emul.h:    /* Memory-mapped, software visible timer registers */
hpet_emul.h:    uint8_t wrap_flag;      /* timer pop will indicate wrap for one-shot 32-bit
hpet_emul.h:    /* Memory-mapped, software visible registers */
hw.h:#include "qemu-common.h"
hw.h:#include "cpu-common.h"
hw.h:#define type_check_array(t1,t2,n) ((t1(*)[n])0 - (t2*)0)
hw.h:#define type_check_pointer(t1,t2) ((t1**)0 - (t2*)0)
hw.h:    .size         = (_size - _start),                                \
i2c.c:    bus->saved_address = bus->current_dev ? bus->current_dev->address : -1;
i2c.c:    bus->current_dev = NULL;
i2c.c:    vmstate_register(-1, &vmstate_i2c_bus, bus);
i2c.c:    dev->address = address;
i2c.c:    return bus->current_dev != NULL;
i2c.c:/* Returns non-zero if the address is not valid.  */
i2c.c:    QLIST_FOREACH(qdev, &bus->qbus.children, sibling) {
i2c.c:        if (candidate->address == address) {
i2c.c:    bus->current_dev = slave;
i2c.c:    slave->info->event(slave, recv ? I2C_START_RECV : I2C_START_SEND);
i2c.c:    i2c_slave *dev = bus->current_dev;
i2c.c:    dev->info->event(dev, I2C_FINISH);
i2c.c:    bus->current_dev = NULL;
i2c.c:    i2c_slave *dev = bus->current_dev;
i2c.c:        return -1;
i2c.c:    return dev->info->send(dev, data);
i2c.c:    i2c_slave *dev = bus->current_dev;
i2c.c:        return -1;
i2c.c:    return dev->info->recv(dev);
i2c.c:    i2c_slave *dev = bus->current_dev;
i2c.c:    dev->info->event(dev, I2C_NACK);
i2c.c:    bus = FROM_QBUS(i2c_bus, qdev_get_parent_bus(&dev->qdev));
i2c.c:    if (bus->saved_address == dev->address) {
i2c.c:        bus->current_dev = dev;
i2c.c:    s->info = info;
i2c.c:    return info->init(s);
i2c.c:    assert(info->qdev.size >= sizeof(i2c_slave));
i2c.c:    info->qdev.init = i2c_slave_qdev_init;
i2c.c:    info->qdev.bus_info = &i2c_bus_info;
i2c.c:    qdev_register(&info->qdev);
i2c.c:    dev = qdev_create(&bus->qbus, name);
i8254.c: * Copyright (c) 2003-2004 Fabrice Bellard
i8254.c:#include "qemu-timer.h"
i8254.c:#include "qemu-kvm.h"
i8254.c:    d = muldiv64(qemu_get_clock(vm_clock) - s->count_load_time, PIT_FREQ,
i8254.c:    switch(s->mode) {
i8254.c:        counter = (s->count - d) & 0xffff;
i8254.c:        counter = s->count - ((2 * d) % s->count);
i8254.c:        counter = s->count - (d % s->count);
i8254.c:    d = muldiv64(current_time - s->count_load_time, PIT_FREQ,
i8254.c:    switch(s->mode) {
i8254.c:        out = (d >= s->count);
i8254.c:        out = (d < s->count);
i8254.c:        if ((d % s->count) == 0 && d != 0)
i8254.c:        out = (d % s->count) < ((s->count + 1) >> 1);
i8254.c:        out = (d == s->count);
i8254.c:    PITChannelState *s = &pit->channels[channel];
i8254.c:/* return -1 if no transition will occur.  */
i8254.c:    d = muldiv64(current_time - s->count_load_time, PIT_FREQ,
i8254.c:    switch(s->mode) {
i8254.c:        if (d < s->count)
i8254.c:            next_time = s->count;
i8254.c:            return -1;
i8254.c:        base = (d / s->count) * s->count;
i8254.c:        if ((d - base) == 0 && d != 0)
i8254.c:            next_time = base + s->count;
i8254.c:            next_time = base + s->count + 1;
i8254.c:        base = (d / s->count) * s->count;
i8254.c:        period2 = ((s->count + 1) >> 1);
i8254.c:        if ((d - base) < period2)
i8254.c:            next_time = base + s->count;
i8254.c:        if (d < s->count)
i8254.c:            next_time = s->count;
i8254.c:        else if (d == s->count)
i8254.c:            next_time = s->count + 1;
i8254.c:            return -1;
i8254.c:    next_time = s->count_load_time + muldiv64(next_time, get_ticks_per_sec(),
i8254.c:    PITChannelState *s = &pit->channels[channel];
i8254.c:    switch(s->mode) {
i8254.c:        if (s->gate < val) {
i8254.c:            s->count_load_time = qemu_get_clock(vm_clock);
i8254.c:            pit_irq_timer_update(s, s->count_load_time);
i8254.c:        if (s->gate < val) {
i8254.c:            s->count_load_time = qemu_get_clock(vm_clock);
i8254.c:            pit_irq_timer_update(s, s->count_load_time);
i8254.c:    s->gate = val;
i8254.c:    PITChannelState *s = &pit->channels[channel];
i8254.c:    return s->gate;
i8254.c:    PITChannelState *s = &pit->channels[channel];
i8254.c:    return s->count;
i8254.c:    PITChannelState *s = &pit->channels[channel];
i8254.c:    return s->mode;
i8254.c:    s->channels[chan].count_load_time = qemu_get_clock(vm_clock);
i8254.c:    s->channels[chan].count = val;
i8254.c:    pit_irq_timer_update(&s->channels[chan], s->channels[chan].count_load_time);
i8254.c:    if (!s->count_latched) {
i8254.c:        s->latched_count = pit_get_count(s);
i8254.c:        s->count_latched = s->rw_mode;
i8254.c:                s = &pit->channels[channel];
i8254.c:                    if (!(val & 0x10) && !s->status_latched) {
i8254.c:                        s->status =  (pit_get_out1(s, qemu_get_clock(vm_clock)) << 7) |
i8254.c:                            (s->rw_mode << 4) |
i8254.c:                            (s->mode << 1) |
i8254.c:                            s->bcd;
i8254.c:                        s->status_latched = 1;
i8254.c:            s = &pit->channels[channel];
i8254.c:                s->rw_mode = access;
i8254.c:                s->read_state = access;
i8254.c:                s->write_state = access;
i8254.c:                s->mode = (val >> 1) & 7;
i8254.c:                s->bcd = val & 1;
i8254.c:        s = &pit->channels[addr];
i8254.c:        switch(s->write_state) {
i8254.c:            s->write_latch = val;
i8254.c:            s->write_state = RW_STATE_WORD1;
i8254.c:            pit_load_count(pit, s->write_latch | (val << 8), addr);
i8254.c:            s->write_state = RW_STATE_WORD0;
i8254.c:    s = &pit->channels[addr];
i8254.c:    if (s->status_latched) {
i8254.c:        s->status_latched = 0;
i8254.c:        ret = s->status;
i8254.c:    } else if (s->count_latched) {
i8254.c:        switch(s->count_latched) {
i8254.c:            ret = s->latched_count & 0xff;
i8254.c:            s->count_latched = 0;
i8254.c:            ret = s->latched_count >> 8;
i8254.c:            s->count_latched = 0;
i8254.c:            ret = s->latched_count & 0xff;
i8254.c:            s->count_latched = RW_STATE_MSB;
i8254.c:        switch(s->read_state) {
i8254.c:            s->read_state = RW_STATE_WORD1;
i8254.c:            s->read_state = RW_STATE_WORD0;
i8254.c:/* global counters for time-drift fix */
i8254.c:    if (!s->irq_timer)
i8254.c:    qemu_set_irq(s->irq, irq_level);
i8254.c:         *        Currently setting it to 5% of PIT-ticks-per-second (per PIT-tick)
i8254.c:        const long pit_ticks_per_sec = (s->count>0) ? (PIT_FREQ/s->count) : 0;
i8254.c:        const long delta = timer_interrupts - timer_acks;
i8254.c:           (double)(expire_time - current_time) / get_ticks_per_sec());
i8254.c:    s->next_transition_time = expire_time;
i8254.c:    if (expire_time != -1) {
i8254.c:        qemu_mod_timer(s->irq_timer, expire_time);
i8254.c:        qemu_del_timer(s->irq_timer);
i8254.c:    pit_irq_timer_update(s, s->next_transition_time);
i8254.c:        return -EINVAL;
i8254.c:    pit->flags = qemu_get_be32(f);
i8254.c:        s = &pit->channels[i];
i8254.c:        s->count=qemu_get_be32(f);
i8254.c:        qemu_get_be16s(f, &s->latched_count);
i8254.c:        qemu_get_8s(f, &s->count_latched);
i8254.c:        qemu_get_8s(f, &s->status_latched);
i8254.c:        qemu_get_8s(f, &s->status);
i8254.c:        qemu_get_8s(f, &s->read_state);
i8254.c:        qemu_get_8s(f, &s->write_state);
i8254.c:        qemu_get_8s(f, &s->write_latch);
i8254.c:        qemu_get_8s(f, &s->rw_mode);
i8254.c:        qemu_get_8s(f, &s->mode);
i8254.c:        qemu_get_8s(f, &s->bcd);
i8254.c:        qemu_get_8s(f, &s->gate);
i8254.c:        s->count_load_time=qemu_get_be64(f);
i8254.c:        if (s->irq_timer) {
i8254.c:            s->next_transition_time=qemu_get_be64(f);
i8254.c:            qemu_get_timer(f, s->irq_timer);
i8254.c:    pit->flags &= ~PIT_FLAGS_HPET_LEGACY;
i8254.c:        s = &pit->channels[i];
i8254.c:        s->mode = 3;
i8254.c:        s->gate = (i != 2);
i8254.c:        if (s->irq_timer) {
i8254.c:            qemu_del_timer(s->irq_timer);
i8254.c:    PITChannelState *s = &pit->channels[0];
i8254.c:        pit_load_count(pit, s->count, 0);
i8254.c:    s = &pit->channels[0];
i8254.c:    s->irq_timer = qemu_new_timer(vm_clock, pit_irq_timer, s);
i8254.c:    s->irq = irq;
i8254.h: * Copyright (c) 2003-2004 Fabrice Bellard
i8254-kvm.c: * Copyright (c) 2003-2004 Fabrice Bellard
i8254-kvm.c:#include "qemu-timer.h"
i8254-kvm.c:#include "qemu-kvm.h"
i8254-kvm.c:        s->flags = pit2.flags;
i8254-kvm.c:	sc = &s->channels[i];
i8254-kvm.c:	sc->count = c->count;
i8254-kvm.c:	sc->latched_count = c->latched_count;
i8254-kvm.c:	sc->count_latched = c->count_latched;
i8254-kvm.c:	sc->status_latched = c->status_latched;
i8254-kvm.c:	sc->status = c->status;
i8254-kvm.c:	sc->read_state = c->read_state;
i8254-kvm.c:	sc->write_state = c->write_state;
i8254-kvm.c:	sc->write_latch = c->write_latch;
i8254-kvm.c:	sc->rw_mode = c->rw_mode;
i8254-kvm.c:	sc->mode = c->mode;
i8254-kvm.c:	sc->bcd = c->bcd;
i8254-kvm.c:	sc->gate = c->gate;
i8254-kvm.c:	sc->count_load_time = c->count_load_time;
i8254-kvm.c:    pit2.flags = s->flags;
i8254-kvm.c:	sc = &s->channels[i];
i8254-kvm.c:	c->count = sc->count;
i8254-kvm.c:	c->latched_count = sc->latched_count;
i8254-kvm.c:	c->count_latched = sc->count_latched;
i8254-kvm.c:	c->status_latched = sc->status_latched;
i8254-kvm.c:	c->status = sc->status;
i8254-kvm.c:	c->read_state = sc->read_state;
i8254-kvm.c:	c->write_state = sc->write_state;
i8254-kvm.c:	c->write_latch = sc->write_latch;
i8254-kvm.c:	c->rw_mode = sc->rw_mode;
i8254-kvm.c:	c->mode = sc->mode;
i8254-kvm.c:	c->bcd = sc->bcd;
i8254-kvm.c:	c->gate = sc->gate;
i8254-kvm.c:	c->count_load_time = sc->count_load_time;
i8254-kvm.c:    s = &pit->channels[0];
i8254-kvm.c:    s->irq_timer = qemu_new_timer(vm_clock, dummy_timer, s);
i8259.c: * Copyright (c) 2003-2004 Fabrice Bellard
i8259.c:#include "qemu-timer.h"
i8259.c:#include "qemu-kvm.h"
i8259.c:    if (s->elcr & mask) {
i8259.c:            s->irr |= mask;
i8259.c:            s->last_irr |= mask;
i8259.c:            s->irr &= ~mask;
i8259.c:            s->last_irr &= ~mask;
i8259.c:            if ((s->last_irr & mask) == 0)
i8259.c:                s->irr |= mask;
i8259.c:            s->last_irr |= mask;
i8259.c:            s->last_irr &= ~mask;
i8259.c:    while ((mask & (1 << ((priority + s->priority_add) & 7))) == 0)
i8259.c:/* return the pic wanted interrupt. return -1 if none */
i8259.c:    mask = s->irr & ~s->imr;
i8259.c:        return -1;
i8259.c:    mask = s->isr;
i8259.c:    if (s->special_mask)
i8259.c:        mask &= ~s->imr;
i8259.c:    if (s->special_fully_nested_mode && s == &s->pics_state->pics[0])
i8259.c:        return (priority + s->priority_add) & 7;
i8259.c:        return -1;
i8259.c:    irq2 = pic_get_irq(&s->pics[1]);
i8259.c:        pic_set_irq1(&s->pics[0], 2, 1);
i8259.c:        pic_set_irq1(&s->pics[0], 2, 0);
i8259.c:    irq = pic_get_irq(&s->pics[0]);
i8259.c:                       i, s->pics[i].imr, s->pics[i].irr,
i8259.c:                       s->pics[i].priority_add);
i8259.c:        qemu_irq_raise(s->parent_irq);
i8259.c:        qemu_irq_lower(s->parent_irq);
i8259.c:    pic_set_irq1(&s->pics[irq >> 3], irq & 7, level);
i8259.c:    if (s->auto_eoi) {
i8259.c:        if (s->rotate_on_auto_eoi)
i8259.c:            s->priority_add = (irq + 1) & 7;
i8259.c:        s->isr |= (1 << irq);
i8259.c:    if (!(s->elcr & (1 << irq)))
i8259.c:        s->irr &= ~(1 << irq);
i8259.c:    irq = pic_get_irq(&s->pics[0]);
i8259.c:        pic_intack(&s->pics[0], irq);
i8259.c:		timer_ints_to_push--;
i8259.c:                pic_set_irq1(&s->pics[0], 0, 0);
i8259.c:                pic_set_irq1(&s->pics[0], 0, 1);
i8259.c:            irq2 = pic_get_irq(&s->pics[1]);
i8259.c:                pic_intack(&s->pics[1], irq2);
i8259.c:            intno = s->pics[1].irq_base + irq2;
i8259.c:            intno = s->pics[0].irq_base + irq;
i8259.c:        intno = s->pics[0].irq_base + irq;
i8259.c:           (double)(qemu_get_clock(vm_clock) -
i8259.c:    s->last_irr = 0;
i8259.c:    s->irr = 0;
i8259.c:    s->imr = 0;
i8259.c:    s->isr = 0;
i8259.c:    s->priority_add = 0;
i8259.c:    s->irq_base = 0;
i8259.c:    s->read_reg_select = 0;
i8259.c:    s->poll = 0;
i8259.c:    s->special_mask = 0;
i8259.c:    s->init_state = 0;
i8259.c:    s->auto_eoi = 0;
i8259.c:    s->rotate_on_auto_eoi = 0;
i8259.c:    s->special_fully_nested_mode = 0;
i8259.c:    s->init4 = 0;
i8259.c:    s->single_mode = 0;
i8259.c:            qemu_irq_lower(s->pics_state->parent_irq);
i8259.c:            s->init_state = 1;
i8259.c:            s->init4 = val & 1;
i8259.c:            s->single_mode = val & 2;
i8259.c:                s->poll = 1;
i8259.c:                s->read_reg_select = val & 1;
i8259.c:                s->special_mask = (val >> 5) & 1;
i8259.c:                s->rotate_on_auto_eoi = cmd >> 2;
i8259.c:                priority = get_priority(s, s->isr);
i8259.c:                    irq = (priority + s->priority_add) & 7;
i8259.c:                    s->isr &= ~(1 << irq);
i8259.c:                        s->priority_add = (irq + 1) & 7;
i8259.c:                    pic_update_irq(s->pics_state);
i8259.c:                s->isr &= ~(1 << irq);
i8259.c:                pic_update_irq(s->pics_state);
i8259.c:                s->priority_add = (val + 1) & 7;
i8259.c:                pic_update_irq(s->pics_state);
i8259.c:                s->isr &= ~(1 << irq);
i8259.c:                s->priority_add = (irq + 1) & 7;
i8259.c:                pic_update_irq(s->pics_state);
i8259.c:        switch(s->init_state) {
i8259.c:            s->imr = val;
i8259.c:            pic_update_irq(s->pics_state);
i8259.c:            s->irq_base = val & 0xf8;
i8259.c:            s->init_state = s->single_mode ? (s->init4 ? 3 : 0) : 2;
i8259.c:            if (s->init4) {
i8259.c:                s->init_state = 3;
i8259.c:                s->init_state = 0;
i8259.c:            s->special_fully_nested_mode = (val >> 4) & 1;
i8259.c:            s->auto_eoi = (val >> 1) & 1;
i8259.c:            s->init_state = 0;
i8259.c:            s->pics_state->pics[0].isr &= ~(1 << 2);
i8259.c:            s->pics_state->pics[0].irr &= ~(1 << 2);
i8259.c:        s->irr &= ~(1 << ret);
i8259.c:        s->isr &= ~(1 << ret);
i8259.c:            pic_update_irq(s->pics_state);
i8259.c:        pic_update_irq(s->pics_state);
i8259.c:    if (s->poll) {
i8259.c:        s->poll = 0;
i8259.c:            if (s->read_reg_select)
i8259.c:                ret = s->isr;
i8259.c:                ret = s->irr;
i8259.c:            ret = s->imr;
i8259.c:    ret = pic_poll_read(&s->pics[0], 0x00);
i8259.c:        ret = pic_poll_read(&s->pics[1], 0x80) + 8;
i8259.c:    s->pics[0].read_reg_select = 1;
i8259.c:    s->elcr = val & s->elcr_mask;
i8259.c:    return s->elcr;
i8259.c:        s = &isa_pic->pics[i];
i8259.c:                       i, s->irr, s->imr, s->isr, s->priority_add,
i8259.c:                       s->irq_base, s->read_reg_select, s->elcr,
i8259.c:                       s->special_fully_nested_mode);
i8259.c:    pic_init1(0x20, 0x4d0, &s->pics[0]);
i8259.c:    pic_init1(0xa0, 0x4d1, &s->pics[1]);
i8259.c:    s->pics[0].elcr_mask = 0xf8;
i8259.c:    s->pics[1].elcr_mask = 0xde;
i8259.c:    s->parent_irq = parent_irq;
i8259.c:    s->pics[0].pics_state = s;
i8259.c:    s->pics[1].pics_state = s;
i8259.c:    chip.chip_id = (&s->pics_state->pics[0] == s) ?
i8259.c:    s->last_irr = kpic->last_irr;
i8259.c:    s->irr = kpic->irr;
i8259.c:    s->imr = kpic->imr;
i8259.c:    s->isr = kpic->isr;
i8259.c:    s->priority_add = kpic->priority_add;
i8259.c:    s->irq_base = kpic->irq_base;
i8259.c:    s->read_reg_select = kpic->read_reg_select;
i8259.c:    s->poll = kpic->poll;
i8259.c:    s->special_mask = kpic->special_mask;
i8259.c:    s->init_state = kpic->init_state;
i8259.c:    s->auto_eoi = kpic->auto_eoi;
i8259.c:    s->rotate_on_auto_eoi = kpic->rotate_on_auto_eoi;
i8259.c:    s->special_fully_nested_mode = kpic->special_fully_nested_mode;
i8259.c:    s->init4 = kpic->init4;
i8259.c:    s->elcr = kpic->elcr;
i8259.c:    s->elcr_mask = kpic->elcr_mask;
i8259.c:    chip.chip_id = (&s->pics_state->pics[0] == s) ?
i8259.c:    kpic->last_irr = s->last_irr;
i8259.c:    kpic->irr = s->irr;
i8259.c:    kpic->imr = s->imr;
i8259.c:    kpic->isr = s->isr;
i8259.c:    kpic->priority_add = s->priority_add;
i8259.c:    kpic->irq_base = s->irq_base;
i8259.c:    kpic->read_reg_select = s->read_reg_select;
i8259.c:    kpic->poll = s->poll;
i8259.c:    kpic->special_mask = s->special_mask;
i8259.c:    kpic->init_state = s->init_state;
i8259.c:    kpic->auto_eoi = s->auto_eoi;
i8259.c:    kpic->rotate_on_auto_eoi = s->rotate_on_auto_eoi;
i8259.c:    kpic->special_fully_nested_mode = s->special_fully_nested_mode;
i8259.c:    kpic->init4 = s->init4;
i8259.c:    kpic->elcr = s->elcr;
i8259.c:    kpic->elcr_mask = s->elcr_mask;
i8259.c:    kvm_pic_init1(0x20, &s->pics[0]);
i8259.c:    kvm_pic_init1(0xa0, &s->pics[1]);
i8259.c:    s->parent_irq = parent_irq;
i8259.c:    s->pics[0].pics_state = s;
i8259.c:    s->pics[1].pics_state = s;
ide.h:/* ide-isa.c */
ide.h:/* ide-pci.c */
ide.h:/* ide-macio.c */
ide.h:/* ide-mmio.c */
integratorcp.c: * Copyright (c) 2005-2007 CodeSourcery.
integratorcp.c:#include "arm-misc.h"
integratorcp.c:        return s->cm_osc;
integratorcp.c:        return s->cm_ctrl;
integratorcp.c:        if (s->cm_lock == 0xa05f) {
integratorcp.c:            return s->cm_lock;
integratorcp.c:        return s->cm_auxosc;
integratorcp.c:        return s->cm_sdram;
integratorcp.c:        return s->cm_init;
integratorcp.c:        return s->cm_flags;
integratorcp.c:        return s->cm_nvflags;
integratorcp.c:        return s->int_level & s->irq_enabled;
integratorcp.c:        return s->int_level;
integratorcp.c:        return s->irq_enabled;
integratorcp.c:        return s->int_level & 1;
integratorcp.c:        return s->int_level & s->fiq_enabled;
integratorcp.c:        return s->int_level;
integratorcp.c:        return s->fiq_enabled;
integratorcp.c:        cpu_register_physical_memory(0, 0x100000, s->flash_offset | IO_MEM_RAM);
integratorcp.c:    if ((s->cm_init ^ value) & 4) {
integratorcp.c:    if ((s->cm_init ^ value) & 1) {
integratorcp.c:    s->cm_init = (s->cm_init & ~ 5) | (value ^ 5);
integratorcp.c:    if (s->int_level & (s->irq_enabled | s->fiq_enabled))
integratorcp.c:        if (s->cm_lock == 0xa05f)
integratorcp.c:            s->cm_osc = value;
integratorcp.c:        s->cm_lock = value & 0xffff;
integratorcp.c:        if (s->cm_lock == 0xa05f)
integratorcp.c:            s->cm_auxosc = value;
integratorcp.c:        s->cm_sdram = value;
integratorcp.c:        s->cm_init = value;
integratorcp.c:        s->cm_flags |= value;
integratorcp.c:        s->cm_flags &= ~value;
integratorcp.c:        s->cm_nvflags |= value;
integratorcp.c:        s->cm_nvflags &= ~value;
integratorcp.c:        s->irq_enabled |= value;
integratorcp.c:        s->irq_enabled &= ~value;
integratorcp.c:        s->int_level |= (value & 1);
integratorcp.c:        s->int_level &= ~(value & 1);
integratorcp.c:        s->fiq_enabled |= value;
integratorcp.c:        s->fiq_enabled &= ~value;
integratorcp.c:    s->cm_osc = 0x01000048;
integratorcp.c:    s->cm_auxosc = 0x0007feff;
integratorcp.c:    s->cm_sdram = 0x00011122;
integratorcp.c:    if (s->memsz >= 256) {
integratorcp.c:        s->cm_sdram |= 0x10;
integratorcp.c:    } else if (s->memsz >= 128) {
integratorcp.c:        s->cm_sdram |= 0x0c;
integratorcp.c:    } else if (s->memsz >= 64) {
integratorcp.c:        s->cm_sdram |= 0x08;
integratorcp.c:    } else if (s->memsz >= 32) {
integratorcp.c:        s->cm_sdram |= 0x04;
integratorcp.c:    memcpy(integrator_spd + 73, "QEMU-MEMORY", 11);
integratorcp.c:    s->cm_init = 0x00000112;
integratorcp.c:    s->flash_offset = qemu_ram_alloc(0x100000);
integratorcp.c:    flags = (s->level & s->irq_enabled);
integratorcp.c:    qemu_set_irq(s->parent_irq, flags != 0);
integratorcp.c:    flags = (s->level & s->fiq_enabled);
integratorcp.c:    qemu_set_irq(s->parent_fiq, flags != 0);
integratorcp.c:        s->level |= 1 << irq;
integratorcp.c:        s->level &= ~(1 << irq);
integratorcp.c:        return s->level & s->irq_enabled;
integratorcp.c:        return s->level;
integratorcp.c:        return s->irq_enabled;
integratorcp.c:        return s->level & 1;
integratorcp.c:        return s->level & s->fiq_enabled;
integratorcp.c:        return s->level;
integratorcp.c:        return s->fiq_enabled;
integratorcp.c:        s->irq_enabled |= value;
integratorcp.c:        s->irq_enabled &= ~value;
integratorcp.c:        s->fiq_enabled |= value;
integratorcp.c:        s->fiq_enabled &= ~value;
integratorcp.c:    qdev_init_gpio_in(&dev->qdev, icp_pic_set_irq, 32);
integratorcp.c:    sysbus_init_irq(dev, &s->parent_irq);
integratorcp.c:    sysbus_init_irq(dev, &s->parent_fiq);
integratorcp.c:    .desc = "ARM Integrator/CP (ARM926EJ-S)",
ioapic.c: *  Copyright (c) 2004-2005 Fabrice Bellard
ioapic.c:#include "qemu-timer.h"
ioapic.c:#include "host-utils.h"
ioapic.c:#include "qemu-kvm.h"
ioapic.c:        if (s->irr & mask) {
ioapic.c:            entry = s->ioredtbl[i];
ioapic.c:                    s->irr &= ~mask;
ioapic.c:    /* ISA IRQs map to GSI 1-1 except for IRQ0 which maps
ioapic.c:     * to GSI 2.  GSI maps to ioapic 1-1.  This is not
ioapic.c:        uint64_t entry = s->ioredtbl[vector];
ioapic.c:                s->irr |= mask;
ioapic.c:                s->irr &= ~mask;
ioapic.c:                s->irr |= mask;
ioapic.c:        val = s->ioregsel;
ioapic.c:        switch (s->ioregsel) {
ioapic.c:                val = s->id << 24;
ioapic.c:                val = 0x11 | ((IOAPIC_NUM_PINS - 1) << 16); /* version 0x11 */
ioapic.c:                index = (s->ioregsel - 0x10) >> 1;
ioapic.c:                    if (s->ioregsel & 1)
ioapic.c:                        val = s->ioredtbl[index] >> 32;
ioapic.c:                        val = s->ioredtbl[index] & 0xffffffff;
ioapic.c:        printf("I/O APIC read: %08x = %08x\n", s->ioregsel, val);
ioapic.c:        s->ioregsel = val;
ioapic.c:        printf("I/O APIC write: %08x = %08x\n", s->ioregsel, val);
ioapic.c:        switch (s->ioregsel) {
ioapic.c:                s->id = (val >> 24) & 0xff;
ioapic.c:                index = (s->ioregsel - 0x10) >> 1;
ioapic.c:                    if (s->ioregsel & 1) {
ioapic.c:                        s->ioredtbl[index] &= 0xffffffff;
ioapic.c:                        s->ioredtbl[index] |= (uint64_t)val << 32;
ioapic.c:                        s->ioredtbl[index] &= ~0xffffffffULL;
ioapic.c:                        s->ioredtbl[index] |= val;
ioapic.c:    s->id = kioapic->id;
ioapic.c:    s->ioregsel = kioapic->ioregsel;
ioapic.c:    s->base_address = kioapic->base_address;
ioapic.c:    s->irr = kioapic->irr;
ioapic.c:        s->ioredtbl[i] = kioapic->redirtbl[i].bits;
ioapic.c:    kioapic->id = s->id;
ioapic.c:    kioapic->ioregsel = s->ioregsel;
ioapic.c:    kioapic->base_address = s->base_address;
ioapic.c:    kioapic->irr = s->irr;
ioapic.c:        kioapic->redirtbl[i].bits = s->ioredtbl[i];
ioapic.c:    s->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;
ioapic.c:    s->irr = 0;
ioapic.c:    s->base_address = IOAPIC_DEFAULT_BASE_ADDRESS;
ioapic.c:        s->ioredtbl[i] = 1 << 16; /* mask LVT */
iommu.c: * Copyright (c) 2003-2005 Fabrice Bellard
iommu.c:#define IOMMU_RNGE_16MB     0x00000000 /* 0xff000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_32MB     0x00000004 /* 0xfe000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_64MB     0x00000008 /* 0xfc000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_128MB    0x0000000c /* 0xf8000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_256MB    0x00000010 /* 0xf0000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_512MB    0x00000014 /* 0xe0000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_1GB      0x00000018 /* 0xc0000000 -> 0xffffffff */
iommu.c:#define IOMMU_RNGE_2GB      0x0000001c /* 0x80000000 -> 0xffffffff */
iommu.c:#define IOMMU_AER_EN_F      0x00100000    /* SBus on-board */
iommu.c:#define IOMMU_AER_SBW       0x80000000    /* S-to-M asynchronous writes */
iommu.c:#define IOMMU_SBCFG0        (0x1010 >> 2) /* SBUS configration per-slot */
iommu.c:#define IOMMU_SBCFG1        (0x1014 >> 2) /* SBUS configration per-slot */
iommu.c:#define IOMMU_SBCFG2        (0x1018 >> 2) /* SBUS configration per-slot */
iommu.c:#define IOMMU_SBCFG3        (0x101c >> 2) /* SBUS configration per-slot */
iommu.c:#define IOMMU_SBCFG_SAB30   0x00010000 /* Phys-address bit 30 when
iommu.c:#define IOMMU_PAGE_MASK     ~(IOMMU_PAGE_SIZE - 1)
iommu.c:        ret = s->regs[saddr];
iommu.c:        ret = s->regs[saddr];
iommu.c:        qemu_irq_lower(s->irq);
iommu.c:            s->iostart = 0xffffffffff000000ULL;
iommu.c:            s->iostart = 0xfffffffffe000000ULL;
iommu.c:            s->iostart = 0xfffffffffc000000ULL;
iommu.c:            s->iostart = 0xfffffffff8000000ULL;
iommu.c:            s->iostart = 0xfffffffff0000000ULL;
iommu.c:            s->iostart = 0xffffffffe0000000ULL;
iommu.c:            s->iostart = 0xffffffffc0000000ULL;
iommu.c:            s->iostart = 0xffffffff80000000ULL;
iommu.c:        DPRINTF("iostart = " TARGET_FMT_plx "\n", s->iostart);
iommu.c:        s->regs[saddr] = ((val & IOMMU_CTRL_MASK) | s->version);
iommu.c:        s->regs[saddr] = val & IOMMU_BASE_MASK;
iommu.c:        s->regs[saddr] = val & IOMMU_TLBFLUSH_MASK;
iommu.c:        s->regs[saddr] = val & IOMMU_PGFLUSH_MASK;
iommu.c:        s->regs[saddr] = val;
iommu.c:        qemu_irq_lower(s->irq);
iommu.c:        s->regs[saddr] = (val & IOMMU_AER_MASK) | IOMMU_AER_EN_P0_ARB;
iommu.c:        s->regs[saddr] = (val & IOMMU_AFSR_MASK) | IOMMU_AFSR_RESV;
iommu.c:        qemu_irq_lower(s->irq);
iommu.c:        s->regs[saddr] = val & IOMMU_SBCFG_MASK;
iommu.c:        s->regs[saddr] = (val & IOMMU_ARBEN_MASK) | IOMMU_MID;
iommu.c:        s->regs[saddr] |= val & IOMMU_MASK_ID_MASK;
iommu.c:        s->regs[saddr] = val;
iommu.c:    iopte = s->regs[IOMMU_BASE] << 4;
iommu.c:    addr &= ~s->iostart;
iommu.c:    iopte += (addr >> (IOMMU_PAGE_SHIFT - 2)) & ~3;
iommu.c:    s->regs[IOMMU_AFSR] = IOMMU_AFSR_ERR | IOMMU_AFSR_LE | IOMMU_AFSR_RESV |
iommu.c:        s->regs[IOMMU_AFSR] |= IOMMU_AFSR_RD;
iommu.c:    s->regs[IOMMU_AFAR] = addr;
iommu.c:    qemu_irq_raise(s->irq);
iommu.c:        l = (page + IOMMU_PAGE_SIZE) - addr;
iommu.c:        len -= l;
iommu.c:    memset(s->regs, 0, IOMMU_NREGS * 4);
iommu.c:    s->iostart = 0;
iommu.c:    s->regs[IOMMU_CTRL] = s->version;
iommu.c:    s->regs[IOMMU_ARBEN] = IOMMU_MID;
iommu.c:    s->regs[IOMMU_AFSR] = IOMMU_AFSR_RESV;
iommu.c:    s->regs[IOMMU_AER] = IOMMU_AER_EN_P0_ARB | IOMMU_AER_EN_P1_ARB;
iommu.c:    s->regs[IOMMU_MASK_ID] = IOMMU_TS_MASK;
iommu.c:    sysbus_init_irq(dev, &s->irq);
ipf.c: * Copyright (c) 2003-2004 Fabrice Bellard
ipf.c:#include "device-assignment.h"
ipf.c:#include "virtio-blk.h"
ipf.c:#include "qemu-kvm.h"
ipf.c:        return 0x03; /* CD-ROM boot */
ipf.c:    val = (ram_size / 1024) - 1024;
ipf.c:    rtc_set_memory(s, 0x5f, smp_cpus - 1);
ipf.c:        val = (ram_size / 65536) - ((16 * 1024 * 1024) / 65536);
ipf.c:                translation--;
ipf.c:    for (c = soundhw; !audio_enabled && c->name; ++c) {
ipf.c:        audio_enabled = c->enabled;
ipf.c:            for (c = soundhw; c->name; ++c) {
ipf.c:                if (c->enabled) {
ipf.c:                    if (c->isa) {
ipf.c:                        c->init.init_isa (s, pic);
ipf.c:                            c->init.init_pci (pci_bus, s);
ipf.c:    int piix3_devfn = -1;
ipf.c:        exit(-1);
ipf.c:        above_4g_mem_size = ram_size - 0xc0000000;
ipf.c:            env->hflags |= HF_HALTED_MASK;
ipf.c:        ram_addr = qemu_ram_alloc(0x20000); // Workaround 0xa0000-0xc0000
ipf.c:        ram_addr = qemu_ram_alloc(ram_size - 0x100000);
ipf.c:        cpu_register_physical_memory(0x100000, ram_size - 0x100000, ram_addr);
ipf.c:        fw_offset = GFW_START + GFW_SIZE - image_size;
ipf.c:            if (nvram_fd != -1) {
ipf.c:        piix3_devfn = piix3_init(pci_bus, -1);
ipf.c:        if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))
ipf.c:	if (index != -1)
ipf.c:	if (index != -1)
ipf.c:            eeprom = qdev_create((BusState *)smbus, "smbus-eeprom");
ipf.c:            pci_create_simple(pci_bus, -1, "lsi53c895a");
ipf.c:	while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {
ipf.c:            pci_dev = pci_create("virtio-blk-pci",
ipf.c:            qdev_init(&pci_dev->qdev);
ipf.c:    vector = ioapic_map_irq(pci_dev->devfn, irq_num);
ipf.c:        ioapic_irq_count[vector] -= 1;
ipf.c:	return ioapic_map_irq(pci_dev->devfn, irq_num);
irq.c:#include "qemu-common.h"
irq.c:    irq->handler(irq->opaque, irq->n, level);
irq.c:        p->handler = handler;
irq.c:        p->opaque = opaque;
irq.c:        p->n = i;
irq.c:    irq->handler(irq->opaque, irq->n, !level);
isa-bus.c:        dev = qdev_create(NULL, "isabus-bridge");
isa-bus.c:    isabus->irqs = irqs;
isa-bus.c:    if (isabus->assigned & (1 << isairq)) {
isa-bus.c:    isabus->assigned |= (1 << isairq);
isa-bus.c:    return isabus->irqs[isairq];
isa-bus.c:    assert(dev->nirqs < ARRAY_SIZE(dev->isairq));
isa-bus.c:    if (isabus->assigned & (1 << isairq)) {
isa-bus.c:    isabus->assigned |= (1 << isairq);
isa-bus.c:    dev->isairq[dev->nirqs] = isairq;
isa-bus.c:    *p = isabus->irqs[isairq];
isa-bus.c:    dev->nirqs++;
isa-bus.c:    dev->isairq[0] = -1;
isa-bus.c:    dev->isairq[1] = -1;
isa-bus.c:    return info->init(dev);
isa-bus.c:    info->qdev.init = isa_qdev_init;
isa-bus.c:    info->qdev.bus_info = &isa_bus_info;
isa-bus.c:    qdev_register(&info->qdev);
isa-bus.c:    dev = qdev_create(&isabus->qbus, name);
isa-bus.c:    qdev_init_nofail(&dev->qdev);
isa-bus.c:    if (d->isairq[1] != -1) {
isa-bus.c:                       d->isairq[0], d->isairq[1]);
isa-bus.c:    } else if (d->isairq[0] != -1) {
isa-bus.c:                       d->isairq[0]);
isa-bus.c:    .qdev.name  = "isabus-bridge",
jazz_led.c:            val = s->segments;
jazz_led.c:            s->segments = val;
jazz_led.c:            s->state |= REDRAW_SEGMENTS;
jazz_led.c:    DisplayState *ds = s->ds;
jazz_led.c:    if (s->state & REDRAW_BACKGROUND) {
jazz_led.c:    if (s->state & REDRAW_SEGMENTS) {
jazz_led.c:        draw_horizontal_line(ds, 40, 10, 40, (s->segments & 0x02) ? color_segment : 0);
jazz_led.c:        draw_vertical_line(ds, 10, 10, 40, (s->segments & 0x04) ? color_segment : 0);
jazz_led.c:        draw_vertical_line(ds, 10, 40, 70, (s->segments & 0x08) ? color_segment : 0);
jazz_led.c:        draw_horizontal_line(ds, 70, 10, 40, (s->segments & 0x10) ? color_segment : 0);
jazz_led.c:        draw_vertical_line(ds, 40, 40, 70, (s->segments & 0x20) ? color_segment : 0);
jazz_led.c:        draw_vertical_line(ds, 40, 10, 40, (s->segments & 0x40) ? color_segment : 0);
jazz_led.c:        draw_horizontal_line(ds, 10, 10, 40, (s->segments & 0x80) ? color_segment : 0);
jazz_led.c:        if (!(s->segments & 0x01))
jazz_led.c:    s->state = REDRAW_NONE;
jazz_led.c:    s->state |= REDRAW_SEGMENTS | REDRAW_BACKGROUND;
jazz_led.c:    dpy_cursor(s->ds, -1, -1);
jazz_led.c:    qemu_console_resize(s->ds, 2, 1);
jazz_led.c:    snprintf(buf, 2, "%02hhx\n", s->segments);
jazz_led.c:    dpy_update(s->ds, 0, 0, 2, 1);
jazz_led.c:    s->state = REDRAW_SEGMENTS | REDRAW_BACKGROUND;
jazz_led.c:    s->ds = graphic_console_init(jazz_led_update_display,
jazz_led.c:    qemu_console_resize(s->ds, 60, 80);
lan9118.c:    level = (s->int_sts & s->int_en) != 0;
lan9118.c:    if ((s->irq_cfg & IRQ_EN) == 0) {
lan9118.c:    qemu_set_irq(s->irq, level);
lan9118.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
lan9118.c:    if (s->eeprom[0] != 0xa5) {
lan9118.c:        s->e2p_cmd &= ~0x10;
lan9118.c:        s->conf.macaddr.a[i] = s->eeprom[i + 1];
lan9118.c:    s->e2p_cmd |= 0x10;
lan9118.c:    if (s->nic->nc.link_down) {
lan9118.c:        s->phy_status &= ~0x0024;
lan9118.c:        s->phy_status |= 0x0024;
lan9118.c:    phy_update_link(DO_UPCAST(NICState, nc, nc)->opaque);
lan9118.c:    s->phy_status = 0x7805;
lan9118.c:    s->phy_control = 0x3000;
lan9118.c:    s->phy_advertise = 0x01e1;
lan9118.c:    s->irq_cfg &= ~(IRQ_TYPE | IRQ_POL);
lan9118.c:    s->int_sts = 0;
lan9118.c:    s->int_en = 0;
lan9118.c:    s->fifo_int = 0x48000000;
lan9118.c:    s->rx_cfg = 0;
lan9118.c:    s->tx_cfg = 0;
lan9118.c:    s->hw_cfg = 0x00050000;
lan9118.c:    s->pmt_ctrl &= 0x45;
lan9118.c:    s->gpio_cfg = 0;
lan9118.c:    s->txp->fifo_used = 0;
lan9118.c:    s->txp->state = TX_IDLE;
lan9118.c:    s->txp->cmd_a = 0xffffffffu;
lan9118.c:    s->txp->cmd_b = 0xffffffffu;
lan9118.c:    s->txp->len = 0;
lan9118.c:    s->txp->fifo_used = 0;
lan9118.c:    s->tx_fifo_size = 4608;
lan9118.c:    s->tx_status_fifo_used = 0;
lan9118.c:    s->rx_status_fifo_size = 704;
lan9118.c:    s->rx_fifo_size = 2640;
lan9118.c:    s->rx_fifo_used = 0;
lan9118.c:    s->rx_status_fifo_size = 176;
lan9118.c:    s->rx_status_fifo_used = 0;
lan9118.c:    s->rxp_offset = 0;
lan9118.c:    s->rxp_size = 0;
lan9118.c:    s->rxp_pad = 0;
lan9118.c:    s->rx_packet_size_tail = s->rx_packet_size_head;
lan9118.c:    s->rx_packet_size[s->rx_packet_size_head] = 0;
lan9118.c:    s->mac_cmd = 0;
lan9118.c:    s->mac_data = 0;
lan9118.c:    s->afc_cfg = 0;
lan9118.c:    s->e2p_cmd = 0;
lan9118.c:    s->e2p_data = 0;
lan9118.c:    s->free_timer_start = qemu_get_clock(vm_clock) / 40;
lan9118.c:    s->mac_cr = MAC_CR_PRMS;
lan9118.c:    s->mac_hashh = 0;
lan9118.c:    s->mac_hashl = 0;
lan9118.c:    s->mac_mii_acc = 0;
lan9118.c:    s->mac_mii_data = 0;
lan9118.c:    s->mac_flow = 0;
lan9118.c:    s->eeprom_writable = 0;
lan9118.c:    fifo_pos = s->rx_fifo_head + s->rx_fifo_used;
lan9118.c:    if (fifo_pos >= s->rx_fifo_size)
lan9118.c:      fifo_pos -= s->rx_fifo_size;
lan9118.c:    s->rx_fifo[fifo_pos] = val;
lan9118.c:    s->rx_fifo_used++;
lan9118.c:    if (s->mac_cr & MAC_CR_PRMS) {
lan9118.c:        return (s->mac_cr & MAC_CR_BCAST) == 0;
lan9118.c:    if (multicast &&s->mac_cr & MAC_CR_MCPAS) {
lan9118.c:    if (multicast ? (s->mac_cr & MAC_CR_HPFILT) == 0
lan9118.c:                  : (s->mac_cr & MAC_CR_HO) == 0) {
lan9118.c:        hash = memcmp(addr, s->conf.macaddr.a, 6);
lan9118.c:        if (s->mac_cr & MAC_CR_INVFILT) {
lan9118.c:            return (s->mac_hashh >> (hash & 0x1f)) & 1;
lan9118.c:            return (s->mac_hashl >> (hash & 0x1f)) & 1;
lan9118.c:    lan9118_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
lan9118.c:    if ((s->mac_cr & MAC_CR_RXEN) == 0) {
lan9118.c:        return -1;
lan9118.c:        return -1;
lan9118.c:    if (s->rx_status_fifo_used == s->rx_status_fifo_size) {
lan9118.c:        return -1;
lan9118.c:    if (!filter && (s->mac_cr & MAC_CR_RXALL) == 0) {
lan9118.c:    offset = (s->rx_cfg >> 8) & 0x1f;
lan9118.c:    if (s->rx_fifo_size - s->rx_fifo_used < fifo_len) {
lan9118.c:        return -1;
lan9118.c:        val >>= ((4 - n) * 8);
lan9118.c:        val = crc >> ((4 - n) * 8);
lan9118.c:    n = s->rx_status_fifo_head + s->rx_status_fifo_used;
lan9118.c:    if (n >= s->rx_status_fifo_size) {
lan9118.c:        n -= s->rx_status_fifo_size;
lan9118.c:    s->rx_packet_size[s->rx_packet_size_tail] = fifo_len;
lan9118.c:    s->rx_packet_size_tail = (s->rx_packet_size_tail + 1023) & 1023;
lan9118.c:    s->rx_status_fifo_used++;
lan9118.c:    s->rx_status_fifo[n] = status;
lan9118.c:    if (s->rx_status_fifo_used > (s->fifo_int & 0xff)) {
lan9118.c:        s->int_sts |= RSFL_INT;
lan9118.c:    if (s->rxp_size == 0 && s->rxp_pad == 0) {
lan9118.c:        s->rxp_size = s->rx_packet_size[s->rx_packet_size_head];
lan9118.c:        s->rx_packet_size[s->rx_packet_size_head] = 0;
lan9118.c:        if (s->rxp_size != 0) {
lan9118.c:            s->rx_packet_size_head = (s->rx_packet_size_head + 1023) & 1023;
lan9118.c:            s->rxp_offset = (s->rx_cfg >> 10) & 7;
lan9118.c:            n = s->rxp_offset + s->rxp_size;
lan9118.c:            switch (s->rx_cfg >> 30) {
lan9118.c:                n = (-n) & 3;
lan9118.c:                n = (-n) & 7;
lan9118.c:            s->rxp_pad = n;
lan9118.c:                    s->rxp_size, s->rxp_offset, s->rxp_pad);
lan9118.c:    if (s->rxp_offset > 0) {
lan9118.c:        s->rxp_offset--;
lan9118.c:    } else if (s->rxp_size > 0) {
lan9118.c:        s->rxp_size--;
lan9118.c:        val = s->rx_fifo[s->rx_fifo_head++];
lan9118.c:        if (s->rx_fifo_head >= s->rx_fifo_size) {
lan9118.c:            s->rx_fifo_head -= s->rx_fifo_size;
lan9118.c:        s->rx_fifo_used--;
lan9118.c:    } else if (s->rxp_pad > 0) {
lan9118.c:        s->rxp_pad--;
lan9118.c:        s->int_sts |= RXE_INT;
lan9118.c:    if (s->phy_control & 0x4000)  {
lan9118.c:        lan9118_receive(&s->nic->nc, s->txp->data, s->txp->len);
lan9118.c:        qemu_send_packet(&s->nic->nc, s->txp->data, s->txp->len);
lan9118.c:    s->txp->fifo_used = 0;
lan9118.c:    if (s->tx_status_fifo_used == 512) {
lan9118.c:    status = s->txp->cmd_b & 0xffff0000u;
lan9118.c:    DPRINTF("Sent packet tag:%04x len %d\n", status >> 16, s->txp->len);
lan9118.c:    n = (s->tx_status_fifo_head + s->tx_status_fifo_used) & 511;
lan9118.c:    s->tx_status_fifo[n] = status;
lan9118.c:    s->tx_status_fifo_used++;
lan9118.c:    if (s->tx_status_fifo_used == 512) {
lan9118.c:        s->int_sts |= TSFF_INT;
lan9118.c:    val = s->rx_status_fifo[s->rx_status_fifo_head];
lan9118.c:    if (s->rx_status_fifo_used != 0) {
lan9118.c:        s->rx_status_fifo_used--;
lan9118.c:        s->rx_status_fifo_head++;
lan9118.c:        if (s->rx_status_fifo_head >= s->rx_status_fifo_size) {
lan9118.c:            s->rx_status_fifo_head -= s->rx_status_fifo_size;
lan9118.c:    val = s->tx_status_fifo[s->tx_status_fifo_head];
lan9118.c:    if (s->tx_status_fifo_used != 0) {
lan9118.c:        s->tx_status_fifo_used--;
lan9118.c:        s->tx_status_fifo_head = (s->tx_status_fifo_head + 1) & 511;
lan9118.c:    if (s->txp->fifo_used == s->tx_fifo_size) {
lan9118.c:        s->int_sts |= TDFO_INT;
lan9118.c:    switch (s->txp->state) {
lan9118.c:        s->txp->cmd_a = val & 0x831f37ff;
lan9118.c:        s->txp->fifo_used++;
lan9118.c:        s->txp->state = TX_B;
lan9118.c:        if (s->txp->cmd_a & 0x2000) {
lan9118.c:            s->txp->cmd_b = val;
lan9118.c:            s->txp->fifo_used++;
lan9118.c:            s->txp->buffer_size = s->txp->cmd_a & 0x7ff;
lan9118.c:            s->txp->offset = (s->txp->cmd_a >> 16) & 0x1f;
lan9118.c:            n = (s->txp->buffer_size + s->txp->offset + 3) >> 2;
lan9118.c:                n = (-n) & 3;
lan9118.c:                n = (-n) & 7;
lan9118.c:            s->txp->pad = n;
lan9118.c:            s->txp->len = 0;
lan9118.c:                s->txp->buffer_size, s->txp->offset, s->txp->pad,
lan9118.c:                s->txp->cmd_a);
lan9118.c:        s->txp->state = TX_DATA;
lan9118.c:        if (s->txp->offset >= 4) {
lan9118.c:            s->txp->offset -= 4;
lan9118.c:        if (s->txp->buffer_size <= 0 && s->txp->pad != 0) {
lan9118.c:            s->txp->pad--;
lan9118.c:            while (s->txp->offset) {
lan9118.c:                n--;
lan9118.c:                s->txp->offset--;
lan9118.c:               in FIFO words.  Empirical results show it to be little-endian.
lan9118.c:            while (n--) {
lan9118.c:                s->txp->data[s->txp->len] = val & 0xff;
lan9118.c:                s->txp->len++;
lan9118.c:                s->txp->buffer_size--;
lan9118.c:            s->txp->fifo_used++;
lan9118.c:        if (s->txp->buffer_size <= 0 && s->txp->pad == 0) {
lan9118.c:            if (s->txp->cmd_a & 0x1000) {
lan9118.c:            if (s->txp->cmd_a & 0x80000000) {
lan9118.c:                s->int_sts |= TX_IOC_INT;
lan9118.c:            s->txp->state = TX_IDLE;
lan9118.c:        return s->phy_control;
lan9118.c:        return s->phy_status;
lan9118.c:    case 4: /* Auto-neg advertisment */
lan9118.c:        return s->phy_advertise;
lan9118.c:    case 5: /* Auto-neg Link Partner Ability */
lan9118.c:    case 6: /* Auto-neg Expansion */
lan9118.c:        s->phy_control = val & 0x7980;
lan9118.c:            s->phy_status |= 0x0020;
lan9118.c:    case 4: /* Auto-neg advertisment */
lan9118.c:        s->phy_advertise = (val & 0x2d7f) | 0x80;
lan9118.c:        if ((s->mac_cr & MAC_CR_RXEN) != 0 && (val & MAC_CR_RXEN) == 0) {
lan9118.c:            s->int_sts |= RXSTOP_INT;
lan9118.c:        s->mac_cr = val & ~MAC_CR_RESERVED;
lan9118.c:        s->conf.macaddr.a[4] = val & 0xff;
lan9118.c:        s->conf.macaddr.a[5] = (val >> 8) & 0xff;
lan9118.c:        s->conf.macaddr.a[0] = val & 0xff;
lan9118.c:        s->conf.macaddr.a[1] = (val >> 8) & 0xff;
lan9118.c:        s->conf.macaddr.a[2] = (val >> 16) & 0xff;
lan9118.c:        s->conf.macaddr.a[3] = (val >> 24) & 0xff;
lan9118.c:        s->mac_hashh = val;
lan9118.c:        s->mac_hashl = val;
lan9118.c:        s->mac_mii_acc = val & 0xffc2;
lan9118.c:                    (val >> 6) & 0x1f, s->mac_mii_data);
lan9118.c:            do_phy_write(s, (val >> 6) & 0x1f, s->mac_mii_data);
lan9118.c:            s->mac_mii_data = do_phy_read(s, (val >> 6) & 0x1f);
lan9118.c:                    (val >> 6) & 0x1f, s->mac_mii_data);
lan9118.c:        s->mac_mii_data = val & 0xffff;
lan9118.c:        s->mac_flow = val & 0xffff0000;
lan9118.c:                 s->mac_cmd & 0xf, val);
lan9118.c:        return s->mac_cr;
lan9118.c:        return s->conf.macaddr.a[4] | (s->conf.macaddr.a[5] << 8);
lan9118.c:        return s->conf.macaddr.a[0] | (s->conf.macaddr.a[1] << 8)
lan9118.c:               | (s->conf.macaddr.a[2] << 16) | (s->conf.macaddr.a[3] << 24);
lan9118.c:        return s->mac_hashh;
lan9118.c:        return s->mac_hashl;
lan9118.c:        return s->mac_mii_acc;
lan9118.c:        return s->mac_mii_data;
lan9118.c:        return s->mac_flow;
lan9118.c:                 s->mac_cmd & 0xf);
lan9118.c:    s->e2p_cmd = (s->e2p_cmd & 0x10) | (cmd << 28) | addr;
lan9118.c:        s->e2p_data = s->eeprom[addr];
lan9118.c:        DPRINTF("EEPROM Read %d = 0x%02x\n", addr, s->e2p_data);
lan9118.c:        s->eeprom_writable = 0;
lan9118.c:        s->eeprom_writable = 1;
lan9118.c:        if (s->eeprom_writable) {
lan9118.c:            s->eeprom[addr] &= s->e2p_data;
lan9118.c:            DPRINTF("EEPROM Write %d = 0x%02x\n", addr, s->e2p_data);
lan9118.c:        if (s->eeprom_writable) {
lan9118.c:                s->eeprom[addr] &= s->e2p_data;
lan9118.c:            DPRINTF("EEPROM Write All 0x%02x\n", s->e2p_data);
lan9118.c:        if (s->eeprom_writable) {
lan9118.c:            s->eeprom[addr] = 0xff;
lan9118.c:        if (s->eeprom_writable) {
lan9118.c:            memset(s->eeprom, 0xff, 128);
lan9118.c:        s->irq_cfg = (val & IRQ_EN);
lan9118.c:        s->int_sts &= ~val;
lan9118.c:        s->int_en = val & ~RESERVED_INT;
lan9118.c:        s->int_sts |= val & SW_INT;
lan9118.c:        s->fifo_int = val;
lan9118.c:            s->rx_fifo_used = 0;
lan9118.c:            s->rx_status_fifo_used = 0;
lan9118.c:            s->rx_packet_size_tail = s->rx_packet_size_head;
lan9118.c:            s->rx_packet_size[s->rx_packet_size_head] = 0;
lan9118.c:        s->rx_cfg = val & 0xcfff1ff0;
lan9118.c:            s->tx_status_fifo_used = 0;
lan9118.c:            s->txp->state = TX_IDLE;
lan9118.c:            s->txp->fifo_used = 0;
lan9118.c:            s->txp->cmd_a = 0xffffffff;
lan9118.c:        s->tx_cfg = val & 6;
lan9118.c:            lan9118_reset(&s->busdev.qdev);
lan9118.c:            s->hw_cfg = val & 0x003f300;
lan9118.c:            s->rxp_pad = 0;
lan9118.c:            s->rxp_offset = 0;
lan9118.c:            if (s->rxp_size == 0) {
lan9118.c:                s->rxp_pad = 0;
lan9118.c:                s->rxp_offset = 0;
lan9118.c:            s->rx_fifo_head += s->rxp_size;
lan9118.c:            if (s->rx_fifo_head >= s->rx_fifo_size) {
lan9118.c:                s->rx_fifo_head -= s->rx_fifo_size;
lan9118.c:        s->pmt_ctrl &= ~0x34e;
lan9118.c:        s->pmt_ctrl |= (val & 0x34e);
lan9118.c:        s->gpio_cfg = val & 0x7777071f;
lan9118.c:        /* Ignored because we're in 32-bit mode.  */
lan9118.c:        s->word_swap = val;
lan9118.c:        s->mac_cmd = val & 0x4000000f;
lan9118.c:                s->mac_data = do_mac_read(s, val & 0xf);
lan9118.c:                DPRINTF("MAC read %d = 0x%08x\n", val & 0xf, s->mac_data);
lan9118.c:                DPRINTF("MAC write %d = 0x%08x\n", val & 0xf, s->mac_data);
lan9118.c:                do_mac_write(s, val & 0xf, s->mac_data);
lan9118.c:        s->mac_data = val;
lan9118.c:        s->afc_cfg = val & 0x00ffffff;
lan9118.c:        s->e2p_data = val & 0xff;
lan9118.c:        return s->rx_status_fifo[s->tx_status_fifo_head];
lan9118.c:        return s->tx_status_fifo[s->tx_status_fifo_head];
lan9118.c:        return s->irq_cfg;
lan9118.c:        return s->int_sts;
lan9118.c:        return s->int_en;
lan9118.c:        return s->fifo_int;
lan9118.c:        return s->rx_cfg;
lan9118.c:        return s->tx_cfg;
lan9118.c:        return s->hw_cfg | 0x4;
lan9118.c:        return (s->rx_status_fifo_used << 16) | (s->rx_fifo_used << 2);
lan9118.c:        return (s->tx_status_fifo_used << 16)
lan9118.c:               | (s->tx_fifo_size - s->txp->fifo_used);
lan9118.c:        return s->pmt_ctrl;
lan9118.c:        return s->gpio_cfg;
lan9118.c:        return s->word_swap;
lan9118.c:        return (qemu_get_clock(vm_clock) / 40) - s->free_timer_start;
lan9118.c:        return s->mac_cmd;
lan9118.c:        return s->mac_data;
lan9118.c:        return s->afc_cfg;
lan9118.c:        return s->e2p_cmd;
lan9118.c:        return s->e2p_data;
lan9118.c:    lan9118_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
lan9118.c:    s->nic = NULL;
lan9118.c:    s->mmio_index = cpu_register_io_memory(lan9118_readfn,
lan9118.c:    sysbus_init_mmio(dev, 0x100, s->mmio_index);
lan9118.c:    sysbus_init_irq(dev, &s->irq);
lan9118.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
lan9118.c:    s->nic = qemu_new_nic(&net_lan9118_info, &s->conf,
lan9118.c:                          dev->qdev.info->name, dev->qdev.id, s);
lan9118.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
lan9118.c:    s->eeprom[0] = 0xa5;
lan9118.c:        s->eeprom[i + 1] = s->conf.macaddr.a[i];
lan9118.c:    s->pmt_ctrl = 1;
lan9118.c:    s->txp = &s->tx_packet;
lance.c: * QEMU AMD PC-Net II (Am79C970A) emulation
lance.c: * AMD Am79C970A PCnet-PCI II Ethernet Controller Data-Sheet
lance.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C100.txt
lance.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR92C990.txt
lance.c:#include "qemu-timer.h"
lance.c:        pcnet_h_reset(&d->state);
lance.c:    pcnet_ioport_writew(&d->state, addr, val & 0xffff);
lance.c:    val = pcnet_ioport_readw(&d->state, addr);
lance.c:    PCNetState *d = DO_UPCAST(NICState, nc, nc)->opaque;
lance.c:    PCNetState *s = &d->state;
lance.c:    s->mmio_index =
lance.c:    qdev_init_gpio_in(&dev->qdev, parent_lance_reset, 1);
lance.c:    sysbus_init_mmio(dev, 4, s->mmio_index);
lance.c:    sysbus_init_irq(dev, &s->irq);
lance.c:    s->phys_mem_read = ledma_memory_read;
lance.c:    s->phys_mem_write = ledma_memory_write;
lance.c:    return pcnet_common_init(&dev->qdev, s, &net_lance_info);
lance.c:    pcnet_h_reset(&d->state);
lm832x.c:#include "qemu-timer.h"
lm832x.c:    qemu_set_irq(s->nirq, !s->status);
lm832x.c:    s->config = 0x80;
lm832x.c:    s->status = INT_NOINIT;
lm832x.c:    s->acttime = 125;
lm832x.c:    s->kbd.dbnctime = 3;
lm832x.c:    s->kbd.size = 0x33;
lm832x.c:    s->clock = 0x08;
lm832x.c:    s->error |= err;
lm832x.c:    s->status |= INT_ERROR;
lm832x.c:    LM823x_CMD_WRITE_PULL_DOWN	= 0x84, /* Select GPIO pull-up/down. */
lm832x.c:    LM832x_CMD_WRITE_PORT_STATE	= 0x86, /* Set GPIO pull-up/down. */
lm832x.c:    LM832x_CMD_READ_PORT_STATE	= 0x88, /* Get GPIO pull-up/down. */
lm832x.c:                                           Previously was represented by -1
lm832x.c:        ret = s->status;
lm832x.c:        if (!(s->status & INT_NOINIT)) {
lm832x.c:            s->status = 0;
lm832x.c:        ret = s->gpio.dir;
lm832x.c:        ret = s->gpio.mask;
lm832x.c:        if (s->kbd.len <= 1)
lm832x.c:        s->kbd.start ++;
lm832x.c:        s->kbd.start &= sizeof(s->kbd.fifo) - 1;
lm832x.c:        s->kbd.len --;
lm832x.c:        return s->kbd.fifo[s->kbd.start];
lm832x.c:        if (byte >= s->kbd.len)
lm832x.c:        return s->kbd.fifo[(s->kbd.start + byte) & (sizeof(s->kbd.fifo) - 1)];
lm832x.c:        return s->error;
lm832x.c:        return s->kbd.size;
lm832x.c:        return s->config & 0xf;
lm832x.c:        return (s->clock & 0xfc) | 2;
lm832x.c:        s->config = value;
lm832x.c:        /* This must be done whenever s->mux.in is updated (never).  */
lm832x.c:        if ((s->config >> 1) & 1)			/* MUX1EN */
lm832x.c:            qemu_set_irq(s->mux.out[0], s->mux.in[0][(s->config >> 0) & 1]);
lm832x.c:        if ((s->config >> 3) & 1)			/* MUX2EN */
lm832x.c:            qemu_set_irq(s->mux.out[0], s->mux.in[0][(s->config >> 2) & 1]);
lm832x.c:         * the GPIO ports re-resablishing through WRITE_PORT_SEL and
lm832x.c:        s->status = 0;
lm832x.c:        s->kbd.len = 0;
lm832x.c:        s->kbd.start = 0;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:            s->gpio.pull = value;
lm832x.c:            s->gpio.pull |= value << 8;
lm832x.c:            s->reg = LM832x_GENERAL_ERROR;
lm832x.c:            s->gpio.dir = value;
lm832x.c:            s->gpio.dir |= value << 8;
lm832x.c:            s->reg = LM832x_GENERAL_ERROR;
lm832x.c:            s->gpio.mask = value;
lm832x.c:            s->gpio.mask |= value << 8;
lm832x.c:            s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->acttime = value;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->kbd.dbnctime = value;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->kbd.size = value;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->clock = value;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:                s->reg = LM832x_GENERAL_ERROR;
lm832x.c:            s->pwm.faddr = value;
lm832x.c:            s->pwm.file[s->pwm.faddr] = 0;
lm832x.c:            s->pwm.file[s->pwm.faddr] |= value << 8;
lm832x.c:            s->pwm.file[s->pwm.faddr] |= value << 0;
lm832x.c:            s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        s->pwm.addr[(value & 3) - 1] = value >> 2;
lm832x.c:        lm_kbd_pwm_start(s, (value & 3) - 1);
lm832x.c:        s->reg = LM832x_GENERAL_ERROR;
lm832x.c:        qemu_del_timer(s->pwm.tm[(value & 3) - 1]);
lm832x.c:        s->i2c_cycle = 0;
lm832x.c:        s->i2c_dir = (event == I2C_START_SEND);
lm832x.c:    return lm_kbd_read(s, s->reg, s->i2c_cycle ++);
lm832x.c:    if (!s->i2c_cycle)
lm832x.c:        s->reg = data;
lm832x.c:        lm_kbd_write(s, s->reg, s->i2c_cycle - 1, data);
lm832x.c:    s->i2c_cycle ++;
lm832x.c:    s->model = 0x8323;
lm832x.c:    s->pwm.tm[0] = qemu_new_timer(vm_clock, lm_kbd_pwm0_tick, s);
lm832x.c:    s->pwm.tm[1] = qemu_new_timer(vm_clock, lm_kbd_pwm1_tick, s);
lm832x.c:    s->pwm.tm[2] = qemu_new_timer(vm_clock, lm_kbd_pwm2_tick, s);
lm832x.c:    qdev_init_gpio_out(&i2c->qdev, &s->nirq, 1);
lm832x.c:    if ((s->status & INT_ERROR) && (s->error & ERR_FIFOOVR))
lm832x.c:    if (s->kbd.len >= sizeof(s->kbd.fifo)) {
lm832x.c:    s->kbd.fifo[(s->kbd.start + s->kbd.len ++) & (sizeof(s->kbd.fifo) - 1)] =
lm832x.c:    s->status |= INT_KEYPAD;
loader.c: * Gunzip functionality in this file is derived from u-boot:
loader.c: * (C) Copyright 2000-2005
loader.c:/* return the size or -1 if error */
loader.c:        return -1;
loader.c:/* return the size or -1 if error */
loader.c:        return -1;
loader.c:        return -1;
loader.c:/* read()-like version */
loader.c:/* return the size or -1 if error */
loader.c:        rom_add_blob_fixed(name, source, (nulp - source) + 1, dest);
loader.c:        ptr = rom_ptr(dest + buf_size - 1);
loader.c:    bswap32s(&e->a_info);
loader.c:    bswap32s(&e->a_text);
loader.c:    bswap32s(&e->a_data);
loader.c:    bswap32s(&e->a_bss);
loader.c:    bswap32s(&e->a_syms);
loader.c:    bswap32s(&e->a_entry);
loader.c:    bswap32s(&e->a_trsize);
loader.c:    bswap32s(&e->a_drsize);
loader.c:#define _N_HDROFF(x) (1024 - sizeof (struct exec))
loader.c:#define _N_SEGMENT_ROUND(x, target_page_size) (((x) + target_page_size - 1) & ~(target_page_size - 1))
loader.c:        return -1;
loader.c:    return -1;
loader.c:        return -1;
loader.c:        return -1;
loader.c:    return -1;
loader.c:    bswap32s(&hdr->ih_magic);
loader.c:    bswap32s(&hdr->ih_hcrc);
loader.c:    bswap32s(&hdr->ih_time);
loader.c:    bswap32s(&hdr->ih_size);
loader.c:    bswap32s(&hdr->ih_load);
loader.c:    bswap32s(&hdr->ih_ep);
loader.c:    bswap32s(&hdr->ih_dcrc);
loader.c:    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
loader.c:        return -1;
loader.c:        return -1;
loader.c:    r = inflateInit2(&s, -MAX_WBITS);
loader.c:        return (-1);
loader.c:    s.avail_in = srclen - i;
loader.c:        return -1;
loader.c:    dstbytes = s.next_out - (unsigned char *) dst;
loader.c:/* Load a U-Boot image.  */
loader.c:    int ret = -1;
loader.c:        return -1;
loader.c:    if (hdr->ih_magic != IH_MAGIC)
loader.c:    if (hdr->ih_type != IH_TYPE_KERNEL) {
loader.c:        fprintf(stderr, "Can only load u-boot image type \"kernel\"\n");
loader.c:    switch (hdr->ih_comp) {
loader.c:                "Unable to load u-boot images with compression type %d\n",
loader.c:                hdr->ih_comp);
loader.c:        if (hdr->ih_os == IH_OS_LINUX)
loader.c:    *ep = hdr->ih_ep;
loader.c:    data = qemu_malloc(hdr->ih_size);
loader.c:    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {
loader.c:    if (hdr->ih_comp == IH_COMP_GZIP) {
loader.c:        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);
loader.c:        hdr->ih_size = bytes;
loader.c:    rom_add_blob_fixed(filename, data, hdr->ih_size, hdr->ih_load);
loader.c:        *loadaddr = hdr->ih_load;
loader.c:    ret = hdr->ih_size;
loader.c: * Functions for reboot-persistent memory regions.
loader.c: *  - used for vga bios and option roms.
loader.c: *  - also linux kernel (-kernel / -initrd).
loader.c:        if (rom->addr >= item->addr)
loader.c:    int rc, fd = -1;
loader.c:    rom->name = qemu_strdup(file);
loader.c:    rom->path = qemu_find_file(QEMU_FILE_TYPE_BIOS, rom->name);
loader.c:    if (rom->path == NULL) {
loader.c:        rom->path = qemu_strdup(file);
loader.c:    fd = open(rom->path, O_RDONLY | O_BINARY);
loader.c:    if (fd == -1) {
loader.c:                rom->path, strerror(errno));
loader.c:        rom->fw_dir  = qemu_strdup(fw_dir);
loader.c:        rom->fw_file = qemu_strdup(file);
loader.c:    rom->addr    = addr;
loader.c:    rom->romsize = lseek(fd, 0, SEEK_END);
loader.c:    rom->data    = qemu_mallocz(rom->romsize);
loader.c:    rc = read(fd, rom->data, rom->romsize);
loader.c:    if (rc != rom->romsize) {
loader.c:        fprintf(stderr, "rom: file %-20s: read error: rc=%d (expected %zd)\n",
loader.c:                rom->name, rc, rom->romsize);
loader.c:    if (rom->fw_file && fw_cfg)
loader.c:        fw_cfg_add_file(fw_cfg, rom->fw_dir, rom->fw_file, rom->data, rom->romsize);
loader.c:    if (fd != -1)
loader.c:    qemu_free(rom->data);
loader.c:    qemu_free(rom->path);
loader.c:    qemu_free(rom->name);
loader.c:    return -1;
loader.c:    rom->name    = qemu_strdup(name);
loader.c:    rom->addr    = addr;
loader.c:    rom->romsize = len;
loader.c:    rom->data    = qemu_mallocz(rom->romsize);
loader.c:    memcpy(rom->data, blob, len);
loader.c:        if (rom->fw_file) {
loader.c:        if (rom->data == NULL) {
loader.c:        cpu_physical_memory_write_rom(rom->addr, rom->data, rom->romsize);
loader.c:        if (rom->isrom) {
loader.c:            qemu_free(rom->data);
loader.c:            rom->data = NULL;
loader.c:        if (rom->fw_file) {
loader.c:        if (addr > rom->addr) {
loader.c:                    rom->name, addr, rom->addr);
loader.c:            return -1;
loader.c:        addr  = rom->addr;
loader.c:        addr += rom->romsize;
loader.c:        memtype = cpu_get_physical_page_desc(rom->addr) & (3 << IO_MEM_SHIFT);
loader.c:            rom->isrom = 1;
loader.c:        if (rom->fw_file) {
loader.c:        if (rom->addr > addr) {
loader.c:        if (rom->addr + rom->romsize < addr) {
loader.c:        if (rom->fw_file) {
loader.c:        if (rom->addr + rom->romsize < addr) {
loader.c:        if (rom->addr > end) {
loader.c:        if (!rom->data) {
loader.c:        d = dest + (rom->addr - addr);
loader.c:        s = rom->data;
loader.c:        l = rom->romsize;
loader.c:        if (rom->addr < addr) {
loader.c:            s += (addr - rom->addr);
loader.c:            l -= (addr - rom->addr);
loader.c:            l = dest - d;
loader.c:    return (d + l) - dest;
loader.c:    if (!rom || !rom->data)
loader.c:    return rom->data + (addr - rom->addr);
loader.c:        if (!rom->fw_file) {
loader.c:                           rom->addr, rom->romsize,
loader.c:                           rom->isrom ? "rom" : "ram",
loader.c:                           rom->name);
loader.c:                           rom->fw_dir,
loader.c:                           rom->fw_file,
loader.c:                           rom->romsize,
loader.c:                           rom->name);
loader.h:#define PC_ROM_SIZE        (PC_ROM_MAX - PC_ROM_MIN_VGA)
lsi53c895a.c:   big-endian targets.  */
lsi53c895a.c:    uint32_t scratch[18]; /* SCRATCHA-SCRATCHR */
lsi53c895a.c:    /* Script ram is stored as 32-bit words in host byteorder.  */
lsi53c895a.c:    return (s->sien0 & LSI_SIST0_RSL) && (s->scid & LSI_SCID_RRE);
lsi53c895a.c:    s->carry = 0;
lsi53c895a.c:    s->waiting = 0;
lsi53c895a.c:    s->dsa = 0;
lsi53c895a.c:    s->dnad = 0;
lsi53c895a.c:    s->dbc = 0;
lsi53c895a.c:    s->temp = 0;
lsi53c895a.c:    memset(s->scratch, 0, sizeof(s->scratch));
lsi53c895a.c:    s->istat0 = 0;
lsi53c895a.c:    s->istat1 = 0;
lsi53c895a.c:    s->dcmd = 0;
lsi53c895a.c:    s->dstat = 0;
lsi53c895a.c:    s->dien = 0;
lsi53c895a.c:    s->sist0 = 0;
lsi53c895a.c:    s->sist1 = 0;
lsi53c895a.c:    s->sien0 = 0;
lsi53c895a.c:    s->sien1 = 0;
lsi53c895a.c:    s->mbox0 = 0;
lsi53c895a.c:    s->mbox1 = 0;
lsi53c895a.c:    s->dfifo = 0;
lsi53c895a.c:    s->ctest2 = 0;
lsi53c895a.c:    s->ctest3 = 0;
lsi53c895a.c:    s->ctest4 = 0;
lsi53c895a.c:    s->ctest5 = 0;
lsi53c895a.c:    s->ccntl0 = 0;
lsi53c895a.c:    s->ccntl1 = 0;
lsi53c895a.c:    s->dsp = 0;
lsi53c895a.c:    s->dsps = 0;
lsi53c895a.c:    s->dmode = 0;
lsi53c895a.c:    s->dcntl = 0;
lsi53c895a.c:    s->scntl0 = 0xc0;
lsi53c895a.c:    s->scntl1 = 0;
lsi53c895a.c:    s->scntl2 = 0;
lsi53c895a.c:    s->scntl3 = 0;
lsi53c895a.c:    s->sstat0 = 0;
lsi53c895a.c:    s->sstat1 = 0;
lsi53c895a.c:    s->scid = 7;
lsi53c895a.c:    s->sxfer = 0;
lsi53c895a.c:    s->socl = 0;
lsi53c895a.c:    s->stest1 = 0;
lsi53c895a.c:    s->stest2 = 0;
lsi53c895a.c:    s->stest3 = 0;
lsi53c895a.c:    s->sidl = 0;
lsi53c895a.c:    s->stime0 = 0;
lsi53c895a.c:    s->respid0 = 0x80;
lsi53c895a.c:    s->respid1 = 0;
lsi53c895a.c:    s->mmrs = 0;
lsi53c895a.c:    s->mmws = 0;
lsi53c895a.c:    s->sfs = 0;
lsi53c895a.c:    s->drs = 0;
lsi53c895a.c:    s->sbms = 0;
lsi53c895a.c:    s->dbms = 0;
lsi53c895a.c:    s->dnad64 = 0;
lsi53c895a.c:    s->pmjad1 = 0;
lsi53c895a.c:    s->pmjad2 = 0;
lsi53c895a.c:    s->rbc = 0;
lsi53c895a.c:    s->ua = 0;
lsi53c895a.c:    s->ia = 0;
lsi53c895a.c:    s->sbc = 0;
lsi53c895a.c:    s->csbc = 0;
lsi53c895a.c:    s->sbr = 0;
lsi53c895a.c:    if ((s->ccntl1 & LSI_CCNTL1_40BIT) == LSI_CCNTL1_40BIT)
lsi53c895a.c:    if ((s->ccntl1 & LSI_CCNTL1_EN64TIBMV) == LSI_CCNTL1_EN64TIBMV)
lsi53c895a.c:    if ((s->ccntl1 & LSI_CCNTL1_EN64DBMV) == LSI_CCNTL1_EN64DBMV)
lsi53c895a.c:    if ((addr & 0xffffe000) == s->script_ram_base) {
lsi53c895a.c:        return s->script_ram[(addr & 0x1fff) >> 2];
lsi53c895a.c:    s->istat1 &= ~LSI_ISTAT1_SRUN;
lsi53c895a.c:    if (s->dstat) {
lsi53c895a.c:        if (s->dstat & s->dien)
lsi53c895a.c:        s->istat0 |= LSI_ISTAT0_DIP;
lsi53c895a.c:        s->istat0 &= ~LSI_ISTAT0_DIP;
lsi53c895a.c:    if (s->sist0 || s->sist1) {
lsi53c895a.c:        if ((s->sist0 & s->sien0) || (s->sist1 & s->sien1))
lsi53c895a.c:        s->istat0 |= LSI_ISTAT0_SIP;
lsi53c895a.c:        s->istat0 &= ~LSI_ISTAT0_SIP;
lsi53c895a.c:    if (s->istat0 & LSI_ISTAT0_INTF)
lsi53c895a.c:                level, s->dstat, s->sist1, s->sist0);
lsi53c895a.c:    qemu_set_irq(s->dev.irq[0], level);
lsi53c895a.c:    if (!level && lsi_irq_on_rsl(s) && !(s->scntl1 & LSI_SCNTL1_CON)) {
lsi53c895a.c:        for (i = 0; i < s->active_commands; i++) {
lsi53c895a.c:            if (s->queue[i].pending) {
lsi53c895a.c:                lsi_reselect(s, s->queue[i].tag);
lsi53c895a.c:            stat1, stat0, s->sist1, s->sist0);
lsi53c895a.c:    s->sist0 |= stat0;
lsi53c895a.c:    s->sist1 |= stat1;
lsi53c895a.c:    mask0 = s->sien0 | ~(LSI_SIST0_CMP | LSI_SIST0_SEL | LSI_SIST0_RSL);
lsi53c895a.c:    mask1 = s->sien1 | ~(LSI_SIST1_GEN | LSI_SIST1_HTH);
lsi53c895a.c:    if (s->sist0 & mask0 || s->sist1 & mask1) {
lsi53c895a.c:    DPRINTF("DMA Interrupt 0x%x prev 0x%x\n", stat, s->dstat);
lsi53c895a.c:    s->dstat |= stat;
lsi53c895a.c:    s->sstat1 = (s->sstat1 & ~PHASE_MASK) | phase;
lsi53c895a.c:    if (s->ccntl0 & LSI_CCNTL0_ENPMJ) {
lsi53c895a.c:        if ((s->ccntl0 & LSI_CCNTL0_PMJCTL) || out) {
lsi53c895a.c:            s->dsp = s->pmjad1;
lsi53c895a.c:            s->dsp = s->pmjad2;
lsi53c895a.c:        DPRINTF("Data phase mismatch jump to %08x\n", s->dsp);
lsi53c895a.c:    if (s->waiting != 2) {
lsi53c895a.c:        s->waiting = 0;
lsi53c895a.c:        s->waiting = 0;
lsi53c895a.c:    if (!s->current_dma_len) {
lsi53c895a.c:    count = s->dbc;
lsi53c895a.c:    if (count > s->current_dma_len)
lsi53c895a.c:        count = s->current_dma_len;
lsi53c895a.c:    addr = s->dnad;
lsi53c895a.c:    /* both 40 and Table Indirect 64-bit DMAs store upper bits in dnad64 */
lsi53c895a.c:        addr |= ((uint64_t)s->dnad64 << 32);
lsi53c895a.c:    else if (s->dbms)
lsi53c895a.c:        addr |= ((uint64_t)s->dbms << 32);
lsi53c895a.c:    else if (s->sbms)
lsi53c895a.c:        addr |= ((uint64_t)s->sbms << 32);
lsi53c895a.c:    s->csbc += count;
lsi53c895a.c:    s->dnad += count;
lsi53c895a.c:    s->dbc -= count;
lsi53c895a.c:    if (s->dma_buf == NULL) {
lsi53c895a.c:        s->dma_buf = s->current_dev->info->get_buf(s->current_dev,
lsi53c895a.c:                                                   s->current_tag);
lsi53c895a.c:        cpu_physical_memory_read(addr, s->dma_buf, count);
lsi53c895a.c:        cpu_physical_memory_write(addr, s->dma_buf, count);
lsi53c895a.c:    s->current_dma_len -= count;
lsi53c895a.c:    if (s->current_dma_len == 0) {
lsi53c895a.c:        s->dma_buf = NULL;
lsi53c895a.c:            s->current_dev->info->write_data(s->current_dev, s->current_tag);
lsi53c895a.c:            s->current_dev->info->read_data(s->current_dev, s->current_tag);
lsi53c895a.c:        s->dma_buf += count;
lsi53c895a.c:    DPRINTF("Queueing tag=0x%x\n", s->current_tag);
lsi53c895a.c:    if (s->queue_len == s->active_commands) {
lsi53c895a.c:        s->queue_len++;
lsi53c895a.c:        s->queue = qemu_realloc(s->queue, s->queue_len * sizeof(lsi_queue));
lsi53c895a.c:    p = &s->queue[s->active_commands++];
lsi53c895a.c:    p->tag = s->current_tag;
lsi53c895a.c:    p->pending = 0;
lsi53c895a.c:    p->out = (s->sstat1 & PHASE_MASK) == PHASE_DO;
lsi53c895a.c:    if (s->msg_len >= LSI_MAX_MSGIN_LEN) {
lsi53c895a.c:        s->msg[s->msg_len++] = data;
lsi53c895a.c:    for (n = 0; n < s->active_commands; n++) {
lsi53c895a.c:        p = &s->queue[n];
lsi53c895a.c:        if (p->tag == tag)
lsi53c895a.c:    if (n == s->active_commands) {
lsi53c895a.c:        BADF("Reselected non-existant command tag=0x%x\n", tag);
lsi53c895a.c:    s->ssid = id | 0x80;
lsi53c895a.c:    /* LSI53C700 Family Compatibility, see LSI53C895A 4-73 */
lsi53c895a.c:    if (!s->dcntl & LSI_DCNTL_COM) {
lsi53c895a.c:        s->sfbr = 1 << (id & 0x7);
lsi53c895a.c:    s->current_dev = s->bus.devs[id];
lsi53c895a.c:    s->current_tag = tag;
lsi53c895a.c:    s->scntl1 |= LSI_SCNTL1_CON;
lsi53c895a.c:    s->msg_action = p->out ? 2 : 3;
lsi53c895a.c:    s->current_dma_len = p->pending;
lsi53c895a.c:    s->dma_buf = NULL;
lsi53c895a.c:    if (s->current_tag & LSI_TAG_VALID) {
lsi53c895a.c:    s->active_commands--;
lsi53c895a.c:    if (n != s->active_commands) {
lsi53c895a.c:        s->queue[n] = s->queue[s->active_commands];
lsi53c895a.c:    for (i = 0; i < s->active_commands; i++) {
lsi53c895a.c:        p = &s->queue[i];
lsi53c895a.c:        if (p->tag == tag) {
lsi53c895a.c:            if (p->pending) {
lsi53c895a.c:            p->pending = arg;
lsi53c895a.c:            if (s->waiting == 1 ||
lsi53c895a.c:                (lsi_irq_on_rsl(s) && !(s->scntl1 & LSI_SCNTL1_CON) &&
lsi53c895a.c:                 !(s->istat0 & (LSI_ISTAT0_SIP | LSI_ISTAT0_DIP)))) {
lsi53c895a.c:                p->pending = arg;
lsi53c895a.c:    LSIState *s = DO_UPCAST(LSIState, dev.qdev, bus->qbus.parent);
lsi53c895a.c:    out = (s->sstat1 & PHASE_MASK) == PHASE_DO;
lsi53c895a.c:        s->sense = arg;
lsi53c895a.c:        s->command_complete = 2;
lsi53c895a.c:        if (s->waiting && s->dbc != 0) {
lsi53c895a.c:    if (s->waiting == 1 || tag != s->current_tag ||
lsi53c895a.c:        (lsi_irq_on_rsl(s) && !(s->scntl1 & LSI_SCNTL1_CON))) {
lsi53c895a.c:    s->current_dma_len = arg;
lsi53c895a.c:    s->command_complete = 1;
lsi53c895a.c:    if (!s->waiting)
lsi53c895a.c:    if (s->waiting == 1 || s->dbc == 0) {
lsi53c895a.c:    DPRINTF("Send command len=%d\n", s->dbc);
lsi53c895a.c:    if (s->dbc > 16)
lsi53c895a.c:        s->dbc = 16;
lsi53c895a.c:    cpu_physical_memory_read(s->dnad, buf, s->dbc);
lsi53c895a.c:    s->sfbr = buf[0];
lsi53c895a.c:    s->command_complete = 0;
lsi53c895a.c:    n = s->current_dev->info->send_command(s->current_dev, s->current_tag, buf,
lsi53c895a.c:                                           s->current_lun);
lsi53c895a.c:        s->current_dev->info->read_data(s->current_dev, s->current_tag);
lsi53c895a.c:        s->current_dev->info->write_data(s->current_dev, s->current_tag);
lsi53c895a.c:    if (!s->command_complete) {
lsi53c895a.c:            s->msg_action = 1;
lsi53c895a.c:    DPRINTF("Get status len=%d sense=%d\n", s->dbc, s->sense);
lsi53c895a.c:    if (s->dbc != 1)
lsi53c895a.c:    s->dbc = 1;
lsi53c895a.c:    sense = s->sense;
lsi53c895a.c:    s->sfbr = sense;
lsi53c895a.c:    cpu_physical_memory_write(s->dnad, &sense, 1);
lsi53c895a.c:    s->msg_action = 1;
lsi53c895a.c:    s->scntl1 &= ~LSI_SCNTL1_CON;
lsi53c895a.c:    s->sstat1 &= ~PHASE_MASK;
lsi53c895a.c:    DPRINTF("Message in len=%d/%d\n", s->dbc, s->msg_len);
lsi53c895a.c:    s->sfbr = s->msg[0];
lsi53c895a.c:    len = s->msg_len;
lsi53c895a.c:    if (len > s->dbc)
lsi53c895a.c:        len = s->dbc;
lsi53c895a.c:    cpu_physical_memory_write(s->dnad, s->msg, len);
lsi53c895a.c:    s->sidl = s->msg[len - 1];
lsi53c895a.c:    s->msg_len -= len;
lsi53c895a.c:    if (s->msg_len) {
lsi53c895a.c:        memmove(s->msg, s->msg + len, s->msg_len);
lsi53c895a.c:        switch (s->msg_action) {
lsi53c895a.c:    cpu_physical_memory_read(s->dnad, &data, 1);
lsi53c895a.c:    s->dnad++;
lsi53c895a.c:    s->dbc--;
lsi53c895a.c:    DPRINTF("MSG out len=%d\n", s->dbc);
lsi53c895a.c:    while (s->dbc) {
lsi53c895a.c:        s->sfbr = msg;
lsi53c895a.c:                s->dbc -= 2;
lsi53c895a.c:                s->dbc -= 1;
lsi53c895a.c:            s->current_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID;
lsi53c895a.c:            DPRINTF("SIMPLE queue tag=0x%x\n", s->current_tag & 0xff);
lsi53c895a.c:            s->current_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID;
lsi53c895a.c:            s->current_tag |= lsi_get_msgbyte(s) | LSI_TAG_VALID;
lsi53c895a.c:            s->current_lun = msg & 7;
lsi53c895a.c:            DPRINTF("Select LUN %d\n", s->current_lun);
lsi53c895a.c:    s->msg_action = 0;
lsi53c895a.c:/* Sign extend a 24-bit value.  */
lsi53c895a.c:        count -= n;
lsi53c895a.c:    if (s->current_dma_len)
lsi53c895a.c:    for (i = 0; i < s->active_commands; i++) {
lsi53c895a.c:        if (s->queue[i].pending) {
lsi53c895a.c:            lsi_reselect(s, s->queue[i].tag);
lsi53c895a.c:    if (s->current_dma_len == 0) {
lsi53c895a.c:        s->waiting = 1;
lsi53c895a.c:    s->istat1 |= LSI_ISTAT1_SRUN;
lsi53c895a.c:    insn = read_dword(s, s->dsp);
lsi53c895a.c:        s->dsp += 4;
lsi53c895a.c:    addr = read_dword(s, s->dsp + 4);
lsi53c895a.c:    DPRINTF("SCRIPTS dsp=%08x opcode %08x arg %08x\n", s->dsp, insn, addr);
lsi53c895a.c:    s->dsps = addr;
lsi53c895a.c:    s->dcmd = insn >> 24;
lsi53c895a.c:    s->dsp += 8;
lsi53c895a.c:        if (s->sist1 & LSI_SIST1_STO) {
lsi53c895a.c:        s->dbc = insn & 0xffffff;
lsi53c895a.c:        s->rbc = s->dbc;
lsi53c895a.c:        s->ia = s->dsp - 8;
lsi53c895a.c:            /* 32-bit Table indirect */
lsi53c895a.c:            cpu_physical_memory_read(s->dsa + offset, (uint8_t *)buf, 8);
lsi53c895a.c:            s->dbc = cpu_to_le32(buf[0]) & 0xffffff;
lsi53c895a.c:            s->rbc = s->dbc;
lsi53c895a.c:            /* 40-bit DMA, upper addr bits [39:32] stored in first DWORD of
lsi53c895a.c:                    addr_high = s->scratch[2 + selector];
lsi53c895a.c:                    addr_high = s->mmrs;
lsi53c895a.c:                    addr_high = s->mmws;
lsi53c895a.c:                    addr_high = s->sfs;
lsi53c895a.c:                    addr_high = s->drs;
lsi53c895a.c:                    addr_high = s->sbms;
lsi53c895a.c:                    addr_high = s->dbms;
lsi53c895a.c:                         " for 64-bit DMA block move", selector);
lsi53c895a.c:            /* fetch a 3rd dword if 64-bit direct move is enabled and
lsi53c895a.c:            s->dbms = read_dword(s, s->dsp);
lsi53c895a.c:            s->dsp += 4;
lsi53c895a.c:            s->ia = s->dsp - 12;
lsi53c895a.c:        if ((s->sstat1 & PHASE_MASK) != ((insn >> 24) & 7)) {
lsi53c895a.c:                    s->sstat1 & PHASE_MASK, (insn >> 24) & 7);
lsi53c895a.c:        s->dnad = addr;
lsi53c895a.c:        s->dnad64 = addr_high;
lsi53c895a.c:        switch (s->sstat1 & 0x7) {
lsi53c895a.c:            s->waiting = 2;
lsi53c895a.c:            if (s->waiting)
lsi53c895a.c:                s->waiting = 3;
lsi53c895a.c:            s->waiting = 2;
lsi53c895a.c:            if (s->waiting)
lsi53c895a.c:                s->waiting = 3;
lsi53c895a.c:            BADF("Unimplemented phase %d\n", s->sstat1 & PHASE_MASK);
lsi53c895a.c:        s->dfifo = s->dbc & 0xff;
lsi53c895a.c:        s->ctest5 = (s->ctest5 & 0xfc) | ((s->dbc >> 8) & 3);
lsi53c895a.c:        s->sbc = s->dbc;
lsi53c895a.c:        s->rbc -= s->dbc;
lsi53c895a.c:        s->ua = addr + s->dbc;
lsi53c895a.c:                id = read_dword(s, s->dsa + sxt24(insn));
lsi53c895a.c:                addr = s->dsp + sxt24(addr);
lsi53c895a.c:            s->dnad = addr;
lsi53c895a.c:                s->sdid = id;
lsi53c895a.c:                if (s->scntl1 & LSI_SCNTL1_CON) {
lsi53c895a.c:                    s->dsp = s->dnad;
lsi53c895a.c:                s->sstat0 |= LSI_SSTAT0_WOA;
lsi53c895a.c:                s->scntl1 &= ~LSI_SCNTL1_IARB;
lsi53c895a.c:                if (id >= LSI_MAX_DEVS || !s->bus.devs[id]) {
lsi53c895a.c:                   it only applies in low-level mode (unimplemented).
lsi53c895a.c:                s->current_dev = s->bus.devs[id];
lsi53c895a.c:                s->current_tag = id << 8;
lsi53c895a.c:                s->scntl1 |= LSI_SCNTL1_CON;
lsi53c895a.c:                    s->socl |= LSI_SOCL_ATN;
lsi53c895a.c:                s->scntl1 &= ~LSI_SCNTL1_CON;
lsi53c895a.c:                    s->socl |= LSI_SOCL_ATN;
lsi53c895a.c:                    s->carry = 1;
lsi53c895a.c:                    s->socl &= ~LSI_SOCL_ATN;
lsi53c895a.c:                    s->carry = 0;
lsi53c895a.c:                {"Write", "Read", "Read-Modify-Write"};
lsi53c895a.c:                    opcode_names[opcode - 5], reg,
lsi53c895a.c:                    operator_names[operator], data8, s->sfbr,
lsi53c895a.c:                op0 = s->sfbr;
lsi53c895a.c:            case 7: /* Read-modify-write */
lsi53c895a.c:                    op1 = s->sfbr;
lsi53c895a.c:                op0 = (op0 << 1) | s->carry;
lsi53c895a.c:                s->carry = op1;
lsi53c895a.c:                op0 = (op0 >> 1) | (s->carry << 7);
lsi53c895a.c:                s->carry = op1;
lsi53c895a.c:                s->carry = op0 < op1;
lsi53c895a.c:                op0 += op1 + s->carry;
lsi53c895a.c:                if (s->carry)
lsi53c895a.c:                    s->carry = op0 <= op1;
lsi53c895a.c:                    s->carry = op0 < op1;
lsi53c895a.c:            case 7: /* Read-modify-write */
lsi53c895a.c:                s->sfbr = op0;
lsi53c895a.c:            if (s->sist1 & LSI_SIST1_STO) {
lsi53c895a.c:                DPRINTF("Compare carry %d\n", s->carry == jmp);
lsi53c895a.c:                cond = s->carry != 0;
lsi53c895a.c:                        (s->sstat1 & PHASE_MASK),
lsi53c895a.c:                cond = (s->sstat1 & PHASE_MASK) == ((insn >> 24) & 7);
lsi53c895a.c:                        s->sfbr, mask, jmp ? '=' : '!', insn & mask);
lsi53c895a.c:                cond = (s->sfbr & mask) == (insn & mask);
lsi53c895a.c:                    addr = s->dsp + sxt24(addr);
lsi53c895a.c:                    s->dsp = addr;
lsi53c895a.c:                    s->temp = s->dsp;
lsi53c895a.c:                    s->dsp = addr;
lsi53c895a.c:                    DPRINTF("Return to 0x%08x\n", s->temp);
lsi53c895a.c:                    s->dsp = s->temp;
lsi53c895a.c:                    DPRINTF("Interrupt 0x%08x\n", s->dsps);
lsi53c895a.c:                        s->istat0 |= LSI_ISTAT0_INTF;
lsi53c895a.c:            dest = read_dword(s, s->dsp);
lsi53c895a.c:            s->dsp += 4;
lsi53c895a.c:                addr = s->dsa + sxt24(addr);
lsi53c895a.c:    if (insn_processed > 10000 && !s->waiting) {
lsi53c895a.c:        if (!(s->sien0 & LSI_SIST0_UDC))
lsi53c895a.c:    } else if (s->istat1 & LSI_ISTAT1_SRUN && !s->waiting) {
lsi53c895a.c:        if (s->dcntl & LSI_DCNTL_SSM) {
lsi53c895a.c:    case addr: return s->name & 0xff; \
lsi53c895a.c:    case addr + 1: return (s->name >> 8) & 0xff; \
lsi53c895a.c:    case addr + 2: return (s->name >> 16) & 0xff;
lsi53c895a.c:    case addr: return s->name & 0xff; \
lsi53c895a.c:    case addr + 1: return (s->name >> 8) & 0xff; \
lsi53c895a.c:    case addr + 2: return (s->name >> 16) & 0xff; \
lsi53c895a.c:    case addr + 3: return (s->name >> 24) & 0xff;
lsi53c895a.c:        return s->scntl0;
lsi53c895a.c:        return s->scntl1;
lsi53c895a.c:        return s->scntl2;
lsi53c895a.c:        return s->scntl3;
lsi53c895a.c:        return s->scid;
lsi53c895a.c:        return s->sxfer;
lsi53c895a.c:        return s->sdid;
lsi53c895a.c:        return s->ssid;
lsi53c895a.c:        tmp = s->dstat | 0x80;
lsi53c895a.c:        if ((s->istat0 & LSI_ISTAT0_INTF) == 0)
lsi53c895a.c:            s->dstat = 0;
lsi53c895a.c:        return s->sstat0;
lsi53c895a.c:        return s->sstat1;
lsi53c895a.c:        return s->scntl1 & LSI_SCNTL1_CON ? 0 : 2;
lsi53c895a.c:        return s->istat0;
lsi53c895a.c:        return s->istat1;
lsi53c895a.c:        return s->mbox0;
lsi53c895a.c:        return s->mbox1;
lsi53c895a.c:        tmp = s->ctest2 | LSI_CTEST2_DACK | LSI_CTEST2_CM;
lsi53c895a.c:        if (s->istat0 & LSI_ISTAT0_SIGP) {
lsi53c895a.c:            s->istat0 &= ~LSI_ISTAT0_SIGP;
lsi53c895a.c:        return s->ctest3;
lsi53c895a.c:        return s->ctest4;
lsi53c895a.c:        return s->ctest5;
lsi53c895a.c:        return s->dcmd;
lsi53c895a.c:        return s->dmode;
lsi53c895a.c:        return s->dien;
lsi53c895a.c:        return s->sbr;
lsi53c895a.c:        return s->dcntl;
lsi53c895a.c:        return s->sien0;
lsi53c895a.c:        return s->sien1;
lsi53c895a.c:        tmp = s->sist0;
lsi53c895a.c:        s->sist0 = 0;
lsi53c895a.c:        tmp = s->sist1;
lsi53c895a.c:        s->sist1 = 0;
lsi53c895a.c:        return s->stime0;
lsi53c895a.c:        return s->respid0;
lsi53c895a.c:        return s->respid1;
lsi53c895a.c:        return s->stest1;
lsi53c895a.c:        return s->stest2;
lsi53c895a.c:        return s->stest3;
lsi53c895a.c:        return s->sidl;
lsi53c895a.c:        return s->ccntl0;
lsi53c895a.c:        return s->ccntl1;
lsi53c895a.c:        if ((s->sstat1 & PHASE_MASK) == PHASE_MI)
lsi53c895a.c:            return s->msg[0];
lsi53c895a.c:        n = (offset - 0x58) >> 2;
lsi53c895a.c:        return (s->scratch[n] >> shift) & 0xff;
lsi53c895a.c:    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \
lsi53c895a.c:    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \
lsi53c895a.c:    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break;
lsi53c895a.c:    case addr    : s->name &= 0xffffff00; s->name |= val;       break; \
lsi53c895a.c:    case addr + 1: s->name &= 0xffff00ff; s->name |= val << 8;  break; \
lsi53c895a.c:    case addr + 2: s->name &= 0xff00ffff; s->name |= val << 16; break; \
lsi53c895a.c:    case addr + 3: s->name &= 0x00ffffff; s->name |= val << 24; break;
lsi53c895a.c:        s->scntl0 = val;
lsi53c895a.c:        s->scntl1 = val & ~LSI_SCNTL1_SST;
lsi53c895a.c:            s->sstat0 |= LSI_SSTAT0_RST;
lsi53c895a.c:            s->sstat0 &= ~LSI_SSTAT0_RST;
lsi53c895a.c:        s->scntl2 = val;
lsi53c895a.c:        s->scntl3 = val;
lsi53c895a.c:        s->scid = val;
lsi53c895a.c:        s->sxfer = val;
lsi53c895a.c:        if ((val & 0xf) != (s->ssid & 0xf))
lsi53c895a.c:        s->sdid = val & 0xf;
lsi53c895a.c:        s->sfbr = val;
lsi53c895a.c:        s->istat0 = (s->istat0 & 0x0f) | (val & 0xf0);
lsi53c895a.c:            s->istat0 &= ~LSI_ISTAT0_INTF;
lsi53c895a.c:        if (s->waiting == 1 && val & LSI_ISTAT0_SIGP) {
lsi53c895a.c:            s->waiting = 0;
lsi53c895a.c:            s->dsp = s->dnad;
lsi53c895a.c:        s->mbox0 = val;
lsi53c895a.c:        s->mbox1 = val;
lsi53c895a.c:	s->ctest2 = val & LSI_CTEST2_PCICIE;
lsi53c895a.c:        s->ctest3 = val & 0x0f;
lsi53c895a.c:           BADF("Unimplemented CTEST4-FBL 0x%x\n", val);
lsi53c895a.c:        s->ctest4 = val;
lsi53c895a.c:        s->ctest5 = val;
lsi53c895a.c:        s->dsp &= 0xffffff00;
lsi53c895a.c:        s->dsp |= val;
lsi53c895a.c:        s->dsp &= 0xffff00ff;
lsi53c895a.c:        s->dsp |= val << 8;
lsi53c895a.c:        s->dsp &= 0xff00ffff;
lsi53c895a.c:        s->dsp |= val << 16;
lsi53c895a.c:        s->dsp &= 0x00ffffff;
lsi53c895a.c:        s->dsp |= val << 24;
lsi53c895a.c:        if ((s->dmode & LSI_DMODE_MAN) == 0
lsi53c895a.c:            && (s->istat1 & LSI_ISTAT1_SRUN) == 0)
lsi53c895a.c:        s->dmode = val;
lsi53c895a.c:        s->dien = val;
lsi53c895a.c:        s->sbr = val;
lsi53c895a.c:        s->dcntl = val & ~(LSI_DCNTL_PFF | LSI_DCNTL_STD);
lsi53c895a.c:        if ((val & LSI_DCNTL_STD) && (s->istat1 & LSI_ISTAT1_SRUN) == 0)
lsi53c895a.c:        s->sien0 = val;
lsi53c895a.c:        s->sien1 = val;
lsi53c895a.c:        s->stime0 = val;
lsi53c895a.c:        s->respid0 = val;
lsi53c895a.c:        s->respid1 = val;
lsi53c895a.c:        s->stest1 = val;
lsi53c895a.c:        s->stest2 = val;
lsi53c895a.c:        s->stest3 = val;
lsi53c895a.c:        s->ccntl0 = val;
lsi53c895a.c:        s->ccntl1 = val;
lsi53c895a.c:            n = (offset - 0x58) >> 2;
lsi53c895a.c:            s->scratch[n] &= ~(0xff << shift);
lsi53c895a.c:            s->scratch[n] |= (val & 0xff) << shift;
lsi53c895a.c:    newval = s->script_ram[addr >> 2];
lsi53c895a.c:    s->script_ram[addr >> 2] = newval;
lsi53c895a.c:    newval = s->script_ram[addr >> 2];
lsi53c895a.c:    s->script_ram[addr >> 2] = newval;
lsi53c895a.c:    s->script_ram[addr >> 2] = val;
lsi53c895a.c:    val = s->script_ram[addr >> 2];
lsi53c895a.c:    val = s->script_ram[addr >> 2];
lsi53c895a.c:    return le32_to_cpu(s->script_ram[addr >> 2]);
lsi53c895a.c:    s->script_ram_base = addr;
lsi53c895a.c:    cpu_register_physical_memory(addr + 0, 0x2000, s->ram_io_addr);
lsi53c895a.c:    cpu_register_physical_memory(addr + 0, 0x400, s->mmio_io_addr);
lsi53c895a.c:    assert(s->dma_buf == NULL);
lsi53c895a.c:    assert(s->current_dma_len == 0);
lsi53c895a.c:    assert(s->active_commands == 0);
lsi53c895a.c:    cpu_unregister_io_memory(s->mmio_io_addr);
lsi53c895a.c:    cpu_unregister_io_memory(s->ram_io_addr);
lsi53c895a.c:    qemu_free(s->queue);
lsi53c895a.c:    pci_conf = s->dev.config;
lsi53c895a.c:    s->mmio_io_addr = cpu_register_io_memory(lsi_mmio_readfn,
lsi53c895a.c:    s->ram_io_addr = cpu_register_io_memory(lsi_ram_readfn,
lsi53c895a.c:    s->queue = qemu_malloc(sizeof(lsi_queue));
lsi53c895a.c:    s->queue_len = 1;
lsi53c895a.c:    s->active_commands = 0;
lsi53c895a.c:    scsi_bus_new(&s->bus, &dev->qdev, 1, LSI_MAX_DEVS, lsi_command_complete);
lsi53c895a.c:    if (!dev->qdev.hotplugged) {
lsi53c895a.c:        scsi_bus_legacy_handle_cmdline(&s->bus);
m48t59.c: * Copyright (c) 2003-2005, 2007 Jocelyn Mayer
m48t59.c:#include "qemu-timer.h"
m48t59.c:    qemu_set_irq(NVRAM->IRQ, 1);
m48t59.c:    if ((NVRAM->buffer[0x1FF5] & 0x80) == 0 &&
m48t59.c:	(NVRAM->buffer[0x1FF4] & 0x80) == 0 &&
m48t59.c:	(NVRAM->buffer[0x1FF3] & 0x80) == 0 &&
m48t59.c:	(NVRAM->buffer[0x1FF2] & 0x80) == 0) {
m48t59.c:        qemu_get_timedate(&tm, NVRAM->time_offset);
m48t59.c:        next_time = qemu_timedate_diff(&tm) - NVRAM->time_offset;
m48t59.c:    } else if ((NVRAM->buffer[0x1FF5] & 0x80) != 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF4] & 0x80) == 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF3] & 0x80) == 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF2] & 0x80) == 0) {
m48t59.c:    } else if ((NVRAM->buffer[0x1FF5] & 0x80) != 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF4] & 0x80) != 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF3] & 0x80) == 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF2] & 0x80) == 0) {
m48t59.c:    } else if ((NVRAM->buffer[0x1FF5] & 0x80) != 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF4] & 0x80) != 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF3] & 0x80) != 0 &&
m48t59.c:	       (NVRAM->buffer[0x1FF2] & 0x80) == 0) {
m48t59.c:    qemu_mod_timer(NVRAM->alrm_timer, qemu_get_clock(vm_clock) +
m48t59.c:    qemu_set_irq(NVRAM->IRQ, 0);
m48t59.c:    if (NVRAM->alrm_timer != NULL) {
m48t59.c:        qemu_del_timer(NVRAM->alrm_timer);
m48t59.c:        diff = qemu_timedate_diff(&NVRAM->alarm) - NVRAM->time_offset;
m48t59.c:            qemu_mod_timer(NVRAM->alrm_timer, diff * 1000);
m48t59.c:    qemu_get_timedate(tm, NVRAM->time_offset);
m48t59.c:    NVRAM->time_offset = qemu_timedate_diff(tm);
m48t59.c:    NVRAM->buffer[0x1FF0] |= 0x80;
m48t59.c:    if (NVRAM->buffer[0x1FF7] & 0x80) {
m48t59.c:	NVRAM->buffer[0x1FF7] = 0x00;
m48t59.c:	NVRAM->buffer[0x1FFC] &= ~0x40;
m48t59.c:	qemu_set_irq(NVRAM->IRQ, 1);
m48t59.c:	qemu_set_irq(NVRAM->IRQ, 0);
m48t59.c:    NVRAM->buffer[0x1FF0] &= ~0x80;
m48t59.c:    if (NVRAM->wd_timer != NULL) {
m48t59.c:        qemu_del_timer(NVRAM->wd_timer);
m48t59.c:            qemu_mod_timer(NVRAM->wd_timer, ((uint64_t)time(NULL) * 1000) +
m48t59.c:    if ((NVRAM->type == 2 && addr < 0x7f8) ||
m48t59.c:        (NVRAM->type == 8 && addr < 0x1ff8) ||
m48t59.c:        (NVRAM->type == 59 && addr < 0x1ff0))
m48t59.c:        /* flags register : read-only */
m48t59.c:            NVRAM->alarm.tm_sec = tmp;
m48t59.c:            NVRAM->buffer[0x1FF2] = val;
m48t59.c:            NVRAM->alarm.tm_min = tmp;
m48t59.c:            NVRAM->buffer[0x1FF3] = val;
m48t59.c:            NVRAM->alarm.tm_hour = tmp;
m48t59.c:            NVRAM->buffer[0x1FF4] = val;
m48t59.c:            NVRAM->alarm.tm_mday = tmp;
m48t59.c:            NVRAM->buffer[0x1FF5] = val;
m48t59.c:        NVRAM->buffer[0x1FF6] = val;
m48t59.c:        NVRAM->buffer[0x1FF7] = val;
m48t59.c:       NVRAM->buffer[addr] = (val & ~0xA0) | 0x90;
m48t59.c:        if ((val & 0x80) ^ (NVRAM->buffer[addr] & 0x80)) {
m48t59.c:		NVRAM->stop_time = time(NULL);
m48t59.c:		NVRAM->time_offset += NVRAM->stop_time - time(NULL);
m48t59.c:		NVRAM->stop_time = 0;
m48t59.c:        NVRAM->buffer[addr] = val & 0x80;
m48t59.c:        NVRAM->buffer[addr] = val & 0x40;
m48t59.c:	    tm.tm_mon = tmp - 1;
m48t59.c:            if (NVRAM->type == 8)
m48t59.c:        if (addr >= 0x20 && addr <= 0x2F && (NVRAM->lock & 1))
m48t59.c:        if (addr >= 0x30 && addr <= 0x3F && (NVRAM->lock & 2))
m48t59.c:        if (addr < NVRAM->size) {
m48t59.c:            NVRAM->buffer[addr] = val & 0xFF;
m48t59.c:    if ((NVRAM->type == 2 && addr < 0x078f) ||
m48t59.c:        (NVRAM->type == 8 && addr < 0x1ff8) ||
m48t59.c:        (NVRAM->type == 59 && addr < 0x1ff0))
m48t59.c:	set_up_watchdog(NVRAM, NVRAM->buffer[0x1FF7]);
m48t59.c:        retval = (NVRAM->buffer[addr] & 0x80) | to_bcd(tm.tm_sec);
m48t59.c:        retval = NVRAM->buffer[addr] | tm.tm_wday;
m48t59.c:        if (NVRAM->type == 8)
m48t59.c:            retval = to_bcd(tm.tm_year - 68); // Base year is 1968
m48t59.c:        if (addr >= 0x20 && addr <= 0x2F && (NVRAM->lock & 1))
m48t59.c:        if (addr >= 0x30 && addr <= 0x3F && (NVRAM->lock & 2))
m48t59.c:        if (addr < NVRAM->size) {
m48t59.c:            retval = NVRAM->buffer[addr];
m48t59.c:    NVRAM->addr = addr;
m48t59.c:    NVRAM->lock ^= 1 << lock;
m48t59.c:    addr -= NVRAM->io_base;
m48t59.c:        NVRAM->addr &= ~0x00FF;
m48t59.c:        NVRAM->addr |= val;
m48t59.c:        NVRAM->addr &= ~0xFF00;
m48t59.c:        NVRAM->addr |= val << 8;
m48t59.c:        m48t59_write(NVRAM, val, NVRAM->addr);
m48t59.c:        NVRAM->addr = 0x0000;
m48t59.c:    addr -= NVRAM->io_base;
m48t59.c:        retval = m48t59_read(NVRAM, NVRAM->addr);
m48t59.c:        retval = -1;
m48t59.c:    qemu_put_8s(f, &s->lock);
m48t59.c:    qemu_put_be16s(f, &s->addr);
m48t59.c:    qemu_put_buffer(f, s->buffer, s->size);
m48t59.c:        return -EINVAL;
m48t59.c:    qemu_get_8s(f, &s->lock);
m48t59.c:    qemu_get_be16s(f, &s->addr);
m48t59.c:    qemu_get_buffer(f, s->buffer, s->size);
m48t59.c:    NVRAM->addr = 0;
m48t59.c:    NVRAM->lock = 0;
m48t59.c:    if (NVRAM->alrm_timer != NULL)
m48t59.c:        qemu_del_timer(NVRAM->alrm_timer);
m48t59.c:    if (NVRAM->wd_timer != NULL)
m48t59.c:        qemu_del_timer(NVRAM->wd_timer);
m48t59.c:    m48t59_t *NVRAM = &isa->state;
m48t59.c:    m48t59_t *NVRAM = &sys->state;
m48t59.c:    return &d->state;
m48t59.c:    qdev_prop_set_uint32(&dev->qdev, "type", type);
m48t59.c:    qdev_prop_set_uint32(&dev->qdev, "size", size);
m48t59.c:    qdev_prop_set_uint32(&dev->qdev, "io_base", io_base);
m48t59.c:    qdev_init_nofail(&dev->qdev);
m48t59.c:    s = &d->state;
m48t59.c:    s->buffer = qemu_mallocz(s->size);
m48t59.c:    if (s->type == 59) {
m48t59.c:        s->alrm_timer = qemu_new_timer(vm_clock, &alarm_cb, s);
m48t59.c:        s->wd_timer = qemu_new_timer(vm_clock, &watchdog_cb, s);
m48t59.c:    qemu_get_timedate(&s->alarm, 0);
m48t59.c:    register_savevm("m48t59", -1, 1, m48t59_save, m48t59_load, s);
m48t59.c:    m48t59_t *s = &d->state;
m48t59.c:    isa_init_irq(dev, &s->IRQ, 8);
m48t59.c:    m48t59_t *s = &d->state;
m48t59.c:    sysbus_init_irq(dev, &s->IRQ);
m48t59.c:    sysbus_init_mmio(dev, s->size, mem_index);
m48t59.c:        DEFINE_PROP_UINT32("size",    M48t59ISAState, state.size,    -1),
m48t59.c:        DEFINE_PROP_UINT32("type",    M48t59ISAState, state.type,    -1),
m48t59.c:        DEFINE_PROP_UINT32("size",    M48t59SysBusState, state.size,    -1),
m48t59.c:        DEFINE_PROP_UINT32("type",    M48t59SysBusState, state.type,    -1),
mac_dbdma.c: * PowerMac descriptor-based DMA emulation
mac_dbdma.c: * Copyright (c) 2005-2007 Fabrice Bellard
mac_dbdma.c: * some parts from linux-2.6.28, arch/powerpc/include/asm/dbdma.h
mac_dbdma.c: *   Definitions for using the Apple Descriptor-Based DMA controller
mac_dbdma.c: *   Copyright (C) 1998-2004 Samuel Rydh (samuel@ibrium.se)
mac_dbdma.c: * DBDMA control/status registers.  All little-endian.
mac_dbdma.c: * DBDMA command structure.  These fields are all little-endian!
mac_dbdma.c:    uint16_t command;	  /* command word (has bit-fields) */
mac_dbdma.c:    uint32_t cmd_dep;	  /* command-dependent field */
mac_dbdma.c:#define KEY_STREAM2	0x0200	/* device-dependent stream */
mac_dbdma.c:#define KEY_STREAM3	0x0300	/* device-dependent stream */
mac_dbdma.c:#define KEY_SYSTEM	0x0600	/* system memory-mapped space */
mac_dbdma.c:#define KEY_DEVICE	0x0700	/* device memory-mapped space */
mac_dbdma.c:    printf("    req_count 0x%04x\n", le16_to_cpu(cmd->req_count));
mac_dbdma.c:    printf("    command 0x%04x\n", le16_to_cpu(cmd->command));
mac_dbdma.c:    printf("    phy_addr 0x%08x\n", le32_to_cpu(cmd->phy_addr));
mac_dbdma.c:    printf("    cmd_dep 0x%08x\n", le32_to_cpu(cmd->cmd_dep));
mac_dbdma.c:    printf("    res_count 0x%04x\n", le16_to_cpu(cmd->res_count));
mac_dbdma.c:    printf("    xfer_status 0x%04x\n", le16_to_cpu(cmd->xfer_status));
mac_dbdma.c:                  be32_to_cpu(ch->regs[DBDMA_CMDPTR_LO]));
mac_dbdma.c:    cpu_physical_memory_read(be32_to_cpu(ch->regs[DBDMA_CMDPTR_LO]),
mac_dbdma.c:                             (uint8_t*)&ch->current, sizeof(dbdma_cmd));
mac_dbdma.c:                  be32_to_cpu(ch->regs[DBDMA_CMDPTR_LO]));
mac_dbdma.c:                  le16_to_cpu(ch->current.xfer_status),
mac_dbdma.c:                  le16_to_cpu(ch->current.res_count));
mac_dbdma.c:    cpu_physical_memory_write(be32_to_cpu(ch->regs[DBDMA_CMDPTR_LO]),
mac_dbdma.c:                              (uint8_t*)&ch->current, sizeof(dbdma_cmd));
mac_dbdma.c:    ch->regs[DBDMA_STATUS] |= cpu_to_be32(DEAD);
mac_dbdma.c:    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~ACTIVE);
mac_dbdma.c:    qemu_irq_raise(ch->irq);
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    intr = le16_to_cpu(current->command) & INTR_MASK;
mac_dbdma.c:        qemu_irq_raise(ch->irq);
mac_dbdma.c:    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
mac_dbdma.c:    sel_mask = (be32_to_cpu(ch->regs[DBDMA_INTR_SEL]) >> 16) & 0x0f;
mac_dbdma.c:    sel_value = be32_to_cpu(ch->regs[DBDMA_INTR_SEL]) & 0x0f;
mac_dbdma.c:            qemu_irq_raise(ch->irq);
mac_dbdma.c:            qemu_irq_raise(ch->irq);
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    wait = le16_to_cpu(current->command) & WAIT_MASK;
mac_dbdma.c:    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
mac_dbdma.c:    sel_mask = (be32_to_cpu(ch->regs[DBDMA_WAIT_SEL]) >> 16) & 0x0f;
mac_dbdma.c:    sel_value = be32_to_cpu(ch->regs[DBDMA_WAIT_SEL]) & 0x0f;
mac_dbdma.c:    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~BT);
mac_dbdma.c:    cp = be32_to_cpu(ch->regs[DBDMA_CMDPTR_LO]);
mac_dbdma.c:    ch->regs[DBDMA_CMDPTR_LO] = cpu_to_be32(cp + sizeof(dbdma_cmd));
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    ch->regs[DBDMA_CMDPTR_LO] = current->cmd_dep;
mac_dbdma.c:    ch->regs[DBDMA_STATUS] |= cpu_to_be32(BT);
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    br = le16_to_cpu(current->command) & BR_MASK;
mac_dbdma.c:    status = be32_to_cpu(ch->regs[DBDMA_STATUS]) & DEVSTAT;
mac_dbdma.c:    sel_mask = (be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) >> 16) & 0x0f;
mac_dbdma.c:    sel_value = be32_to_cpu(ch->regs[DBDMA_BRANCH_SEL]) & 0x0f;
mac_dbdma.c:    DBDMA_channel *ch = io->channel;
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    current->xfer_status = cpu_to_le16(be32_to_cpu(ch->regs[DBDMA_STATUS]));
mac_dbdma.c:    current->res_count = cpu_to_le16(be32_to_cpu(io->len));
mac_dbdma.c:    if (io->is_last)
mac_dbdma.c:        ch->regs[DBDMA_STATUS] &= cpu_to_be32(~FLUSH);
mac_dbdma.c:    ch->processing = 0;
mac_dbdma.c:    if ((ch->regs[DBDMA_STATUS] & cpu_to_be32(RUN)) &&
mac_dbdma.c:        (ch->regs[DBDMA_STATUS] & cpu_to_be32(ACTIVE)))
mac_dbdma.c:     * are not implemented in the mac-io chip
mac_dbdma.c:    ch->io.addr = addr;
mac_dbdma.c:    ch->io.len = req_count;
mac_dbdma.c:    ch->io.is_last = is_last;
mac_dbdma.c:    ch->io.dma_end = dbdma_end;
mac_dbdma.c:    ch->io.is_dma_out = 1;
mac_dbdma.c:    ch->processing = 1;
mac_dbdma.c:    ch->rw(&ch->io);
mac_dbdma.c:     * are not implemented in the mac-io chip
mac_dbdma.c:    ch->io.addr = addr;
mac_dbdma.c:    ch->io.len = req_count;
mac_dbdma.c:    ch->io.is_last = is_last;
mac_dbdma.c:    ch->io.dma_end = dbdma_end;
mac_dbdma.c:    ch->io.is_dma_out = 0;
mac_dbdma.c:    ch->processing = 1;
mac_dbdma.c:    ch->rw(&ch->io);
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:        val = (val << 16) | (current->cmd_dep & 0x0000ffff);
mac_dbdma.c:        val = (val << 24) | (current->cmd_dep & 0x00ffffff);
mac_dbdma.c:    current->cmd_dep = val;
mac_dbdma.c:    current->xfer_status = cpu_to_le16(be32_to_cpu(ch->regs[DBDMA_STATUS]));
mac_dbdma.c:    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~FLUSH);
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    val = current->cmd_dep;
mac_dbdma.c:    current->xfer_status = cpu_to_le16(be32_to_cpu(ch->regs[DBDMA_STATUS]));
mac_dbdma.c:    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~FLUSH);
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    current->xfer_status = cpu_to_le16(be32_to_cpu(ch->regs[DBDMA_STATUS]));
mac_dbdma.c:    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~(ACTIVE|DEAD|FLUSH));
mac_dbdma.c:    dbdma_cmd *current = &ch->current;
mac_dbdma.c:    ch->regs[DBDMA_STATUS] &= cpu_to_be32(~WAKE);
mac_dbdma.c:    cmd = le16_to_cpu(current->command) & COMMAND_MASK;
mac_dbdma.c:    key = le16_to_cpu(current->command) & 0x0700;
mac_dbdma.c:    req_count = le16_to_cpu(current->req_count);
mac_dbdma.c:    phy_addr = le32_to_cpu(current->phy_addr);
mac_dbdma.c:            uint32_t status = be32_to_cpu(ch->regs[DBDMA_STATUS]);
mac_dbdma.c:            if (!ch->processing && (status & RUN) && (status & ACTIVE))
mac_dbdma.c:    ch->irq = irq;
mac_dbdma.c:    ch->channel = nchan;
mac_dbdma.c:    ch->rw = rw;
mac_dbdma.c:    ch->flush = flush;
mac_dbdma.c:    ch->io.opaque = opaque;
mac_dbdma.c:    ch->io.channel = ch;
mac_dbdma.c:    mask = (be32_to_cpu(ch->regs[DBDMA_CONTROL]) >> 16) & 0xffff;
mac_dbdma.c:    value = be32_to_cpu(ch->regs[DBDMA_CONTROL]) & 0xffff;
mac_dbdma.c:    status = be32_to_cpu(ch->regs[DBDMA_STATUS]);
mac_dbdma.c:    if ((be32_to_cpu(ch->regs[DBDMA_STATUS]) & RUN) && !(status & RUN)) {
mac_dbdma.c:    ch->regs[DBDMA_STATUS] = cpu_to_be32(status);
mac_dbdma.c:        ch->flush(&ch->io);
mac_dbdma.c:    int reg = (addr - (channel << DBDMA_CHANNEL_SHIFT)) >> 2;
mac_dbdma.c:        (ch->regs[DBDMA_STATUS] & cpu_to_be32(RUN | ACTIVE)))
mac_dbdma.c:    ch->regs[reg] = value;
mac_dbdma.c:        /* 16-byte aligned */
mac_dbdma.c:        ch->regs[DBDMA_CMDPTR_LO] &= cpu_to_be32(~0xf);
mac_dbdma.c:    int reg = (addr - (channel << DBDMA_CHANNEL_SHIFT)) >> 2;
mac_dbdma.c:    value = ch->regs[reg];
mac_dbdma.c:        return -EINVAL;
mac_dbdma.c:    register_savevm("dbdma", -1, 1, dbdma_save, dbdma_load, s);
macio.c: * Copyright (c) 2005-2007 Fabrice Bellard
macio.c:    if (macio_state->pic_mem_index >= 0) {
macio.c:        if (macio_state->is_oldworld) {
macio.c:                                         macio_state->pic_mem_index);
macio.c:                                         macio_state->pic_mem_index);
macio.c:    if (macio_state->dbdma_mem_index >= 0) {
macio.c:                                     macio_state->dbdma_mem_index);
macio.c:    if (macio_state->escc_mem_index >= 0) {
macio.c:                                     macio_state->escc_mem_index);
macio.c:    if (macio_state->cuda_mem_index >= 0) {
macio.c:                                     macio_state->cuda_mem_index);
macio.c:    for (i = 0; i < macio_state->nb_ide; i++) {
macio.c:        if (macio_state->ide_mem_index[i] >= 0) {
macio.c:                                         macio_state->ide_mem_index[i]);
macio.c:    if (macio_state->nvram != NULL)
macio.c:        macio_nvram_map(macio_state->nvram, addr + 0x60000);
macio.c:                            -1, NULL, NULL);
macio.c:    macio_state->is_oldworld = is_oldworld;
macio.c:    macio_state->pic_mem_index = pic_mem_index;
macio.c:    macio_state->dbdma_mem_index = dbdma_mem_index;
macio.c:    macio_state->cuda_mem_index = cuda_mem_index;
macio.c:    macio_state->escc_mem_index = escc_mem_index;
macio.c:    macio_state->nvram = nvram;
macio.c:    macio_state->nb_ide = nb_ide;
macio.c:        macio_state->ide_mem_index[i] = ide_mem_index[i];
macio.c:        macio_state->ide_mem_index[i] = -1;
macio.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_APPLE);
macio.c:    pci_config_set_device_id(d->config, device_id);
macio.c:    pci_config_set_class(d->config, PCI_CLASS_OTHERS << 8);
macio.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
macio.c:    d->config[0x3d] = 0x01; // interrupt on pin 1
mac_nvram.c: * Copyright (c) 2005-2007 Fabrice Bellard
mac_nvram.c:    if (addr < s->size)
mac_nvram.c:        ret = s->data[addr];
mac_nvram.c:        ret = -1;
mac_nvram.c:    if (addr < s->size)
mac_nvram.c:        s->data[addr] = val;
mac_nvram.c:    addr = (addr >> s->it_shift) & (s->size - 1);
mac_nvram.c:    s->data[addr] = value;
mac_nvram.c:    addr = (addr >> s->it_shift) & (s->size - 1);
mac_nvram.c:    value = s->data[addr];
mac_nvram.c:    qemu_put_buffer(f, s->data, s->size);
mac_nvram.c:        return -EINVAL;
mac_nvram.c:    qemu_get_buffer(f, s->data, s->size);
mac_nvram.c:    s->data = qemu_mallocz(size);
mac_nvram.c:    s->size = size;
mac_nvram.c:    s->it_shift = it_shift;
mac_nvram.c:    s->mem_index = cpu_register_io_memory(nvram_read, nvram_write, s);
mac_nvram.c:    *mem_index = s->mem_index;
mac_nvram.c:    register_savevm("macio_nvram", -1, 1, macio_nvram_save, macio_nvram_load,
mac_nvram.c:    cpu_register_physical_memory(mem_base, s->size << s->it_shift,
mac_nvram.c:                                 s->mem_index);
mac_nvram.c:    part_header = (struct OpenBIOS_nvpart_v1 *)nvr->data;
mac_nvram.c:    part_header->signature = OPENBIOS_PART_SYSTEM;
mac_nvram.c:    pstrcpy(part_header->name, sizeof(part_header->name), "system");
mac_nvram.c:        end = OpenBIOS_set_var(nvr->data, end, prom_envs[i]);
mac_nvram.c:    nvr->data[end++] = '\0';
mac_nvram.c:    end = start + ((end - start + 15) & ~15);
mac_nvram.c:    OpenBIOS_finish_partition(part_header, end - start);
mac_nvram.c:    part_header = (struct OpenBIOS_nvpart_v1 *)&nvr->data[start];
mac_nvram.c:    part_header->signature = OPENBIOS_PART_FREE;
mac_nvram.c:    pstrcpy(part_header->name, sizeof(part_header->name), "free");
mac_nvram.c:    OpenBIOS_finish_partition(part_header, end - start);
mainstone.c: * PXA270-based Intel Mainstone platforms.
mainstone.c: * Copyright (c) 2007 by Armin Kuster <akuster@kama-aina.net> or
mainstone.c:#include "arm-misc.h"
mainstone.c:    [0 ... 0xDF] = { -1, -1 },
mainstone.c:        cpu_model = "pxa270-c5";
mainstone.c:    cpu->env->regs[15] = mainstone_binfo.loader_start;
mainstone.c:                                dinfo->bdrv, sector_len,
mainstone.c:    pxa27x_register_keypad(cpu->kp, map, 0xe0);
mainstone.c:    pxa2xx_mmci_handlers(cpu->mmc, NULL, mst_irq[MMC_IRQ]);
mainstone.c:    arm_load_kernel(cpu->env, &mainstone_binfo);
mainstone.h: * PXA270-based Intel Mainstone platforms.
mainstone.h: * Copyright (c) 2007 by Armin Kuster <akuster@kama-aina.net> or
marvell_88w8618_audio.c:    if (!(s->playback_mode & MP_AUDIO_PLAYBACK_EN)) {
marvell_88w8618_audio.c:    if (s->playback_mode & MP_AUDIO_16BIT_SAMPLE) {
marvell_88w8618_audio.c:    if (!(s->playback_mode & MP_AUDIO_MONO)) {
marvell_88w8618_audio.c:    block_size = s->threshold / 2;
marvell_88w8618_audio.c:    if (free_out - s->last_free < block_size) {
marvell_88w8618_audio.c:    cpu_physical_memory_read(s->target_buffer + s->play_pos, (void *)buf,
marvell_88w8618_audio.c:    if (s->playback_mode & MP_AUDIO_16BIT_SAMPLE) {
marvell_88w8618_audio.c:        if (s->playback_mode & MP_AUDIO_MONO) {
marvell_88w8618_audio.c:            codec_buffer = wm8750_dac_buffer(s->wm, block_size >> 1);
marvell_88w8618_audio.c:            memcpy(wm8750_dac_buffer(s->wm, block_size >> 2),
marvell_88w8618_audio.c:        if (s->playback_mode & MP_AUDIO_MONO) {
marvell_88w8618_audio.c:            codec_buffer = wm8750_dac_buffer(s->wm, block_size);
marvell_88w8618_audio.c:            codec_buffer = wm8750_dac_buffer(s->wm, block_size >> 1);
marvell_88w8618_audio.c:    wm8750_dac_commit(s->wm);
marvell_88w8618_audio.c:    s->last_free = free_out - block_size;
marvell_88w8618_audio.c:    if (s->play_pos == 0) {
marvell_88w8618_audio.c:        s->status |= MP_AUDIO_TX_HALF;
marvell_88w8618_audio.c:        s->play_pos = block_size;
marvell_88w8618_audio.c:        s->status |= MP_AUDIO_TX_FULL;
marvell_88w8618_audio.c:        s->play_pos = 0;
marvell_88w8618_audio.c:    if (s->status & s->irq_enable) {
marvell_88w8618_audio.c:        qemu_irq_raise(s->irq);
marvell_88w8618_audio.c:    if (s->playback_mode & MP_AUDIO_CLOCK_24MHZ) {
marvell_88w8618_audio.c:    rate /= ((s->clock_div >> 8) & 0xff) + 1;
marvell_88w8618_audio.c:    wm8750_set_bclk_in(s->wm, rate);
marvell_88w8618_audio.c:        return s->playback_mode;
marvell_88w8618_audio.c:        return s->clock_div;
marvell_88w8618_audio.c:        return s->status;
marvell_88w8618_audio.c:        return s->irq_enable;
marvell_88w8618_audio.c:        return s->play_pos >> 2;
marvell_88w8618_audio.c:            !(s->playback_mode & MP_AUDIO_PLAYBACK_EN)) {
marvell_88w8618_audio.c:            s->status = 0;
marvell_88w8618_audio.c:            s->last_free = 0;
marvell_88w8618_audio.c:            s->play_pos = 0;
marvell_88w8618_audio.c:        s->playback_mode = value;
marvell_88w8618_audio.c:        s->clock_div = value;
marvell_88w8618_audio.c:        s->last_free = 0;
marvell_88w8618_audio.c:        s->play_pos = 0;
marvell_88w8618_audio.c:        s->status &= ~value;
marvell_88w8618_audio.c:        s->irq_enable = value;
marvell_88w8618_audio.c:        if (s->status & s->irq_enable) {
marvell_88w8618_audio.c:            qemu_irq_raise(s->irq);
marvell_88w8618_audio.c:        s->phys_buf = (s->phys_buf & 0xFFFF0000) | (value & 0xFFFF);
marvell_88w8618_audio.c:        s->target_buffer = s->phys_buf;
marvell_88w8618_audio.c:        s->play_pos = 0;
marvell_88w8618_audio.c:        s->last_free = 0;
marvell_88w8618_audio.c:        s->threshold = (value + 1) * 4;
marvell_88w8618_audio.c:        s->phys_buf = (s->phys_buf & 0xFFFF) | (value << 16);
marvell_88w8618_audio.c:        s->target_buffer = s->phys_buf;
marvell_88w8618_audio.c:        s->play_pos = 0;
marvell_88w8618_audio.c:        s->last_free = 0;
marvell_88w8618_audio.c:    s->playback_mode = 0;
marvell_88w8618_audio.c:    s->status = 0;
marvell_88w8618_audio.c:    s->irq_enable = 0;
marvell_88w8618_audio.c:    s->clock_div = 0;
marvell_88w8618_audio.c:    s->threshold = 0;
marvell_88w8618_audio.c:    s->phys_buf = 0;
marvell_88w8618_audio.c:    sysbus_init_irq(dev, &s->irq);
marvell_88w8618_audio.c:    wm8750_data_req_set(s->wm, mv88w8618_audio_callback, s);
max111x.c:/* Control-byte bitfields */
max111x.c:    if (!s->tb1)
max111x.c:    switch (s->cycle ++) {
max111x.c:        return s->rb2;
max111x.c:        return s->rb3;
max111x.c:/* Interpret a control-byte */
max111x.c:    s->cycle = 0;
max111x.c:        s->tb1 = 0;
max111x.c:    s->tb1 = value;
max111x.c:    if (s->inputs == 8)
max111x.c:        measure = s->input[chan] - s->com;
max111x.c:        measure = s->input[chan] - s->input[chan ^ 1];
max111x.c:    s->rb2 = (measure >> 2) & 0x3f;
max111x.c:    s->rb3 = (measure << 6) & 0xc0;
max111x.c:    qemu_irq_raise(s->interrupt);
max111x.c:    qemu_put_8s(f, &s->tb1);
max111x.c:    qemu_put_8s(f, &s->rb2);
max111x.c:    qemu_put_8s(f, &s->rb3);
max111x.c:    qemu_put_be32(f, s->inputs);
max111x.c:    qemu_put_be32(f, s->com);
max111x.c:    for (i = 0; i < s->inputs; i ++)
max111x.c:        qemu_put_byte(f, s->input[i]);
max111x.c:    qemu_get_8s(f, &s->tb1);
max111x.c:    qemu_get_8s(f, &s->rb2);
max111x.c:    qemu_get_8s(f, &s->rb3);
max111x.c:    if (s->inputs != qemu_get_be32(f))
max111x.c:        return -EINVAL;
max111x.c:    s->com = qemu_get_be32(f);
max111x.c:    for (i = 0; i < s->inputs; i ++)
max111x.c:        s->input[i] = qemu_get_byte(f);
max111x.c:    qdev_init_gpio_out(&dev->qdev, &s->interrupt, 1);
max111x.c:    s->inputs = inputs;
max111x.c:    s->input[0] = 0xf0;
max111x.c:    s->input[1] = 0xe0;
max111x.c:    s->input[2] = 0xd0;
max111x.c:    s->input[3] = 0xc0;
max111x.c:    s->input[4] = 0xb0;
max111x.c:    s->input[5] = 0xa0;
max111x.c:    s->input[6] = 0x90;
max111x.c:    s->input[7] = 0x80;
max111x.c:    s->com = 0;
max111x.c:    register_savevm("max111x", -1, 0, max111x_save, max111x_load, s);
max111x.c:    assert(line >= 0 && line < s->inputs);
max111x.c:    s->input[line] = value;
max7310.c: * MAX7310 8-port GPIO expansion chip.
max7310.c:    s->level &= s->direction;
max7310.c:    s->direction = 0xff;
max7310.c:    s->polarity = 0xf0;
max7310.c:    s->status = 0x01;
max7310.c:    s->command = 0x00;
max7310.c:    switch (s->command) {
max7310.c:        return s->level ^ s->polarity;
max7310.c:        return s->level & ~s->direction;
max7310.c:        return s->polarity;
max7310.c:        return s->direction;
max7310.c:        return s->status;
max7310.c:        printf("%s: unknown register %02x\n", __FUNCTION__, s->command);
max7310.c:    if (s->len ++ > 1) {
max7310.c:        printf("%s: message too long (%i bytes)\n", __FUNCTION__, s->len);
max7310.c:    if (s->i2c_command_byte) {
max7310.c:        s->command = data;
max7310.c:        s->i2c_command_byte = 0;
max7310.c:    switch (s->command) {
max7310.c:        for (diff = (data ^ s->level) & ~s->direction; diff;
max7310.c:            line = ffs(diff) - 1;
max7310.c:            if (s->handler[line])
max7310.c:                qemu_set_irq(s->handler[line], (data >> line) & 1);
max7310.c:        s->level = (s->level & s->direction) | (data & ~s->direction);
max7310.c:        s->polarity = data;
max7310.c:        s->level &= ~(s->direction ^ data);
max7310.c:        s->direction = data;
max7310.c:        s->status = data;
max7310.c:    case 0x00:	/* Input port - ignore writes */
max7310.c:        printf("%s: unknown register %02x\n", __FUNCTION__, s->command);
max7310.c:    s->len = 0;
max7310.c:        s->i2c_command_byte = 1;
max7310.c:        if (s->len == 1)
max7310.c:            printf("%s: message too short (%i bytes)\n", __FUNCTION__, s->len);
max7310.c:    if (line >= ARRAY_SIZE(s->handler) || line  < 0)
max7310.c:        s->level |= s->direction & (1 << line);
max7310.c:        s->level &= ~(s->direction & (1 << line));
max7310.c:/* MAX7310 is SMBus-compatible (can be used with only SMBus protocols),
max7310.c:    s->gpio_in = qemu_allocate_irqs(max7310_gpio_set, s,
max7310.c:                    ARRAY_SIZE(s->handler));
max7310.c:    max7310_reset(&s->i2c);
max7310.c:    return s->gpio_in;
max7310.c:    if (line >= ARRAY_SIZE(s->handler) || line  < 0)
max7310.c:    s->handler[line] = handler;
mc146818rtc.c: * Copyright (c) 2003-2004 Fabrice Bellard
mc146818rtc.c:#include "qemu-timer.h"
mc146818rtc.c:    if (s->irq_coalesced == 0) {
mc146818rtc.c:        qemu_del_timer(s->coalesced_timer);
mc146818rtc.c:        /* divide each RTC interval to 2 - 8 smaller intervals */
mc146818rtc.c:        int c = MIN(s->irq_coalesced, 7) + 1; 
mc146818rtc.c:            muldiv64(s->period / c, get_ticks_per_sec(), 32768);
mc146818rtc.c:        qemu_mod_timer(s->coalesced_timer, next_clock);
mc146818rtc.c:    if (s->irq_coalesced != 0) {
mc146818rtc.c:        s->cmos_data[RTC_REG_C] |= 0xc0;
mc146818rtc.c:        rtc_irq_raise(s->irq);
mc146818rtc.c:            s->irq_coalesced--;
mc146818rtc.c:    period_code = s->cmos_data[RTC_REG_A] & 0x0f;
mc146818rtc.c:        && (((s->cmos_data[RTC_REG_B] & REG_B_PIE) && enable_pie)
mc146818rtc.c:            || ((s->cmos_data[RTC_REG_B] & REG_B_SQWE) && s->sqw_irq))) {
mc146818rtc.c:        period = 1 << (period_code - 1);
mc146818rtc.c:        if(period != s->period)
mc146818rtc.c:            s->irq_coalesced = (s->irq_coalesced * s->period) / period;
mc146818rtc.c:        s->period = period;
mc146818rtc.c:        next_irq_clock = (cur_clock & ~(period - 1)) + period;
mc146818rtc.c:        s->next_periodic_time =
mc146818rtc.c:        qemu_mod_timer(s->periodic_timer, s->next_periodic_time);
mc146818rtc.c:        s->irq_coalesced = 0;
mc146818rtc.c:        qemu_del_timer(s->periodic_timer);
mc146818rtc.c:    rtc_timer_update(s, s->next_periodic_time);
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & REG_B_PIE) {
mc146818rtc.c:        s->cmos_data[RTC_REG_C] |= 0xc0;
mc146818rtc.c:            if (s->irq_reinject_on_ack_count >= RTC_REINJECT_ON_ACK_COUNT)
mc146818rtc.c:                s->irq_reinject_on_ack_count = 0;		
mc146818rtc.c:            rtc_irq_raise(s->irq);
mc146818rtc.c:                s->irq_coalesced++;
mc146818rtc.c:        rtc_irq_raise(s->irq);
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & REG_B_SQWE) {
mc146818rtc.c:        qemu_irq_raise(s->sqw_irq);
mc146818rtc.c:        s->cmos_index = data & 0x7f;
mc146818rtc.c:               s->cmos_index, data);
mc146818rtc.c:        switch(s->cmos_index) {
mc146818rtc.c:            s->cmos_data[s->cmos_index] = data;
mc146818rtc.c:            s->cmos_data[s->cmos_index] = data;
mc146818rtc.c:            if (!(s->cmos_data[RTC_REG_B] & REG_B_SET)) {
mc146818rtc.c:            s->cmos_data[RTC_REG_A] = (data & ~REG_A_UIP) |
mc146818rtc.c:                (s->cmos_data[RTC_REG_A] & REG_A_UIP);
mc146818rtc.c:                s->cmos_data[RTC_REG_A] &= ~REG_A_UIP;
mc146818rtc.c:                if (s->cmos_data[RTC_REG_B] & REG_B_SET) {
mc146818rtc.c:            s->cmos_data[RTC_REG_B] = data;
mc146818rtc.c:            s->cmos_data[s->cmos_index] = data;
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & REG_B_DM) {
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & REG_B_DM) {
mc146818rtc.c:    struct tm *tm = &s->current_tm;
mc146818rtc.c:    tm->tm_sec = rtc_from_bcd(s, s->cmos_data[RTC_SECONDS]);
mc146818rtc.c:    tm->tm_min = rtc_from_bcd(s, s->cmos_data[RTC_MINUTES]);
mc146818rtc.c:    tm->tm_hour = rtc_from_bcd(s, s->cmos_data[RTC_HOURS] & 0x7f);
mc146818rtc.c:    if (!(s->cmos_data[RTC_REG_B] & 0x02) &&
mc146818rtc.c:        (s->cmos_data[RTC_HOURS] & 0x80)) {
mc146818rtc.c:        tm->tm_hour += 12;
mc146818rtc.c:    tm->tm_wday = rtc_from_bcd(s, s->cmos_data[RTC_DAY_OF_WEEK]) - 1;
mc146818rtc.c:    tm->tm_mday = rtc_from_bcd(s, s->cmos_data[RTC_DAY_OF_MONTH]);
mc146818rtc.c:    tm->tm_mon = rtc_from_bcd(s, s->cmos_data[RTC_MONTH]) - 1;
mc146818rtc.c:    tm->tm_year = rtc_from_bcd(s, s->cmos_data[RTC_YEAR]) + s->base_year - 1900;
mc146818rtc.c:    const struct tm *tm = &s->current_tm;
mc146818rtc.c:    s->cmos_data[RTC_SECONDS] = rtc_to_bcd(s, tm->tm_sec);
mc146818rtc.c:    s->cmos_data[RTC_MINUTES] = rtc_to_bcd(s, tm->tm_min);
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & 0x02) {
mc146818rtc.c:        s->cmos_data[RTC_HOURS] = rtc_to_bcd(s, tm->tm_hour);
mc146818rtc.c:        s->cmos_data[RTC_HOURS] = rtc_to_bcd(s, tm->tm_hour % 12);
mc146818rtc.c:        if (tm->tm_hour >= 12)
mc146818rtc.c:            s->cmos_data[RTC_HOURS] |= 0x80;
mc146818rtc.c:    s->cmos_data[RTC_DAY_OF_WEEK] = rtc_to_bcd(s, tm->tm_wday + 1);
mc146818rtc.c:    s->cmos_data[RTC_DAY_OF_MONTH] = rtc_to_bcd(s, tm->tm_mday);
mc146818rtc.c:    s->cmos_data[RTC_MONTH] = rtc_to_bcd(s, tm->tm_mon + 1);
mc146818rtc.c:    year = (tm->tm_year - s->base_year) % 100;
mc146818rtc.c:    s->cmos_data[RTC_YEAR] = rtc_to_bcd(s, year);
mc146818rtc.c:    tm->tm_sec++;
mc146818rtc.c:    if ((unsigned)tm->tm_sec >= 60) {
mc146818rtc.c:        tm->tm_sec = 0;
mc146818rtc.c:        tm->tm_min++;
mc146818rtc.c:        if ((unsigned)tm->tm_min >= 60) {
mc146818rtc.c:            tm->tm_min = 0;
mc146818rtc.c:            tm->tm_hour++;
mc146818rtc.c:            if ((unsigned)tm->tm_hour >= 24) {
mc146818rtc.c:                tm->tm_hour = 0;
mc146818rtc.c:                tm->tm_wday++;
mc146818rtc.c:                if ((unsigned)tm->tm_wday >= 7)
mc146818rtc.c:                    tm->tm_wday = 0;
mc146818rtc.c:                days_in_month = get_days_in_month(tm->tm_mon,
mc146818rtc.c:                                                  tm->tm_year + 1900);
mc146818rtc.c:                tm->tm_mday++;
mc146818rtc.c:                if (tm->tm_mday < 1) {
mc146818rtc.c:                    tm->tm_mday = 1;
mc146818rtc.c:                } else if (tm->tm_mday > days_in_month) {
mc146818rtc.c:                    tm->tm_mday = 1;
mc146818rtc.c:                    tm->tm_mon++;
mc146818rtc.c:                    if (tm->tm_mon >= 12) {
mc146818rtc.c:                        tm->tm_mon = 0;
mc146818rtc.c:                        tm->tm_year++;
mc146818rtc.c:    if ((s->cmos_data[RTC_REG_A] & 0x70) != 0x20) {
mc146818rtc.c:        s->next_second_time += get_ticks_per_sec();
mc146818rtc.c:        qemu_mod_timer(s->second_timer, s->next_second_time);
mc146818rtc.c:        rtc_next_second(&s->current_tm);
mc146818rtc.c:        if (!(s->cmos_data[RTC_REG_B] & REG_B_SET)) {
mc146818rtc.c:            s->cmos_data[RTC_REG_A] |= REG_A_UIP;
mc146818rtc.c:        qemu_mod_timer(s->second_timer2,
mc146818rtc.c:                       s->next_second_time + delay);
mc146818rtc.c:    if (!(s->cmos_data[RTC_REG_B] & REG_B_SET)) {
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & REG_B_AIE) {
mc146818rtc.c:        if (((s->cmos_data[RTC_SECONDS_ALARM] & 0xc0) == 0xc0 ||
mc146818rtc.c:             s->cmos_data[RTC_SECONDS_ALARM] == s->current_tm.tm_sec) &&
mc146818rtc.c:            ((s->cmos_data[RTC_MINUTES_ALARM] & 0xc0) == 0xc0 ||
mc146818rtc.c:             s->cmos_data[RTC_MINUTES_ALARM] == s->current_tm.tm_mon) &&
mc146818rtc.c:            ((s->cmos_data[RTC_HOURS_ALARM] & 0xc0) == 0xc0 ||
mc146818rtc.c:             s->cmos_data[RTC_HOURS_ALARM] == s->current_tm.tm_hour)) {
mc146818rtc.c:            s->cmos_data[RTC_REG_C] |= 0xa0;
mc146818rtc.c:            rtc_irq_raise(s->irq);
mc146818rtc.c:    s->cmos_data[RTC_REG_C] |= REG_C_UF;
mc146818rtc.c:    if (s->cmos_data[RTC_REG_B] & REG_B_UIE) {
mc146818rtc.c:      s->cmos_data[RTC_REG_C] |= REG_C_IRQF;
mc146818rtc.c:      rtc_irq_raise(s->irq);
mc146818rtc.c:    s->cmos_data[RTC_REG_A] &= ~REG_A_UIP;
mc146818rtc.c:    s->next_second_time += get_ticks_per_sec();
mc146818rtc.c:    qemu_mod_timer(s->second_timer, s->next_second_time);
mc146818rtc.c:        switch(s->cmos_index) {
mc146818rtc.c:            ret = s->cmos_data[s->cmos_index];
mc146818rtc.c:            ret = s->cmos_data[s->cmos_index];
mc146818rtc.c:            ret = s->cmos_data[s->cmos_index];
mc146818rtc.c:            qemu_irq_lower(s->irq);
mc146818rtc.c:            if(s->irq_coalesced &&
mc146818rtc.c:                    s->irq_reinject_on_ack_count < RTC_REINJECT_ON_ACK_COUNT) {
mc146818rtc.c:                s->irq_reinject_on_ack_count++;
mc146818rtc.c:                qemu_irq_raise(s->irq);
mc146818rtc.c:                    s->irq_coalesced--;
mc146818rtc.c:            s->cmos_data[RTC_REG_C] = 0x00;
mc146818rtc.c:            ret = s->cmos_data[s->cmos_index];
mc146818rtc.c:               s->cmos_index, ret);
mc146818rtc.c:        s->cmos_data[addr] = val;
mc146818rtc.c:    s->current_tm = *tm;
mc146818rtc.c:    s->cmos_data[RTC_REG_B] &= ~(REG_B_PIE | REG_B_AIE | REG_B_SQWE);
mc146818rtc.c:    s->cmos_data[RTC_REG_C] &= ~(REG_C_UF | REG_C_IRQF | REG_C_PF | REG_C_AF);
mc146818rtc.c:    qemu_irq_lower(s->irq);
mc146818rtc.c:	    s->irq_coalesced = 0;
mc146818rtc.c:    isa_init_irq(dev, &s->irq, isairq);
mc146818rtc.c:    s->cmos_data[RTC_REG_A] = 0x26;
mc146818rtc.c:    s->cmos_data[RTC_REG_B] = 0x02;
mc146818rtc.c:    s->cmos_data[RTC_REG_C] = 0x00;
mc146818rtc.c:    s->cmos_data[RTC_REG_D] = 0x80;
mc146818rtc.c:    s->periodic_timer = qemu_new_timer(rtc_clock, rtc_periodic_timer, s);
mc146818rtc.c:        s->coalesced_timer =
mc146818rtc.c:    s->second_timer = qemu_new_timer(rtc_clock, rtc_update_second, s);
mc146818rtc.c:    s->second_timer2 = qemu_new_timer(rtc_clock, rtc_update_second2, s);
mc146818rtc.c:    s->next_second_time =
mc146818rtc.c:    qemu_mod_timer(s->second_timer2, s->next_second_time);
mc146818rtc.c:    qdev_prop_set_int32(&dev->qdev, "base_year", base_year);
mc146818rtc.c:    qdev_init_nofail(&dev->qdev);
mcf5206.c:#include "qemu-timer.h"
mcf5206.c:    if ((s->tmr & TMR_ORI) != 0 && (s->ter & TER_REF))
mcf5206.c:        qemu_irq_raise(s->irq);
mcf5206.c:        qemu_irq_lower(s->irq);
mcf5206.c:    s->tmr = 0;
mcf5206.c:    s->trr = 0;
mcf5206.c:    ptimer_stop(s->timer);
mcf5206.c:    if ((s->tmr & TMR_RST) == 0)
mcf5206.c:    prescale = (s->tmr >> 8) + 1;
mcf5206.c:    mode = (s->tmr >> 1) & 3;
mcf5206.c:    if ((s->tmr & TMR_FRR) == 0)
mcf5206.c:    ptimer_set_freq(s->timer, 66000000 / prescale);
mcf5206.c:    ptimer_set_limit(s->timer, s->trr, 0);
mcf5206.c:    ptimer_run(s->timer, 0);
mcf5206.c:    s->ter |= TER_REF;
mcf5206.c:        return s->tmr;
mcf5206.c:        return s->trr;
mcf5206.c:        return s->tcr;
mcf5206.c:        return s->trr - ptimer_get_count(s->timer);
mcf5206.c:        return s->ter;
mcf5206.c:        if ((s->tmr & TMR_RST) != 0 && (val & TMR_RST) == 0) {
mcf5206.c:        s->tmr = val;
mcf5206.c:        s->trr = val;
mcf5206.c:        s->tcr = val;
mcf5206.c:        ptimer_set_count(s->timer, val);
mcf5206.c:        s->ter &= ~val;
mcf5206.c:    s->timer = ptimer_init(bh);
mcf5206.c:    s->irq = irq;
mcf5206.c:    active = s->ipr & ~s->imr;
mcf5206.c:            if ((s->icr[i] & 0x1f) > level) {
mcf5206.c:                level = s->icr[i] & 0x1f;
mcf5206.c:        tmp = s->icr[irq];
mcf5206.c:                vector = s->swivr;
mcf5206.c:                vector = s->uivr[0];
mcf5206.c:                vector = s->uivr[1];
mcf5206.c:    m68k_set_irq_level(s->env, level, vector);
mcf5206.c:        s->ipr |= 1 << irq;
mcf5206.c:        s->ipr &= ~(1 << irq);
mcf5206.c:    s->scr = 0xc0;
mcf5206.c:    s->icr[1] = 0x04;
mcf5206.c:    s->icr[2] = 0x08;
mcf5206.c:    s->icr[3] = 0x0c;
mcf5206.c:    s->icr[4] = 0x10;
mcf5206.c:    s->icr[5] = 0x14;
mcf5206.c:    s->icr[6] = 0x18;
mcf5206.c:    s->icr[7] = 0x1c;
mcf5206.c:    s->icr[8] = 0x1c;
mcf5206.c:    s->icr[9] = 0x80;
mcf5206.c:    s->icr[10] = 0x80;
mcf5206.c:    s->icr[11] = 0x80;
mcf5206.c:    s->icr[12] = 0x00;
mcf5206.c:    s->icr[13] = 0x00;
mcf5206.c:    s->imr = 0x3ffe;
mcf5206.c:    s->rsr = 0x80;
mcf5206.c:    s->swivr = 0x0f;
mcf5206.c:    s->par = 0;
mcf5206.c:        return m5206_timer_read(s->timer[0], offset - 0x100);
mcf5206.c:        return m5206_timer_read(s->timer[1], offset - 0x120);
mcf5206.c:        return mcf_uart_read(s->uart[0], offset - 0x140);
mcf5206.c:        return mcf_uart_read(s->uart[1], offset - 0x180);
mcf5206.c:    case 0x03: return s->scr;
mcf5206.c:    case 0x14 ... 0x20: return s->icr[offset - 0x13];
mcf5206.c:    case 0x36: return s->imr;
mcf5206.c:    case 0x3a: return s->ipr;
mcf5206.c:    case 0x40: return s->rsr;
mcf5206.c:    case 0x42: return s->swivr;
mcf5206.c:    case 0xcb: return s->par;
mcf5206.c:    case 0x170: return s->uivr[0];
mcf5206.c:    case 0x1b0: return s->uivr[1];
mcf5206.c:        m5206_timer_write(s->timer[0], offset - 0x100, value);
mcf5206.c:        m5206_timer_write(s->timer[1], offset - 0x120, value);
mcf5206.c:        mcf_uart_write(s->uart[0], offset - 0x140, value);
mcf5206.c:        mcf_uart_write(s->uart[1], offset - 0x180, value);
mcf5206.c:        s->scr = value;
mcf5206.c:        s->icr[offset - 0x13] = value;
mcf5206.c:        s->imr = value;
mcf5206.c:        s->rsr &= ~value;
mcf5206.c:        s->swivr = value;
mcf5206.c:        s->par = value;
mcf5206.c:        s->uivr[0] = value;
mcf5206.c:        s->uivr[1] = value;
mcf5206.c:  /* 000-040 */ 1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  2, 2, 2, 2,
mcf5206.c:  /* 040-080 */ 1, 2, 2, 2,  4, 1, 2, 4,  1, 2, 4, 2,  2, 4, 2, 2,
mcf5206.c:  /* 080-0c0 */ 4, 2, 2, 4,  2, 2, 4, 2,  2, 4, 2, 2,  4, 2, 2, 4,
mcf5206.c:  /* 0c0-100 */ 2, 2, 1, 0,  0, 0, 0, 0,  0, 0, 0, 0,  0, 0, 0, 0,
mcf5206.c:  /* 100-140 */ 2, 2, 2, 2,  1, 0, 0, 0,  2, 2, 2, 2,  1, 0, 0, 0,
mcf5206.c:  /* 140-180 */ 1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
mcf5206.c:  /* 180-1c0 */ 1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
mcf5206.c:  /* 1c0-200 */ 1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,
mcf5206.c:    s->timer[0] = m5206_timer_init(pic[9]);
mcf5206.c:    s->timer[1] = m5206_timer_init(pic[10]);
mcf5206.c:    s->uart[0] = mcf_uart_init(pic[12], serial_hds[0]);
mcf5206.c:    s->uart[1] = mcf_uart_init(pic[13], serial_hds[1]);
mcf5206.c:    s->env = env;
mcf5208.c:#include "qemu-timer.h"
mcf5208.c:    if ((s->pcsr & (PCSR_PIE | PCSR_PIF)) == (PCSR_PIE | PCSR_PIF))
mcf5208.c:        qemu_irq_raise(s->irq);
mcf5208.c:        qemu_irq_lower(s->irq);
mcf5208.c:        /* The PIF bit is set-to-clear.  */
mcf5208.c:            s->pcsr &= ~PCSR_PIF;
mcf5208.c:        if (((s->pcsr ^ value) & ~PCSR_PIE) == 0) {
mcf5208.c:            s->pcsr = value;
mcf5208.c:        if (s->pcsr & PCSR_EN)
mcf5208.c:            ptimer_stop(s->timer);
mcf5208.c:        s->pcsr = value;
mcf5208.c:        prescale = 1 << ((s->pcsr & PCSR_PRE_MASK) >> PCSR_PRE_SHIFT);
mcf5208.c:        ptimer_set_freq(s->timer, (SYS_FREQ / 2) / prescale);
mcf5208.c:        if (s->pcsr & PCSR_RLD)
mcf5208.c:            limit = s->pmr;
mcf5208.c:        ptimer_set_limit(s->timer, limit, 0);
mcf5208.c:        if (s->pcsr & PCSR_EN)
mcf5208.c:            ptimer_run(s->timer, 0);
mcf5208.c:        s->pmr = value;
mcf5208.c:        s->pcsr &= ~PCSR_PIF;
mcf5208.c:        if ((s->pcsr & PCSR_RLD) == 0) {
mcf5208.c:            if (s->pcsr & PCSR_OVW)
mcf5208.c:                ptimer_set_count(s->timer, value);
mcf5208.c:            ptimer_set_limit(s->timer, value, s->pcsr & PCSR_OVW);
mcf5208.c:    s->pcsr |= PCSR_PIF;
mcf5208.c:        return s->pcsr;
mcf5208.c:        return s->pmr;
mcf5208.c:        return ptimer_get_count(s->timer);
mcf5208.c:            return (n - 1)  | 0x40000000;
mcf5208.c:        s->timer = ptimer_init(bh);
mcf5208.c:        s->irq = pic[4 + i];
mcf5208.c:    env->vbr = 0;
mcf5208.c:    env->pc = entry;
mcf_fec.c:    be16_to_cpus(&bd->flags);
mcf_fec.c:    be16_to_cpus(&bd->length);
mcf_fec.c:    be32_to_cpus(&bd->data);
mcf_fec.c:    tmp.flags = cpu_to_be16(bd->flags);
mcf_fec.c:    tmp.length = cpu_to_be16(bd->length);
mcf_fec.c:    tmp.data = cpu_to_be32(bd->data);
mcf_fec.c:    active = s->eir & s->eimr;
mcf_fec.c:    changed = active ^s->irq_state;
mcf_fec.c:            qemu_set_irq(s->irq[i], (active & mask) != 0);
mcf_fec.c:    s->irq_state = active;
mcf_fec.c:    addr = s->tx_descriptor;
mcf_fec.c:            len = FEC_MAX_FRAME_SIZE - frame_size;
mcf_fec.c:            s->eir |= FEC_INT_BABT;
mcf_fec.c:            qemu_send_packet(&s->nic->nc, frame, len);
mcf_fec.c:            s->eir |= FEC_INT_TXF;
mcf_fec.c:        s->eir |= FEC_INT_TXB;
mcf_fec.c:            addr = s->etdsr;
mcf_fec.c:    s->tx_descriptor = addr;
mcf_fec.c:    mcf_fec_read_bd(&bd, s->rx_descriptor);
mcf_fec.c:    s->rx_enabled = ((bd.flags & FEC_BD_E) != 0);
mcf_fec.c:    if (!s->rx_enabled)
mcf_fec.c:    s->eir = 0;
mcf_fec.c:    s->eimr = 0;
mcf_fec.c:    s->rx_enabled = 0;
mcf_fec.c:    s->ecr = 0;
mcf_fec.c:    s->mscr = 0;
mcf_fec.c:    s->rcr = 0x05ee0001;
mcf_fec.c:    s->tcr = 0;
mcf_fec.c:    s->tfwr = 0;
mcf_fec.c:    s->rfsr = 0x500;
mcf_fec.c:    case 0x004: return s->eir;
mcf_fec.c:    case 0x008: return s->eimr;
mcf_fec.c:    case 0x010: return s->rx_enabled ? (1 << 24) : 0; /* RDAR */
mcf_fec.c:    case 0x024: return s->ecr;
mcf_fec.c:    case 0x040: return s->mmfr;
mcf_fec.c:    case 0x044: return s->mscr;
mcf_fec.c:    case 0x084: return s->rcr;
mcf_fec.c:    case 0x0c4: return s->tcr;
mcf_fec.c:        return (s->conf.macaddr.a[0] << 24) | (s->conf.macaddr.a[1] << 16)
mcf_fec.c:              | (s->conf.macaddr.a[2] << 8) | s->conf.macaddr.a[3];
mcf_fec.c:        return (s->conf.macaddr.a[4] << 24) | (s->conf.macaddr.a[5] << 16) | 0x8808;
mcf_fec.c:    case 0x144: return s->tfwr;
mcf_fec.c:    case 0x150: return s->rfsr;
mcf_fec.c:    case 0x180: return s->erdsr;
mcf_fec.c:    case 0x184: return s->etdsr;
mcf_fec.c:    case 0x188: return s->emrbr;
mcf_fec.c:        s->eir &= ~value;
mcf_fec.c:        s->eimr = value;
mcf_fec.c:        if ((s->ecr & FEC_EN) && !s->rx_enabled) {
mcf_fec.c:        if (s->ecr & FEC_EN) {
mcf_fec.c:        s->ecr = value;
mcf_fec.c:        if ((s->ecr & FEC_EN) == 0) {
mcf_fec.c:            s->rx_enabled = 0;
mcf_fec.c:        s->mmfr = value;
mcf_fec.c:        s->mscr = value & 0xfe;
mcf_fec.c:        s->rcr = value & 0x07ff003f;
mcf_fec.c:        s->tcr = value;
mcf_fec.c:            s->eir |= FEC_INT_GRA;
mcf_fec.c:        s->conf.macaddr.a[0] = value >> 24;
mcf_fec.c:        s->conf.macaddr.a[1] = value >> 16;
mcf_fec.c:        s->conf.macaddr.a[2] = value >> 8;
mcf_fec.c:        s->conf.macaddr.a[3] = value;
mcf_fec.c:        s->conf.macaddr.a[4] = value >> 24;
mcf_fec.c:        s->conf.macaddr.a[5] = value >> 16;
mcf_fec.c:        s->tfwr = value & 3;
mcf_fec.c:        s->rfsr = (value & 0x3fc) | 0x400;
mcf_fec.c:        s->erdsr = value & ~3;
mcf_fec.c:        s->rx_descriptor = s->erdsr;
mcf_fec.c:        s->etdsr = value & ~3;
mcf_fec.c:        s->tx_descriptor = s->etdsr;
mcf_fec.c:        s->emrbr = value & 0x7f0;
mcf_fec.c:    mcf_fec_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
mcf_fec.c:    return s->rx_enabled;
mcf_fec.c:    mcf_fec_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
mcf_fec.c:    if (!s->rx_enabled) {
mcf_fec.c:    if (size > (s->rcr >> 16)) {
mcf_fec.c:    addr = s->rx_descriptor;
mcf_fec.c:        buf_len = (size <= s->emrbr) ? size: s->emrbr;
mcf_fec.c:        size -= buf_len;
mcf_fec.c:            buf_len += size - 4;
mcf_fec.c:            cpu_physical_memory_write(buf_addr + buf_len, crc_ptr, 4 - size);
mcf_fec.c:            crc_ptr += 4 - size;
mcf_fec.c:            s->eir |= FEC_INT_RXF;
mcf_fec.c:            s->eir |= FEC_INT_RXB;
mcf_fec.c:            addr = s->erdsr;
mcf_fec.c:    s->rx_descriptor = addr;
mcf_fec.c:    mcf_fec_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
mcf_fec.c:    cpu_unregister_io_memory(s->mmio_index);
mcf_fec.c:    s->irq = irq;
mcf_fec.c:    s->mmio_index = cpu_register_io_memory(mcf_fec_readfn,
mcf_fec.c:    cpu_register_physical_memory(base, 0x400, s->mmio_index);
mcf_fec.c:    memcpy(s->conf.macaddr.a, nd->macaddr, sizeof(nd->macaddr));
mcf_fec.c:    s->conf.vlan = nd->vlan;
mcf_fec.c:    s->conf.peer = nd->netdev;
mcf_fec.c:    s->nic = qemu_new_nic(&net_mcf_fec_info, &s->conf, nd->model, nd->name, s);
mcf_fec.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
mcf_intc.c:    active = (s->ipr | s->ifr) & s->enabled & ~s->imr;
mcf_intc.c:            if ((active & 1) != 0 && s->icr[i] >= best_level) {
mcf_intc.c:                best_level = s->icr[i];
mcf_intc.c:    s->active_vector = ((best == 64) ? 24 : (best + 64));
mcf_intc.c:    m68k_set_irq_level(s->env, best_level, s->active_vector);
mcf_intc.c:        return s->icr[offset - 0x40];
mcf_intc.c:        return (uint32_t)(s->ipr >> 32);
mcf_intc.c:        return (uint32_t)s->ipr;
mcf_intc.c:        return (uint32_t)(s->imr >> 32);
mcf_intc.c:        return (uint32_t)s->imr;
mcf_intc.c:        return (uint32_t)(s->ifr >> 32);
mcf_intc.c:        return (uint32_t)s->ifr;
mcf_intc.c:        return s->active_vector;
mcf_intc.c:        int n = offset - 0x40;
mcf_intc.c:        s->icr[n] = val;
mcf_intc.c:            s->enabled &= ~(1ull << n);
mcf_intc.c:            s->enabled |= (1ull << n);
mcf_intc.c:        s->imr = (s->imr & 0xffffffff) | ((uint64_t)val << 32);
mcf_intc.c:        s->imr = (s->imr & 0xffffffff00000000ull) | (uint32_t)val;
mcf_intc.c:        s->ipr |= 1ull << irq;
mcf_intc.c:        s->ipr &= ~(1ull << irq);
mcf_intc.c:    s->imr = ~0ull;
mcf_intc.c:    s->ipr = 0;
mcf_intc.c:    s->ifr = 0;
mcf_intc.c:    s->enabled = 0;
mcf_intc.c:    memset(s->icr, 0, 64);
mcf_intc.c:    s->active_vector = 24;
mcf_intc.c:    s->env = env;
mcf_uart.c:#include "qemu-char.h"
mcf_uart.c:    s->isr &= ~(MCF_UART_TxINT | MCF_UART_RxINT);
mcf_uart.c:    if (s->sr & MCF_UART_TxRDY)
mcf_uart.c:        s->isr |= MCF_UART_TxINT;
mcf_uart.c:    if ((s->sr & ((s->mr[0] & MCF_UART_RxIRQ)
mcf_uart.c:        s->isr |= MCF_UART_RxINT;
mcf_uart.c:    qemu_set_irq(s->irq, (s->isr & s->imr) != 0);
mcf_uart.c:        return s->mr[s->current_mr];
mcf_uart.c:        return s->sr;
mcf_uart.c:            if (s->fifo_len == 0)
mcf_uart.c:            val = s->fifo[0];
mcf_uart.c:            s->fifo_len--;
mcf_uart.c:            for (i = 0; i < s->fifo_len; i++)
mcf_uart.c:                s->fifo[i] = s->fifo[i + 1];
mcf_uart.c:            s->sr &= ~MCF_UART_FFULL;
mcf_uart.c:            if (s->fifo_len == 0)
mcf_uart.c:                s->sr &= ~MCF_UART_RxRDY;
mcf_uart.c:            qemu_chr_accept_input(s->chr);
mcf_uart.c:        return s->isr;
mcf_uart.c:        return s->bg1;
mcf_uart.c:        return s->bg2;
mcf_uart.c:    if (s->tx_enabled && (s->sr & MCF_UART_TxEMP) == 0) {
mcf_uart.c:        if (s->chr)
mcf_uart.c:            qemu_chr_write(s->chr, (unsigned char *)&s->tb, 1);
mcf_uart.c:        s->sr |= MCF_UART_TxEMP;
mcf_uart.c:    if (s->tx_enabled) {
mcf_uart.c:        s->sr |= MCF_UART_TxRDY;
mcf_uart.c:        s->sr &= ~MCF_UART_TxRDY;
mcf_uart.c:    case 0: /* No-op.  */
mcf_uart.c:        s->current_mr = 0;
mcf_uart.c:        s->rx_enabled = 0;
mcf_uart.c:        s->fifo_len = 0;
mcf_uart.c:        s->sr &= ~(MCF_UART_RxRDY | MCF_UART_FFULL);
mcf_uart.c:        s->tx_enabled = 0;
mcf_uart.c:        s->sr |= MCF_UART_TxEMP;
mcf_uart.c:        s->sr &= ~MCF_UART_TxRDY;
mcf_uart.c:    case 5: /* Reset break-change interrupt.  */
mcf_uart.c:        s->isr &= ~MCF_UART_DBINT;
mcf_uart.c:    case 0: /* No-op.  */
mcf_uart.c:        s->tx_enabled = 1;
mcf_uart.c:        s->tx_enabled = 0;
mcf_uart.c:    case 0: /* No-op.  */
mcf_uart.c:        s->rx_enabled = 1;
mcf_uart.c:        s->rx_enabled = 0;
mcf_uart.c:        s->mr[s->current_mr] = val;
mcf_uart.c:        s->current_mr = 1;
mcf_uart.c:        s->sr &= ~MCF_UART_TxEMP;
mcf_uart.c:        s->tb = val;
mcf_uart.c:        s->imr = val;
mcf_uart.c:    s->fifo_len = 0;
mcf_uart.c:    s->mr[0] = 0;
mcf_uart.c:    s->mr[1] = 0;
mcf_uart.c:    s->sr = MCF_UART_TxEMP;
mcf_uart.c:    s->tx_enabled = 0;
mcf_uart.c:    s->rx_enabled = 0;
mcf_uart.c:    s->isr = 0;
mcf_uart.c:    s->imr = 0;
mcf_uart.c:    if (s->fifo_len == 4)
mcf_uart.c:        s->fifo_len--;
mcf_uart.c:    s->fifo[s->fifo_len] = data;
mcf_uart.c:    s->fifo_len++;
mcf_uart.c:    s->sr |= MCF_UART_RxRDY;
mcf_uart.c:    if (s->fifo_len == 4)
mcf_uart.c:        s->sr |= MCF_UART_FFULL;
mcf_uart.c:        s->isr |= MCF_UART_DBINT;
mcf_uart.c:    return s->rx_enabled && (s->sr & MCF_UART_FFULL) == 0;
mcf_uart.c:    s->chr = chr;
mcf_uart.c:    s->irq = irq;
mips_int.c:    if ((env->CP0_Status & (1 << CP0St_IE)) &&
mips_int.c:        !(env->CP0_Status & (1 << CP0St_EXL)) &&
mips_int.c:        !(env->CP0_Status & (1 << CP0St_ERL)) &&
mips_int.c:        !(env->hflags & MIPS_HFLAG_DM)) {
mips_int.c:        if ((env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&
mips_int.c:            !(env->interrupt_request & CPU_INTERRUPT_HARD)) {
mips_int.c:        env->CP0_Cause |= 1 << (irq + CP0Ca_IP);
mips_int.c:        env->CP0_Cause &= ~(1 << (irq + CP0Ca_IP));
mips_int.c:        env->irq[i] = qi[i];
mips_jazz.c: * Copyright (c) 2007-2008 Herv Poussineau
mips_jazz.c:#include "mips-bios.h"
mips_jazz.c:    for (c = soundhw; !audio_enabled && c->name; ++c) {
mips_jazz.c:        audio_enabled = c->enabled;
mips_jazz.c:        for (c = soundhw; c->name; ++c) {
mips_jazz.c:            if (c->enabled) {
mips_jazz.c:                if (c->isa) {
mips_jazz.c:                    c->init.init_isa(pic);
mips_jazz.c:        bios_size = -1;
mips_jazz.c:    rc4030_opaque = rc4030_init(env->irq[6], env->irq[3], &rc4030, &dmas);
mips_jazz.c:    i8259 = i8259_init(env->irq[4]);
mips_jazz.c:        if (!nd->model)
mips_jazz.c:            nd->model = qemu_strdup("dp83932");
mips_jazz.c:        if (strcmp(nd->model, "dp83932") == 0) {
mips_jazz.c:        } else if (strcmp(nd->model, "?") == 0) {
mips_jazz.c:            fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd->model);
mips_malta.c:#include "usb-uhci.h"
mips_malta.c:#include "qemu-char.h"
mips_malta.c:#include "qemu-log.h"
mips_malta.c:#include "mips-bios.h"
mips_malta.c:#define VIRT_TO_PHYS_ADDEND (-((int64_t)(int32_t)0x80000000))
mips_malta.c:    for (i = 7 ; i >= 0 ; i--) {
mips_malta.c:        if (s->leds & (1 << i))
mips_malta.c:    qemu_chr_printf(s->display, "\e[H\n\n|\e[32m%-8.8s\e[00m|\r\n", leds_text);
mips_malta.c:    qemu_chr_printf(s->display, "\n\n\n\n|\e[31m%-8.8s\e[00m|", s->display_text);
mips_malta.c: * 24C01 - 1024 bit (128 x 8)
mips_malta.c: * 24C02 - 2048 bit (256 x 8)
mips_malta.c:#  define logout(fmt, ...) fprintf(stderr, "MALTA\t%-24s" fmt, __func__, ## __VA_ARGS__)
mips_malta.c:        logout("%u: scl = %u->%u, sda = %u->%u i2c %s\n",
mips_malta.c:        logout("%u: scl = %u->%u, sda = %u->%u wait for i2c start\n",
mips_malta.c:        logout("%u: scl = %u->%u, sda = %u->%u trigger bit\n",
mips_malta.c:        logout("%u: scl = %u->%u, sda = %u->%u\n", eeprom.tick, eeprom.scl, scl, eeprom.sda, sda);
mips_malta.c:        val = s->leds;
mips_malta.c:        val = s->brk;
mips_malta.c:        val = s->gpout;
mips_malta.c:        if (s->i2csel)
mips_malta.c:            val = s->i2cout;
mips_malta.c:        val = ((s->i2cin & ~1) | eeprom24c0x_read());
mips_malta.c:        val = s->i2coe;
mips_malta.c:        val = s->i2cout;
mips_malta.c:        val = s->i2csel;
mips_malta.c:    /* XXX: implement a 8-LED array */
mips_malta.c:        s->leds = val & 0xff;
mips_malta.c:        snprintf(s->display_text, 9, "%08X", val);
mips_malta.c:        s->display_text[(saddr - 0x00418) >> 3] = (char) val;
mips_malta.c:        s->brk = val & 0xff;
mips_malta.c:        s->gpout = val & 0xff;
mips_malta.c:        s->i2coe = val & 0x03;
mips_malta.c:        s->i2cout = val;
mips_malta.c:        s->i2csel = val & 0x01;
mips_malta.c:    s->leds   = 0x00;
mips_malta.c:    s->brk    = 0x0a;
mips_malta.c:    s->gpout  = 0x00;
mips_malta.c:    s->i2cin  = 0x3;
mips_malta.c:    s->i2coe  = 0x0;
mips_malta.c:    s->i2cout = 0x3;
mips_malta.c:    s->i2csel = 0x1;
mips_malta.c:    s->display_text[8] = '\0';
mips_malta.c:    snprintf(s->display_text, 9, "        ");
mips_malta.c:    qemu_chr_printf(chr, "+--------+\r\n");
mips_malta.c:    qemu_chr_printf(chr, "+--------+\r\n");
mips_malta.c:    qemu_chr_printf(chr, "+--------+\r\n");
mips_malta.c:    qemu_chr_printf(chr, "+--------+\r\n");
mips_malta.c:    cpu_register_physical_memory(base + 0xa00, 0x100000 - 0xa00, malta);
mips_malta.c:    s->display = qemu_chr_open("fpga", "vc:320x200", malta_fpga_led_init);
mips_malta.c:    s->uart = serial_mm_init(base + 0x900, 3, uart_irq, 230400, uart_chr, 1);
mips_malta.c:    for (c = soundhw; !audio_enabled && c->name; ++c) {
mips_malta.c:        audio_enabled = c->enabled;
mips_malta.c:        for (c = soundhw; c->name; ++c) {
mips_malta.c:            if (c->enabled) {
mips_malta.c:                c->init.init_pci(pci_bus);
mips_malta.c:        if (i == 0 && (!nd->model || strcmp(nd->model, "pcnet") == 0))
mips_malta.c:   environment variables tables. Those tables contain the 32-bit address
mips_malta.c:     a0 - number of kernel arguments
mips_malta.c:     a1 - 32-bit address of the kernel arguments table
mips_malta.c:     a2 - 32-bit address of the environment variables table
mips_malta.c:     a3 - RAM size in bytes
mips_malta.c:    stl_raw(p++, 0x3c1d0000 | (((ENVP_ADDR - 64) >> 16) & 0xffff)); /* lui sp, high(ENVP_ADDR) */
mips_malta.c:    stl_raw(p++, 0x37bd0000 | ((ENVP_ADDR - 64) & 0xffff));        /* ori sp, sp, low(ENVP_ADDR) */
mips_malta.c:    stl_raw(p++, 0x258cffff);                                     /* addiu t4,t4,-1 */
mips_malta.c:                                              ram_size - initrd_offset);
mips_malta.c:        if (initrd_size == (target_ulong) -1) {
mips_malta.c:        env->CP0_Status &= ~((1 << CP0St_BEV) | (1 << CP0St_ERL));
mips_malta.c:    malta_fpga = malta_fpga_init(0x1f000000LL, env->irq[2], serial_hds[2]);
mips_malta.c:                   bdrv_get_device_name(dinfo->bdrv), fl_sectors);
mips_malta.c:                                  dinfo->bdrv, 65536, fl_sectors,
mips_malta.c:                bios_size = -1;
mips_malta.c:                        "qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\n",
mips_malta.c:           a neat trick which allows bi-endian firmware. */
mips_malta.c:    i8259 = i8259_init(env->irq[2]);
mips_malta.c:        eeprom = qdev_create((BusState *)smbus, "smbus-eeprom");
mips_mipssim.c:#include "mips-bios.h"
mips_mipssim.c:#define VIRT_TO_PHYS_ADDEND (-((int64_t)(int32_t)0x80000000))
mips_mipssim.c:                initrd_offset, loaderparams.ram_size - initrd_offset);
mips_mipssim.c:        if (initrd_size == (target_ulong) -1) {
mips_mipssim.c:    CPUState *env = s->env;
mips_mipssim.c:    env->active_tc.PC = s->vector;
mips_mipssim.c:    reset_info->env = env;
mips_mipssim.c:    reset_info->vector = env->active_tc.PC;
mips_mipssim.c:        bios_size = -1;
mips_mipssim.c:                "qemu: Could not load MIPS bios '%s', and no -kernel argument was specified\n",
mips_mipssim.c:        env->active_tc.PC = (target_long)(int32_t)0xbfc00000;
mips_mipssim.c:        reset_info->vector = load_kernel();
mips_mipssim.c:        serial_init(0x3f8, env->irq[4], 115200, serial_hds[0]);
mips_mipssim.c:        mipsnet_init(0x4200, env->irq[2], &nd_table[0]);
mipsnet.c:    s->busy = 1;
mipsnet.c:    s->rx_count = 0;
mipsnet.c:    s->rx_read = 0;
mipsnet.c:    s->tx_count = 0;
mipsnet.c:    s->tx_written = 0;
mipsnet.c:    s->intctl = 0;
mipsnet.c:    memset(s->rx_buffer, 0, MAX_ETH_FRAME_SIZE);
mipsnet.c:    memset(s->tx_buffer, 0, MAX_ETH_FRAME_SIZE);
mipsnet.c:    int isr = !!s->intctl;
mipsnet.c:    printf("mipsnet: Set IRQ to %d (%02x)\n", isr, s->intctl);
mipsnet.c:    qemu_set_irq(s->irq, isr);
mipsnet.c:    if (s->rx_count >= MAX_ETH_FRAME_SIZE)
mipsnet.c:    MIPSnetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
mipsnet.c:    if (s->busy)
mipsnet.c:    MIPSnetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
mipsnet.c:        return -1;
mipsnet.c:    s->busy = 1;
mipsnet.c:    memcpy(s->rx_buffer, buf, size);
mipsnet.c:    s->rx_count = size;
mipsnet.c:    s->rx_read = 0;
mipsnet.c:    s->intctl |= MIPSNET_INTCTL_RXDONE;
mipsnet.c:	ret = s->busy;
mipsnet.c:	ret = s->rx_count;
mipsnet.c:	ret = s->tx_count;
mipsnet.c:	ret = s->intctl;
mipsnet.c:        s->intctl &= ~MIPSNET_INTCTL_TESTBIT;
mipsnet.c:        /* XXX: This seems to be a per-VPE interrupt number. */
mipsnet.c:        if (s->rx_count) {
mipsnet.c:            s->rx_count--;
mipsnet.c:            ret = s->rx_buffer[s->rx_read++];
mipsnet.c:	s->tx_count = (val <= MAX_ETH_FRAME_SIZE) ? val : 0;
mipsnet.c:        s->tx_written = 0;
mipsnet.c:            s->intctl &= ~MIPSNET_INTCTL_TXDONE;
mipsnet.c:            s->intctl &= ~MIPSNET_INTCTL_RXDONE;
mipsnet.c:            s->intctl |= MIPSNET_INTCTL_TESTBIT;
mipsnet.c:        s->busy = !!s->intctl;
mipsnet.c:        s->tx_buffer[s->tx_written++] = val;
mipsnet.c:        if (s->tx_written == s->tx_count) {
mipsnet.c:            printf("mipsnet: sending len=%d\n", s->tx_count);
mipsnet.c:            qemu_send_packet(&s->nic->nc, s->tx_buffer, s->tx_count);
mipsnet.c:            s->tx_count = s->tx_written = 0;
mipsnet.c:            s->intctl |= MIPSNET_INTCTL_TXDONE;
mipsnet.c:            s->busy = 1;
mipsnet.c:    /* Read-only registers */
mipsnet.c:    qemu_put_be32s(f, &s->busy);
mipsnet.c:    qemu_put_be32s(f, &s->rx_count);
mipsnet.c:    qemu_put_be32s(f, &s->rx_read);
mipsnet.c:    qemu_put_be32s(f, &s->tx_count);
mipsnet.c:    qemu_put_be32s(f, &s->tx_written);
mipsnet.c:    qemu_put_be32s(f, &s->intctl);
mipsnet.c:    qemu_put_buffer(f, s->rx_buffer, MAX_ETH_FRAME_SIZE);
mipsnet.c:    qemu_put_buffer(f, s->tx_buffer, MAX_ETH_FRAME_SIZE);
mipsnet.c:        return -EINVAL;
mipsnet.c:    qemu_get_be32s(f, &s->busy);
mipsnet.c:    qemu_get_be32s(f, &s->rx_count);
mipsnet.c:    qemu_get_be32s(f, &s->rx_read);
mipsnet.c:    qemu_get_be32s(f, &s->tx_count);
mipsnet.c:    qemu_get_be32s(f, &s->tx_written);
mipsnet.c:    qemu_get_be32s(f, &s->intctl);
mipsnet.c:    qemu_get_buffer(f, s->rx_buffer, MAX_ETH_FRAME_SIZE);
mipsnet.c:    qemu_get_buffer(f, s->tx_buffer, MAX_ETH_FRAME_SIZE);
mipsnet.c:    MIPSnetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
mipsnet.c:    isa_unassign_ioport(s->io_base, 36);
mipsnet.c:    s->io_base = base;
mipsnet.c:    s->irq = irq;
mipsnet.c:        memcpy(s->conf.macaddr.a, nd->macaddr, sizeof(nd->macaddr));
mipsnet.c:        s->conf.vlan = nd->vlan;
mipsnet.c:        s->conf.peer = nd->netdev;
mipsnet.c:        s->nic = qemu_new_nic(&net_mipsnet_info, &s->conf,
mipsnet.c:                              nd->model, nd->name, s);
mipsnet.c:        qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
mips_r4k.c: * QEMU/MIPS pseudo-board
mips_r4k.c: * emulates a simple machine with ISA-like bus.
mips_r4k.c:#include "qemu-log.h"
mips_r4k.c:#include "mips-bios.h"
mips_r4k.c:#define VIRT_TO_PHYS_ADDEND (-((int64_t)(int32_t)0x80000000))
mips_r4k.c:                                              ram_size - initrd_offset);
mips_r4k.c:        if (initrd_size == (target_ulong) -1) {
mips_r4k.c:                       (16 << 20) - 264);
mips_r4k.c:    CPUState *env = s->env;
mips_r4k.c:    env->active_tc.PC = s->vector;
mips_r4k.c:    reset_info->env = env;
mips_r4k.c:    reset_info->vector = env->active_tc.PC;
mips_r4k.c:        bios_size = -1;
mips_r4k.c:            dinfo->bdrv, sector_len, mips_rom / sector_len,
mips_r4k.c:        reset_info->vector = load_kernel();
mips_r4k.c:    i8259 = i8259_init(env->irq[2]);
mips_timer.c:#include "qemu-timer.h"
mips_timer.c:        lfsr = (lfsr >> 1) ^ (-(lfsr & 1u) & 0xd0000001u);
mips_timer.c:        idx = lfsr % (env->tlb->nb_tlb - env->CP0_Wired) + env->CP0_Wired;
mips_timer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC))
mips_timer.c:        return env->CP0_Count;
mips_timer.c:        return env->CP0_Count +
mips_timer.c:    wait = env->CP0_Compare - env->CP0_Count -
mips_timer.c:    qemu_mod_timer(env->timer, next);
mips_timer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC))
mips_timer.c:        env->CP0_Count = count;
mips_timer.c:        env->CP0_Count =
mips_timer.c:            count - (uint32_t)muldiv64(qemu_get_clock(vm_clock),
mips_timer.c:    env->CP0_Compare = value;
mips_timer.c:    if (!(env->CP0_Cause & (1 << CP0Ca_DC)))
mips_timer.c:    if (env->insn_flags & ISA_MIPS32R2)
mips_timer.c:        env->CP0_Cause &= ~(1 << CP0Ca_TI);
mips_timer.c:    qemu_irq_lower(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
mips_timer.c:    cpu_mips_store_count(env, env->CP0_Count);
mips_timer.c:    env->CP0_Count += (uint32_t)muldiv64(qemu_get_clock(vm_clock),
mips_timer.c:    if (env->CP0_Cause & (1 << CP0Ca_DC))
mips_timer.c:    env->CP0_Count++;
mips_timer.c:    env->CP0_Count--;
mips_timer.c:    if (env->insn_flags & ISA_MIPS32R2)
mips_timer.c:        env->CP0_Cause |= 1 << CP0Ca_TI;
mips_timer.c:    qemu_irq_raise(env->irq[(env->CP0_IntCtl >> CP0IntCtl_IPTI) & 0x7]);
mips_timer.c:    env->timer = qemu_new_timer(vm_clock, &mips_timer_cb, env);
mips_timer.c:    env->CP0_Compare = 0;
mpcore.c: * Copyright (c) 2006-2007 CodeSourcery.
mpcore.c:#include "qemu-timer.h"
mpcore.c:  return cpu_single_env->cpu_index;
mpcore.c:/* Per-CPU Timers.  */
mpcore.c:    if (s->status & ~s->old_status) {
mpcore.c:        gic_set_pending_private(&s->mpcore->gic, s->id >> 1, 29 + (s->id & 1));
mpcore.c:    s->old_status = s->status;
mpcore.c:    return (((s->control >> 8) & 0xff) + 1) * 10;
mpcore.c:    if (s->count == 0)
mpcore.c:        s->tick = qemu_get_clock(vm_clock);
mpcore.c:    s->tick += (int64_t)s->count * mpcore_timer_scale(s);
mpcore.c:    qemu_mod_timer(s->timer, s->tick);
mpcore.c:    s->status = 1;
mpcore.c:    if (s->control & 2) {
mpcore.c:        s->count = s->load;
mpcore.c:        s->count = 0;
mpcore.c:        return s->load;
mpcore.c:        if (((s->control & 1) == 0) || (s->count == 0))
mpcore.c:        val = s->tick - qemu_get_clock(vm_clock);
mpcore.c:        return s->control;
mpcore.c:        return s->status;
mpcore.c:        s->load = value;
mpcore.c:        if ((s->control & 1) && s->count) {
mpcore.c:            qemu_del_timer(s->timer);
mpcore.c:        s->count = value;
mpcore.c:        if (s->control & 1) {
mpcore.c:        old = s->control;
mpcore.c:        s->control = value;
mpcore.c:            if (s->count == 0 && (s->control & 2))
mpcore.c:                s->count = s->load;
mpcore.c:        s->status &= ~value;
mpcore.c:    s->id = id;
mpcore.c:    s->mpcore = mpcore;
mpcore.c:    s->timer = qemu_new_timer(vm_clock, mpcore_timer_tick, s);
mpcore.c:/* Per-CPU private memory mapped IO.  */
mpcore.c:            return s->scu_control;
mpcore.c:            id = ((1 << s->num_cpu) - 1) << 4;
mpcore.c:            return id | (s->num_cpu - 1);
mpcore.c:            id = (offset - 0x200) >> 8;
mpcore.c:            if (id >= s->num_cpu) {
mpcore.c:        return gic_cpu_read(&s->gic, id, offset & 0xff);
mpcore.c:            id = (offset - 0x700) >> 8;
mpcore.c:            if (id >= s->num_cpu) {
mpcore.c:        return mpcore_timer_read(&s->timer[id], offset & 0xf);
mpcore.c:            s->scu_control = value & 1;
mpcore.c:            /* This is a no-op as cache is not emulated.  */
mpcore.c:            id = (offset - 0x200) >> 8;
mpcore.c:        if (id < s->num_cpu) {
mpcore.c:            gic_cpu_write(&s->gic, id, offset & 0xff, value);
mpcore.c:            id = (offset - 0x700) >> 8;
mpcore.c:        if (id < s->num_cpu) {
mpcore.c:            mpcore_timer_write(&s->timer[id], offset & 0xf, value);
mpcore.c:    cpu_register_physical_memory(base, 0x1000, s->iomemtype);
mpcore.c:    cpu_register_physical_memory(base + 0x1000, 0x1000, s->gic.iomemtype);
mpcore.c:    gic_init(&s->gic, s->num_cpu);
mpcore.c:    s->iomemtype = cpu_register_io_memory(mpcore_priv_readfn,
mpcore.c:    for (i = 0; i < s->num_cpu * 2; i++) {
mpcore.c:        mpcore_timer_init(s, &s->timer[i], i);
msix.c: * MSI-X device support
msix.c: * This module includes support for MSI-X in pci devices.
msix.c: * the COPYING file in the top-level directory.
msix.c:#include "qemu-kvm.h"
msix.c:#define  PCI_CAP_ID_MSIX 0x11 /* MSI-X */
msix.c:/* MSI-X capability structure */
msix.c:/* MSI-X table format */
msix.c:/* Flag for interrupt controller to declare MSI-X support */
msix.c:    for (vector = 0; vector < dev->msix_entries_nr; ++vector) {
msix.c:        if (dev->msix_entry_used[vector]) {
msix.c:            kvm_del_routing_entry(kvm_context, &dev->msix_irq_entries[vector]);
msix.c:    uint8_t *table_entry = dev->msix_table_page + vector * MSIX_ENTRY_SIZE;
msix.c:    entry->type = KVM_IRQ_ROUTING_MSI;
msix.c:    entry->flags = 0;
msix.c:    entry->u.msi.address_lo = pci_get_long(table_entry + MSIX_MSG_ADDR);
msix.c:    entry->u.msi.address_hi = pci_get_long(table_entry + MSIX_MSG_UPPER_ADDR);
msix.c:    entry->u.msi.data = pci_get_long(table_entry + MSIX_MSG_DATA);
msix.c:    if (!dev->msix_entry_used[vector]) {
msix.c:    entry = dev->msix_irq_entries + vector;
msix.c:    e.gsi = entry->gsi;
msix.c:    if (memcmp(&entry->u.msi, &e.u.msi, sizeof entry->u.msi)) {
msix.c:		    strerror(-r));
msix.c:        memcpy(&entry->u.msi, &e.u.msi, sizeof entry->u.msi);
msix.c:		    strerror(-r));
msix.c:    struct kvm_irq_routing_entry *entry = dev->msix_irq_entries + vector;
msix.c:        fprintf(stderr, "Warning: no MSI-X support found. "
msix.c:                "At least kernel 2.6.30 is required for MSI-X support.\n"
msix.c:        return -EOPNOTSUPP;
msix.c:        fprintf(stderr, "%s: kvm_get_irq_route_gsi failed: %s\n", __func__, strerror(-r));
msix.c:    entry->gsi = r;
msix.c:        fprintf(stderr, "%s: kvm_add_routing_entry failed: %s\n", __func__, strerror(-r));
msix.c:        fprintf(stderr, "%s: kvm_commit_irq_routes failed: %s\n", __func__, strerror(-r));
msix.c:    if (dev->msix_entry_used[vector]) {
msix.c:    kvm_del_routing_entry(kvm_context, &dev->msix_irq_entries[vector]);
msix.c:static int kvm_msix_add(PCIDevice *dev, unsigned vector) { return -1; }
msix.c:/* Add MSI-X capability to the config space for the device. */
msix.c:/* Given a bar and its size, add MSI-X table on top of it
msix.c: * and fill MSI-X capability in the config space.
msix.c:        return -EINVAL;
msix.c:        return -ENOSPC;
msix.c:    /* Add space for MSI-X structures */
msix.c:    pdev->msix_bar_size = new_size;
msix.c:    config = pdev->config + config_offset;
msix.c:    pci_set_word(config + PCI_MSIX_FLAGS, nentries - 1);
msix.c:    pdev->msix_cap = config_offset;
msix.c:    pdev->wmask[config_offset + MSIX_CONTROL_OFFSET] |= MSIX_ENABLE_MASK |
msix.c:    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;
msix.c:    void *page = dev->msix_table_page;
msix.c:    fprintf(stderr, "MSI-X: only dword read is allowed!\n");
msix.c:    return dev->msix_table_page + MSIX_PAGE_PENDING + vector / 8;
msix.c:    return dev->config[dev->msix_cap + MSIX_CONTROL_OFFSET] & MSIX_MASKALL_MASK;
msix.c:	   dev->msix_table_page[offset] & MSIX_VECTOR_MASK;
msix.c:/* Handle MSI-X capability config write. */
msix.c:    unsigned enable_pos = dev->msix_cap + MSIX_CONTROL_OFFSET;
msix.c:    qemu_set_irq(dev->irq[0], 0);
msix.c:    for (vector = 0; vector < dev->msix_entries_nr; ++vector) {
msix.c:    unsigned int offset = addr & (MSIX_PAGE_SIZE - 1) & ~0x3;
msix.c:    pci_set_long(dev->msix_table_page + offset, val);
msix.c:    fprintf(stderr, "MSI-X: only dword write is allowed!\n");
msix.c:    uint8_t *config = d->config + d->msix_cap;
msix.c:    uint32_t offset = table & ~(MSIX_PAGE_SIZE - 1);
msix.c:    cpu_register_physical_memory(addr + offset, size - offset,
msix.c:                                 d->msix_mmio_index);
msix.c:        dev->msix_table_page[offset] |= MSIX_VECTOR_MASK;
msix.c:/* Initialize the MSI-X structures. Note: if MSI-X is supported, BAR size is
msix.c:        return -ENOTSUP;
msix.c:        return -EINVAL;
msix.c:        dev->msix_irq_entries = qemu_malloc(nentries *
msix.c:                                            sizeof *dev->msix_irq_entries);
msix.c:    dev->msix_entry_used = qemu_mallocz(MSIX_MAX_ENTRIES *
msix.c:                                        sizeof *dev->msix_entry_used);
msix.c:    dev->msix_table_page = qemu_mallocz(MSIX_PAGE_SIZE);
msix.c:    dev->msix_mmio_index = cpu_register_io_memory(msix_mmio_read,
msix.c:    if (dev->msix_mmio_index == -1) {
msix.c:        ret = -EBUSY;
msix.c:    dev->msix_entries_nr = nentries;
msix.c:    dev->cap_present |= QEMU_PCI_CAP_MSIX;
msix.c:    dev->msix_entries_nr = 0;
msix.c:    cpu_unregister_io_memory(dev->msix_mmio_index);
msix.c:    qemu_free(dev->msix_table_page);
msix.c:    dev->msix_table_page = NULL;
msix.c:    qemu_free(dev->msix_entry_used);
msix.c:    dev->msix_entry_used = NULL;
msix.c:    for (vector = 0; vector < dev->msix_entries_nr; ++vector) {
msix.c:        dev->msix_entry_used[vector] = 0;
msix.c:    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX))
msix.c:    dev->msix_cap = 0;
msix.c:    dev->msix_entries_nr = 0;
msix.c:    cpu_unregister_io_memory(dev->msix_mmio_index);
msix.c:    qemu_free(dev->msix_table_page);
msix.c:    dev->msix_table_page = NULL;
msix.c:    qemu_free(dev->msix_entry_used);
msix.c:    dev->msix_entry_used = NULL;
msix.c:    qemu_free(dev->msix_irq_entries);
msix.c:    dev->msix_irq_entries = NULL;
msix.c:    dev->cap_present &= ~QEMU_PCI_CAP_MSIX;
msix.c:    unsigned n = dev->msix_entries_nr;
msix.c:    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX)) {
msix.c:    qemu_put_buffer(f, dev->msix_table_page, n * MSIX_ENTRY_SIZE);
msix.c:    qemu_put_buffer(f, dev->msix_table_page + MSIX_PAGE_PENDING, (n + 7) / 8);
msix.c:    unsigned n = dev->msix_entries_nr;
msix.c:    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX)) {
msix.c:    qemu_get_buffer(f, dev->msix_table_page, n * MSIX_ENTRY_SIZE);
msix.c:    qemu_get_buffer(f, dev->msix_table_page + MSIX_PAGE_PENDING, (n + 7) / 8);
msix.c:/* Does device support MSI-X? */
msix.c:    return dev->cap_present & QEMU_PCI_CAP_MSIX;
msix.c:/* Is MSI-X enabled? */
msix.c:    return (dev->cap_present & QEMU_PCI_CAP_MSIX) &&
msix.c:        (dev->config[dev->msix_cap + MSIX_CONTROL_OFFSET] &
msix.c:/* Size of bar where MSI-X table resides, or 0 if MSI-X not supported. */
msix.c:    return (dev->cap_present & QEMU_PCI_CAP_MSIX) ?
msix.c:        dev->msix_bar_size : 0;
msix.c:/* Send an MSI-X message */
msix.c:    uint8_t *table_entry = dev->msix_table_page + vector * MSIX_ENTRY_SIZE;
msix.c:    if (vector >= dev->msix_entries_nr || !dev->msix_entry_used[vector])
msix.c:        kvm_set_irq(dev->msix_irq_entries[vector].gsi, 1, NULL);
msix.c:    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX))
msix.c:    dev->config[dev->msix_cap + MSIX_CONTROL_OFFSET] &=
msix.c:	    ~dev->wmask[dev->msix_cap + MSIX_CONTROL_OFFSET];
msix.c:    memset(dev->msix_table_page, 0, MSIX_PAGE_SIZE);
msix.c:    msix_mask_all(dev, dev->msix_entries_nr);
msix.c:    if (vector >= dev->msix_entries_nr)
msix.c:        return -EINVAL;
msix.c:    if (dev->msix_entry_used[vector]) {
msix.c:    ++dev->msix_entry_used[vector];
msix.c:    if (vector >= dev->msix_entries_nr || !dev->msix_entry_used[vector]) {
msix.c:    if (--dev->msix_entry_used[vector]) {
msix.c:    if (!(dev->cap_present & QEMU_PCI_CAP_MSIX))
msix.h:#include "qemu-common.h"
msmouse.c:#include "../qemu-common.h"
msmouse.c:#include "../qemu-char.h"
msmouse.c:    chr->chr_write = msmouse_chr_write;
msmouse.c:    chr->chr_close = msmouse_chr_close;
mst_fpga.c: * PXA270-based Intel Mainstone platforms.
mst_fpga.c: * Copyright (c) 2007 by Armin Kuster <akuster@kama-aina.net> or
mst_fpga.c:	level = s->prev_level ^ s->intsetclr;
mst_fpga.c:	for (diff = s->prev_level ^ level; diff; diff ^= 1 << bit) {
mst_fpga.c:		bit = ffs(diff) - 1;
mst_fpga.c:		qemu_set_irq(s->pins[bit], (level >> bit) & 1 );
mst_fpga.c:	s->prev_level = level;
mst_fpga.c:		s->prev_level |= 1u << irq;
mst_fpga.c:		s->prev_level &= ~(1u << irq);
mst_fpga.c:	if(s->intmskena & (1u << irq)) {
mst_fpga.c:		s->intsetclr = 1u << irq;
mst_fpga.c:		qemu_set_irq(s->parent[0], level);
mst_fpga.c:		return s->leddat1;
mst_fpga.c:		return s->leddat2;
mst_fpga.c:		return s->ledctrl;
mst_fpga.c:		return s->gpswr;
mst_fpga.c:		return s->mscwr1;
mst_fpga.c:		return s->mscwr2;
mst_fpga.c:		return s->mscwr3;
mst_fpga.c:		return s->mscrd;
mst_fpga.c:		return s->intmskena;
mst_fpga.c:		return s->intsetclr;
mst_fpga.c:		return s->pcmcia0;
mst_fpga.c:		return s->pcmcia1;
mst_fpga.c:		printf("Mainstone - mst_fpga_readb: Bad register offset "
mst_fpga.c:		s->leddat1 = value;
mst_fpga.c:		s->leddat2 = value;
mst_fpga.c:		s->ledctrl = value;
mst_fpga.c:		s->gpswr = value;
mst_fpga.c:		s->mscwr1 = value;
mst_fpga.c:		s->mscwr2 = value;
mst_fpga.c:		s->mscwr3 = value;
mst_fpga.c:		s->mscrd =  value;
mst_fpga.c:		s->intmskena = (value & 0xFEEFF);
mst_fpga.c:		s->intsetclr = (value & 0xFEEFF);
mst_fpga.c:		s->pcmcia0 = value;
mst_fpga.c:		s->pcmcia1 = value;
mst_fpga.c:		printf("Mainstone - mst_fpga_writeb: Bad register offset "
mst_fpga.c:	qemu_put_be32s(f, &s->prev_level);
mst_fpga.c:	qemu_put_be32s(f, &s->leddat1);
mst_fpga.c:	qemu_put_be32s(f, &s->leddat2);
mst_fpga.c:	qemu_put_be32s(f, &s->ledctrl);
mst_fpga.c:	qemu_put_be32s(f, &s->gpswr);
mst_fpga.c:	qemu_put_be32s(f, &s->mscwr1);
mst_fpga.c:	qemu_put_be32s(f, &s->mscwr2);
mst_fpga.c:	qemu_put_be32s(f, &s->mscwr3);
mst_fpga.c:	qemu_put_be32s(f, &s->mscrd);
mst_fpga.c:	qemu_put_be32s(f, &s->intmskena);
mst_fpga.c:	qemu_put_be32s(f, &s->intsetclr);
mst_fpga.c:	qemu_put_be32s(f, &s->pcmcia0);
mst_fpga.c:	qemu_put_be32s(f, &s->pcmcia1);
mst_fpga.c:	qemu_get_be32s(f, &s->prev_level);
mst_fpga.c:	qemu_get_be32s(f, &s->leddat1);
mst_fpga.c:	qemu_get_be32s(f, &s->leddat2);
mst_fpga.c:	qemu_get_be32s(f, &s->ledctrl);
mst_fpga.c:	qemu_get_be32s(f, &s->gpswr);
mst_fpga.c:	qemu_get_be32s(f, &s->mscwr1);
mst_fpga.c:	qemu_get_be32s(f, &s->mscwr2);
mst_fpga.c:	qemu_get_be32s(f, &s->mscwr3);
mst_fpga.c:	qemu_get_be32s(f, &s->mscrd);
mst_fpga.c:	qemu_get_be32s(f, &s->intmskena);
mst_fpga.c:	qemu_get_be32s(f, &s->intsetclr);
mst_fpga.c:	qemu_get_be32s(f, &s->pcmcia0);
mst_fpga.c:	qemu_get_be32s(f, &s->pcmcia1);
mst_fpga.c:	s->parent = &cpu->pic[irq];
mst_fpga.c:	s->pins = qi;
musicpal.c:#include "arm-misc.h"
musicpal.c:#include "qemu-timer.h"
musicpal.c:#define MP_ETH_PCXR_2BSM_BIT    28 /* 2-byte incoming suffix */
musicpal.c:    cpu_to_le32s(&desc->cmdstat);
musicpal.c:    cpu_to_le16s(&desc->bytes);
musicpal.c:    cpu_to_le16s(&desc->buffer_size);
musicpal.c:    cpu_to_le32s(&desc->buffer);
musicpal.c:    cpu_to_le32s(&desc->next);
musicpal.c:    le32_to_cpus(&desc->cmdstat);
musicpal.c:    le16_to_cpus(&desc->bytes);
musicpal.c:    le16_to_cpus(&desc->buffer_size);
musicpal.c:    le32_to_cpus(&desc->buffer);
musicpal.c:    le32_to_cpus(&desc->next);
musicpal.c:    mv88w8618_eth_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
musicpal.c:        desc_addr = s->cur_rx[i];
musicpal.c:                cpu_physical_memory_write(desc.buffer + s->vlan_header,
musicpal.c:                desc.bytes = size + s->vlan_header;
musicpal.c:                s->cur_rx[i] = desc.next;
musicpal.c:                s->icr |= MP_ETH_IRQ_RX;
musicpal.c:                if (s->icr & s->imr) {
musicpal.c:                    qemu_irq_raise(s->irq);
musicpal.c:        } while (desc_addr != s->rx_queue[i]);
musicpal.c:    cpu_to_le32s(&desc->cmdstat);
musicpal.c:    cpu_to_le16s(&desc->res);
musicpal.c:    cpu_to_le16s(&desc->bytes);
musicpal.c:    cpu_to_le32s(&desc->buffer);
musicpal.c:    cpu_to_le32s(&desc->next);
musicpal.c:    le32_to_cpus(&desc->cmdstat);
musicpal.c:    le16_to_cpus(&desc->res);
musicpal.c:    le16_to_cpus(&desc->bytes);
musicpal.c:    le32_to_cpus(&desc->buffer);
musicpal.c:    le32_to_cpus(&desc->next);
musicpal.c:    uint32_t desc_addr = s->tx_queue[queue_index];
musicpal.c:                qemu_send_packet(&s->nic->nc, buf, len);
musicpal.c:            s->icr |= 1 << (MP_ETH_IRQ_TXLO_BIT - queue_index);
musicpal.c:    } while (desc_addr != s->tx_queue[queue_index]);
musicpal.c:        if (s->smir & MP_ETH_SMIR_OPCODE) {
musicpal.c:            switch (s->smir & MP_ETH_SMIR_ADDR) {
musicpal.c:        return s->icr;
musicpal.c:        return s->imr;
musicpal.c:        return s->frx_queue[(offset - MP_ETH_FRDP0)/4];
musicpal.c:        return s->rx_queue[(offset - MP_ETH_CRDP0)/4];
musicpal.c:        return s->tx_queue[(offset - MP_ETH_CTDP0)/4];
musicpal.c:        s->smir = value;
musicpal.c:        s->vlan_header = ((value >> MP_ETH_PCXR_2BSM_BIT) & 1) * 2;
musicpal.c:        if (value & (MP_ETH_CMD_TXHI | MP_ETH_CMD_TXLO) && s->icr & s->imr) {
musicpal.c:            qemu_irq_raise(s->irq);
musicpal.c:        s->icr &= value;
musicpal.c:        s->imr = value;
musicpal.c:        if (s->icr & s->imr) {
musicpal.c:            qemu_irq_raise(s->irq);
musicpal.c:        s->frx_queue[(offset - MP_ETH_FRDP0)/4] = value;
musicpal.c:        s->rx_queue[(offset - MP_ETH_CRDP0)/4] =
musicpal.c:            s->cur_rx[(offset - MP_ETH_CRDP0)/4] = value;
musicpal.c:        s->tx_queue[(offset - MP_ETH_CTDP0)/4] = value;
musicpal.c:    mv88w8618_eth_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
musicpal.c:    s->nic = NULL;
musicpal.c:    sysbus_init_irq(dev, &s->irq);
musicpal.c:    s->nic = qemu_new_nic(&net_mv88w8618_info, &s->conf,
musicpal.c:                          dev->qdev.info->name, dev->qdev.id, s);
musicpal.c:    s->mmio_index = cpu_register_io_memory(mv88w8618_eth_readfn,
musicpal.c:    sysbus_init_mmio(dev, MP_ETH_SIZE, s->mmio_index);
musicpal.c:    switch (s->brightness) {
musicpal.c:        return (col * s->brightness) / 7;
musicpal.c:    type *pixel = &((type *) ds_get_data(s->ds))[(y * 128 * 3 + x) * 3]; \
musicpal.c:    switch (ds_get_bits_per_pixel(s->ds)) {
musicpal.c:                if (s->video_ram[x + (y/8)*128] & (1 << (y % 8))) { \
musicpal.c:    LCD_REFRESH(32, (is_surface_bgr(s->ds->surface) ?
musicpal.c:                  ds_get_bits_per_pixel(s->ds));
musicpal.c:    dpy_update(s->ds, 0, 0, 128*3, 64*3);
musicpal.c:    s->brightness &= ~(1 << irq);
musicpal.c:    s->brightness |= level << irq;
musicpal.c:        return s->irqctrl;
musicpal.c:        s->irqctrl = value;
musicpal.c:            s->mode = value;
musicpal.c:            s->mode = MP_LCD_SPI_INVALID;
musicpal.c:            s->page = value - MP_LCD_INST_SETPAGE0;
musicpal.c:            s->page_off = 0;
musicpal.c:        if (s->mode == MP_LCD_SPI_CMD) {
musicpal.c:                s->page = value - MP_LCD_INST_SETPAGE0;
musicpal.c:                s->page_off = 0;
musicpal.c:        } else if (s->mode == MP_LCD_SPI_DATA) {
musicpal.c:            s->video_ram[s->page*128 + s->page_off] = value;
musicpal.c:            s->page_off = (s->page_off + 1) & 127;
musicpal.c:    s->brightness = 7;
musicpal.c:    s->ds = graphic_console_init(lcd_refresh, lcd_invalidate,
musicpal.c:    qemu_console_resize(s->ds, 128*3, 64*3);
musicpal.c:    qdev_init_gpio_in(&dev->qdev, musicpal_lcd_gpio_brigthness_in, 3);
musicpal.c:    qemu_set_irq(s->parent_irq, (s->level & s->enabled));
musicpal.c:        s->level |= 1 << irq;
musicpal.c:        s->level &= ~(1 << irq);
musicpal.c:        return s->level & s->enabled;
musicpal.c:        s->enabled |= value;
musicpal.c:        s->enabled &= ~value;
musicpal.c:        s->level &= ~value;
musicpal.c:    s->level = 0;
musicpal.c:    s->enabled = 0;
musicpal.c:    qdev_init_gpio_in(&dev->qdev, mv88w8618_pic_set_irq, 32);
musicpal.c:    sysbus_init_irq(dev, &s->parent_irq);
musicpal.c:    qemu_irq_raise(s->irq);
musicpal.c:    sysbus_init_irq(dev, &s->irq);
musicpal.c:    s->freq = freq;
musicpal.c:    s->ptimer = ptimer_init(bh);
musicpal.c:        t = &s->timer[(offset-MP_PIT_TIMER1_VALUE) >> 2];
musicpal.c:        return ptimer_get_count(t->ptimer);
musicpal.c:        t = &s->timer[offset >> 2];
musicpal.c:        t->limit = value;
musicpal.c:        if (t->limit > 0) {
musicpal.c:            ptimer_set_limit(t->ptimer, t->limit, 1);
musicpal.c:            ptimer_stop(t->ptimer);
musicpal.c:            t = &s->timer[i];
musicpal.c:            if (value & 0xf && t->limit > 0) {
musicpal.c:                ptimer_set_limit(t->ptimer, t->limit, 0);
musicpal.c:                ptimer_set_freq(t->ptimer, t->freq);
musicpal.c:                ptimer_run(t->ptimer, 0);
musicpal.c:                ptimer_stop(t->ptimer);
musicpal.c:        ptimer_stop(s->timer[i].ptimer);
musicpal.c:        s->timer[i].limit = 0;
musicpal.c:        mv88w8618_timer_init(dev, &s->timer[i], 1000000);
musicpal.c:        return s->cfgr0;
musicpal.c:        s->cfgr0 = value;
musicpal.c:    s->cfgr0 = 0xfffe4285; /* Default as set by U-Boot for 8 MB flash */
musicpal.c:    /* Workaround to allow loading the binary-only wlandrv.ko crap
musicpal.c:        return -1;
musicpal.c:    switch (s->lcd_brightness) {
musicpal.c:        qemu_set_irq(s->out[i], (brightness >> i) & 1);
musicpal.c:    uint32_t old = s->in_state & mask;
musicpal.c:    s->in_state &= ~mask;
musicpal.c:    s->in_state |= delta;
musicpal.c:        ((level && (s->imr & mask)) || (!level && (s->ier & mask)))) {
musicpal.c:        s->isr = mask;
musicpal.c:        qemu_irq_raise(s->irq);
musicpal.c:        return s->lcd_brightness & MP_OE_LCD_BRIGHTNESS;
musicpal.c:        return s->out_state & 0xFFFF;
musicpal.c:        return s->out_state >> 16;
musicpal.c:        return s->in_state & 0xFFFF;
musicpal.c:        return s->in_state >> 16;
musicpal.c:        return s->ier & 0xFFFF;
musicpal.c:        return s->ier >> 16;
musicpal.c:        return s->imr & 0xFFFF;
musicpal.c:        return s->imr >> 16;
musicpal.c:        return s->isr & 0xFFFF;
musicpal.c:        return s->isr >> 16;
musicpal.c:        s->lcd_brightness = (s->lcd_brightness & MP_GPIO_LCD_BRIGHTNESS) |
musicpal.c:        s->out_state = (s->out_state & 0xFFFF0000) | (value & 0xFFFF);
musicpal.c:        s->out_state = (s->out_state & 0xFFFF) | (value << 16);
musicpal.c:        s->lcd_brightness = (s->lcd_brightness & 0xFFFF) |
musicpal.c:                            (s->out_state & MP_GPIO_LCD_BRIGHTNESS);
musicpal.c:        qemu_set_irq(s->out[3], (s->out_state >> MP_GPIO_I2C_DATA_BIT) & 1);
musicpal.c:        qemu_set_irq(s->out[4], (s->out_state >> MP_GPIO_I2C_CLOCK_BIT) & 1);
musicpal.c:        s->ier = (s->ier & 0xFFFF0000) | (value & 0xFFFF);
musicpal.c:        s->ier = (s->ier & 0xFFFF) | (value << 16);
musicpal.c:        s->imr = (s->imr & 0xFFFF0000) | (value & 0xFFFF);
musicpal.c:        s->imr = (s->imr & 0xFFFF) | (value << 16);
musicpal.c:    s->lcd_brightness = 0;
musicpal.c:    s->out_state = 0;
musicpal.c:    s->in_state = 0xffffffff;
musicpal.c:    s->ier = 0;
musicpal.c:    s->imr = 0;
musicpal.c:    s->isr = 0;
musicpal.c:    sysbus_init_irq(dev, &s->irq);
musicpal.c:    musicpal_gpio_reset(&dev->qdev);
musicpal.c:    qdev_init_gpio_out(&dev->qdev, s->out, ARRAY_SIZE(s->out));
musicpal.c:    qdev_init_gpio_in(&dev->qdev, musicpal_gpio_pin_event, 32);
musicpal.c:        s->kbd_extended = 1;
musicpal.c:    if (s->kbd_extended) {
musicpal.c:        if (!(keycode & KEY_RELEASED) && (s->pressed_keys & event)) {
musicpal.c:        if (!(keycode & KEY_RELEASED) && (s->pressed_keys & event)) {
musicpal.c:                    qemu_set_irq(s->out[i], 1);
musicpal.c:                qemu_set_irq(s->out[i], !!(keycode & KEY_RELEASED));
musicpal.c:            s->pressed_keys &= ~event;
musicpal.c:            s->pressed_keys |= event;
musicpal.c:    s->kbd_extended = 0;
musicpal.c:    s->kbd_extended = 0;
musicpal.c:    s->pressed_keys = 0;
musicpal.c:    qdev_init_gpio_out(&dev->qdev, s->out, ARRAY_SIZE(s->out));
musicpal.c:    /* For now we use a fixed - the original - RAM size */
musicpal.c:        flash_size = bdrv_getlength(dinfo->bdrv);
musicpal.c:         * The original U-Boot accesses the flash at 0xFE000000 instead of
musicpal.c:        pflash_cfi02_register(0-MP_FLASH_SIZE_MAX, qemu_ram_alloc(flash_size),
musicpal.c:                              dinfo->bdrv, 0x10000,
musicpal.c:    .desc = "Marvell 88w8618 / MusicPal (ARM926EJ-S)",
nand.c:# define PAGE_MASK		((1 << ADDR_SHIFT) - 1)
nand.c:# define OOB_SHIFT		(PAGE_SHIFT - 5)
nand.c:# define SECTOR(addr)		((addr) >> (9 + ADDR_SHIFT - PAGE_SHIFT))
nand.c:    s->cmd = NAND_CMD_READ0;
nand.c:    s->addr = 0;
nand.c:    s->addrlen = 0;
nand.c:    s->iolen = 0;
nand.c:    s->offset = 0;
nand.c:    s->status &= NAND_IOSTATUS_UNPROTCT;
nand.c:    switch (s->cmd) {
nand.c:        s->iolen = 0;
nand.c:        s->io[0] = s->manf_id;
nand.c:        s->io[1] = s->chip_id;
nand.c:        s->io[2] = 'Q';		/* Don't-care byte (often 0xa5) */
nand.c:        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP)
nand.c:            s->io[3] = 0x15;	/* Page Size, Block Size, Spare Size.. */
nand.c:            s->io[3] = 0xc0;	/* Multi-plane */
nand.c:        s->ioaddr = s->io;
nand.c:        s->iolen = 4;
nand.c:        if (!(nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP))
nand.c:        s->blk_load(s, s->addr, s->addr & ((1 << s->addr_shift) - 1));
nand.c:        s->ioaddr = s->io;
nand.c:        s->iolen = 0;
nand.c:        if (s->wp) {
nand.c:            s->blk_write(s);
nand.c:        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP)
nand.c:            s->addr <<= 16;
nand.c:            s->addr <<= 8;
nand.c:        if (s->wp) {
nand.c:            s->blk_erase(s);
nand.c:        s->io[0] = s->status;
nand.c:        s->ioaddr = s->io;
nand.c:        s->iolen = 1;
nand.c:        printf("%s: Unknown NAND command 0x%02x\n", __FUNCTION__, s->cmd);
nand.c:    qemu_put_byte(f, s->cle);
nand.c:    qemu_put_byte(f, s->ale);
nand.c:    qemu_put_byte(f, s->ce);
nand.c:    qemu_put_byte(f, s->wp);
nand.c:    qemu_put_byte(f, s->gnd);
nand.c:    qemu_put_buffer(f, s->io, sizeof(s->io));
nand.c:    qemu_put_be32(f, s->ioaddr - s->io);
nand.c:    qemu_put_be32(f, s->iolen);
nand.c:    qemu_put_be32s(f, &s->cmd);
nand.c:    qemu_put_be32s(f, &s->addr);
nand.c:    qemu_put_be32(f, s->addrlen);
nand.c:    qemu_put_be32(f, s->status);
nand.c:    qemu_put_be32(f, s->offset);
nand.c:    /* XXX: do we want to save s->storage too? */
nand.c:    s->cle = qemu_get_byte(f);
nand.c:    s->ale = qemu_get_byte(f);
nand.c:    s->ce = qemu_get_byte(f);
nand.c:    s->wp = qemu_get_byte(f);
nand.c:    s->gnd = qemu_get_byte(f);
nand.c:    qemu_get_buffer(f, s->io, sizeof(s->io));
nand.c:    s->ioaddr = s->io + qemu_get_be32(f);
nand.c:    s->iolen = qemu_get_be32(f);
nand.c:    if (s->ioaddr >= s->io + sizeof(s->io) || s->ioaddr < s->io)
nand.c:        return -EINVAL;
nand.c:    qemu_get_be32s(f, &s->cmd);
nand.c:    qemu_get_be32s(f, &s->addr);
nand.c:    s->addrlen = qemu_get_be32(f);
nand.c:    s->status = qemu_get_be32(f);
nand.c:    s->offset = qemu_get_be32(f);
nand.c:    s->cle = cle;
nand.c:    s->ale = ale;
nand.c:    s->ce = ce;
nand.c:    s->wp = wp;
nand.c:    s->gnd = gnd;
nand.c:        s->status |= NAND_IOSTATUS_UNPROTCT;
nand.c:        s->status &= ~NAND_IOSTATUS_UNPROTCT;
nand.c:    if (!s->ce && s->cle) {
nand.c:        if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) {
nand.c:            if (s->cmd == NAND_CMD_READ0 && value == NAND_CMD_LPREAD2)
nand.c:                s->addr &= ~((1 << s->addr_shift) - 1);
nand.c:                s->addrlen = 0;
nand.c:            s->offset = 0;
nand.c:            s->offset = 0x100;
nand.c:            s->offset = 1 << s->page_shift;
nand.c:        s->cmd = value;
nand.c:        if (s->cmd == NAND_CMD_READSTATUS ||
nand.c:                s->cmd == NAND_CMD_PAGEPROGRAM2 ||
nand.c:                s->cmd == NAND_CMD_BLOCKERASE1 ||
nand.c:                s->cmd == NAND_CMD_BLOCKERASE2 ||
nand.c:                s->cmd == NAND_CMD_NOSERIALREAD2 ||
nand.c:                s->cmd == NAND_CMD_RANDOMREAD2 ||
nand.c:                s->cmd == NAND_CMD_RESET)
nand.c:        if (s->cmd != NAND_CMD_RANDOMREAD2) {
nand.c:            s->addrlen = 0;
nand.c:            s->addr = 0;
nand.c:    if (s->ale) {
nand.c:        s->addr |= value << (s->addrlen * 8);
nand.c:        s->addrlen ++;
nand.c:        if (s->addrlen == 1 && s->cmd == NAND_CMD_READID)
nand.c:        if (!(nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) &&
nand.c:                s->addrlen == 3 && (
nand.c:                    s->cmd == NAND_CMD_READ0 ||
nand.c:                    s->cmd == NAND_CMD_PAGEPROGRAM1))
nand.c:        if ((nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) &&
nand.c:               s->addrlen == 4 && (
nand.c:                    s->cmd == NAND_CMD_READ0 ||
nand.c:                    s->cmd == NAND_CMD_PAGEPROGRAM1))
nand.c:    if (!s->cle && !s->ale && s->cmd == NAND_CMD_PAGEPROGRAM1) {
nand.c:        if (s->iolen < (1 << s->page_shift) + (1 << s->oob_shift))
nand.c:            s->io[s->iolen ++] = value;
nand.c:    } else if (!s->cle && !s->ale && s->cmd == NAND_CMD_COPYBACKPRG1) {
nand.c:        if ((s->addr & ((1 << s->addr_shift) - 1)) <
nand.c:                (1 << s->page_shift) + (1 << s->oob_shift)) {
nand.c:            s->io[s->iolen + (s->addr & ((1 << s->addr_shift) - 1))] = value;
nand.c:            s->addr ++;
nand.c:    if (!s->iolen && s->cmd == NAND_CMD_READ0) {
nand.c:        offset = (s->addr & ((1 << s->addr_shift) - 1)) + s->offset;
nand.c:        s->offset = 0;
nand.c:        s->blk_load(s, s->addr, offset);
nand.c:        if (s->gnd)
nand.c:            s->iolen = (1 << s->page_shift) - offset;
nand.c:            s->iolen = (1 << s->page_shift) + (1 << s->oob_shift) - offset;
nand.c:    if (s->ce || s->iolen <= 0)
nand.c:    s->iolen --;
nand.c:    return *(s->ioaddr ++);
nand.c:        s->bdrv = dinfo->bdrv;
nand.c:    s->manf_id = manf_id;
nand.c:    s->chip_id = chip_id;
nand.c:    s->size = nand_flash_ids[s->chip_id].size << 20;
nand.c:    if (nand_flash_ids[s->chip_id].options & NAND_SAMSUNG_LP) {
nand.c:        s->page_shift = 11;
nand.c:        s->erase_shift = 6;
nand.c:        s->page_shift = nand_flash_ids[s->chip_id].page_shift;
nand.c:        s->erase_shift = nand_flash_ids[s->chip_id].erase_shift;
nand.c:    switch (1 << s->page_shift) {
nand.c:    pagesize = 1 << s->oob_shift;
nand.c:    s->mem_oob = 1;
nand.c:    if (s->bdrv && bdrv_getlength(s->bdrv) >=
nand.c:                    (s->pages << s->page_shift) + (s->pages << s->oob_shift)) {
nand.c:        s->mem_oob = 0;
nand.c:    if (!s->bdrv)
nand.c:        pagesize += 1 << s->page_shift;
nand.c:        s->storage = (uint8_t *) memset(qemu_malloc(s->pages * pagesize),
nand.c:                        0xff, s->pages * pagesize);
nand.c:    /* Give s->ioaddr a sane value in case we save state before it
nand.c:    s->ioaddr = s->io;
nand.c:    register_savevm("nand", -1, 0, nand_save, nand_load, s);
nand.c:    if (s->bdrv) {
nand.c:        bdrv_close(s->bdrv);
nand.c:        bdrv_delete(s->bdrv);
nand.c:    if (!s->bdrv || s->mem_oob)
nand.c:        qemu_free(s->storage);
nand.c:    if (PAGE(s->addr) >= s->pages)
nand.c:    if (!s->bdrv) {
nand.c:        memcpy(s->storage + PAGE_START(s->addr) + (s->addr & PAGE_MASK) +
nand.c:                        s->offset, s->io, s->iolen);
nand.c:    } else if (s->mem_oob) {
nand.c:        sector = SECTOR(s->addr);
nand.c:        off = (s->addr & PAGE_MASK) + s->offset;
nand.c:        soff = SECTOR_OFFSET(s->addr);
nand.c:        if (bdrv_read(s->bdrv, sector, iobuf, PAGE_SECTORS) == -1) {
nand.c:        memcpy(iobuf + (soff | off), s->io, MIN(s->iolen, PAGE_SIZE - off));
nand.c:        if (off + s->iolen > PAGE_SIZE) {
nand.c:            page = PAGE(s->addr);
nand.c:            memcpy(s->storage + (page << OOB_SHIFT), s->io + PAGE_SIZE - off,
nand.c:                            MIN(OOB_SIZE, off + s->iolen - PAGE_SIZE));
nand.c:        if (bdrv_write(s->bdrv, sector, iobuf, PAGE_SECTORS) == -1)
nand.c:        off = PAGE_START(s->addr) + (s->addr & PAGE_MASK) + s->offset;
nand.c:        if (bdrv_read(s->bdrv, sector, iobuf, PAGE_SECTORS + 2) == -1) {
nand.c:        memcpy(iobuf + soff, s->io, s->iolen);
nand.c:        if (bdrv_write(s->bdrv, sector, iobuf, PAGE_SECTORS + 2) == -1)
nand.c:    s->offset = 0;
nand.c:    addr = s->addr & ~((1 << (ADDR_SHIFT + s->erase_shift)) - 1);
nand.c:    if (PAGE(addr) >= s->pages)
nand.c:    if (!s->bdrv) {
nand.c:        memset(s->storage + PAGE_START(addr),
nand.c:                        0xff, (PAGE_SIZE + OOB_SIZE) << s->erase_shift);
nand.c:    } else if (s->mem_oob) {
nand.c:        memset(s->storage + (PAGE(addr) << OOB_SHIFT),
nand.c:                        0xff, OOB_SIZE << s->erase_shift);
nand.c:        page = SECTOR(addr + (ADDR_SHIFT + s->erase_shift));
nand.c:            if (bdrv_write(s->bdrv, i, iobuf, 1) == -1)
nand.c:        if (bdrv_read(s->bdrv, page, iobuf, 1) == -1)
nand.c:        if (bdrv_write(s->bdrv, page, iobuf, 1) == -1)
nand.c:        for (addr += ((PAGE_SIZE + OOB_SIZE) << s->erase_shift) - 0x200;
nand.c:            if (bdrv_write(s->bdrv, i >> 9, iobuf, 1) == -1)
nand.c:        if (bdrv_read(s->bdrv, page, iobuf, 1) == -1)
nand.c:        memset(iobuf, 0xff, ((addr - 1) & 0x1ff) + 1);
nand.c:        if (bdrv_write(s->bdrv, page, iobuf, 1) == -1)
nand.c:    if (PAGE(addr) >= s->pages)
nand.c:    if (s->bdrv) {
nand.c:        if (s->mem_oob) {
nand.c:            if (bdrv_read(s->bdrv, SECTOR(addr), s->io, PAGE_SECTORS) == -1)
nand.c:            memcpy(s->io + SECTOR_OFFSET(s->addr) + PAGE_SIZE,
nand.c:                            s->storage + (PAGE(s->addr) << OOB_SHIFT),
nand.c:            s->ioaddr = s->io + SECTOR_OFFSET(s->addr) + offset;
nand.c:            if (bdrv_read(s->bdrv, PAGE_START(addr) >> 9,
nand.c:                                    s->io, (PAGE_SECTORS + 2)) == -1)
nand.c:            s->ioaddr = s->io + (PAGE_START(addr) & 0x1ff) + offset;
nand.c:        memcpy(s->io, s->storage + PAGE_START(s->addr) +
nand.c:                        offset, PAGE_SIZE + OOB_SIZE - offset);
nand.c:        s->ioaddr = s->io;
nand.c:    s->addr &= PAGE_SIZE - 1;
nand.c:    s->addr += PAGE_SIZE;
nand.c:    s->oob_shift = PAGE_SHIFT - 5;
nand.c:    s->pages = s->size >> PAGE_SHIFT;
nand.c:    s->addr_shift = ADDR_SHIFT;
nand.c:    s->blk_erase = glue(nand_blk_erase_, PAGE_SIZE);
nand.c:    s->blk_write = glue(nand_blk_write_, PAGE_SIZE);
nand.c:    s->blk_load = glue(nand_blk_load_, PAGE_SIZE);
ne2000.c: * Copyright (c) 2003-2004 Fabrice Bellard
ne2000.c:#define E8390_PAGE1	0x40	/* using the two high-order bits */
ne2000.c:/* Bits in EN0_ISR - Interrupt status register */
ne2000.c:#define ENTSR_OWC 0x80  /* There was an out-of-window collision. */
ne2000.c:    s->isr = ENISR_RESET;
ne2000.c:    memcpy(s->mem, &s->c.macaddr, 6);
ne2000.c:    s->mem[14] = 0x57;
ne2000.c:    s->mem[15] = 0x57;
ne2000.c:    for(i = 15;i >= 0; i--) {
ne2000.c:        s->mem[2 * i] = s->mem[i];
ne2000.c:        s->mem[2 * i + 1] = s->mem[i];
ne2000.c:    isr = (s->isr & s->imr) & 0x7f;
ne2000.c:	   isr ? 1 : 0, s->isr, s->imr);
ne2000.c:    qemu_set_irq(s->irq, (isr != 0));
ne2000.c:    index = s->curpag << 8;
ne2000.c:    boundary = s->boundary << 8;
ne2000.c:        avail = boundary - index;
ne2000.c:        avail = (s->stop - s->start) - (index - boundary);
ne2000.c:    NE2000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
ne2000.c:    if (s->cmd & E8390_STOP)
ne2000.c:    NE2000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
ne2000.c:    if (s->cmd & E8390_STOP || ne2000_buffer_full(s))
ne2000.c:        return -1;
ne2000.c:    if (s->rxcr & 0x10) {
ne2000.c:            if (!(s->rxcr & 0x04))
ne2000.c:            if (!(s->rxcr & 0x08))
ne2000.c:            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))
ne2000.c:        } else if (s->mem[0] == buf[0] &&
ne2000.c:                   s->mem[2] == buf[1] &&
ne2000.c:                   s->mem[4] == buf[2] &&
ne2000.c:                   s->mem[6] == buf[3] &&
ne2000.c:                   s->mem[8] == buf[4] &&
ne2000.c:                   s->mem[10] == buf[5]) {
ne2000.c:        memset(buf1 + size, 0, MIN_BUF_SIZE - size);
ne2000.c:    index = s->curpag << 8;
ne2000.c:    if (next >= s->stop)
ne2000.c:        next -= (s->stop - s->start);
ne2000.c:    p = s->mem + index;
ne2000.c:    s->rsr = ENRSR_RXOK; /* receive status */
ne2000.c:        s->rsr |= ENRSR_PHY;
ne2000.c:    p[0] = s->rsr;
ne2000.c:        if (index <= s->stop)
ne2000.c:            avail = s->stop - index;
ne2000.c:        memcpy(s->mem + index, buf, len);
ne2000.c:        if (index == s->stop)
ne2000.c:            index = s->start;
ne2000.c:        size -= len;
ne2000.c:    s->curpag = next >> 8;
ne2000.c:    s->isr |= ENISR_RX;
ne2000.c:        s->cmd = val;
ne2000.c:            s->isr &= ~ENISR_RESET;
ne2000.c:                s->rcnt == 0) {
ne2000.c:                s->isr |= ENISR_RDC;
ne2000.c:                index = (s->tpsr << 8);
ne2000.c:                    index -= NE2000_PMEM_SIZE;
ne2000.c:                if (index + s->tcnt <= NE2000_PMEM_END) {
ne2000.c:                    qemu_send_packet(&s->nic->nc, s->mem + index, s->tcnt);
ne2000.c:                s->tsr = ENTSR_PTX;
ne2000.c:                s->isr |= ENISR_TX;
ne2000.c:                s->cmd &= ~E8390_TRANS;
ne2000.c:        page = s->cmd >> 6;
ne2000.c:            s->start = val << 8;
ne2000.c:            s->stop = val << 8;
ne2000.c:            s->boundary = val;
ne2000.c:            s->imr = val;
ne2000.c:            s->tpsr = val;
ne2000.c:            s->tcnt = (s->tcnt & 0xff00) | val;
ne2000.c:            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);
ne2000.c:            s->rsar = (s->rsar & 0xff00) | val;
ne2000.c:            s->rsar = (s->rsar & 0x00ff) | (val << 8);
ne2000.c:            s->rcnt = (s->rcnt & 0xff00) | val;
ne2000.c:            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);
ne2000.c:            s->rxcr = val;
ne2000.c:            s->dcfg = val;
ne2000.c:            s->isr &= ~(val & 0x7f);
ne2000.c:            s->phys[offset - EN1_PHYS] = val;
ne2000.c:            s->curpag = val;
ne2000.c:            s->mult[offset - EN1_MULT] = val;
ne2000.c:        ret = s->cmd;
ne2000.c:        page = s->cmd >> 6;
ne2000.c:            ret = s->tsr;
ne2000.c:            ret = s->boundary;
ne2000.c:            ret = s->isr;
ne2000.c:	    ret = s->rsar & 0x00ff;
ne2000.c:	    ret = s->rsar >> 8;
ne2000.c:            ret = s->phys[offset - EN1_PHYS];
ne2000.c:            ret = s->curpag;
ne2000.c:            ret = s->mult[offset - EN1_MULT];
ne2000.c:            ret = s->rsr;
ne2000.c:            ret = s->start >> 8;
ne2000.c:            ret = s->stop >> 8;
ne2000.c:        s->mem[addr] = val;
ne2000.c:        *(uint16_t *)(s->mem + addr) = cpu_to_le16(val);
ne2000.c:        cpu_to_le32wu((uint32_t *)(s->mem + addr), val);
ne2000.c:        return s->mem[addr];
ne2000.c:        return le16_to_cpu(*(uint16_t *)(s->mem + addr));
ne2000.c:        return le32_to_cpupu((uint32_t *)(s->mem + addr));
ne2000.c:    s->rsar += len;
ne2000.c:    if (s->rsar == s->stop)
ne2000.c:        s->rsar = s->start;
ne2000.c:    if (s->rcnt <= len) {
ne2000.c:        s->rcnt = 0;
ne2000.c:        s->isr |= ENISR_RDC;
ne2000.c:        s->rcnt -= len;
ne2000.c:    if (s->rcnt == 0)
ne2000.c:    if (s->dcfg & 0x01) {
ne2000.c:        ne2000_mem_writew(s, s->rsar, val);
ne2000.c:        ne2000_mem_writeb(s, s->rsar, val);
ne2000.c:    if (s->dcfg & 0x01) {
ne2000.c:        ret = ne2000_mem_readw(s, s->rsar);
ne2000.c:        ret = ne2000_mem_readb(s, s->rsar);
ne2000.c:    if (s->rcnt == 0)
ne2000.c:    ne2000_mem_writel(s, s->rsar, val);
ne2000.c:    ret = ne2000_mem_readl(s, s->rsar);
ne2000.c:        s->rxcr = 0x0c;
ne2000.c:    NE2000State *s = &d->ne2000;
ne2000.c:    NE2000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
ne2000.c:    s->nic = NULL;
ne2000.c:    pci_conf = d->dev.config;
ne2000.c:    pci_register_bar(&d->dev, 0, 0x100,
ne2000.c:    s = &d->ne2000;
ne2000.c:    s->irq = d->dev.irq[0];
ne2000.c:    qemu_macaddr_default_if_unset(&s->c.macaddr);
ne2000.c:    s->nic = qemu_new_nic(&net_ne2000_info, &s->c,
ne2000.c:                          pci_dev->qdev.info->name, pci_dev->qdev.id, s);
ne2000.c:    qemu_format_nic_info_str(&s->nic->nc, s->c.macaddr.a);
ne2000.c:    if (!pci_dev->qdev.hotplugged) {
ne2000.c:            rom_add_option("pxe-ne2k_pci.bin");
ne2000.c:    NE2000State *s = &d->ne2000;
ne2000.c:    qemu_del_vlan_client(&s->nic->nc);
ne2000-isa.c: * QEMU NE2000 emulation -- isa bus windup
ne2000-isa.c: * Copyright (c) 2003-2004 Fabrice Bellard
ne2000-isa.c:    NE2000State *s = DO_UPCAST(NICState, nc, nc)->opaque;
ne2000-isa.c:    s->nic = NULL;
ne2000-isa.c:    NE2000State *s = &isa->ne2000;
ne2000-isa.c:    register_ioport_write(isa->iobase, 16, 1, ne2000_ioport_write, s);
ne2000-isa.c:    register_ioport_read(isa->iobase, 16, 1, ne2000_ioport_read, s);
ne2000-isa.c:    register_ioport_write(isa->iobase + 0x10, 1, 1, ne2000_asic_ioport_write, s);
ne2000-isa.c:    register_ioport_read(isa->iobase + 0x10, 1, 1, ne2000_asic_ioport_read, s);
ne2000-isa.c:    register_ioport_write(isa->iobase + 0x10, 2, 2, ne2000_asic_ioport_write, s);
ne2000-isa.c:    register_ioport_read(isa->iobase + 0x10, 2, 2, ne2000_asic_ioport_read, s);
ne2000-isa.c:    register_ioport_write(isa->iobase + 0x1f, 1, 1, ne2000_reset_ioport_write, s);
ne2000-isa.c:    register_ioport_read(isa->iobase + 0x1f, 1, 1, ne2000_reset_ioport_read, s);
ne2000-isa.c:    isa_init_irq(dev, &s->irq, isa->isairq);
ne2000-isa.c:    qemu_macaddr_default_if_unset(&s->c.macaddr);
ne2000-isa.c:    s->nic = qemu_new_nic(&net_ne2000_isa_info, &s->c,
ne2000-isa.c:                          dev->qdev.info->name, dev->qdev.id, s);
ne2000-isa.c:    qemu_format_nic_info_str(&s->nic->nc, s->c.macaddr.a);
ne2000-isa.c:    qdev_prop_set_uint32(&dev->qdev, "iobase", base);
ne2000-isa.c:    qdev_prop_set_uint32(&dev->qdev, "irq",    irq);
ne2000-isa.c:    qdev_set_nic_properties(&dev->qdev, nd);
ne2000-isa.c:    qdev_init_nofail(&dev->qdev);
nseries.c: * Nokia N-series internet tablets.
nseries.c:#include "qemu-common.h"
nseries.c:#include "arm-misc.h"
nseries.c:    qemu_irq *mmc_cs = qemu_allocate_irqs(n800_mmc_cs_cb, s->cpu->mmc, 1);
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_MMC_CS_GPIO, mmc_cs[0]);
nseries.c:    qemu_irq_lower(omap2_gpio_in_get(s->cpu->gpif, N800_BAT_COVER_GPIO)[0]);
nseries.c:    MAEMO_CAL_HEADER('w', 'l', 'a', 'n', '-', 'm', 'a', 'c')
nseries.c:    MAEMO_CAL_HEADER('b', 't', '-', 'i', 'd', 0, 0, 0)
nseries.c:    omap_gpmc_attach(s->cpu->gpmc, N8X0_ONENAND_CS, 0, onenand_base_update,
nseries.c:                    (s->nand = onenand_init(0xec4800, 1,
nseries.c:                                            omap2_gpio_in_get(s->cpu->gpif,
nseries.c:    otp_region = onenand_raw_otp(s->nand);
nseries.c:    qemu_irq tmp_irq = omap2_gpio_in_get(s->cpu->gpif, N8X0_TMP105_GPIO)[0];
nseries.c:    s->i2c = omap_i2c_bus(s->cpu->i2c[0]);
nseries.c:    dev = i2c_create_slave(s->i2c, "twl92230", N8X0_MENELAUS_ADDR);
nseries.c:    qdev_connect_gpio_out(dev, 3, s->cpu->irq[0][OMAP_INT_24XX_SYS_NIRQ]);
nseries.c:    dev = i2c_create_slave(s->i2c, "tmp105", N8X0_TMP105_ADDR);
nseries.c:    .a = { 14560, -68, -3455208, -39, -9621, 35152972, 65536 },
nseries.c:    .a = { 15041, 148, -4731056, 171, -10238, 35933380, 65536 },
nseries.c:    int code = s->keymap[keycode & 0x7f];
nseries.c:    if (code == -1) {
nseries.c:            retu_key_event(s->retu, !(keycode & 0x80));
nseries.c:    tsc210x_key_event(s->ts.chip, code, !(keycode & 0x80));
nseries.c:    -1,
nseries.c:    -1,
nseries.c:    -1,
nseries.c:    -1,
nseries.c:    66,	/* Zoom- (F8) */
nseries.c:    -1,
nseries.c:    qemu_irq kbirq = omap2_gpio_in_get(s->cpu->gpif, N800_TSC_KP_IRQ_GPIO)[0];
nseries.c:    qemu_irq dav = omap2_gpio_in_get(s->cpu->gpif, N800_TSC_TS_GPIO)[0];
nseries.c:    s->ts.chip = tsc2301_init(penirq, kbirq, dav);
nseries.c:    s->ts.opaque = s->ts.chip->opaque;
nseries.c:    s->ts.txrx = tsc210x_txrx;
nseries.c:        s->keymap[i] = -1;
nseries.c:            s->keymap[n800_keys[i]] = i;
nseries.c:    tsc210x_set_transform(s->ts.chip, &n800_pointercal);
nseries.c:    qemu_irq pintdav = omap2_gpio_in_get(s->cpu->gpif, N810_TSC_TS_GPIO)[0];
nseries.c:    s->ts.opaque = tsc2005_init(pintdav);
nseries.c:    s->ts.txrx = tsc2005_txrx;
nseries.c:    tsc2005_set_transform(s->ts.opaque, &n810_pointercal);
nseries.c:    int code = s->keymap[keycode & 0x7f];
nseries.c:    if (code == -1) {
nseries.c:            retu_key_event(s->retu, !(keycode & 0x80));
nseries.c:    lm832x_key_event(s->kbd, code, !(keycode & 0x80));
nseries.c:    [0x23] = 12,	/* - (Minus) */
nseries.c:    [0x2f] = 66,	/* Zoom- (F8) */
nseries.c:    qemu_irq kbd_irq = omap2_gpio_in_get(s->cpu->gpif, N810_KEYBOARD_GPIO)[0];
nseries.c:        s->keymap[i] = -1;
nseries.c:            s->keymap[n810_keys[i]] = i;
nseries.c:     * should happen in n8x0_i2c_setup and s->kbd be initialised here.  */
nseries.c:    dev = i2c_create_slave(s->i2c, "lm8323", N810_LM8323_ADDR);
nseries.c:/* LCD MIPI DBI-C controller (URAL) */
nseries.c:    if (!s->sleep)
nseries.c:    s->pm = 0;
nseries.c:    s->cmd = 0;
nseries.c:    s->sleep = 1;
nseries.c:    s->booster = 0;
nseries.c:    s->selfcheck =
nseries.c:    s->te = 0;
nseries.c:    s->partial = 0;
nseries.c:    s->normal = 1;
nseries.c:    s->vscr = 0;
nseries.c:    s->invert = 0;
nseries.c:    s->onoff = 1;
nseries.c:    s->gamma = 0;
nseries.c:    if (s->p >= ARRAY_SIZE(s->resp))
nseries.c:        ret = s->resp[s->p ++];
nseries.c:    if (s->pm --> 0)
nseries.c:        s->param[s->pm] = cmd;
nseries.c:        s->cmd = cmd;
nseries.c:    switch (s->cmd) {
nseries.c:        s->booster = 0;
nseries.c:        s->booster = 1;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = (s->id >> 16) & 0xff;
nseries.c:        s->resp[1] = (s->id >>  8) & 0xff;
nseries.c:        s->resp[2] = (s->id >>  0) & 0xff;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = 0x01;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = s->booster << 7;
nseries.c:        s->resp[1] = (5 << 4) | (s->partial << 2) |
nseries.c:                (s->sleep << 1) | s->normal;
nseries.c:        s->resp[2] = (s->vscr << 7) | (s->invert << 5) |
nseries.c:                (s->onoff << 2) | (s->te << 1) | (s->gamma >> 2);
nseries.c:        s->resp[3] = s->gamma << 6;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = (s->onoff << 2) | (s->normal << 3) | (s->sleep << 4) |
nseries.c:                (s->partial << 5) | (s->sleep << 6) | (s->booster << 7);
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = 0;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = 5;	/* 65K colours */
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = (s->invert << 5) | (s->vscr << 7) | s->gamma;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = s->te << 7;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = s->selfcheck;
nseries.c:        s->sleep = 1;
nseries.c:        s->sleep = 0;
nseries.c:        s->selfcheck ^= 1 << 6;	/* POFF self-diagnosis Ok */
nseries.c:        s->partial = 1;
nseries.c:        s->normal = 0;
nseries.c:        s->vscr = 0;
nseries.c:        s->partial = 0;
nseries.c:        s->normal = 1;
nseries.c:        s->vscr = 0;
nseries.c:        s->invert = 0;
nseries.c:        s->invert = 1;
nseries.c:        if (s->pm < 0)
nseries.c:            s->pm = 1;
nseries.c:        if (!s->pm)
nseries.c:            s->gamma = ffs(s->param[0] & 0xf) - 1;
nseries.c:        else if (s->pm < 0)
nseries.c:            s->pm = 1;
nseries.c:        s->onoff = 0;
nseries.c:        s->onoff = 1;
nseries.c:        s->te = 0;
nseries.c:        if (!s->pm)
nseries.c:            s->te = 1;
nseries.c:        else if (s->pm < 0)
nseries.c:            s->pm = 1;
nseries.c:        s->partial = 0;
nseries.c:        s->normal = 0;
nseries.c:        s->vscr = 1;
nseries.c:        if (s->pm < 0)
nseries.c:            s->pm = 2;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = 0;
nseries.c:        s->resp[1] = 1;
nseries.c:        if (s->pm < 0)
nseries.c:            s->pm = 2;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = (s->id >> 16) & 0xff;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = (s->id >>  8) & 0xff;
nseries.c:        s->p = 0;
nseries.c:        s->resp[0] = (s->id >>  0) & 0xff;
nseries.c:        fprintf(stderr, "%s: unknown command %02x\n", __FUNCTION__, s->cmd);
nseries.c:    s->id = 0x838f03;
nseries.c:    void *tsc = s->ts.opaque;
nseries.c:    omap_mcspi_attach(s->cpu->mcspi[0], s->ts.txrx, tsc, 0);
nseries.c:    omap_mcspi_attach(s->cpu->mcspi[0], mipid_txrx, mipid, 1);
nseries.c:    chip->write(chip->opaque, 0, 0x2a);		/* LCD Width register */
nseries.c:    chip->write(chip->opaque, 1, 0x64);
nseries.c:    chip->write(chip->opaque, 0, 0x2c);		/* LCD HNDP register */
nseries.c:    chip->write(chip->opaque, 1, 0x1e);
nseries.c:    chip->write(chip->opaque, 0, 0x2e);		/* LCD Height 0 register */
nseries.c:    chip->write(chip->opaque, 1, 0xe0);
nseries.c:    chip->write(chip->opaque, 0, 0x30);		/* LCD Height 1 register */
nseries.c:    chip->write(chip->opaque, 1, 0x01);
nseries.c:    chip->write(chip->opaque, 0, 0x32);		/* LCD VNDP register */
nseries.c:    chip->write(chip->opaque, 1, 0x06);
nseries.c:    chip->write(chip->opaque, 0, 0x68);		/* Display Mode register */
nseries.c:    chip->write(chip->opaque, 1, 1);		/* Enable bit */
nseries.c:    chip->write(chip->opaque, 0, 0x6c);	
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Input X Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Input X Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Input Y Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Input Y Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x1f);		/* Input X End Position */
nseries.c:    chip->write(chip->opaque, 1, 0x03);		/* Input X End Position */
nseries.c:    chip->write(chip->opaque, 1, 0xdf);		/* Input Y End Position */
nseries.c:    chip->write(chip->opaque, 1, 0x01);		/* Input Y End Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Output X Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Output X Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Output Y Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x00);		/* Output Y Start Position */
nseries.c:    chip->write(chip->opaque, 1, 0x1f);		/* Output X End Position */
nseries.c:    chip->write(chip->opaque, 1, 0x03);		/* Output X End Position */
nseries.c:    chip->write(chip->opaque, 1, 0xdf);		/* Output Y End Position */
nseries.c:    chip->write(chip->opaque, 1, 0x01);		/* Output Y End Position */
nseries.c:    chip->write(chip->opaque, 1, 0x01);		/* Input Data Format */
nseries.c:    chip->write(chip->opaque, 1, 0x01);		/* Data Source Select */
nseries.c:    chip->block(chip->opaque, 1, fb_blank, 800 * 480 * 2, 800);
nseries.c:    s->blizzard.opaque = s1d13745_init(NULL);
nseries.c:    s->blizzard.block = s1d13745_write_block;
nseries.c:    s->blizzard.write = s1d13745_write;
nseries.c:    s->blizzard.read = s1d13745_read;
nseries.c:    omap_rfbi_attach(s->cpu->dss, 0, &s->blizzard);
nseries.c:    qemu_irq dat_out = omap2_gpio_in_get(s->cpu->gpif, N8X0_CBUS_DAT_GPIO)[0];
nseries.c:    qemu_irq retu_irq = omap2_gpio_in_get(s->cpu->gpif, N8X0_RETU_GPIO)[0];
nseries.c:    qemu_irq tahvo_irq = omap2_gpio_in_get(s->cpu->gpif, N8X0_TAHVO_GPIO)[0];
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_CBUS_CLK_GPIO, cbus->clk);
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_CBUS_DAT_GPIO, cbus->dat);
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_CBUS_SEL_GPIO, cbus->sel);
nseries.c:    cbus_attach(cbus, s->retu = retu_init(retu_irq, 1));
nseries.c:    cbus_attach(cbus, s->tahvo = tahvo_init(tahvo_irq, 1));
nseries.c:                    omap2_gpio_in_get(s->cpu->gpif,
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_BT_RESET_GPIO,
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_BT_WKUP_GPIO,
nseries.c:    omap_uart_attach(s->cpu->uart[BT_UART], radio);
nseries.c:    tusb6010_power(s->usb, level);
nseries.c:    qemu_irq tusb_irq = omap2_gpio_in_get(s->cpu->gpif, N8X0_TUSB_INT_GPIO)[0];
nseries.c:    omap_gpmc_attach(s->cpu->gpmc, N8X0_USB_ASYNC_CS,
nseries.c:    omap_gpmc_attach(s->cpu->gpmc, N8X0_USB_SYNC_CS,
nseries.c:    s->usb = tusb;
nseries.c:    omap2_gpio_out_set(s->cpu->gpif, N8X0_TUSB_ENABLE_GPIO, tusb_pwr);
nseries.c: * - used when we want to run the main bootloader in emulation.  This
nseries.c:    strcpy((void *) (p + 9), "RX-34");
nseries.c:    stl_raw(p ++, OMAP2_SRAM_BASE | (((void *) v - sram_base) & 0xffff));
nseries.c:    stl_raw(v ++, XLDR_LL_UART);	/* UART number (1 - 3) */
nseries.c:    n800_dss_init(&s->blizzard);
nseries.c:    s->cpu->env->regs[15] = s->cpu->env->boot_info->loader_start;
nseries.c:    s->cpu->env->GE = 0x5;
nseries.c:    if (s->kbd)
nseries.c:        qemu_irq_raise(omap2_gpio_in_get(s->cpu->gpif, N810_SLIDE_GPIO)[0]);
nseries.c:    for (; gpiosw->name; gpiosw ++) {
nseries.c:        strcpy((void *) w, gpiosw->name);	/* char name[12] */
nseries.c:        stw_raw(w ++, gpiosw->line);		/* u16 gpio */
nseries.c:        stw_raw(w ++, gpiosw->type);
nseries.c:    stw_raw(w ++, -1);				/* s16 spi_cs_gpio */
nseries.c:        stw_raw(w ++, -1);			/* s16 power_pin */
nseries.c:        stw_raw(w ++, -1);			/* s16 switch_pin */
nseries.c:        stw_raw(w ++, -1);			/* s16 wp_pin */
nseries.c:        stw_raw(w ++, -1);			/* s16 power_pin */
nseries.c:        stw_raw(w ++, -1);			/* s16 switch_pin */
nseries.c:        stw_raw(w ++, -1);			/* s16 wp_pin */
nseries.c:    for (; partition->name; partition ++) {
nseries.c:        strcpy((void *) w, partition->name);	/* char name[16] */
nseries.c:        stl_raw(l ++, partition->size);		/* unsigned int size */
nseries.c:        stl_raw(l ++, partition->offset);	/* unsigned int offset */
nseries.c:        stl_raw(l ++, partition->mask);		/* unsigned int mask_flags */
nseries.c:    tag = (model == 810) ? "RX-44" : "RX-34";
nseries.c:    strcpy((void *) w, "hw-build");		/* char component[12] */
nseries.c:    tag = (model == 810) ? "1.1.10-qemu" : "1.1.6-qemu";
nseries.c:    return (void *) w - p;
nseries.c:    int sdram_size = binfo->ram_size;
nseries.c:    s->cpu = omap2420_mpu_init(sdram_size, cpu_model);
nseries.c:     * (somewhere on i2c - maybe N800-only)
nseries.c:    s->cpu->env->regs[15] = 0;
nseries.c:        binfo->kernel_filename = kernel_filename;
nseries.c:        binfo->kernel_cmdline = kernel_cmdline;
nseries.c:        binfo->initrd_filename = initrd_filename;
nseries.c:        arm_load_kernel(s->cpu->env, binfo);
nseries.c:        s->cpu->env->regs[15] = OMAP2_Q2_BASE + 0x400000;
nseries.c:                                       sdram_size - 0x400000);
nseries.c:    ds->surface = qemu_resize_displaysurface(ds, 800, 480);
nseries.c:    .desc = "Nokia N800 tablet aka. RX-34 (OMAP2420)",
nseries.c:    .desc = "Nokia N810 tablet aka. RX-44 (OMAP2420)",
omap1.c: * Copyright (C) 2006-2008 Andrzej Zaborowski  <balrog@zabor.org>
omap1.c:#include "arm-misc.h"
omap1.c:#include "qemu-timer.h"
omap1.c:#include "qemu-char.h"
omap1.c:/* We use pc-style serial ports.  */
omap1.c:     * IRQ_N-1,...,IRQ_0. */
omap1.c:    for (j = 0; j < s->nbanks; ++j) {
omap1.c:        level = s->bank[j].irqs & ~s->bank[j].mask &
omap1.c:                (is_fiq ? s->bank[j].fiq : ~s->bank[j].fiq);
omap1.c:        for (f = ffs(level), i = f - 1, level >>= f - 1; f; i += f,
omap1.c:            p = s->bank[j].priority[i];
omap1.c:    s->sir_intr[is_fiq] = sir_intr;
omap1.c:    for (i = 0; i < s->nbanks; ++i)
omap1.c:        has_intr |= s->bank[i].irqs & ~s->bank[i].mask &
omap1.c:                (is_fiq ? s->bank[i].fiq : ~s->bank[i].fiq);
omap1.c:    if (s->new_agr[is_fiq] & has_intr & s->mask) {
omap1.c:        s->new_agr[is_fiq] = 0;
omap1.c:        qemu_set_irq(s->parent_intr[is_fiq], 1);
omap1.c:    struct omap_intr_handler_bank_s *bank = &ih->bank[irq >> 5];
omap1.c:        rise = ~bank->irqs & (1 << n);
omap1.c:        if (~bank->sens_edge & (1 << n))
omap1.c:            rise &= ~bank->inputs;
omap1.c:        bank->inputs |= (1 << n);
omap1.c:            bank->irqs |= rise;
omap1.c:        rise = bank->sens_edge & bank->irqs & (1 << n);
omap1.c:        bank->irqs &= ~rise;
omap1.c:        bank->inputs &= ~(1 << n);
omap1.c:    struct omap_intr_handler_bank_s *bank = &ih->bank[irq >> 5];
omap1.c:        rise = ~bank->inputs & (1 << n);
omap1.c:            bank->irqs |= bank->inputs |= rise;
omap1.c:        bank->irqs = (bank->inputs &= ~(1 << n)) | bank->swi;
omap1.c:    struct omap_intr_handler_bank_s *bank = &s->bank[bank_no];
omap1.c:        return bank->irqs;
omap1.c:        return bank->mask;
omap1.c:        line_no = s->sir_intr[(offset - 0x10) >> 2];
omap1.c:        bank = &s->bank[line_no >> 5];
omap1.c:        if (((bank->sens_edge >> i) & 1) == INT_FALLING_EDGE)
omap1.c:            bank->irqs &= ~(1 << i);
omap1.c:        i = (offset - 0x1c) >> 2;
omap1.c:        return (bank->priority[i] << 2) |
omap1.c:                (((bank->sens_edge >> i) & 1) << 1) |
omap1.c:                ((bank->fiq >> i) & 1);
omap1.c:    struct omap_intr_handler_bank_s *bank = &s->bank[bank_no];
omap1.c:        /* Important: ignore the clearing if the IRQ is level-triggered and
omap1.c:        bank->irqs &= value | (bank->inputs & bank->sens_edge);
omap1.c:        bank->mask = value;
omap1.c:            qemu_set_irq(s->parent_intr[1], 0);
omap1.c:            s->new_agr[1] = ~0;
omap1.c:            qemu_set_irq(s->parent_intr[0], 0);
omap1.c:            s->new_agr[0] = ~0;
omap1.c:        i = (offset - 0x1c) >> 2;
omap1.c:        bank->priority[i] = (value >> 2) & 0x1f;
omap1.c:        bank->sens_edge &= ~(1 << i);
omap1.c:        bank->sens_edge |= ((value >> 1) & 1) << i;
omap1.c:        bank->fiq &= ~(1 << i);
omap1.c:        bank->fiq |= (value & 1) << i;
omap1.c:    for (i = 0; i < s->nbanks; ++i){
omap1.c:        s->bank[i].irqs = 0x00000000;
omap1.c:        s->bank[i].mask = 0xffffffff;
omap1.c:        s->bank[i].sens_edge = 0x00000000;
omap1.c:        s->bank[i].fiq = 0x00000000;
omap1.c:        s->bank[i].inputs = 0x00000000;
omap1.c:        s->bank[i].swi = 0x00000000;
omap1.c:        memset(s->bank[i].priority, 0, sizeof(s->bank[i].priority));
omap1.c:        if (s->level_only)
omap1.c:            s->bank[i].sens_edge = 0xffffffff;
omap1.c:    s->new_agr[0] = ~0;
omap1.c:    s->new_agr[1] = ~0;
omap1.c:    s->sir_intr[0] = 0;
omap1.c:    s->sir_intr[1] = 0;
omap1.c:    s->autoidle = 0;
omap1.c:    s->mask = ~0;
omap1.c:    qemu_set_irq(s->parent_intr[0], 0);
omap1.c:    qemu_set_irq(s->parent_intr[1], 0);
omap1.c:    s->parent_intr[0] = parent_irq;
omap1.c:    s->parent_intr[1] = parent_fiq;
omap1.c:    s->nbanks = nbanks;
omap1.c:    s->pins = qemu_allocate_irqs(omap_set_intr, s, nbanks * 32);
omap1.c:        *pins = s->pins;
omap1.c:        if (bank_no < s->nbanks) {
omap1.c:            bank = &s->bank[bank_no];
omap1.c:        return (s->autoidle >> 2) & 1;
omap1.c:        return s->sir_intr[0];
omap1.c:        return s->sir_intr[1];
omap1.c:        return (!s->mask) << 2;					/* GLOBALMASK */
omap1.c:        return s->autoidle & 3;
omap1.c:    /* Per-bank registers */
omap1.c:        return bank->inputs;
omap1.c:        return bank->mask;
omap1.c:        return bank->swi;
omap1.c:        return bank->irqs & ~bank->mask & ~bank->fiq;
omap1.c:        return bank->irqs & ~bank->mask & bank->fiq;
omap1.c:    /* Per-line registers */
omap1.c:        bank_no = (offset - 0x100) >> 7;
omap1.c:        if (bank_no > s->nbanks)
omap1.c:        bank = &s->bank[bank_no];
omap1.c:        return (bank->priority[line_no] << 2) |
omap1.c:                ((bank->fiq >> line_no) & 1);
omap1.c:        if (bank_no < s->nbanks) {
omap1.c:            bank = &s->bank[bank_no];
omap1.c:        s->autoidle &= 4;
omap1.c:        s->autoidle |= (value & 1) << 2;
omap1.c:        s->mask = (value & 4) ? 0 : ~0;				/* GLOBALMASK */
omap1.c:            qemu_set_irq(s->parent_intr[1], 0);
omap1.c:            s->new_agr[1] = ~0;
omap1.c:            qemu_set_irq(s->parent_intr[0], 0);
omap1.c:            s->new_agr[0] = ~0;
omap1.c:        s->autoidle &= ~3;
omap1.c:        s->autoidle |= value & 3;
omap1.c:    /* Per-bank registers */
omap1.c:        bank->mask = value;
omap1.c:        bank->mask &= ~value;
omap1.c:        bank->mask |= value;
omap1.c:        bank->irqs |= bank->swi |= value;
omap1.c:        bank->swi &= ~value;
omap1.c:        bank->irqs = bank->swi & bank->inputs;
omap1.c:    /* Per-line registers */
omap1.c:        bank_no = (offset - 0x100) >> 7;
omap1.c:        if (bank_no > s->nbanks)
omap1.c:        bank = &s->bank[bank_no];
omap1.c:        bank->priority[line_no] = (value >> 2) & 0x3f;
omap1.c:        bank->fiq &= ~(1 << line_no);
omap1.c:        bank->fiq |= (value & 1) << line_no;
omap1.c:    s->parent_intr[0] = parent_irq;
omap1.c:    s->parent_intr[1] = parent_fiq;
omap1.c:    s->nbanks = nbanks;
omap1.c:    s->level_only = 1;
omap1.c:    s->pins = qemu_allocate_irqs(omap_set_intr_noedge, s, nbanks * 32);
omap1.c:        *pins = s->pins;
omap1.c:    uint64_t distance = qemu_get_clock(vm_clock) - timer->time;
omap1.c:    if (timer->st && timer->enable && timer->rate)
omap1.c:        return timer->val - muldiv64(distance >> (timer->ptv + 1),
omap1.c:                                     timer->rate, get_ticks_per_sec());
omap1.c:        return timer->val;
omap1.c:    timer->val = omap_timer_read(timer);
omap1.c:    timer->time = qemu_get_clock(vm_clock);
omap1.c:    if (timer->enable && timer->st && timer->rate) {
omap1.c:        timer->val = timer->reset_val;	/* Should skip this on clk enable */
omap1.c:        expires = muldiv64((uint64_t) timer->val << (timer->ptv + 1),
omap1.c:                           get_ticks_per_sec(), timer->rate);
omap1.c:         * auto-reload isn't set, then fire immediately.  This is a hack
omap1.c:        if (expires > (get_ticks_per_sec() >> 10) || timer->ar)
omap1.c:            qemu_mod_timer(timer->timer, timer->time + expires);
omap1.c:            qemu_bh_schedule(timer->tick);
omap1.c:        qemu_del_timer(timer->timer);
omap1.c:    if (!timer->ar) {
omap1.c:        timer->val = 0;
omap1.c:        timer->st = 0;
omap1.c:    if (timer->it_ena)
omap1.c:        /* Edge-triggered irq */
omap1.c:        qemu_irq_pulse(timer->irq);
omap1.c:    timer->rate = on ? omap_clk_getrate(timer->clk) : 0;
omap1.c:    omap_clk_adduser(timer->clk,
omap1.c:    timer->rate = omap_clk_getrate(timer->clk);
omap1.c:        return (s->enable << 5) | (s->ptv << 2) | (s->ar << 1) | s->st;
omap1.c:        s->enable = (value >> 5) & 1;
omap1.c:        s->ptv = (value >> 2) & 7;
omap1.c:        s->ar = (value >> 1) & 1;
omap1.c:        s->st = value & 1;
omap1.c:        s->reset_val = value;
omap1.c:    qemu_del_timer(s->timer);
omap1.c:    s->enable = 0;
omap1.c:    s->reset_val = 31337;
omap1.c:    s->val = 0;
omap1.c:    s->ptv = 0;
omap1.c:    s->ar = 0;
omap1.c:    s->st = 0;
omap1.c:    s->it_ena = 1;
omap1.c:    s->irq = irq;
omap1.c:    s->clk = clk;
omap1.c:    s->timer = qemu_new_timer(vm_clock, omap_timer_tick, s);
omap1.c:    s->tick = qemu_bh_new(omap_timer_fire, s);
omap1.c:        return (s->timer.ptv << 9) | (s->timer.ar << 8) |
omap1.c:                (s->timer.st << 7) | (s->free << 1);
omap1.c:        return omap_timer_read(&s->timer);
omap1.c:        return s->mode << 15;
omap1.c:        omap_timer_sync(&s->timer);
omap1.c:        s->timer.ptv = (value >> 9) & 7;
omap1.c:        s->timer.ar = (value >> 8) & 1;
omap1.c:        s->timer.st = (value >> 7) & 1;
omap1.c:        s->free = (value >> 1) & 1;
omap1.c:        omap_timer_update(&s->timer);
omap1.c:        s->timer.reset_val = value & 0xffff;
omap1.c:        if (!s->mode && ((value >> 15) & 1))
omap1.c:            omap_clk_get(s->timer.clk);
omap1.c:        s->mode |= (value >> 15) & 1;
omap1.c:        if (s->last_wr == 0xf5) {
omap1.c:                if (s->mode) {
omap1.c:                    s->mode = 0;
omap1.c:                    omap_clk_put(s->timer.clk);
omap1.c:                s->reset = 1;
omap1.c:        s->last_wr = value & 0xff;
omap1.c:    qemu_del_timer(s->timer.timer);
omap1.c:    if (!s->mode)
omap1.c:        omap_clk_get(s->timer.clk);
omap1.c:    s->mode = 1;
omap1.c:    s->free = 1;
omap1.c:    s->reset = 0;
omap1.c:    s->timer.enable = 1;
omap1.c:    s->timer.it_ena = 1;
omap1.c:    s->timer.reset_val = 0xffff;
omap1.c:    s->timer.val = 0;
omap1.c:    s->timer.st = 0;
omap1.c:    s->timer.ptv = 0;
omap1.c:    s->timer.ar = 0;
omap1.c:    omap_timer_update(&s->timer);
omap1.c:    s->timer.irq = irq;
omap1.c:    s->timer.clk = clk;
omap1.c:    s->timer.timer = qemu_new_timer(vm_clock, omap_timer_tick, &s->timer);
omap1.c:    omap_timer_clk_setup(&s->timer);
omap1.c:/* 32-kHz timer */
omap1.c:        return s->timer.reset_val;
omap1.c:        return omap_timer_read(&s->timer);
omap1.c:        return (s->timer.ar << 3) | (s->timer.it_ena << 2) | s->timer.st;
omap1.c:        s->timer.reset_val = value & 0x00ffffff;
omap1.c:        s->timer.ar = (value >> 3) & 1;
omap1.c:        s->timer.it_ena = (value >> 2) & 1;
omap1.c:        if (s->timer.st != (value & 1) || (value & 2)) {
omap1.c:            omap_timer_sync(&s->timer);
omap1.c:            s->timer.enable = value & 1;
omap1.c:            s->timer.st = value & 1;
omap1.c:            omap_timer_update(&s->timer);
omap1.c:    qemu_del_timer(s->timer.timer);
omap1.c:    s->timer.enable = 0;
omap1.c:    s->timer.it_ena = 0;
omap1.c:    s->timer.reset_val = 0x00ffffff;
omap1.c:    s->timer.val = 0;
omap1.c:    s->timer.st = 0;
omap1.c:    s->timer.ptv = 0;
omap1.c:    s->timer.ar = 1;
omap1.c:    s->timer.irq = irq;
omap1.c:    s->timer.clk = clk;
omap1.c:    s->timer.timer = qemu_new_timer(vm_clock, omap_timer_tick, &s->timer);
omap1.c:    omap_timer_clk_setup(&s->timer);
omap1.c:/* Ultra Low-Power Device Module */
omap1.c:        ret = s->ulpd_pm_regs[addr >> 2];
omap1.c:        s->ulpd_pm_regs[addr >> 2] = 0;
omap1.c:        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);
omap1.c:        return s->ulpd_pm_regs[addr >> 2];
omap1.c:        if ((s->ulpd_pm_regs[addr >> 2] ^ value) & 1) {
omap1.c:                s->ulpd_gauge_start = now;
omap1.c:                now -= s->ulpd_gauge_start;
omap1.c:                /* 32-kHz ticks */
omap1.c:                s->ulpd_pm_regs[0x00 >> 2] = (ticks >>  0) & 0xffff;
omap1.c:                s->ulpd_pm_regs[0x04 >> 2] = (ticks >> 16) & 0xffff;
omap1.c:                    s->ulpd_pm_regs[0x14 >> 2] |= 1 << 2;
omap1.c:                s->ulpd_pm_regs[0x08 >> 2] = (ticks >>  0) & 0xffff;
omap1.c:                s->ulpd_pm_regs[0x0c >> 2] = (ticks >> 16) & 0xffff;
omap1.c:                    s->ulpd_pm_regs[0x14 >> 2] |= 1 << 1;
omap1.c:                s->ulpd_pm_regs[0x14 >> 2] |= 1 << 0;	/* IT_GAUGING */
omap1.c:                qemu_irq_raise(s->irq[1][OMAP_INT_GAUGE_32K]);
omap1.c:        s->ulpd_pm_regs[addr >> 2] = value;
omap1.c:        s->ulpd_pm_regs[addr >> 2] = value;
omap1.c:        diff = s->ulpd_pm_regs[addr >> 2] ^ value;
omap1.c:        s->ulpd_pm_regs[addr >> 2] = value & 0x3f;
omap1.c:        diff = s->ulpd_pm_regs[addr >> 2] ^ value;
omap1.c:        s->ulpd_pm_regs[addr >> 2] = value & 0x1f;
omap1.c:        diff = s->ulpd_pm_regs[addr >> 2] & value;
omap1.c:        s->ulpd_pm_regs[addr >> 2] = value & 0x2fff;
omap1.c:        s->ulpd_pm_regs[addr >> 2] =
omap1.c:                (s->ulpd_pm_regs[addr >> 2] & 0xfffe) |
omap1.c:                ((s->ulpd_pm_regs[addr >> 2] >> 4) & 1);
omap1.c:        s->ulpd_pm_regs[addr >> 2] |= 2;
omap1.c:        diff = s->ulpd_pm_regs[addr >> 2] & value;
omap1.c:        s->ulpd_pm_regs[addr >> 2] = value & 0xf;
omap1.c:    mpu->ulpd_pm_regs[0x00 >> 2] = 0x0001;
omap1.c:    mpu->ulpd_pm_regs[0x04 >> 2] = 0x0000;
omap1.c:    mpu->ulpd_pm_regs[0x08 >> 2] = 0x0001;
omap1.c:    mpu->ulpd_pm_regs[0x0c >> 2] = 0x0000;
omap1.c:    mpu->ulpd_pm_regs[0x10 >> 2] = 0x0000;
omap1.c:    mpu->ulpd_pm_regs[0x18 >> 2] = 0x01;
omap1.c:    mpu->ulpd_pm_regs[0x1c >> 2] = 0x01;
omap1.c:    mpu->ulpd_pm_regs[0x20 >> 2] = 0x01;
omap1.c:    mpu->ulpd_pm_regs[0x24 >> 2] = 0x03ff;
omap1.c:    mpu->ulpd_pm_regs[0x28 >> 2] = 0x01;
omap1.c:    mpu->ulpd_pm_regs[0x2c >> 2] = 0x01;
omap1.c:    omap_ulpd_clk_update(mpu, mpu->ulpd_pm_regs[0x30 >> 2], 0x0000);
omap1.c:    mpu->ulpd_pm_regs[0x30 >> 2] = 0x0000;
omap1.c:    omap_ulpd_req_update(mpu, mpu->ulpd_pm_regs[0x34 >> 2], 0x0000);
omap1.c:    mpu->ulpd_pm_regs[0x34 >> 2] = 0x0000;
omap1.c:    mpu->ulpd_pm_regs[0x38 >> 2] = 0x0001;
omap1.c:    mpu->ulpd_pm_regs[0x3c >> 2] = 0x2211;
omap1.c:    mpu->ulpd_pm_regs[0x40 >> 2] = 0x0000; /* FIXME: dump a real STATUS_REQ */
omap1.c:    mpu->ulpd_pm_regs[0x48 >> 2] = 0x960;
omap1.c:    mpu->ulpd_pm_regs[0x4c >> 2] = 0x08;
omap1.c:    mpu->ulpd_pm_regs[0x50 >> 2] = 0x08;
omap1.c:        return s->func_mux_ctrl[addr >> 2];
omap1.c:        return s->comp_mode_ctrl[0];
omap1.c:        return s->func_mux_ctrl[(addr >> 2) - 1];
omap1.c:        return s->pull_dwn_ctrl[(addr & 0xf) >> 2];
omap1.c:        return s->gate_inh_ctrl[0];
omap1.c:        return s->voltage_ctrl[0];
omap1.c:        return s->test_dbg_ctrl[0];
omap1.c:        return s->mod_conf_ctrl[0];
omap1.c:    if (s->compat1509) {
omap1.c:    if (s->compat1509) {
omap1.c:        diff = s->func_mux_ctrl[addr >> 2] ^ value;
omap1.c:        s->func_mux_ctrl[addr >> 2] = value;
omap1.c:        diff = s->func_mux_ctrl[addr >> 2] ^ value;
omap1.c:        s->func_mux_ctrl[addr >> 2] = value;
omap1.c:        s->func_mux_ctrl[addr >> 2] = value;
omap1.c:        s->comp_mode_ctrl[0] = value;
omap1.c:        s->compat1509 = (value != 0x0000eaef);
omap1.c:        omap_pin_funcmux0_update(s, ~0, s->func_mux_ctrl[0]);
omap1.c:        omap_pin_funcmux1_update(s, ~0, s->func_mux_ctrl[1]);
omap1.c:        s->func_mux_ctrl[(addr >> 2) - 1] = value;
omap1.c:        s->pull_dwn_ctrl[(addr & 0xf) >> 2] = value;
omap1.c:        s->gate_inh_ctrl[0] = value;
omap1.c:        s->voltage_ctrl[0] = value;
omap1.c:        s->test_dbg_ctrl[0] = value;
omap1.c:        diff = s->mod_conf_ctrl[0] ^ value;
omap1.c:        s->mod_conf_ctrl[0] = value;
omap1.c:    mpu->compat1509 = 1;
omap1.c:    omap_pin_funcmux0_update(mpu, mpu->func_mux_ctrl[0], 0);
omap1.c:    omap_pin_funcmux1_update(mpu, mpu->func_mux_ctrl[1], 0);
omap1.c:    omap_pin_modconf1_update(mpu, mpu->mod_conf_ctrl[0], 0);
omap1.c:    memset(mpu->func_mux_ctrl, 0, sizeof(mpu->func_mux_ctrl));
omap1.c:    memset(mpu->comp_mode_ctrl, 0, sizeof(mpu->comp_mode_ctrl));
omap1.c:    memset(mpu->pull_dwn_ctrl, 0, sizeof(mpu->pull_dwn_ctrl));
omap1.c:    memset(mpu->gate_inh_ctrl, 0, sizeof(mpu->gate_inh_ctrl));
omap1.c:    memset(mpu->voltage_ctrl, 0, sizeof(mpu->voltage_ctrl));
omap1.c:    memset(mpu->test_dbg_ctrl, 0, sizeof(mpu->test_dbg_ctrl));
omap1.c:    memset(mpu->mod_conf_ctrl, 0, sizeof(mpu->mod_conf_ctrl));
omap1.c:        switch (s->mpu_model) {
omap1.c:        switch (s->mpu_model) {
omap1.c:        return s->mpui_ctrl;
omap1.c:        s->mpui_ctrl = value & 0x007fffff;
omap1.c:    s->mpui_ctrl = 0x0003ff1b;
omap1.c:        return s->control;
omap1.c:        return s->alloc;
omap1.c:        return s->buffer;
omap1.c:        return s->enh_control;
omap1.c:        s->control = value & 0xffff;
omap1.c:        s->alloc = value & 0x003f;
omap1.c:        s->buffer = value & 0x0003;
omap1.c:        s->width_intr = !(value & 2);
omap1.c:        s->enh_control = value & 0x000f;
omap1.c:    s->control = 0xffff;
omap1.c:    s->alloc = 0x0009;
omap1.c:    s->buffer = 0x0000;
omap1.c:    s->enh_control = 0x000f;
omap1.c:    s->abort = abort_irq;
omap1.c:        return s->tcmi_regs[addr >> 2];
omap1.c:        ret = s->tcmi_regs[addr >> 2];
omap1.c:        s->tcmi_regs[addr >> 2] &= ~1; /* XXX: Clear SLRF on SDRAM access */
omap1.c:        s->tcmi_regs[addr >> 2] = value;
omap1.c:        s->tcmi_regs[addr >> 2] = (value & 0xf) | (1 << 4);
omap1.c:    mpu->tcmi_regs[0x00 >> 2] = 0x00000000;
omap1.c:    mpu->tcmi_regs[0x04 >> 2] = 0x00000000;
omap1.c:    mpu->tcmi_regs[0x08 >> 2] = 0x00000000;
omap1.c:    mpu->tcmi_regs[0x0c >> 2] = 0x00000010;
omap1.c:    mpu->tcmi_regs[0x10 >> 2] = 0x0010fffb;
omap1.c:    mpu->tcmi_regs[0x14 >> 2] = 0x0010fffb;
omap1.c:    mpu->tcmi_regs[0x18 >> 2] = 0x0010fffb;
omap1.c:    mpu->tcmi_regs[0x1c >> 2] = 0x0010fffb;
omap1.c:    mpu->tcmi_regs[0x20 >> 2] = 0x00618800;
omap1.c:    mpu->tcmi_regs[0x24 >> 2] = 0x00000037;
omap1.c:    mpu->tcmi_regs[0x28 >> 2] = 0x00000000;
omap1.c:    mpu->tcmi_regs[0x2c >> 2] = 0x00000000;
omap1.c:    mpu->tcmi_regs[0x30 >> 2] = 0x00000000;
omap1.c:    mpu->tcmi_regs[0x3c >> 2] = 0x00000003;
omap1.c:    mpu->tcmi_regs[0x40 >> 2] = 0x00000000;
omap1.c:/* Digital phase-locked loops control */
omap1.c:        return s->mode;
omap1.c:        diff = s->mode & value;
omap1.c:        s->mode = value & 0x2fff;
omap1.c:            omap_clk_setrate(s->dpll, div, mult);
omap1.c:        s->mode = (s->mode & 0xfffe) | ((s->mode >> 4) & 1);
omap1.c:        s->mode |= 2;
omap1.c:    s->mode = 0x2002;
omap1.c:    omap_clk_setrate(s->dpll, 1, 1);
omap1.c:    s->dpll = clk;
omap1.c:    s->eblr = 0x00;
omap1.c:    s->syscontrol = 0;
omap1.c:    s->wkup = 0x3f;
omap1.c:    s->cfps = 0x69;
omap1.c:    s->clksel = 0;
omap1.c:    s->base = base;
omap1.c:    s->fclk = fclk;
omap1.c:    s->irq = irq;
omap1.c:    s->serial = serial_mm_init(base, 2, irq, omap_clk_getrate(fclk)/16,
omap1.c:        return s->mdr[0];
omap1.c:        return s->mdr[1];
omap1.c:        return s->scr;
omap1.c:        return s->eblr;
omap1.c:        return s->clksel;
omap1.c:        return s->syscontrol;
omap1.c:        return s->wkup;
omap1.c:        return s->cfps;
omap1.c:        s->mdr[0] = value & 0x7f;
omap1.c:        s->mdr[1] = value & 0xff;
omap1.c:        s->scr = value & 0xff;
omap1.c:        s->eblr = value & 0xff;
omap1.c:        s->clksel = value & 1;
omap1.c:        s->syscontrol = value & 0x1d;
omap1.c:        s->wkup = value & 0x7f;
omap1.c:        s->cfps = value & 0xff;
omap1.c:    s->ta = ta;
omap1.c:    /* TODO: Should reuse or destroy current s->serial */
omap1.c:    s->serial = serial_mm_init(s->base, 2, s->irq,
omap1.c:                    omap_clk_getrate(s->fclk) / 16,
omap1.c:        return s->clkm.arm_ckctl;
omap1.c:        return s->clkm.arm_idlect1;
omap1.c:        return s->clkm.arm_idlect2;
omap1.c:        return s->clkm.arm_ewupct;
omap1.c:        return s->clkm.arm_rstct1;
omap1.c:        return s->clkm.arm_rstct2;
omap1.c:        return (s->clkm.clocking_scheme << 11) | s->clkm.cold_start;
omap1.c:        return s->clkm.arm_ckout1;
omap1.c:        cpu_interrupt(s->env, CPU_INTERRUPT_HALT);
omap1.c:        diff = s->clkm.arm_ckctl ^ value;
omap1.c:        s->clkm.arm_ckctl = value & 0x7fff;
omap1.c:        diff = s->clkm.arm_idlect1 ^ value;
omap1.c:        s->clkm.arm_idlect1 = value & 0x0fff;
omap1.c:        diff = s->clkm.arm_idlect2 ^ value;
omap1.c:        s->clkm.arm_idlect2 = value & 0x07ff;
omap1.c:        diff = s->clkm.arm_ewupct ^ value;
omap1.c:        s->clkm.arm_ewupct = value & 0x003f;
omap1.c:        diff = s->clkm.arm_rstct1 ^ value;
omap1.c:        s->clkm.arm_rstct1 = value & 0x0007;
omap1.c:            s->clkm.cold_start = 0xa;
omap1.c:            omap_tipb_bridge_reset(s->private_tipb);
omap1.c:            omap_tipb_bridge_reset(s->public_tipb);
omap1.c:        s->clkm.arm_rstct2 = value & 0x0001;
omap1.c:        if ((s->clkm.clocking_scheme ^ (value >> 11)) & 7) {
omap1.c:            s->clkm.clocking_scheme = (value >> 11) & 7;
omap1.c:                            clkschemename[s->clkm.clocking_scheme]);
omap1.c:        s->clkm.cold_start &= value & 0x3f;
omap1.c:        diff = s->clkm.arm_ckout1 ^ value;
omap1.c:        s->clkm.arm_ckout1 = value & 0x003f;
omap1.c:        return s->clkm.dsp_idlect1;
omap1.c:        return s->clkm.dsp_idlect2;
omap1.c:        return s->clkm.dsp_rstct2;
omap1.c:        return (s->clkm.clocking_scheme << 11) | s->clkm.cold_start |
omap1.c:                (s->env->halted << 6);	/* Quite useless... */
omap1.c:        diff = s->clkm.dsp_idlect1 ^ value;
omap1.c:        s->clkm.dsp_idlect1 = value & 0x01f7;
omap1.c:        s->clkm.dsp_idlect2 = value & 0x0037;
omap1.c:        diff = s->clkm.dsp_idlect1 ^ value;
omap1.c:        s->clkm.dsp_rstct2 = value & 0x0001;
omap1.c:        s->clkm.cold_start &= value & 0x3f;
omap1.c:    if (s->wdt && s->wdt->reset)
omap1.c:        s->clkm.cold_start = 0x6;
omap1.c:    s->clkm.clocking_scheme = 0;
omap1.c:    s->clkm.arm_ckctl = 0x3000;
omap1.c:    omap_clkm_idlect1_update(s, s->clkm.arm_idlect1 ^ 0x0400, 0x0400);
omap1.c:    s->clkm.arm_idlect1 = 0x0400;
omap1.c:    omap_clkm_idlect2_update(s, s->clkm.arm_idlect2 ^ 0x0100, 0x0100);
omap1.c:    s->clkm.arm_idlect2 = 0x0100;
omap1.c:    s->clkm.arm_ewupct = 0x003f;
omap1.c:    s->clkm.arm_rstct1 = 0x0000;
omap1.c:    s->clkm.arm_rstct2 = 0x0000;
omap1.c:    s->clkm.arm_ckout1 = 0x0015;
omap1.c:    s->clkm.dpll1_mode = 0x2002;
omap1.c:    omap_clkdsp_idlect1_update(s, s->clkm.dsp_idlect1 ^ 0x0040, 0x0040);
omap1.c:    s->clkm.dsp_idlect1 = 0x0040;
omap1.c:    s->clkm.dsp_idlect2 = 0x0000;
omap1.c:    s->clkm.dsp_rstct2 = 0x0000;
omap1.c:    s->clkm.arm_idlect1 = 0x03ff;
omap1.c:    s->clkm.arm_idlect2 = 0x0100;
omap1.c:    s->clkm.dsp_idlect1 = 0x0002;
omap1.c:    s->clkm.cold_start = 0x3a;
omap1.c:    uint16_t prev = s->inputs;
omap1.c:        s->inputs |= 1 << line;
omap1.c:        s->inputs &= ~(1 << line);
omap1.c:    if (((1 << line) & s->dir & ~s->mask) && s->clk) {
omap1.c:        if ((s->edge & s->inputs & ~prev) | (~s->edge & ~s->inputs & prev)) {
omap1.c:            s->ints |= 1 << line;
omap1.c:            qemu_irq_raise(s->irq);
omap1.c:        if ((s->event & (1 << 0)) &&		/* SET_GPIO_EVENT_MODE */
omap1.c:                (s->event >> 1) == line)	/* PIN_SELECT */
omap1.c:            s->latch = s->inputs;
omap1.c:    uint8_t *row, rows = 0, cols = ~s->cols;
omap1.c:    for (row = s->buttons + 4, i = 1 << 4; i; row --, i >>= 1)
omap1.c:    qemu_set_irq(s->kbd_irq, rows && !s->kbd_mask && s->clk);
omap1.c:    s->row_latch = ~rows;
omap1.c:        return s->inputs;
omap1.c:        return s->outputs;
omap1.c:        return s->dir;
omap1.c:        return s->row_latch;
omap1.c:        return s->cols;
omap1.c:        return s->event;
omap1.c:        return s->edge;
omap1.c:        return (~s->row_latch & 0x1f) && !s->kbd_mask;
omap1.c:        ret = s->ints;
omap1.c:        s->ints &= s->mask;
omap1.c:            qemu_irq_lower(s->irq);
omap1.c:        return s->kbd_mask;
omap1.c:        return s->mask;
omap1.c:        return s->debounce;
omap1.c:        return s->latch;
omap1.c:        diff = (s->outputs ^ value) & ~s->dir;
omap1.c:        s->outputs = value;
omap1.c:            ln --;
omap1.c:            if (s->handler[ln])
omap1.c:                qemu_set_irq(s->handler[ln], (value >> ln) & 1);
omap1.c:        diff = s->outputs & (s->dir ^ value);
omap1.c:        s->dir = value;
omap1.c:        value = s->outputs & ~s->dir;
omap1.c:            ln --;
omap1.c:            if (s->handler[ln])
omap1.c:                qemu_set_irq(s->handler[ln], (value >> ln) & 1);
omap1.c:        s->cols = value;
omap1.c:        s->event = value & 0x1f;
omap1.c:        s->edge = value;
omap1.c:        s->kbd_mask = value & 1;
omap1.c:        s->mask = value;
omap1.c:        s->debounce = value & 0x1ff;
omap1.c:    s->inputs = 0;
omap1.c:    s->outputs = 0;
omap1.c:    s->dir = ~0;
omap1.c:    s->event = 0;
omap1.c:    s->edge = 0;
omap1.c:    s->kbd_mask = 0;
omap1.c:    s->mask = 0;
omap1.c:    s->debounce = 0;
omap1.c:    s->latch = 0;
omap1.c:    s->ints = 0;
omap1.c:    s->row_latch = 0x1f;
omap1.c:    s->clk = 1;
omap1.c:    s->clk = on;
omap1.c:    s->irq = gpio_int;
omap1.c:    s->kbd_irq = kbd_int;
omap1.c:    s->wakeup = wakeup;
omap1.c:    s->in = qemu_allocate_irqs(omap_mpuio_set, s, 16);
omap1.c:    return s->in;
omap1.c:    s->handler[line] = handler;
omap1.c:        hw_error("%s: No key %i-%i\n", __FUNCTION__, col, row);
omap1.c:        s->buttons[row] |= 1 << col;
omap1.c:        s->buttons[row] &= ~(1 << col);
omap1.c:/* General-Purpose I/O */
omap1.c:    uint16_t prev = s->inputs;
omap1.c:        s->inputs |= 1 << line;
omap1.c:        s->inputs &= ~(1 << line);
omap1.c:    if (((s->edge & s->inputs & ~prev) | (~s->edge & ~s->inputs & prev)) &
omap1.c:                    (1 << line) & s->dir & ~s->mask) {
omap1.c:        s->ints |= 1 << line;
omap1.c:        qemu_irq_raise(s->irq);
omap1.c:        return s->inputs & s->pins;
omap1.c:        return s->outputs;
omap1.c:        return s->dir;
omap1.c:        return s->edge;
omap1.c:        return s->mask;
omap1.c:        return s->ints;
omap1.c:        return s->pins;
omap1.c:        diff = (s->outputs ^ value) & ~s->dir;
omap1.c:        s->outputs = value;
omap1.c:            ln --;
omap1.c:            if (s->handler[ln])
omap1.c:                qemu_set_irq(s->handler[ln], (value >> ln) & 1);
omap1.c:        diff = s->outputs & (s->dir ^ value);
omap1.c:        s->dir = value;
omap1.c:        value = s->outputs & ~s->dir;
omap1.c:            ln --;
omap1.c:            if (s->handler[ln])
omap1.c:                qemu_set_irq(s->handler[ln], (value >> ln) & 1);
omap1.c:        s->edge = value;
omap1.c:        s->mask = value;
omap1.c:        s->ints &= ~value;
omap1.c:        if (!s->ints)
omap1.c:            qemu_irq_lower(s->irq);
omap1.c:        s->pins = value;
omap1.c:/* *Some* sources say the memory region is 32-bit.  */
omap1.c:    s->inputs = 0;
omap1.c:    s->outputs = ~0;
omap1.c:    s->dir = ~0;
omap1.c:    s->edge = ~0;
omap1.c:    s->mask = ~0;
omap1.c:    s->ints = 0;
omap1.c:    s->pins = ~0;
omap1.c:    s->irq = irq;
omap1.c:    s->in = qemu_allocate_irqs(omap_gpio_set, s, 16);
omap1.c:    return s->in;
omap1.c:    s->handler[line] = handler;
omap1.c:    int chipselect = (s->control >> 10) & 3;		/* INDEX */
omap1.c:    uWireSlave *slave = s->chip[chipselect];
omap1.c:    if ((s->control >> 5) & 0x1f) {			/* NB_BITS_WR */
omap1.c:        if (s->control & (1 << 12))			/* CS_CMD */
omap1.c:            if (slave && slave->send)
omap1.c:                slave->send(slave->opaque,
omap1.c:                                s->txbuf >> (16 - ((s->control >> 5) & 0x1f)));
omap1.c:        s->control &= ~(1 << 14);			/* CSRB */
omap1.c:        /* TODO: depending on s->setup[4] bits [1:0] assert an IRQ or
omap1.c:    if ((s->control >> 0) & 0x1f) {			/* NB_BITS_RD */
omap1.c:        if (s->control & (1 << 12))			/* CS_CMD */
omap1.c:            if (slave && slave->receive)
omap1.c:                s->rxbuf = slave->receive(slave->opaque);
omap1.c:        s->control |= 1 << 15;				/* RDRB */
omap1.c:        /* TODO: depending on s->setup[4] bits [1:0] assert an IRQ or
omap1.c:        s->control &= ~(1 << 15);			/* RDRB */
omap1.c:        return s->rxbuf;
omap1.c:        return s->control;
omap1.c:        return s->setup[0];
omap1.c:        return s->setup[1];
omap1.c:        return s->setup[2];
omap1.c:        return s->setup[3];
omap1.c:        return s->setup[4];
omap1.c:        s->txbuf = value;				/* TD */
omap1.c:        if ((s->setup[4] & (1 << 2)) &&			/* AUTO_TX_EN */
omap1.c:                        ((s->setup[4] & (1 << 3)) ||	/* CS_TOGGLE_TX_EN */
omap1.c:                         (s->control & (1 << 12)))) {	/* CS_CMD */
omap1.c:            s->control |= 1 << 14;			/* CSRB */
omap1.c:        s->control = value & 0x1fff;
omap1.c:        s->setup[0] = value & 0x003f;
omap1.c:        s->setup[1] = value & 0x0fc0;
omap1.c:        s->setup[2] = value & 0x0003;
omap1.c:        s->setup[3] = value & 0x0001;
omap1.c:        s->setup[4] = value & 0x000f;
omap1.c:    s->control = 0;
omap1.c:    s->setup[0] = 0;
omap1.c:    s->setup[1] = 0;
omap1.c:    s->setup[2] = 0;
omap1.c:    s->setup[3] = 0;
omap1.c:    s->setup[4] = 0;
omap1.c:    s->txirq = irq[0];
omap1.c:    s->rxirq = irq[1];
omap1.c:    s->txdrq = dma;
omap1.c:        exit(-1);
omap1.c:    s->chip[chipselect] = slave;
omap1.c:/* Pseudonoise Pulse-Width Light Modulator */
omap1.c:    int output = (s->pwl.clk && s->pwl.enable) ? s->pwl.level : 0;
omap1.c:    if (output != s->pwl.output) {
omap1.c:        s->pwl.output = output;
omap1.c:        return s->pwl.level;
omap1.c:        return s->pwl.enable;
omap1.c:        s->pwl.level = value;
omap1.c:        s->pwl.enable = value & 1;
omap1.c:    s->pwl.output = 0;
omap1.c:    s->pwl.level = 0;
omap1.c:    s->pwl.enable = 0;
omap1.c:    s->pwl.clk = 1;
omap1.c:    s->pwl.clk = on;
omap1.c:/* Pulse-Width Tone module */
omap1.c:        return s->pwt.frc;
omap1.c:        return s->pwt.vrc;
omap1.c:        return s->pwt.gcr;
omap1.c:        s->pwt.frc = value & 0x3f;
omap1.c:        if ((value ^ s->pwt.vrc) & 1) {
omap1.c:                                /* 1.5 MHz from a 12-MHz or 13-MHz PWT_CLK */
omap1.c:                                ((omap_clk_getrate(s->pwt.clk) >> 3) /
omap1.c:                                 /* Pre-multiplexer divider */
omap1.c:                                 ((s->pwt.gcr & 2) ? 1 : 154) /
omap1.c:        s->pwt.vrc = value & 0x7f;
omap1.c:        s->pwt.gcr = value & 3;
omap1.c:    s->pwt.frc = 0;
omap1.c:    s->pwt.vrc = 0;
omap1.c:    s->pwt.gcr = 0;
omap1.c:    s->pwt.clk = clk;
omap1.c:/* Real-time Clock module */
omap1.c:    /* s->alarm is level-triggered */
omap1.c:    qemu_set_irq(s->alarm, (s->status >> 6) & 1);
omap1.c:    s->alarm_ti = mktimegm(&s->alarm_tm);
omap1.c:    if (s->alarm_ti == -1)
omap1.c:        return to_bcd(s->current_tm.tm_sec);
omap1.c:        return to_bcd(s->current_tm.tm_min);
omap1.c:        if (s->pm_am)
omap1.c:            return ((s->current_tm.tm_hour > 11) << 7) |
omap1.c:                    to_bcd(((s->current_tm.tm_hour - 1) % 12) + 1);
omap1.c:            return to_bcd(s->current_tm.tm_hour);
omap1.c:        return to_bcd(s->current_tm.tm_mday);
omap1.c:        return to_bcd(s->current_tm.tm_mon + 1);
omap1.c:        return to_bcd(s->current_tm.tm_year % 100);
omap1.c:        return s->current_tm.tm_wday;
omap1.c:        return to_bcd(s->alarm_tm.tm_sec);
omap1.c:        return to_bcd(s->alarm_tm.tm_min);
omap1.c:        if (s->pm_am)
omap1.c:            return ((s->alarm_tm.tm_hour > 11) << 7) |
omap1.c:                    to_bcd(((s->alarm_tm.tm_hour - 1) % 12) + 1);
omap1.c:            return to_bcd(s->alarm_tm.tm_hour);
omap1.c:        return to_bcd(s->alarm_tm.tm_mday);
omap1.c:        return to_bcd(s->alarm_tm.tm_mon + 1);
omap1.c:        return to_bcd(s->alarm_tm.tm_year % 100);
omap1.c:        return (s->pm_am << 3) | (s->auto_comp << 2) |
omap1.c:                (s->round << 1) | s->running;
omap1.c:        i = s->status;
omap1.c:        s->status &= ~0x3d;
omap1.c:        return s->interrupts;
omap1.c:        return ((uint16_t) s->comp_reg) & 0xff;
omap1.c:        return ((uint16_t) s->comp_reg) >> 8;
omap1.c:        printf("RTC SEC_REG <-- %02x\n", value);
omap1.c:        s->ti -= s->current_tm.tm_sec;
omap1.c:        s->ti += from_bcd(value);
omap1.c:        printf("RTC MIN_REG <-- %02x\n", value);
omap1.c:        s->ti -= s->current_tm.tm_min * 60;
omap1.c:        s->ti += from_bcd(value) * 60;
omap1.c:        printf("RTC HRS_REG <-- %02x\n", value);
omap1.c:        s->ti -= s->current_tm.tm_hour * 3600;
omap1.c:        if (s->pm_am) {
omap1.c:            s->ti += (from_bcd(value & 0x3f) & 12) * 3600;
omap1.c:            s->ti += ((value >> 7) & 1) * 43200;
omap1.c:            s->ti += from_bcd(value & 0x3f) * 3600;
omap1.c:        printf("RTC DAY_REG <-- %02x\n", value);
omap1.c:        s->ti -= s->current_tm.tm_mday * 86400;
omap1.c:        s->ti += from_bcd(value) * 86400;
omap1.c:        printf("RTC MTH_REG <-- %02x\n", value);
omap1.c:        memcpy(&new_tm, &s->current_tm, sizeof(new_tm));
omap1.c:        ti[0] = mktimegm(&s->current_tm);
omap1.c:        if (ti[0] != -1 && ti[1] != -1) {
omap1.c:            s->ti -= ti[0];
omap1.c:            s->ti += ti[1];
omap1.c:            s->ti -= s->current_tm.tm_mon * 2592000;
omap1.c:            s->ti += from_bcd(value) * 2592000;
omap1.c:        printf("RTC YRS_REG <-- %02x\n", value);
omap1.c:        memcpy(&new_tm, &s->current_tm, sizeof(new_tm));
omap1.c:        new_tm.tm_year += from_bcd(value) - (new_tm.tm_year % 100);
omap1.c:        ti[0] = mktimegm(&s->current_tm);
omap1.c:        if (ti[0] != -1 && ti[1] != -1) {
omap1.c:            s->ti -= ti[0];
omap1.c:            s->ti += ti[1];
omap1.c:            s->ti -= (s->current_tm.tm_year % 100) * 31536000;
omap1.c:            s->ti += from_bcd(value) * 31536000;
omap1.c:        printf("ALM SEC_REG <-- %02x\n", value);
omap1.c:        s->alarm_tm.tm_sec = from_bcd(value);
omap1.c:        printf("ALM MIN_REG <-- %02x\n", value);
omap1.c:        s->alarm_tm.tm_min = from_bcd(value);
omap1.c:        printf("ALM HRS_REG <-- %02x\n", value);
omap1.c:        if (s->pm_am)
omap1.c:            s->alarm_tm.tm_hour =
omap1.c:            s->alarm_tm.tm_hour = from_bcd(value);
omap1.c:        printf("ALM DAY_REG <-- %02x\n", value);
omap1.c:        s->alarm_tm.tm_mday = from_bcd(value);
omap1.c:        printf("ALM MON_REG <-- %02x\n", value);
omap1.c:        s->alarm_tm.tm_mon = from_bcd(value);
omap1.c:        printf("ALM YRS_REG <-- %02x\n", value);
omap1.c:        s->alarm_tm.tm_year = from_bcd(value);
omap1.c:        printf("RTC CONTROL <-- %02x\n", value);
omap1.c:        s->pm_am = (value >> 3) & 1;
omap1.c:        s->auto_comp = (value >> 2) & 1;
omap1.c:        s->round = (value >> 1) & 1;
omap1.c:        s->running = value & 1;
omap1.c:        s->status &= 0xfd;
omap1.c:        s->status |= s->running << 1;
omap1.c:        printf("RTC STATUSL <-- %02x\n", value);
omap1.c:        s->status &= ~((value & 0xc0) ^ 0x80);
omap1.c:        printf("RTC INTRS <-- %02x\n", value);
omap1.c:        s->interrupts = value;
omap1.c:        printf("RTC COMPLSB <-- %02x\n", value);
omap1.c:        s->comp_reg &= 0xff00;
omap1.c:        s->comp_reg |= 0x00ff & value;
omap1.c:        printf("RTC COMPMSB <-- %02x\n", value);
omap1.c:        s->comp_reg &= 0x00ff;
omap1.c:        s->comp_reg |= 0xff00 & (value << 8);
omap1.c:    if (s->round) {
omap1.c:        if (s->current_tm.tm_sec < 30)
omap1.c:            s->ti -= s->current_tm.tm_sec;
omap1.c:            s->ti += 60 - s->current_tm.tm_sec;
omap1.c:        s->round = 0;
omap1.c:    memcpy(&s->current_tm, localtime(&s->ti), sizeof(s->current_tm));
omap1.c:    if ((s->interrupts & 0x08) && s->ti == s->alarm_ti) {
omap1.c:        s->status |= 0x40;
omap1.c:    if (s->interrupts & 0x04)
omap1.c:        switch (s->interrupts & 3) {
omap1.c:            s->status |= 0x04;
omap1.c:            qemu_irq_pulse(s->irq);
omap1.c:            if (s->current_tm.tm_sec)
omap1.c:            s->status |= 0x08;
omap1.c:            qemu_irq_pulse(s->irq);
omap1.c:            if (s->current_tm.tm_sec || s->current_tm.tm_min)
omap1.c:            s->status |= 0x10;
omap1.c:            qemu_irq_pulse(s->irq);
omap1.c:            if (s->current_tm.tm_sec ||
omap1.c:                            s->current_tm.tm_min || s->current_tm.tm_hour)
omap1.c:            s->status |= 0x20;
omap1.c:            qemu_irq_pulse(s->irq);
omap1.c:    if (s->running)
omap1.c:        s->ti ++;
omap1.c:    s->tick += 1000;
omap1.c:    if (s->auto_comp && !s->current_tm.tm_sec && !s->current_tm.tm_min)
omap1.c:        s->tick += s->comp_reg * 1000 / 32768;
omap1.c:    qemu_mod_timer(s->clk, s->tick);
omap1.c:    s->interrupts = 0;
omap1.c:    s->comp_reg = 0;
omap1.c:    s->running = 0;
omap1.c:    s->pm_am = 0;
omap1.c:    s->auto_comp = 0;
omap1.c:    s->round = 0;
omap1.c:    s->tick = qemu_get_clock(rt_clock);
omap1.c:    memset(&s->alarm_tm, 0, sizeof(s->alarm_tm));
omap1.c:    s->alarm_tm.tm_mday = 0x01;
omap1.c:    s->status = 1 << 7;
omap1.c:    s->ti = mktimegm(&tm);
omap1.c:    s->irq = irq[0];
omap1.c:    s->alarm = irq[1];
omap1.c:    s->clk = qemu_new_timer(rt_clock, omap_rtc_tick, s);
omap1.c:/* Multi-channel Buffered Serial Port interfaces */
omap1.c:    switch ((s->spcr[0] >> 4) & 3) {			/* RINTM */
omap1.c:        irq = (s->spcr[0] >> 1) & 1;			/* RRDY */
omap1.c:        irq = (s->spcr[0] >> 3) & 1;			/* RSYNCERR */
omap1.c:        qemu_irq_pulse(s->rxirq);
omap1.c:    switch ((s->spcr[1] >> 4) & 3) {			/* XINTM */
omap1.c:        irq = (s->spcr[1] >> 1) & 1;			/* XRDY */
omap1.c:        irq = (s->spcr[1] >> 3) & 1;			/* XSYNCERR */
omap1.c:        qemu_irq_pulse(s->txirq);
omap1.c:    if ((s->spcr[0] >> 1) & 1)				/* RRDY */
omap1.c:        s->spcr[0] |= 1 << 2;				/* RFULL */
omap1.c:    s->spcr[0] |= 1 << 1;				/* RRDY */
omap1.c:    qemu_irq_raise(s->rxdrq);
omap1.c:    static const int bps[8] = { 0, 1, 1, 2, 2, 2, -255, -255 };
omap1.c:    if (!s->rx_rate)
omap1.c:    if (s->rx_req)
omap1.c:    s->rx_req = s->rx_rate << bps[(s->rcr[0] >> 5) & 7];
omap1.c:    qemu_mod_timer(s->source_timer, qemu_get_clock(vm_clock) +
omap1.c:    if (!s->codec || !s->codec->rts)
omap1.c:    else if (s->codec->in.len) {
omap1.c:        s->rx_req = s->codec->in.len;
omap1.c:    qemu_del_timer(s->source_timer);
omap1.c:    s->spcr[0] &= ~(1 << 1);				/* RRDY */
omap1.c:    qemu_irq_lower(s->rxdrq);
omap1.c:    s->spcr[1] |= 1 << 1;				/* XRDY */
omap1.c:    qemu_irq_raise(s->txdrq);
omap1.c:    static const int bps[8] = { 0, 1, 1, 2, 2, 2, -255, -255 };
omap1.c:    if (!s->tx_rate)
omap1.c:    if (s->tx_req)
omap1.c:    s->tx_req = s->tx_rate << bps[(s->xcr[0] >> 5) & 7];
omap1.c:    qemu_mod_timer(s->sink_timer, qemu_get_clock(vm_clock) +
omap1.c:    if (!s->codec || !s->codec->cts)
omap1.c:    else if (s->codec->out.size) {
omap1.c:        s->tx_req = s->codec->out.size;
omap1.c:    s->spcr[1] &= ~(1 << 1);				/* XRDY */
omap1.c:    qemu_irq_lower(s->txdrq);
omap1.c:    if (s->codec && s->codec->cts)
omap1.c:        s->codec->tx_swallow(s->codec->opaque);
omap1.c:    s->tx_req = 0;
omap1.c:    qemu_del_timer(s->sink_timer);
omap1.c:    if (s->spcr[1] & (1 << 6)) {			/* GRST */
omap1.c:        if (s->spcr[0] & (1 << 0)) {			/* RRST */
omap1.c:            if ((s->srgr[1] & (1 << 13)) &&		/* CLKSM */
omap1.c:                            (s->pcr & (1 << 8))) {	/* CLKRM */
omap1.c:                if (~s->pcr & (1 << 7))			/* SCLKME */
omap1.c:                            ((s->srgr[0] & 0xff) + 1);	/* CLKGDV */
omap1.c:                if (s->codec)
omap1.c:                    rx_rate = s->codec->rx_rate;
omap1.c:        if (s->spcr[1] & (1 << 0)) {			/* XRST */
omap1.c:            if ((s->srgr[1] & (1 << 13)) &&		/* CLKSM */
omap1.c:                            (s->pcr & (1 << 9))) {	/* CLKXM */
omap1.c:                if (~s->pcr & (1 << 7))			/* SCLKME */
omap1.c:                            ((s->srgr[0] & 0xff) + 1);	/* CLKGDV */
omap1.c:                if (s->codec)
omap1.c:                    tx_rate = s->codec->tx_rate;
omap1.c:    prev_tx_rate = s->tx_rate;
omap1.c:    prev_rx_rate = s->rx_rate;
omap1.c:    s->tx_rate = tx_rate;
omap1.c:    s->rx_rate = rx_rate;
omap1.c:    if (s->codec)
omap1.c:        s->codec->set_rate(s->codec->opaque, rx_rate, tx_rate);
omap1.c:    else if (s->tx_rate && !tx_rate)
omap1.c:        if (((s->rcr[0] >> 5) & 7) < 3)			/* RWDLEN1 */
omap1.c:        if (s->rx_req < 2) {
omap1.c:            s->tx_req -= 2;
omap1.c:            if (s->codec && s->codec->in.len >= 2) {
omap1.c:                ret = s->codec->in.fifo[s->codec->in.start ++] << 8;
omap1.c:                ret |= s->codec->in.fifo[s->codec->in.start ++];
omap1.c:                s->codec->in.len -= 2;
omap1.c:            if (!s->tx_req)
omap1.c:        return s->spcr[1];
omap1.c:        return s->spcr[0];
omap1.c:        return s->rcr[1];
omap1.c:        return s->rcr[0];
omap1.c:        return s->xcr[1];
omap1.c:        return s->xcr[0];
omap1.c:        return s->srgr[1];
omap1.c:        return s->srgr[0];
omap1.c:        return s->mcr[1];
omap1.c:        return s->mcr[0];
omap1.c:        return s->rcer[0];
omap1.c:        return s->rcer[1];
omap1.c:        return s->xcer[0];
omap1.c:        return s->xcer[1];
omap1.c:        return s->pcr;
omap1.c:        return s->rcer[2];
omap1.c:        return s->rcer[3];
omap1.c:        return s->xcer[2];
omap1.c:        return s->xcer[3];
omap1.c:        return s->rcer[4];
omap1.c:        return s->rcer[5];
omap1.c:        return s->xcer[4];
omap1.c:        return s->xcer[5];
omap1.c:        return s->rcer[6];
omap1.c:        return s->rcer[7];
omap1.c:        return s->xcer[6];
omap1.c:        return s->xcer[7];
omap1.c:        if (((s->xcr[0] >> 5) & 7) < 3)			/* XWDLEN1 */
omap1.c:        if (s->tx_req > 1) {
omap1.c:            s->tx_req -= 2;
omap1.c:            if (s->codec && s->codec->cts) {
omap1.c:                s->codec->out.fifo[s->codec->out.len ++] = (value >> 8) & 0xff;
omap1.c:                s->codec->out.fifo[s->codec->out.len ++] = (value >> 0) & 0xff;
omap1.c:            if (s->tx_req < 2)
omap1.c:        s->spcr[1] &= 0x0002;
omap1.c:        s->spcr[1] |= 0x03f9 & value;
omap1.c:        s->spcr[1] |= 0x0004 & (value << 2);		/* XEMPTY := XRST */
omap1.c:            s->spcr[1] &= ~6;
omap1.c:        s->spcr[0] &= 0x0006;
omap1.c:        s->spcr[0] |= 0xf8f9 & value;
omap1.c:            s->spcr[0] &= ~6;
omap1.c:            s->rx_req = 0;
omap1.c:        s->rcr[1] = value & 0xffff;
omap1.c:        s->rcr[0] = value & 0x7fe0;
omap1.c:        s->xcr[1] = value & 0xffff;
omap1.c:        s->xcr[0] = value & 0x7fe0;
omap1.c:        s->srgr[1] = value & 0xffff;
omap1.c:        s->srgr[0] = value & 0xffff;
omap1.c:        s->mcr[1] = value & 0x03e3;
omap1.c:        s->mcr[0] = value & 0x03e1;
omap1.c:        s->rcer[0] = value & 0xffff;
omap1.c:        s->rcer[1] = value & 0xffff;
omap1.c:        s->xcer[0] = value & 0xffff;
omap1.c:        s->xcer[1] = value & 0xffff;
omap1.c:        s->pcr = value & 0x7faf;
omap1.c:        s->rcer[2] = value & 0xffff;
omap1.c:        s->rcer[3] = value & 0xffff;
omap1.c:        s->xcer[2] = value & 0xffff;
omap1.c:        s->xcer[3] = value & 0xffff;
omap1.c:        s->rcer[4] = value & 0xffff;
omap1.c:        s->rcer[5] = value & 0xffff;
omap1.c:        s->xcer[4] = value & 0xffff;
omap1.c:        s->xcer[5] = value & 0xffff;
omap1.c:        s->rcer[6] = value & 0xffff;
omap1.c:        s->rcer[7] = value & 0xffff;
omap1.c:        s->xcer[6] = value & 0xffff;
omap1.c:        s->xcer[7] = value & 0xffff;
omap1.c:        if (((s->xcr[0] >> 5) & 7) < 3)			/* XWDLEN1 */
omap1.c:        if (s->tx_req > 3) {
omap1.c:            s->tx_req -= 4;
omap1.c:            if (s->codec && s->codec->cts) {
omap1.c:                s->codec->out.fifo[s->codec->out.len ++] =
omap1.c:                s->codec->out.fifo[s->codec->out.len ++] =
omap1.c:                s->codec->out.fifo[s->codec->out.len ++] =
omap1.c:                s->codec->out.fifo[s->codec->out.len ++] =
omap1.c:            if (s->tx_req < 4)
omap1.c:    memset(&s->spcr, 0, sizeof(s->spcr));
omap1.c:    memset(&s->rcr, 0, sizeof(s->rcr));
omap1.c:    memset(&s->xcr, 0, sizeof(s->xcr));
omap1.c:    s->srgr[0] = 0x0001;
omap1.c:    s->srgr[1] = 0x2000;
omap1.c:    memset(&s->mcr, 0, sizeof(s->mcr));
omap1.c:    memset(&s->pcr, 0, sizeof(s->pcr));
omap1.c:    memset(&s->rcer, 0, sizeof(s->rcer));
omap1.c:    memset(&s->xcer, 0, sizeof(s->xcer));
omap1.c:    s->tx_req = 0;
omap1.c:    s->rx_req = 0;
omap1.c:    s->tx_rate = 0;
omap1.c:    s->rx_rate = 0;
omap1.c:    qemu_del_timer(s->source_timer);
omap1.c:    qemu_del_timer(s->sink_timer);
omap1.c:    s->txirq = irq[0];
omap1.c:    s->rxirq = irq[1];
omap1.c:    s->txdrq = dma[0];
omap1.c:    s->rxdrq = dma[1];
omap1.c:    s->sink_timer = qemu_new_timer(vm_clock, omap_mcbsp_sink_tick, s);
omap1.c:    s->source_timer = qemu_new_timer(vm_clock, omap_mcbsp_source_tick, s);
omap1.c:    if (s->rx_rate) {
omap1.c:        s->rx_req = s->codec->in.len;
omap1.c:    if (s->tx_rate) {
omap1.c:        s->tx_req = s->codec->out.size;
omap1.c:    s->codec = slave;
omap1.c:    slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0];
omap1.c:    slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0];
omap1.c:    if (s->cycle)
omap1.c:        qemu_mod_timer(s->tm, qemu_get_clock(rt_clock) + s->period - s->on);
omap1.c:        qemu_mod_timer(s->tm, qemu_get_clock(rt_clock) + s->on);
omap1.c:    s->cycle = !s->cycle;
omap1.c:    printf("%s: LED is %s\n", __FUNCTION__, s->cycle ? "on" : "off");
omap1.c:    if (~s->control & (1 << 6))					/* LPGRES */
omap1.c:    else if (s->control & (1 << 7))				/* PERM_ON */
omap1.c:        period = muldiv64(ticks, per[s->control & 7],		/* PERCTRL */
omap1.c:        on = (s->clk && s->power) ? muldiv64(ticks,
omap1.c:                        per[(s->control >> 3) & 7], 256) : 0;	/* ONCTRL */
omap1.c:    qemu_del_timer(s->tm);
omap1.c:    if (on == period && s->on < s->period)
omap1.c:    else if (on == 0 && s->on)
omap1.c:    else if (on && (on != s->on || period != s->period)) {
omap1.c:        s->cycle = 0;
omap1.c:        s->on = on;
omap1.c:        s->period = period;
omap1.c:    s->on = on;
omap1.c:    s->period = period;
omap1.c:    s->control = 0x00;
omap1.c:    s->power = 0x00;
omap1.c:    s->clk = 1;
omap1.c:        return s->control;
omap1.c:        return s->power;
omap1.c:        s->control = value & 0xff;
omap1.c:        s->power = value & 0x01;
omap1.c:    s->clk = on;
omap1.c:    s->tm = qemu_new_timer(rt_clock, omap_lpg_tick, s);
omap1.c:    omap_inth_reset(mpu->ih[0]);
omap1.c:    omap_inth_reset(mpu->ih[1]);
omap1.c:    omap_dma_reset(mpu->dma);
omap1.c:    omap_mpu_timer_reset(mpu->timer[0]);
omap1.c:    omap_mpu_timer_reset(mpu->timer[1]);
omap1.c:    omap_mpu_timer_reset(mpu->timer[2]);
omap1.c:    omap_wd_timer_reset(mpu->wdt);
omap1.c:    omap_os_timer_reset(mpu->os_timer);
omap1.c:    omap_lcdc_reset(mpu->lcd);
omap1.c:    omap_tipb_bridge_reset(mpu->private_tipb);
omap1.c:    omap_tipb_bridge_reset(mpu->public_tipb);
omap1.c:    omap_dpll_reset(&mpu->dpll[0]);
omap1.c:    omap_dpll_reset(&mpu->dpll[1]);
omap1.c:    omap_dpll_reset(&mpu->dpll[2]);
omap1.c:    omap_uart_reset(mpu->uart[0]);
omap1.c:    omap_uart_reset(mpu->uart[1]);
omap1.c:    omap_uart_reset(mpu->uart[2]);
omap1.c:    omap_mmc_reset(mpu->mmc);
omap1.c:    omap_mpuio_reset(mpu->mpuio);
omap1.c:    omap_gpio_reset(mpu->gpio);
omap1.c:    omap_uwire_reset(mpu->microwire);
omap1.c:    omap_i2c_reset(mpu->i2c[0]);
omap1.c:    omap_rtc_reset(mpu->rtc);
omap1.c:    omap_mcbsp_reset(mpu->mcbsp1);
omap1.c:    omap_mcbsp_reset(mpu->mcbsp2);
omap1.c:    omap_mcbsp_reset(mpu->mcbsp3);
omap1.c:    omap_lpg_reset(mpu->led[0]);
omap1.c:    omap_lpg_reset(mpu->led[1]);
omap1.c:    cpu_reset(mpu->env);
omap1.c:    { 0xe1012800, 0xfffb2800, 0x800, "MCSI1 BT u-Law" },	/* CS5 */
omap1.c:    { 0xe1019000, 0xfffb9000, 0x800, "32-kHz timer" },		/* CS18 */
omap1.c:    for (; map->phys_dsp; map ++) {
omap1.c:        io = cpu_get_physical_page_desc(map->phys_mpu);
omap1.c:        cpu_register_physical_memory(map->phys_dsp, map->size, io);
omap1.c:    if (mpu->env->halted)
omap1.c:        cpu_interrupt(mpu->env, CPU_INTERRUPT_EXITTB);
omap1.c:    return addr >= OMAP_EMIFF_BASE && addr < OMAP_EMIFF_BASE + s->sdram_size;
omap1.c:    return addr >= OMAP_IMIF_BASE && addr < OMAP_IMIF_BASE + s->sram_size;
omap1.c:    s->mpu_model = omap310;
omap1.c:    s->env = cpu_init(core);
omap1.c:    if (!s->env) {
omap1.c:    s->sdram_size = sdram_size;
omap1.c:    s->sram_size = OMAP15XX_SRAM_SIZE;
omap1.c:    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];
omap1.c:    /* Memory-mapped stuff */
omap1.c:    cpu_register_physical_memory(OMAP_EMIFF_BASE, s->sdram_size,
omap1.c:                    (emiff_base = qemu_ram_alloc(s->sdram_size)) | IO_MEM_RAM);
omap1.c:    cpu_register_physical_memory(OMAP_IMIF_BASE, s->sram_size,
omap1.c:                    (imif_base = qemu_ram_alloc(s->sram_size)) | IO_MEM_RAM);
omap1.c:    cpu_irq = arm_pic_init_cpu(s->env);
omap1.c:    s->ih[0] = omap_inth_init(0xfffecb00, 0x100, 1, &s->irq[0],
omap1.c:    s->ih[1] = omap_inth_init(0xfffe0000, 0x800, 1, &s->irq[1],
omap1.c:                    s->ih[0]->pins[OMAP_INT_15XX_IH2_IRQ], NULL,
omap1.c:                s->irq[omap1_dma_irq_map[i].ih][omap1_dma_irq_map[i].intr];
omap1.c:    s->dma = omap_dma_init(0xfffed800, dma_irqs, s->irq[0][OMAP_INT_DMA_LCD],
omap1.c:    s->port[emiff    ].addr_valid = omap_validate_emiff_addr;
omap1.c:    s->port[emifs    ].addr_valid = omap_validate_emifs_addr;
omap1.c:    s->port[imif     ].addr_valid = omap_validate_imif_addr;
omap1.c:    s->port[tipb     ].addr_valid = omap_validate_tipb_addr;
omap1.c:    s->port[local    ].addr_valid = omap_validate_local_addr;
omap1.c:    s->port[tipb_mpui].addr_valid = omap_validate_tipb_mpui_addr;
omap1.c:    soc_dma_port_add_mem_ram(s->dma,
omap1.c:                    emiff_base, OMAP_EMIFF_BASE, s->sdram_size);
omap1.c:    soc_dma_port_add_mem_ram(s->dma,
omap1.c:                    imif_base, OMAP_IMIF_BASE, s->sram_size);
omap1.c:    s->timer[0] = omap_mpu_timer_init(0xfffec500,
omap1.c:                    s->irq[0][OMAP_INT_TIMER1],
omap1.c:    s->timer[1] = omap_mpu_timer_init(0xfffec600,
omap1.c:                    s->irq[0][OMAP_INT_TIMER2],
omap1.c:    s->timer[2] = omap_mpu_timer_init(0xfffec700,
omap1.c:                    s->irq[0][OMAP_INT_TIMER3],
omap1.c:    s->wdt = omap_wd_timer_init(0xfffec800,
omap1.c:                    s->irq[0][OMAP_INT_WD_TIMER],
omap1.c:    s->os_timer = omap_os_timer_init(0xfffb9000,
omap1.c:                    s->irq[1][OMAP_INT_OS_TIMER],
omap1.c:                    omap_findclk(s, "clk32-kHz"));
omap1.c:    s->lcd = omap_lcdc_init(0xfffec000, s->irq[0][OMAP_INT_LCD_CTRL],
omap1.c:                    omap_dma_get_lcdch(s->dma), imif_base, emiff_base,
omap1.c:    s->private_tipb = omap_tipb_bridge_init(0xfffeca00,
omap1.c:                    s->irq[0][OMAP_INT_BRIDGE_PRIV],
omap1.c:    s->public_tipb = omap_tipb_bridge_init(0xfffed300,
omap1.c:                    s->irq[0][OMAP_INT_BRIDGE_PUB],
omap1.c:    s->uart[0] = omap_uart_init(0xfffb0000, s->irq[1][OMAP_INT_UART1],
omap1.c:                    s->drq[OMAP_DMA_UART1_TX], s->drq[OMAP_DMA_UART1_RX],
omap1.c:    s->uart[1] = omap_uart_init(0xfffb0800, s->irq[1][OMAP_INT_UART2],
omap1.c:                    s->drq[OMAP_DMA_UART2_TX], s->drq[OMAP_DMA_UART2_RX],
omap1.c:    s->uart[2] = omap_uart_init(0xfffb9800, s->irq[0][OMAP_INT_UART3],
omap1.c:                    s->drq[OMAP_DMA_UART3_TX], s->drq[OMAP_DMA_UART3_RX],
omap1.c:    omap_dpll_init(&s->dpll[0], 0xfffecf00, omap_findclk(s, "dpll1"));
omap1.c:    omap_dpll_init(&s->dpll[1], 0xfffed000, omap_findclk(s, "dpll2"));
omap1.c:    omap_dpll_init(&s->dpll[2], 0xfffed100, omap_findclk(s, "dpll3"));
omap1.c:    s->mmc = omap_mmc_init(0xfffb7800, dinfo->bdrv,
omap1.c:                    s->irq[1][OMAP_INT_OQN], &s->drq[OMAP_DMA_MMC_TX],
omap1.c:    s->mpuio = omap_mpuio_init(0xfffb5000,
omap1.c:                    s->irq[1][OMAP_INT_KEYBOARD], s->irq[1][OMAP_INT_MPUIO],
omap1.c:                    s->wakeup, omap_findclk(s, "clk32-kHz"));
omap1.c:    s->gpio = omap_gpio_init(0xfffce000, s->irq[0][OMAP_INT_GPIO_BANK1],
omap1.c:    s->microwire = omap_uwire_init(0xfffb3000, &s->irq[1][OMAP_INT_uWireTX],
omap1.c:                    s->drq[OMAP_DMA_UWIRE_TX], omap_findclk(s, "mpuper_ck"));
omap1.c:    s->i2c[0] = omap_i2c_init(0xfffb3800, s->irq[1][OMAP_INT_I2C],
omap1.c:                    &s->drq[OMAP_DMA_I2C_RX], omap_findclk(s, "mpuper_ck"));
omap1.c:    s->rtc = omap_rtc_init(0xfffb4800, &s->irq[1][OMAP_INT_RTC_TIMER],
omap1.c:                    omap_findclk(s, "clk32-kHz"));
omap1.c:    s->mcbsp1 = omap_mcbsp_init(0xfffb1800, &s->irq[1][OMAP_INT_McBSP1TX],
omap1.c:                    &s->drq[OMAP_DMA_MCBSP1_TX], omap_findclk(s, "dspxor_ck"));
omap1.c:    s->mcbsp2 = omap_mcbsp_init(0xfffb1000, &s->irq[0][OMAP_INT_310_McBSP2_TX],
omap1.c:                    &s->drq[OMAP_DMA_MCBSP2_TX], omap_findclk(s, "mpuper_ck"));
omap1.c:    s->mcbsp3 = omap_mcbsp_init(0xfffb7000, &s->irq[1][OMAP_INT_McBSP3TX],
omap1.c:                    &s->drq[OMAP_DMA_MCBSP3_TX], omap_findclk(s, "dspxor_ck"));
omap1.c:    s->led[0] = omap_lpg_init(0xfffbd000, omap_findclk(s, "clk32-kHz"));
omap1.c:    s->led[1] = omap_lpg_init(0xfffbd800, omap_findclk(s, "clk32-kHz"));
omap1.c:     * MCSI2 Comm	fffb2000 - fffb27ff (not mapped on OMAP310)
omap1.c:     * MCSI1 Bluetooth	fffb2800 - fffb2fff (not mapped on OMAP310)
omap1.c:     * USB W2FC		fffb4000 - fffb47ff
omap1.c:     * Camera Interface	fffb6800 - fffb6fff
omap1.c:     * USB Host		fffba000 - fffba7ff
omap1.c:     * FAC		fffba800 - fffbafff
omap1.c:     * HDQ/1-Wire	fffbc000 - fffbc7ff
omap1.c:     * TIPB switches	fffbc800 - fffbcfff
omap1.c:     * Mailbox		fffcf000 - fffcf7ff
omap1.c:     * Local bus IF	fffec100 - fffec1ff
omap1.c:     * Local bus MMU	fffec200 - fffec2ff
omap1.c:     * DSP MMU		fffed200 - fffed2ff
omap2.c: * Copyright (C) 2007-2008 Nokia Corporation
omap2.c:#include "arm-misc.h"
omap2.c:#include "qemu-timer.h"
omap2.c:#include "qemu-char.h"
omap2.c:    if (timer->it_ena & it) {
omap2.c:        if (!timer->status)
omap2.c:            qemu_irq_raise(timer->irq);
omap2.c:        timer->status |= it;
omap2.c:    if (timer->wu_ena & it)
omap2.c:        qemu_irq_pulse(timer->wkup);
omap2.c:    if (!timer->inout && timer->out_val != level) {
omap2.c:        timer->out_val = level;
omap2.c:        qemu_set_irq(timer->out, level);
omap2.c:    if (timer->st && timer->rate) {
omap2.c:        distance = qemu_get_clock(vm_clock) - timer->time;
omap2.c:        distance = muldiv64(distance, timer->rate, timer->ticks_per_sec);
omap2.c:        if (distance >= 0xffffffff - timer->val)
omap2.c:            return timer->val + distance;
omap2.c:        return timer->val;
omap2.c:    if (timer->st) {
omap2.c:        timer->val = omap_gp_timer_read(timer);
omap2.c:        timer->time = qemu_get_clock(vm_clock);
omap2.c:    if (timer->st && timer->rate) {
omap2.c:        expires = muldiv64(0x100000000ll - timer->val,
omap2.c:                        timer->ticks_per_sec, timer->rate);
omap2.c:        qemu_mod_timer(timer->timer, timer->time + expires);
omap2.c:        if (timer->ce && timer->match_val >= timer->val) {
omap2.c:            matches = muldiv64(timer->match_val - timer->val,
omap2.c:                            timer->ticks_per_sec, timer->rate);
omap2.c:            qemu_mod_timer(timer->match, timer->time + matches);
omap2.c:            qemu_del_timer(timer->match);
omap2.c:        qemu_del_timer(timer->timer);
omap2.c:        qemu_del_timer(timer->match);
omap2.c:        omap_gp_timer_out(timer, timer->scpwm);
omap2.c:    if (timer->pt)
omap2.c:        /* TODO in overflow-and-match mode if the first event to
omap2.c:        omap_gp_timer_out(timer, !timer->out_val);
omap2.c:        /* TODO inverted pulse on timer->out_val == 1?  */
omap2.c:        qemu_irq_pulse(timer->out);
omap2.c:    if (!timer->ar) {
omap2.c:        timer->st = 0;
omap2.c:        timer->val = 0;
omap2.c:        timer->val = timer->load_val;
omap2.c:        timer->time = qemu_get_clock(vm_clock);
omap2.c:    if (timer->trigger == gpt_trigger_overflow ||
omap2.c:                    timer->trigger == gpt_trigger_both)
omap2.c:    if (timer->trigger == gpt_trigger_both)
omap2.c:    switch (s->capture) {
omap2.c:        trigger = !s->in_val && on;
omap2.c:        trigger = s->in_val && !on;
omap2.c:        trigger = (s->in_val == !on);
omap2.c:    s->in_val = on;
omap2.c:    if (s->inout && trigger && s->capt_num < 2) {
omap2.c:        s->capture_val[s->capt_num] = omap_gp_timer_read(s);
omap2.c:        if (s->capt2 == s->capt_num ++)
omap2.c:    timer->rate = on ? omap_clk_getrate(timer->clk) : 0;
omap2.c:    omap_clk_adduser(timer->clk,
omap2.c:    timer->rate = omap_clk_getrate(timer->clk);
omap2.c:    s->config = 0x000;
omap2.c:    s->status = 0;
omap2.c:    s->it_ena = 0;
omap2.c:    s->wu_ena = 0;
omap2.c:    s->inout = 0;
omap2.c:    s->capt2 = 0;
omap2.c:    s->capt_num = 0;
omap2.c:    s->pt = 0;
omap2.c:    s->trigger = gpt_trigger_none;
omap2.c:    s->capture = gpt_capture_none;
omap2.c:    s->scpwm = 0;
omap2.c:    s->ce = 0;
omap2.c:    s->pre = 0;
omap2.c:    s->ptv = 0;
omap2.c:    s->ar = 0;
omap2.c:    s->st = 0;
omap2.c:    s->posted = 1;
omap2.c:    s->val = 0x00000000;
omap2.c:    s->load_val = 0x00000000;
omap2.c:    s->capture_val[0] = 0x00000000;
omap2.c:    s->capture_val[1] = 0x00000000;
omap2.c:    s->match_val = 0x00000000;
omap2.c:        return s->config;
omap2.c:        return s->status;
omap2.c:        return s->it_ena;
omap2.c:        return s->wu_ena;
omap2.c:        return (s->inout << 14) |
omap2.c:                (s->capt2 << 13) |
omap2.c:                (s->pt << 12) |
omap2.c:                (s->trigger << 10) |
omap2.c:                (s->capture << 8) |
omap2.c:                (s->scpwm << 7) |
omap2.c:                (s->ce << 6) |
omap2.c:                (s->pre << 5) |
omap2.c:                (s->ptv << 2) |
omap2.c:                (s->ar << 1) |
omap2.c:                (s->st << 0);
omap2.c:        return s->load_val;
omap2.c:        return s->match_val;
omap2.c:        return s->capture_val[0];
omap2.c:        return s->posted << 2;
omap2.c:        return s->capture_val[1];
omap2.c:        return s->readh;
omap2.c:        s->readh = ret >> 16;
omap2.c:        s->config = value & 0x33d;
omap2.c:            s->capt_num = 0;
omap2.c:        if (s->status && !(s->status &= ~value))
omap2.c:            qemu_irq_lower(s->irq);
omap2.c:        s->it_ena = value & 7;
omap2.c:        s->wu_ena = value & 7;
omap2.c:        s->inout = (value >> 14) & 1;
omap2.c:        s->capt2 = (value >> 13) & 1;
omap2.c:        s->pt = (value >> 12) & 1;
omap2.c:        s->trigger = (value >> 10) & 3;
omap2.c:        if (s->capture == gpt_capture_none &&
omap2.c:            s->capt_num = 0;
omap2.c:        s->capture = (value >> 8) & 3;
omap2.c:        s->scpwm = (value >> 7) & 1;
omap2.c:        s->ce = (value >> 6) & 1;
omap2.c:        s->pre = (value >> 5) & 1;
omap2.c:        s->ptv = (value >> 2) & 7;
omap2.c:        s->ar = (value >> 1) & 1;
omap2.c:        s->st = (value >> 0) & 1;
omap2.c:        if (s->inout && s->trigger != gpt_trigger_none)
omap2.c:        if (!s->inout && s->capture != gpt_capture_none)
omap2.c:        if (s->trigger == gpt_trigger_none)
omap2.c:            omap_gp_timer_out(s, s->scpwm);
omap2.c:        /* TODO: make sure this doesn't overflow 32-bits */
omap2.c:        s->ticks_per_sec = get_ticks_per_sec() << (s->pre ? s->ptv + 1 : 0);
omap2.c:        s->time = qemu_get_clock(vm_clock);
omap2.c:        s->val = value;
omap2.c:        s->load_val = value;
omap2.c:        s->time = qemu_get_clock(vm_clock);
omap2.c:        s->val = s->load_val;
omap2.c:        s->match_val = value;
omap2.c:        s->posted = (value >> 2) & 1;
omap2.c:        return omap_gp_timer_write(opaque, addr, (value << 16) | s->writeh);
omap2.c:        s->writeh = (uint16_t) value;
omap2.c:    s->ta = ta;
omap2.c:    s->irq = irq;
omap2.c:    s->clk = fclk;
omap2.c:    s->timer = qemu_new_timer(vm_clock, omap_gp_timer_tick, s);
omap2.c:    s->match = qemu_new_timer(vm_clock, omap_gp_timer_match, s);
omap2.c:    s->in = qemu_allocate_irqs(omap_gp_timer_input, s, 1)[0];
omap2.c:/* 32-kHz Sync Timer of the OMAP2 */
omap2.c:    s->val = omap_synctimer_read(s);
omap2.c:        return omap_synctimer_read(s) - s->val;
omap2.c:        return s->readh;
omap2.c:        s->readh = ret >> 16;
omap2.c:    struct omap_synctimer_s *s = &mpu->synctimer;
omap2.c:/* General-Purpose Interface of OMAP2 */
omap2.c:    qemu_set_irq(s->irq[line], s->ints[line] & s->mask[line]);
omap2.c:    if (!(s->config[0] & (1 << 2)))			/* ENAWAKEUP */
omap2.c:    if (!(s->config[0] & (3 << 3)))			/* Force Idle */
omap2.c:    if (!(s->wumask & (1 << line)))
omap2.c:    qemu_irq_raise(s->wkup);
omap2.c:    s->outputs ^= diff;
omap2.c:    diff &= ~s->dir;
omap2.c:        ln --;
omap2.c:        qemu_set_irq(s->handler[ln], (s->outputs >> ln) & 1);
omap2.c:    s->ints[line] |= s->dir &
omap2.c:            ((s->inputs & s->level[1]) | (~s->inputs & s->level[0]));
omap2.c:    s->ints[0] |= 1 << line;
omap2.c:    s->ints[1] |= 1 << line;
omap2.c:        if (s->dir & (1 << line) & ((~s->inputs & s->edge[0]) | s->level[1]))
omap2.c:        s->inputs |= 1 << line;
omap2.c:        if (s->dir & (1 << line) & ((s->inputs & s->edge[1]) | s->level[0]))
omap2.c:        s->inputs &= ~(1 << line);
omap2.c:    s->config[0] = 0;
omap2.c:    s->config[1] = 2;
omap2.c:    s->ints[0] = 0;
omap2.c:    s->ints[1] = 0;
omap2.c:    s->mask[0] = 0;
omap2.c:    s->mask[1] = 0;
omap2.c:    s->wumask = 0;
omap2.c:    s->dir = ~0;
omap2.c:    s->level[0] = 0;
omap2.c:    s->level[1] = 0;
omap2.c:    s->edge[0] = 0;
omap2.c:    s->edge[1] = 0;
omap2.c:    s->debounce = 0;
omap2.c:    s->delay = 0;
omap2.c:        return s->config[0];
omap2.c:        return s->ints[0];
omap2.c:        return s->mask[0];
omap2.c:        return s->wumask;
omap2.c:        return s->ints[1];
omap2.c:        return s->mask[1];
omap2.c:        return s->config[1];
omap2.c:        return s->dir;
omap2.c:        return s->inputs;
omap2.c:        return s->outputs;
omap2.c:        return s->level[0];
omap2.c:        return s->level[1];
omap2.c:        return s->edge[0];
omap2.c:        return s->edge[1];
omap2.c:        return s->debounce;
omap2.c:        return s->delay;
omap2.c:        s->config[0] = value & 0x1d;
omap2.c:        if (s->ints[0] & value) {
omap2.c:            s->ints[0] &= ~value;
omap2.c:        s->mask[0] = value;
omap2.c:        s->wumask = value;
omap2.c:        if (s->ints[1] & value) {
omap2.c:            s->ints[1] &= ~value;
omap2.c:        s->mask[1] = value;
omap2.c:        s->config[1] = value & 7;
omap2.c:        diff = s->outputs & (s->dir ^ value);
omap2.c:        s->dir = value;
omap2.c:        value = s->outputs & ~s->dir;
omap2.c:            diff &= ~(1 <<-- ln);
omap2.c:            qemu_set_irq(s->handler[ln], (value >> ln) & 1);
omap2.c:        omap_gpio_module_out_update(s, s->outputs ^ value);
omap2.c:        s->level[0] = value;
omap2.c:        s->level[1] = value;
omap2.c:        s->edge[0] = value;
omap2.c:        s->edge[1] = value;
omap2.c:        s->debounce = value;
omap2.c:        s->delay = value;
omap2.c:        s->mask[0] &= ~value;
omap2.c:        s->mask[0] |= value;
omap2.c:        s->mask[1] &= ~value;
omap2.c:        s->mask[1] |= value;
omap2.c:        s->wumask &= ~value;
omap2.c:        s->wumask |= value;
omap2.c:        omap_gpio_module_out_update(s, s->outputs & value);
omap2.c:        omap_gpio_module_out_update(s, ~s->outputs & value);
omap2.c:    s->irq[0] = mpu;
omap2.c:    s->irq[1] = dsp;
omap2.c:    s->wkup = wkup;
omap2.c:    s->in = qemu_allocate_irqs(omap_gpio_module_set, s, 32);
omap2.c:    for (i = 0; i < s->modules; i ++)
omap2.c:        omap_gpio_module_reset(s->module + i);
omap2.c:    s->autoidle = 0;
omap2.c:    s->gpo = 0;
omap2.c:        return s->autoidle;
omap2.c:        return s->gpo;
omap2.c:        s->autoidle = value & 1;
omap2.c:        s->gpo = value & 1;
omap2.c:    s->modules = modules;
omap2.c:        omap_gpio_module_init(s->module + i, ta, region[i],
omap2.c:    if (start >= s->modules * 32 || start < 0)
omap2.c:    return s->module[start >> 5].in + (start & 31);
omap2.c:    if (line >= s->modules * 32 || line < 0)
omap2.c:    s->module[line >> 5].handler[line & 31] = handler;
omap2.c:    qemu_set_irq(s->irq, s->irqst & s->irqen);
omap2.c:    qemu_set_irq(ch->txdrq,
omap2.c:                    (ch->control & 1) &&		/* EN */
omap2.c:                    (ch->config & (1 << 14)) &&		/* DMAW */
omap2.c:                    (ch->status & (1 << 1)) &&		/* TXS */
omap2.c:                    ((ch->config >> 12) & 3) != 1);	/* TRM */
omap2.c:    qemu_set_irq(ch->rxdrq,
omap2.c:                    (ch->control & 1) &&		/* EN */
omap2.c:                    (ch->config & (1 << 15)) &&		/* DMAW */
omap2.c:                    (ch->status & (1 << 0)) &&		/* RXS */
omap2.c:                    ((ch->config >> 12) & 3) != 2);	/* TRM */
omap2.c:    struct omap_mcspi_ch_s *ch = s->ch + chnum;
omap2.c:    if (!(ch->control & 1))				/* EN */
omap2.c:    if ((ch->status & (1 << 0)) &&			/* RXS */
omap2.c:                    ((ch->config >> 12) & 3) != 2 &&	/* TRM */
omap2.c:                    !(ch->config & (1 << 19)))		/* TURBO */
omap2.c:    if ((ch->status & (1 << 1)) &&			/* TXS */
omap2.c:                    ((ch->config >> 12) & 3) != 1)	/* TRM */
omap2.c:    if (!(s->control & 1) ||				/* SINGLE */
omap2.c:                    (ch->config & (1 << 20))) {		/* FORCE */
omap2.c:        if (ch->txrx)
omap2.c:            ch->rx = ch->txrx(ch->opaque, ch->tx,	/* WL */
omap2.c:                            1 + (0x1f & (ch->config >> 7)));
omap2.c:    ch->tx = 0;
omap2.c:    ch->status |= 1 << 2;				/* EOT */
omap2.c:    ch->status |= 1 << 1;				/* TXS */
omap2.c:    if (((ch->config >> 12) & 3) != 2)			/* TRM */
omap2.c:        ch->status |= 1 << 0;				/* RXS */
omap2.c:    if ((ch->status & (1 << 0)) &&			/* RXS */
omap2.c:                    ((ch->config >> 12) & 3) != 2 &&	/* TRM */
omap2.c:                    !(ch->config & (1 << 19)))		/* TURBO */
omap2.c:        s->irqst |= 1 << (2 + 4 * chnum);		/* RX_FULL */
omap2.c:    if ((ch->status & (1 << 1)) &&			/* TXS */
omap2.c:                    ((ch->config >> 12) & 3) != 1)	/* TRM */
omap2.c:        s->irqst |= 1 << (0 + 4 * chnum);		/* TX_EMPTY */
omap2.c:    s->sysconfig = 0;
omap2.c:    s->systest = 0;
omap2.c:    s->irqst = 0;
omap2.c:    s->irqen = 0;
omap2.c:    s->wken = 0;
omap2.c:    s->control = 4;
omap2.c:        s->ch[ch].config = 0x060000;
omap2.c:        s->ch[ch].status = 2;				/* TXS */
omap2.c:        s->ch[ch].control = 0;
omap2.c:        omap_mcspi_dmarequest_update(s->ch + ch);
omap2.c:        return s->sysconfig;
omap2.c:        return s->irqst;
omap2.c:        return s->irqen;
omap2.c:        return s->wken;
omap2.c:        return s->systest;
omap2.c:        return s->control;
omap2.c:        return s->ch[ch].config;
omap2.c:        return s->ch[ch].status;
omap2.c:        return s->ch[ch].control;
omap2.c:        return s->ch[ch].tx;
omap2.c:        s->ch[ch].status &= ~(1 << 0);			/* RXS */
omap2.c:        ret = s->ch[ch].rx;
omap2.c:        s->sysconfig = value & 0x31d;
omap2.c:        if (!((s->control & (1 << 3)) && (s->systest & (1 << 11)))) {
omap2.c:            s->irqst &= ~value;
omap2.c:        s->irqen = value & 0x1777f;
omap2.c:        s->wken = value & 1;
omap2.c:        if (s->control & (1 << 3))			/* SYSTEM_TEST */
omap2.c:                s->irqst |= 0x1777f;
omap2.c:        s->systest = value & 0xfff;
omap2.c:            if (s->systest & (1 << 11)) {		/* SSB */
omap2.c:                s->irqst |= 0x1777f;
omap2.c:        s->control = value & 0xf;
omap2.c:        if ((value ^ s->ch[ch].config) & (3 << 14))	/* DMAR | DMAW */
omap2.c:            omap_mcspi_dmarequest_update(s->ch + ch);
omap2.c:        s->ch[ch].config = value & 0x7fffff;
omap2.c:        if (value & ~s->ch[ch].control & 1) {		/* EN */
omap2.c:            s->ch[ch].control |= 1;
omap2.c:            s->ch[ch].control = value & 1;
omap2.c:        s->ch[ch].tx = value;
omap2.c:        s->ch[ch].status &= ~(1 << 1);			/* TXS */
omap2.c:    struct omap_mcspi_ch_s *ch = s->ch;
omap2.c:    s->irq = irq;
omap2.c:    s->chnum = chnum;
omap2.c:    while (chnum --) {
omap2.c:        ch->txdrq = *drq ++;
omap2.c:        ch->rxdrq = *drq ++;
omap2.c:    if (chipselect < 0 || chipselect >= s->chnum)
omap2.c:    s->ch[chipselect].txrx = txrx;
omap2.c:    s->ch[chipselect].opaque = opaque;
omap2.c:    qemu_set_irq(s->irq, (s->codec.config[1] >> 14) & 1);	/* AURDI */
omap2.c:    qemu_set_irq(s->codec.rxdrq, (s->codec.rxavail || s->codec.rxlen) &&
omap2.c:                    ((s->codec.config[1] >> 12) & 1));		/* DMAREN */
omap2.c:    qemu_set_irq(s->codec.txdrq, s->codec.txlen < s->codec.txavail &&
omap2.c:                    ((s->codec.config[1] >> 11) & 1));		/* DMAWEN */
omap2.c:    int left = MIN(EAC_BUF_LEN - s->codec.rxlen, s->codec.rxavail) << 2;
omap2.c:    int start = ((s->codec.rxoff + s->codec.rxlen) & (EAC_BUF_LEN - 1)) << 2;
omap2.c:    int leftwrap = MIN(left, (EAC_BUF_LEN << 2) - start);
omap2.c:    uint8_t *buf = (uint8_t *) s->codec.rxbuf + start;
omap2.c:    left -= leftwrap;
omap2.c:    while (leftwrap && (recv = AUD_read(s->codec.in_voice, buf + start,
omap2.c:        leftwrap -= recv;
omap2.c:        s->codec.rxavail = 0;
omap2.c:        s->codec.rxavail -= start >> 2;
omap2.c:    s->codec.rxlen += start >> 2;
omap2.c:        while (left && (recv = AUD_read(s->codec.in_voice,
omap2.c:                                        (uint8_t *) s->codec.rxbuf + start,
omap2.c:            left -= recv;
omap2.c:            s->codec.rxavail = 0;
omap2.c:            s->codec.rxavail -= start >> 2;
omap2.c:        s->codec.rxlen += start >> 2;
omap2.c:    int left = s->codec.txlen << 2;
omap2.c:    while (left && (sent = AUD_write(s->codec.out_voice,
omap2.c:                                    (uint8_t *) s->codec.txbuf + start,
omap2.c:        left -= sent;
omap2.c:        s->codec.txavail = 0;
omap2.c:        s->codec.txlen = 0;
omap2.c:    s->codec.rxavail = avail_b >> 2;
omap2.c:    s->codec.txavail = free_b >> 2;
omap2.c:    if (s->codec.txlen)
omap2.c:    s->codec.enable = !(s->codec.config[1] & 1) &&		/* EACPWD */
omap2.c:            (s->codec.config[1] & 2) &&				/* AUDEN */
omap2.c:            s->codec.hw_enable;
omap2.c:    fsint[2] = (s->codec.config[3] >> 9) & 0xf;
omap2.c:    fsint[1] = (s->codec.config[2] >> 0) & 0x7;
omap2.c:    fsint[0] = (s->codec.config[0] >> 6) & 0x3;
omap2.c:        s->codec.rate = omap_eac_fsint3[fsint[2]];
omap2.c:        s->codec.rate = omap_eac_fsint2[fsint[1]];
omap2.c:        s->codec.rate = omap_eac_fsint[fsint[0]];
omap2.c:    if (s->codec.rxlen)
omap2.c:        s->codec.rxlen = 1;
omap2.c:    if (s->codec.in_voice) {
omap2.c:        AUD_set_active_in(s->codec.in_voice, 0);
omap2.c:        AUD_close_in(&s->codec.card, s->codec.in_voice);
omap2.c:        s->codec.in_voice = NULL;
omap2.c:    if (s->codec.out_voice) {
omap2.c:        AUD_set_active_out(s->codec.out_voice, 0);
omap2.c:        AUD_close_out(&s->codec.card, s->codec.out_voice);
omap2.c:        s->codec.out_voice = NULL;
omap2.c:        s->codec.txavail = 0;
omap2.c:    s->codec.txlen = 0;
omap2.c:    if (!s->codec.enable)
omap2.c:    fmt.endianness = ((s->codec.config[0] >> 8) & 1);		/* LI_BI */
omap2.c:    fmt.nchannels = ((s->codec.config[0] >> 10) & 1) ? 2 : 1;	/* MN_ST */
omap2.c:    fmt.freq = s->codec.rate;
omap2.c:    /* TODO: signedness possibly depends on the CODEC hardware - or
omap2.c:    /* All register writes are 16 bits so we we store 16-bit samples
omap2.c:    s->codec.in_voice = AUD_open_in(&s->codec.card, s->codec.in_voice,
omap2.c:    s->codec.out_voice = AUD_open_out(&s->codec.card, s->codec.out_voice,
omap2.c:    AUD_set_active_in(s->codec.in_voice, 1);
omap2.c:    AUD_set_active_out(s->codec.out_voice, 1);
omap2.c:    s->sysconfig = 0;
omap2.c:    s->config[0] = 0x0c;
omap2.c:    s->config[1] = 0x09;
omap2.c:    s->config[2] = 0xab;
omap2.c:    s->config[3] = 0x03;
omap2.c:    s->control = 0x00;
omap2.c:    s->address = 0x00;
omap2.c:    s->data = 0x0000;
omap2.c:    s->vtol = 0x00;
omap2.c:    s->vtsl = 0x00;
omap2.c:    s->mixer = 0x0000;
omap2.c:    s->gain[0] = 0xe7e7;
omap2.c:    s->gain[1] = 0x6767;
omap2.c:    s->gain[2] = 0x6767;
omap2.c:    s->gain[3] = 0x6767;
omap2.c:    s->att = 0xce;
omap2.c:    s->max[0] = 0;
omap2.c:    s->max[1] = 0;
omap2.c:    s->max[2] = 0;
omap2.c:    s->max[3] = 0;
omap2.c:    s->max[4] = 0;
omap2.c:    s->max[5] = 0;
omap2.c:    s->max[6] = 0;
omap2.c:    s->modem.control = 0x00;
omap2.c:    s->modem.config = 0x0000;
omap2.c:    s->bt.control = 0x00;
omap2.c:    s->bt.config = 0x0000;
omap2.c:    s->codec.config[0] = 0x0649;
omap2.c:    s->codec.config[1] = 0x0000;
omap2.c:    s->codec.config[2] = 0x0007;
omap2.c:    s->codec.config[3] = 0x1ffc;
omap2.c:    s->codec.rxoff = 0;
omap2.c:    s->codec.rxlen = 0;
omap2.c:    s->codec.txlen = 0;
omap2.c:    s->codec.rxavail = 0;
omap2.c:    s->codec.txavail = 0;
omap2.c:        return s->config[0];
omap2.c:        return s->config[1];
omap2.c:        return s->config[2];
omap2.c:        return s->config[3];
omap2.c:        return s->control | ((s->codec.rxavail + s->codec.rxlen > 0) << 7) |
omap2.c:                ((s->codec.txlen < s->codec.txavail) << 5);
omap2.c:        return s->address;
omap2.c:        return s->data & 0xff;
omap2.c:        return s->data >> 8;
omap2.c:        return s->vtol;
omap2.c:        return s->vtsl | (3 << 5);	/* CRDY1 | CRDY2 */
omap2.c:        return s->modem.control;
omap2.c:        return s->modem.config;
omap2.c:        return s->bt.control;
omap2.c:        return s->bt.config;
omap2.c:        return s->mixer;
omap2.c:        return s->gain[0];
omap2.c:        return s->gain[1];
omap2.c:        return s->gain[2];
omap2.c:        return s->gain[3];
omap2.c:        return s->att;
omap2.c:        return s->max[0];
omap2.c:        return s->max[1];
omap2.c:        return s->max[2];
omap2.c:        return s->max[3];
omap2.c:        return s->max[4];
omap2.c:        return s->max[5];
omap2.c:        return s->max[6];
omap2.c:        /* This should be write-only?  Docs list it as read-only.  */
omap2.c:        if (likely(s->codec.rxlen > 1)) {
omap2.c:            ret = s->codec.rxbuf[s->codec.rxoff ++];
omap2.c:            s->codec.rxlen --;
omap2.c:            s->codec.rxoff &= EAC_BUF_LEN - 1;
omap2.c:        } else if (s->codec.rxlen) {
omap2.c:            ret = s->codec.rxbuf[s->codec.rxoff ++];
omap2.c:            s->codec.rxlen --;
omap2.c:            s->codec.rxoff &= EAC_BUF_LEN - 1;
omap2.c:            if (s->codec.rxavail)
omap2.c:        return s->codec.config[0];
omap2.c:        return s->codec.config[1] | ((s->codec.config[1] & 2) << 14);
omap2.c:        return s->codec.config[2];
omap2.c:        return s->codec.config[3];
omap2.c:        return s->sysconfig;
omap2.c:        s->config[0] = value & 0xff;
omap2.c:        s->config[1] = value & 0xff;
omap2.c:        s->config[2] = value & 0xff;
omap2.c:        s->config[3] = value & 0xff;
omap2.c:        /* Assuming TXF and TXE bits are read-only... */
omap2.c:        s->control = value & 0x5f;
omap2.c:        s->address = value & 0xff;
omap2.c:        s->data &= 0xff00;
omap2.c:        s->data |= value & 0xff;
omap2.c:        s->data &= 0x00ff;
omap2.c:        s->data |= value << 8;
omap2.c:        s->vtol = value & 0xf8;
omap2.c:        s->vtsl = value & 0x9f;
omap2.c:        s->modem.control = value & 0x8f;
omap2.c:        s->modem.config = value & 0x7fff;
omap2.c:        s->bt.control = value & 0x8f;
omap2.c:        s->bt.config = value & 0x7fff;
omap2.c:        s->mixer = value & 0x0fff;
omap2.c:        s->gain[0] = value & 0xffff;
omap2.c:        s->gain[1] = value & 0xff7f;
omap2.c:        s->gain[2] = value & 0xff7f;
omap2.c:        s->gain[3] = value & 0xff7f;
omap2.c:        s->att = value & 0xff;
omap2.c:        s->codec.txbuf[s->codec.txlen ++] = value;
omap2.c:        if (unlikely(s->codec.txlen == EAC_BUF_LEN ||
omap2.c:                                s->codec.txlen == s->codec.txavail)) {
omap2.c:            if (s->codec.txavail)
omap2.c:            s->codec.txlen = 0;
omap2.c:        s->codec.config[0] = value & 0x07ff;
omap2.c:        s->codec.config[1] = value & 0x780f;
omap2.c:        s->codec.config[2] = value & 0x003f;
omap2.c:        s->codec.config[3] = value & 0xffff;
omap2.c:        s->sysconfig = value & 0x31d;
omap2.c:    s->irq = irq;
omap2.c:    s->codec.rxdrq = *drq ++;
omap2.c:    s->codec.txdrq = *drq ++;
omap2.c:    AUD_register_card("OMAP EAC", &s->codec.card);
omap2.c:/* STI/XTI (emulation interface) console - reverse engineered only */
omap2.c:    qemu_set_irq(s->irq, s->irqst & s->irqen);
omap2.c:    s->sysconfig = 0;
omap2.c:    s->irqst = 0;
omap2.c:    s->irqen = 0;
omap2.c:    s->clkcontrol = 0;
omap2.c:    s->serial_config = 0;
omap2.c:        return s->sysconfig;
omap2.c:        return s->irqst;
omap2.c:        return s->irqen;
omap2.c:        return s->clkcontrol;
omap2.c:        return s->serial_config;
omap2.c:        s->sysconfig = value & 0xfe;
omap2.c:        s->irqst &= ~value;
omap2.c:        s->irqen = value & 0xffff;
omap2.c:        s->clkcontrol = value & 0xff;
omap2.c:        s->serial_config = value & 0xff;
omap2.c:        qemu_chr_write(s->chr, (const uint8_t *) "\r", 1);
omap2.c:            qemu_chr_write(s->chr, (const uint8_t *) "\n", 1);
omap2.c:            qemu_chr_write(s->chr, &byte, 1);
omap2.c:    s->irq = irq;
omap2.c:    s->chr = chr ?: qemu_chr_open("null", "null", NULL);
omap2.c:    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
omap2.c:    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
omap2.c:    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
omap2.c:    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
omap2.c:    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
omap2.c:    unsigned int i = (addr - OMAP2_L4_BASE) >> TARGET_PAGE_BITS;
omap2.c:                    sizeof(*bus) + ta_num * sizeof(*bus->ta));
omap2.c:    bus->ta_num = ta_num;
omap2.c:    bus->base = base;
omap2.c:        return s->component;
omap2.c:        return s->control;
omap2.c:        return s->status;
omap2.c:        s->control = value & 0x01000700;
omap2.c:            s->status &= ~1;				/* REQ_TIMEOUT */
omap2.c:    [123] = { 0xb2000, 0x1000, 32          }, /* HDQ/1-Wire */
omap2.c:    { -1,        121, 2, 1 },
omap2.c:    { L4TA(39),  123, 2, 1 }, /* HDQ/1-Wire */
omap2.c:    for (i = 0; i < bus->ta_num; i ++)
omap2.c:            ta = &bus->ta[i];
omap2.c:        exit(-1);
omap2.c:    ta->bus = bus;
omap2.c:    ta->start = &omap_l4_region[info->region];
omap2.c:    ta->regions = info->regions;
omap2.c:    ta->component = ('Q' << 24) | ('E' << 16) | ('M' << 8) | ('U' << 0);
omap2.c:    ta->status = 0x00000000;
omap2.c:    ta->control = 0x00000200;	/* XXX 01000200 for L4TAO */
omap2.c:    ta->base = omap_l4_attach(ta, info->ta_region, iomemtype);
omap2.c:    if (region < 0 || region >= ta->regions) {
omap2.c:        exit(-1);
omap2.c:    base = ta->bus->base + ta->start[region].offset;
omap2.c:    size = ta->start[region].size;
omap2.c:        i = (base - ta->bus->base) / TARGET_PAGE_SIZE;
omap2.c:        for (; size > 0; size -= TARGET_PAGE_SIZE, i ++) {
omap2.c:/* TEST-Chip-level TAP */
omap2.c:        switch (s->mpu_model) {
omap2.c:        switch (s->mpu_model) {
omap2.c:        switch (s->mpu_model) {
omap2.c:    qemu_set_irq(s->irq[dom], s->irqst[dom] & s->irqen[dom]);
omap2.c:        return s->sysconfig;
omap2.c:        return s->irqst[0];
omap2.c:        return s->irqen[0];
omap2.c:        return s->voltctrl;
omap2.c:        return s->voltctrl & 3;
omap2.c:        return s->clksrc[0];
omap2.c:        return s->clkout[0];
omap2.c:        return s->clkemul[0];
omap2.c:        return s->setuptime[0];
omap2.c:        return s->setuptime[1];
omap2.c:        return s->clkpol[0];
omap2.c:        return s->scratch[(addr - 0xb0) >> 2];
omap2.c:        return s->clksel[0];
omap2.c:        return s->clkctrl[0];
omap2.c:        return s->rst[0];
omap2.c:        return s->wkup[0];
omap2.c:        return s->ev;
omap2.c:        return s->evtime[0];
omap2.c:        return s->evtime[1];
omap2.c:        return s->power[0];
omap2.c:        return s->clken[0];
omap2.c:        return s->clken[1];
omap2.c:        return s->clken[2];
omap2.c:        return s->clken[3];
omap2.c:        return s->clken[4];
omap2.c:        return s->clkidle[0];
omap2.c:        return s->clkidle[1];
omap2.c:        return s->clkidle[2];
omap2.c:        return s->clkidle[3];
omap2.c:        return s->clksel[1];
omap2.c:        return s->clksel[2];
omap2.c:        return s->clkctrl[1];
omap2.c:        return s->wken[0];
omap2.c:        return s->wken[1];
omap2.c:        return s->wkst[0];
omap2.c:        return s->wkst[1];
omap2.c:        return s->power[1];
omap2.c:        return 0x000030 | (s->power[1] & 0xfc00);
omap2.c:        return s->clken[5];
omap2.c:        return s->clken[6];
omap2.c:        return s->clksel[3];
omap2.c:        return s->clkctrl[2];
omap2.c:        return s->rstctrl[0];
omap2.c:        return s->rst[1];
omap2.c:        return s->wkup[1];
omap2.c:        return s->power[2];
omap2.c:        return s->power[2] & 3;
omap2.c:        return s->clken[7];
omap2.c:        return s->clken[8];
omap2.c:        return s->clkidle[4];
omap2.c:        return s->clksel[4];
omap2.c:        return s->rsttime_wkup;
omap2.c:        return s->rst[2];
omap2.c:        return s->wken[2];
omap2.c:        return s->wkst[2];
omap2.c:        return s->clken[9];
omap2.c:        ret = 0x0000070 | (s->apll_lock[0] << 9) | (s->apll_lock[1] << 8);
omap2.c:        if (!(s->clksel[6] & 3))
omap2.c:            /* Core uses 32-kHz clock */
omap2.c:        else if (!s->dpll_lock)
omap2.c:        return s->clkidle[5];
omap2.c:        return s->clksel[5];
omap2.c:        return s->clksel[6];
omap2.c:        return s->clken[10];
omap2.c:        return s->clken[11];
omap2.c:        return s->clkidle[6];
omap2.c:        return s->clksel[7];
omap2.c:        return s->clkctrl[3];
omap2.c:        return s->rst[3];
omap2.c:        return s->wkup[2];
omap2.c:        return s->power[3];
omap2.c:        return 0x008030 | (s->power[3] & 0x3003);
omap2.c:        return s->irqst[1];
omap2.c:        return s->irqen[1];
omap2.c:        return s->irqst[2];
omap2.c:        return s->irqen[2];
omap2.c:    mode[0] = (s->clken[9] >> 6) & 3;
omap2.c:    s->apll_lock[0] = (mode[0] == 3);
omap2.c:    mode[1] = (s->clken[9] >> 2) & 3;
omap2.c:    s->apll_lock[1] = (mode[1] == 3);
omap2.c:    omap_clk dpll = omap_findclk(s->mpu, "dpll");
omap2.c:    omap_clk dpll_x2 = omap_findclk(s->mpu, "dpll");
omap2.c:    omap_clk core = omap_findclk(s->mpu, "core_clk");
omap2.c:    int mode = (s->clken[9] >> 0) & 3;
omap2.c:    mult = (s->clksel[5] >> 12) & 0x3ff;
omap2.c:    div = (s->clksel[5] >> 8) & 0xf;
omap2.c:    s->dpll_lock = 0;
omap2.c:    case 1:	/* Low-power bypass mode (Default) */
omap2.c:    case 2:	/* Fast-relock bypass mode */
omap2.c:        s->dpll_lock = 1; /* After 20 FINT cycles (ref_clk / (div + 1)).  */
omap2.c:    switch ((s->clksel[6] >> 0) & 3) {
omap2.c:        omap_clk_reparent(core, omap_findclk(s->mpu, "clk32-kHz"));
omap2.c:        s->sysconfig = value & 1;
omap2.c:        s->irqst[0] &= ~value;
omap2.c:        s->irqen[0] = value & 0x3f;
omap2.c:        s->voltctrl = value & 0xf1c3;
omap2.c:        s->clksrc[0] = value & 0xdb;
omap2.c:        s->clkout[0] = value & 0xbbbb;
omap2.c:        s->clkemul[0] = value & 1;
omap2.c:        s->setuptime[0] = value & 0xffff;
omap2.c:        s->setuptime[1] = value & 0xffff;
omap2.c:        s->clkpol[0] = value & 0x701;
omap2.c:        s->scratch[(addr - 0xb0) >> 2] = value;
omap2.c:        s->clksel[0] = value & 0x1f;
omap2.c:        s->clkctrl[0] = value & 0x1f;
omap2.c:        s->rst[0] &= ~value;
omap2.c:        s->wkup[0] = value & 0x15;
omap2.c:        s->ev = value & 0x1f;
omap2.c:        s->evtime[0] = value;
omap2.c:        s->evtime[1] = value;
omap2.c:        s->power[0] = value & 0xc0f;
omap2.c:        s->clken[0] = value & 0xbfffffff;
omap2.c:        s->clken[1] = value & 0x00000007;
omap2.c:        s->clken[2] = value & 0xfffffff9;
omap2.c:        s->clken[3] = value & 0x00000007;
omap2.c:        s->clken[4] = value & 0x0000001f;
omap2.c:        s->clkidle[0] = value & 0xfffffff9;
omap2.c:        s->clkidle[1] = value & 0x00000007;
omap2.c:        s->clkidle[2] = value & 0x00000007;
omap2.c:        s->clkidle[3] = value & 0x0000001f;
omap2.c:        s->clksel[1] = value & 0x0fffbf7f;
omap2.c:        s->clksel[2] = value & 0x00fffffc;
omap2.c:        s->clkctrl[1] = value & 0x7;
omap2.c:        s->wken[0] = value & 0x04667ff8;
omap2.c:        s->wken[1] = value & 0x00000005;
omap2.c:        s->wkst[0] &= ~value;
omap2.c:        s->wkst[1] &= ~value;
omap2.c:        s->power[1] = (value & 0x00fc3f) | (1 << 2);
omap2.c:        s->clken[5] = value & 6;
omap2.c:        s->clken[6] = value & 1;
omap2.c:        s->clksel[3] = value & 7;
omap2.c:        s->clkctrl[2] = value & 1;
omap2.c:        s->rstctrl[0] = value & 1;
omap2.c:        s->rst[1] &= ~value;
omap2.c:        s->wkup[1] = value & 0x13;
omap2.c:        s->power[2] = (value & 0x00c0f) | (3 << 2);
omap2.c:        s->clken[7] = value & 0xd;
omap2.c:        s->clken[8] = value & 0x3f;
omap2.c:        s->clkidle[4] = value & 0x0000003f;
omap2.c:        s->clksel[4] = value & 3;
omap2.c:        s->rsttime_wkup = value & 0x1fff;
omap2.c:        s->rst[2] &= ~value;
omap2.c:        s->wken[2] = value & 0x00000005;
omap2.c:        s->wkst[2] &= ~value;
omap2.c:        if ((s->clken[9] ^ value) & 0xcc) {
omap2.c:            s->clken[9] &= ~0xcc;
omap2.c:            s->clken[9] |= value & 0xcc;
omap2.c:        if ((s->clken[9] ^ value) & 3) {
omap2.c:            s->clken[9] &= ~3;
omap2.c:            s->clken[9] |= value & 3;
omap2.c:        s->clkidle[5] = value & 0x000000cf;
omap2.c:        if ((s->clksel[5] ^ value) & 0x003fff00) {
omap2.c:            s->clksel[5] = value & 0x03bfff28;
omap2.c:        s->clksel[5] = value & 0x03bfff28;
omap2.c:        if (s->clksel[6] != (value & 3)) {
omap2.c:            s->clksel[6] = value & 3;
omap2.c:        s->clken[10] = value & 0x501;
omap2.c:        s->clken[11] = value & 0x2;
omap2.c:        s->clkidle[6] = value & 0x2;
omap2.c:        s->clksel[7] = value & 0x3fff;
omap2.c:        s->clkctrl[3] = value & 0x101;
omap2.c:        s->rst[3] &= ~value;
omap2.c:        s->wkup[2] = value & 0x13;
omap2.c:        s->power[3] = (value & 0x03017) | (3 << 2);
omap2.c:        s->irqst[1] &= ~value;
omap2.c:        s->irqen[1] = value & 0x7;
omap2.c:        s->irqst[2] &= ~value;
omap2.c:        s->irqen[2] = value & 0x7;
omap2.c:    s->sysconfig = 0;
omap2.c:    s->irqst[0] = 0;
omap2.c:    s->irqst[1] = 0;
omap2.c:    s->irqst[2] = 0;
omap2.c:    s->irqen[0] = 0;
omap2.c:    s->irqen[1] = 0;
omap2.c:    s->irqen[2] = 0;
omap2.c:    s->voltctrl = 0x1040;
omap2.c:    s->ev = 0x14;
omap2.c:    s->evtime[0] = 0;
omap2.c:    s->evtime[1] = 0;
omap2.c:    s->clkctrl[0] = 0;
omap2.c:    s->clkctrl[1] = 0;
omap2.c:    s->clkctrl[2] = 0;
omap2.c:    s->clkctrl[3] = 0;
omap2.c:    s->clken[1] = 7;
omap2.c:    s->clken[3] = 7;
omap2.c:    s->clken[4] = 0;
omap2.c:    s->clken[5] = 0;
omap2.c:    s->clken[6] = 0;
omap2.c:    s->clken[7] = 0xc;
omap2.c:    s->clken[8] = 0x3e;
omap2.c:    s->clken[9] = 0x0d;
omap2.c:    s->clken[10] = 0;
omap2.c:    s->clken[11] = 0;
omap2.c:    s->clkidle[0] = 0;
omap2.c:    s->clkidle[2] = 7;
omap2.c:    s->clkidle[3] = 0;
omap2.c:    s->clkidle[4] = 0;
omap2.c:    s->clkidle[5] = 0x0c;
omap2.c:    s->clkidle[6] = 0;
omap2.c:    s->clksel[0] = 0x01;
omap2.c:    s->clksel[1] = 0x02100121;
omap2.c:    s->clksel[2] = 0x00000000;
omap2.c:    s->clksel[3] = 0x01;
omap2.c:    s->clksel[4] = 0;
omap2.c:    s->clksel[7] = 0x0121;
omap2.c:    s->wkup[0] = 0x15;
omap2.c:    s->wkup[1] = 0x13;
omap2.c:    s->wkup[2] = 0x13;
omap2.c:    s->wken[0] = 0x04667ff8;
omap2.c:    s->wken[1] = 0x00000005;
omap2.c:    s->wken[2] = 5;
omap2.c:    s->wkst[0] = 0;
omap2.c:    s->wkst[1] = 0;
omap2.c:    s->wkst[2] = 0;
omap2.c:    s->power[0] = 0x00c;
omap2.c:    s->power[1] = 4;
omap2.c:    s->power[2] = 0x0000c;
omap2.c:    s->power[3] = 0x14;
omap2.c:    s->rstctrl[0] = 1;
omap2.c:    s->rst[3] = 1;
omap2.c:    s->setuptime[0] = 0;
omap2.c:    s->setuptime[1] = 0;
omap2.c:    memset(&s->scratch, 0, sizeof(s->scratch));
omap2.c:    s->rst[0] = 0x01;
omap2.c:    s->rst[1] = 0x00;
omap2.c:    s->rst[2] = 0x01;
omap2.c:    s->clken[0] = 0;
omap2.c:    s->clken[2] = 0;
omap2.c:    s->clkidle[1] = 0;
omap2.c:    s->clksel[5] = 0;
omap2.c:    s->clksel[6] = 2;
omap2.c:    s->clksrc[0] = 0x43;
omap2.c:    s->clkout[0] = 0x0303;
omap2.c:    s->clkemul[0] = 0;
omap2.c:    s->clkpol[0] = 0x100;
omap2.c:    s->rsttime_wkup = 0x1002;
omap2.c:    s->irq[0] = mpu_int;
omap2.c:    s->irq[1] = dsp_int;
omap2.c:    s->irq[2] = iva_int;
omap2.c:    s->mpu = mpu;
omap2.c:    case 0x030 ... 0x140:	/* CONTROL_PADCONF - only used in the POP */
omap2.c:        pad_offset = (addr - 0x30) >> 2;
omap2.c:        byte_offset = (addr - 0x30) & (4 - 1);
omap2.c:        value = s->padconf[pad_offset];
omap2.c:        return s->sysconfig;
omap2.c:    case 0x030 ... 0x140:	/* CONTROL_PADCONF - only used in the POP */
omap2.c:        return s->padconf[(addr - 0x30) >> 2];
omap2.c:        return s->obs;
omap2.c:        return s->devconfig;
omap2.c:        return s->msuspendmux[0];
omap2.c:        return s->msuspendmux[1];
omap2.c:        return s->msuspendmux[2];
omap2.c:        return s->msuspendmux[3];
omap2.c:        return s->msuspendmux[4];
omap2.c:        return s->psaconfig;
omap2.c:        /* Secure mode is not present on general-pusrpose device.  Outside
omap2.c:        /* Device Type => General-purpose */
omap2.c:    case 0x030 ... 0x140:	/* CONTROL_PADCONF - only used in the POP */
omap2.c:        pad_offset = (addr - 0x30) >> 2;
omap2.c:        byte_offset = (addr - 0x30) & (4 - 1);
omap2.c:        prev_value = s->padconf[pad_offset];
omap2.c:        s->padconf[pad_offset] = prev_value;
omap2.c:        s->sysconfig = value & 0x1e;
omap2.c:    case 0x030 ... 0x140:	/* CONTROL_PADCONF - only used in the POP */
omap2.c:        s->padconf[(addr - 0x30) >> 2] = value & 0x1f1f1f1f;
omap2.c:        s->obs = value & 0xff;
omap2.c:        s->devconfig = value & 0xffffc7ff;
omap2.c:        s->msuspendmux[0] = value & 0x3fffffff;
omap2.c:        s->msuspendmux[1] = value & 0x3fffffff;
omap2.c:        s->msuspendmux[2] = value & 0x3fffffff;
omap2.c:        s->msuspendmux[3] = value & 0x3fffffff;
omap2.c:        s->msuspendmux[4] = value & 0x3fffffff;
omap2.c:        s->psaconfig = value & 0x1c;
omap2.c:        s->psaconfig |= (value & 0x20) ? 2 : 1;
omap2.c:    /* (power-on reset) */
omap2.c:    s->sysconfig = 0;
omap2.c:    s->obs = 0;
omap2.c:    s->devconfig = 0x0c000000;
omap2.c:    s->msuspendmux[0] = 0x00000000;
omap2.c:    s->msuspendmux[1] = 0x00000000;
omap2.c:    s->msuspendmux[2] = 0x00000000;
omap2.c:    s->msuspendmux[3] = 0x00000000;
omap2.c:    s->msuspendmux[4] = 0x00000000;
omap2.c:    s->psaconfig = 1;
omap2.c:    s->padconf[0x00] = 0x000f0f0f;
omap2.c:    s->padconf[0x01] = 0x00000000;
omap2.c:    s->padconf[0x02] = 0x00000000;
omap2.c:    s->padconf[0x03] = 0x00000000;
omap2.c:    s->padconf[0x04] = 0x00000000;
omap2.c:    s->padconf[0x05] = 0x00000000;
omap2.c:    s->padconf[0x06] = 0x00000000;
omap2.c:    s->padconf[0x07] = 0x00000000;
omap2.c:    s->padconf[0x08] = 0x08080800;
omap2.c:    s->padconf[0x09] = 0x08080808;
omap2.c:    s->padconf[0x0a] = 0x08080808;
omap2.c:    s->padconf[0x0b] = 0x08080808;
omap2.c:    s->padconf[0x0c] = 0x08080808;
omap2.c:    s->padconf[0x0d] = 0x08080800;
omap2.c:    s->padconf[0x0e] = 0x08080808;
omap2.c:    s->padconf[0x0f] = 0x08080808;
omap2.c:    s->padconf[0x10] = 0x18181808;	/* | 0x07070700 if SBoot3 */
omap2.c:    s->padconf[0x11] = 0x18181818;	/* | 0x07070707 if SBoot3 */
omap2.c:    s->padconf[0x12] = 0x18181818;	/* | 0x07070707 if SBoot3 */
omap2.c:    s->padconf[0x13] = 0x18181818;	/* | 0x07070707 if SBoot3 */
omap2.c:    s->padconf[0x14] = 0x18181818;	/* | 0x00070707 if SBoot3 */
omap2.c:    s->padconf[0x15] = 0x18181818;
omap2.c:    s->padconf[0x16] = 0x18181818;	/* | 0x07000000 if SBoot3 */
omap2.c:    s->padconf[0x17] = 0x1f001f00;
omap2.c:    s->padconf[0x18] = 0x1f1f1f1f;
omap2.c:    s->padconf[0x19] = 0x00000000;
omap2.c:    s->padconf[0x1a] = 0x1f180000;
omap2.c:    s->padconf[0x1b] = 0x00001f1f;
omap2.c:    s->padconf[0x1c] = 0x1f001f00;
omap2.c:    s->padconf[0x1d] = 0x00000000;
omap2.c:    s->padconf[0x1e] = 0x00000000;
omap2.c:    s->padconf[0x1f] = 0x08000000;
omap2.c:    s->padconf[0x20] = 0x08080808;
omap2.c:    s->padconf[0x21] = 0x08080808;
omap2.c:    s->padconf[0x22] = 0x0f080808;
omap2.c:    s->padconf[0x23] = 0x0f0f0f0f;
omap2.c:    s->padconf[0x24] = 0x000f0f0f;
omap2.c:    s->padconf[0x25] = 0x1f1f1f0f;
omap2.c:    s->padconf[0x26] = 0x080f0f1f;
omap2.c:    s->padconf[0x27] = 0x070f1808;
omap2.c:    s->padconf[0x28] = 0x0f070707;
omap2.c:    s->padconf[0x29] = 0x000f0f1f;
omap2.c:    s->padconf[0x2a] = 0x0f0f0f1f;
omap2.c:    s->padconf[0x2b] = 0x08000000;
omap2.c:    s->padconf[0x2c] = 0x0000001f;
omap2.c:    s->padconf[0x2d] = 0x0f0f1f00;
omap2.c:    s->padconf[0x2e] = 0x1f1f0f0f;
omap2.c:    s->padconf[0x2f] = 0x0f1f1f1f;
omap2.c:    s->padconf[0x30] = 0x0f0f0f0f;
omap2.c:    s->padconf[0x31] = 0x0f1f0f1f;
omap2.c:    s->padconf[0x32] = 0x0f0f0f0f;
omap2.c:    s->padconf[0x33] = 0x0f1f0f1f;
omap2.c:    s->padconf[0x34] = 0x1f1f0f0f;
omap2.c:    s->padconf[0x35] = 0x0f0f1f1f;
omap2.c:    s->padconf[0x36] = 0x0f0f1f0f;
omap2.c:    s->padconf[0x37] = 0x0f0f0f0f;
omap2.c:    s->padconf[0x38] = 0x1f18180f;
omap2.c:    s->padconf[0x39] = 0x1f1f1f1f;
omap2.c:    s->padconf[0x3a] = 0x00001f1f;
omap2.c:    s->padconf[0x3b] = 0x00000000;
omap2.c:    s->padconf[0x3c] = 0x00000000;
omap2.c:    s->padconf[0x3d] = 0x0f0f0f0f;
omap2.c:    s->padconf[0x3e] = 0x18000f0f;
omap2.c:    s->padconf[0x3f] = 0x00070000;
omap2.c:    s->padconf[0x40] = 0x00000707;
omap2.c:    s->padconf[0x41] = 0x0f1f0700;
omap2.c:    s->padconf[0x42] = 0x1f1f070f;
omap2.c:    s->padconf[0x43] = 0x0008081f;
omap2.c:    s->padconf[0x44] = 0x00000800;
omap2.c:    s->mpu = mpu;
omap2.c:    s->config = 0x10;
omap2.c:        return s->config;
omap2.c:        s->config = value & 0x18;
omap2.c:/* General-Purpose Memory Controller */
omap2.c:    qemu_set_irq(s->irq, s->irqen & s->irqst);
omap2.c:    if (!f->opaque)
omap2.c:    f->base = base << 24;
omap2.c:    f->size = (0x0fffffff & ~(mask << 24)) + 1;
omap2.c:    if (f->iomemtype)
omap2.c:        cpu_register_physical_memory(f->base, f->size, f->iomemtype);
omap2.c:    if (f->base_update)
omap2.c:        f->base_update(f->opaque, f->base);
omap2.c:    if (f->size) {
omap2.c:        if (f->unmap)
omap2.c:            f->unmap(f->opaque);
omap2.c:        if (f->iomemtype)
omap2.c:            cpu_register_physical_memory(f->base, f->size, IO_MEM_UNASSIGNED);
omap2.c:        f->base = 0;
omap2.c:        f->size = 0;
omap2.c:    s->sysconfig = 0;
omap2.c:    s->irqst = 0;
omap2.c:    s->irqen = 0;
omap2.c:    s->timeout = 0;
omap2.c:    s->config = 0xa00;
omap2.c:    s->prefconfig[0] = 0x00004000;
omap2.c:    s->prefconfig[1] = 0x00000000;
omap2.c:    s->prefcontrol = 0;
omap2.c:    s->preffifo = 0;
omap2.c:    s->prefcount = 0;
omap2.c:        if (s->cs_file[i].config[6] & (1 << 6))			/* CSVALID */
omap2.c:            omap_gpmc_cs_unmap(s->cs_file + i);
omap2.c:        s->cs_file[i].config[0] = i ? 1 << 12 : 0;
omap2.c:        s->cs_file[i].config[1] = 0x101001;
omap2.c:        s->cs_file[i].config[2] = 0x020201;
omap2.c:        s->cs_file[i].config[3] = 0x10031003;
omap2.c:        s->cs_file[i].config[4] = 0x10f1111;
omap2.c:        s->cs_file[i].config[5] = 0;
omap2.c:        s->cs_file[i].config[6] = 0xf00 | (i ? 0 : 1 << 6);
omap2.c:        if (s->cs_file[i].config[6] & (1 << 6))			/* CSVALID */
omap2.c:            omap_gpmc_cs_map(&s->cs_file[i],
omap2.c:                            s->cs_file[i].config[6] & 0x1f,	/* MASKADDR */
omap2.c:                        (s->cs_file[i].config[6] >> 8 & 0xf));	/* BASEADDR */
omap2.c:    omap_gpmc_cs_map(s->cs_file, 0, 0xf);
omap2.c:    s->ecc_cs = 0;
omap2.c:    s->ecc_ptr = 0;
omap2.c:    s->ecc_cfg = 0x3fcff000;
omap2.c:        ecc_reset(&s->ecc[i]);
omap2.c:        return s->sysconfig;
omap2.c:        return s->irqst;
omap2.c:        return s->irqen;
omap2.c:        return s->timeout;
omap2.c:        return s->config;
omap2.c:        cs = (addr - 0x060) / 0x30;
omap2.c:        addr -= cs * 0x30;
omap2.c:        f = s->cs_file + cs;
omap2.c:                return f->config[0];
omap2.c:                return f->config[1];
omap2.c:                return f->config[2];
omap2.c:                return f->config[3];
omap2.c:                return f->config[4];
omap2.c:                return f->config[5];
omap2.c:                return f->config[6];
omap2.c:        return s->prefconfig[0];
omap2.c:        return s->prefconfig[1];
omap2.c:        return s->prefcontrol;
omap2.c:        return (s->preffifo << 24) |
omap2.c:                ((s->preffifo >
omap2.c:                  ((s->prefconfig[0] >> 8) & 0x7f) ? 1 : 0) << 16) |
omap2.c:                s->prefcount;
omap2.c:        return s->ecc_cs;
omap2.c:        return s->ecc_ptr;
omap2.c:        return s->ecc_cfg;
omap2.c:                ((s->ecc[cs].cp    &  0x07) <<  0) |
omap2.c:                ((s->ecc[cs].cp    &  0x38) << 13) |
omap2.c:                ((s->ecc[cs].lp[0] & 0x1ff) <<  3) |
omap2.c:                ((s->ecc[cs].lp[1] & 0x1ff) << 19);
omap2.c:        s->sysconfig = value & 0x19;
omap2.c:        s->irqen = ~value;
omap2.c:        s->irqen = value & 0xf03;
omap2.c:        s->timeout = value & 0x1ff1;
omap2.c:        s->config = value & 0xf13;
omap2.c:        cs = (addr - 0x060) / 0x30;
omap2.c:        addr -= cs * 0x30;
omap2.c:        f = s->cs_file + cs;
omap2.c:                f->config[0] = value & 0xffef3e13;
omap2.c:                f->config[1] = value & 0x001f1f8f;
omap2.c:                f->config[2] = value & 0x001f1f8f;
omap2.c:                f->config[3] = value & 0x1f8f1f8f;
omap2.c:                f->config[4] = value & 0x0f1f1f1f;
omap2.c:                f->config[5] = value & 0x00000fcf;
omap2.c:                if ((f->config[6] ^ value) & 0xf7f) {
omap2.c:                    if (f->config[6] & (1 << 6))		/* CSVALID */
omap2.c:                f->config[6] = value & 0x00000f7f;
omap2.c:        s->prefconfig[0] = value & 0x7f8f7fbf;
omap2.c:        s->prefconfig[1] = value & 0x3fff;
omap2.c:        s->prefcontrol = value & 1;
omap2.c:        if (s->prefcontrol) {
omap2.c:            if (s->prefconfig[0] & 1)
omap2.c:                s->preffifo = 0x40;
omap2.c:                s->preffifo = 0x00;
omap2.c:        s->ecc_cs = 0x8f;
omap2.c:                ecc_reset(&s->ecc[cs]);
omap2.c:        s->ecc_ptr = value & 0xf;
omap2.c:        if (s->ecc_ptr == 0 || s->ecc_ptr > 9) {
omap2.c:            s->ecc_ptr = 0;
omap2.c:            s->ecc_cs &= ~1;
omap2.c:        s->ecc_cfg = value & 0x3fcff1ff;
omap2.c:        fprintf(stderr, "%s: bad chip-select %i\n", __FUNCTION__, cs);
omap2.c:        exit(-1);
omap2.c:    f = &s->cs_file[cs];
omap2.c:    f->iomemtype = iomemtype;
omap2.c:    f->base_update = base_upd;
omap2.c:    f->unmap = unmap;
omap2.c:    f->opaque = opaque;
omap2.c:    if (f->config[6] & (1 << 6))				/* CSVALID */
omap2.c:        omap_gpmc_cs_map(f, f->config[6] & 0x1f,		/* MASKADDR */
omap2.c:                        (f->config[6] >> 8 & 0xf));		/* BASEADDR */
omap2.c:    omap_inth_reset(mpu->ih[0]);
omap2.c:    omap_dma_reset(mpu->dma);
omap2.c:    omap_prcm_reset(mpu->prcm);
omap2.c:    omap_sysctl_reset(mpu->sysc);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[0]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[1]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[2]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[3]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[4]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[5]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[6]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[7]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[8]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[9]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[10]);
omap2.c:    omap_gp_timer_reset(mpu->gptimer[11]);
omap2.c:    omap_synctimer_reset(&mpu->synctimer);
omap2.c:    omap_sdrc_reset(mpu->sdrc);
omap2.c:    omap_gpmc_reset(mpu->gpmc);
omap2.c:    omap_dss_reset(mpu->dss);
omap2.c:    omap_uart_reset(mpu->uart[0]);
omap2.c:    omap_uart_reset(mpu->uart[1]);
omap2.c:    omap_uart_reset(mpu->uart[2]);
omap2.c:    omap_mmc_reset(mpu->mmc);
omap2.c:    omap_gpif_reset(mpu->gpif);
omap2.c:    omap_mcspi_reset(mpu->mcspi[0]);
omap2.c:    omap_mcspi_reset(mpu->mcspi[1]);
omap2.c:    omap_i2c_reset(mpu->i2c[0]);
omap2.c:    omap_i2c_reset(mpu->i2c[1]);
omap2.c:    cpu_reset(mpu->env);
omap2.c:    s->mpu_model = omap2420;
omap2.c:    s->env = cpu_init(core ?: "arm1136-r2");
omap2.c:    if (!s->env) {
omap2.c:    s->sdram_size = sdram_size;
omap2.c:    s->sram_size = OMAP242X_SRAM_SIZE;
omap2.c:    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];
omap2.c:    /* Memory-mapped stuff */
omap2.c:    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,
omap2.c:                    (q2_base = qemu_ram_alloc(s->sdram_size)) | IO_MEM_RAM);
omap2.c:    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,
omap2.c:                    (sram_base = qemu_ram_alloc(s->sram_size)) | IO_MEM_RAM);
omap2.c:    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);
omap2.c:    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */
omap2.c:    cpu_irq = arm_pic_init_cpu(s->env);
omap2.c:    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],
omap2.c:    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),
omap2.c:                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);
omap2.c:    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),
omap2.c:                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];
omap2.c:    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,
omap2.c:    s->port->addr_valid = omap2_validate_addr;
omap2.c:    soc_dma_port_add_mem_ram(s->dma, q2_base, OMAP2_Q2_BASE, s->sdram_size);
omap2.c:    soc_dma_port_add_mem_ram(s->dma, sram_base, OMAP2_SRAM_BASE, s->sram_size);
omap2.c:    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),
omap2.c:                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],
omap2.c:                    s->drq[OMAP24XX_DMA_UART1_TX],
omap2.c:                    s->drq[OMAP24XX_DMA_UART1_RX], serial_hds[0]);
omap2.c:    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),
omap2.c:                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],
omap2.c:                    s->drq[OMAP24XX_DMA_UART2_TX],
omap2.c:                    s->drq[OMAP24XX_DMA_UART2_RX],
omap2.c:    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),
omap2.c:                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],
omap2.c:                    s->drq[OMAP24XX_DMA_UART3_TX],
omap2.c:                    s->drq[OMAP24XX_DMA_UART3_RX],
omap2.c:    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER1],
omap2.c:    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER2],
omap2.c:    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER3],
omap2.c:    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER4],
omap2.c:    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER5],
omap2.c:    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER6],
omap2.c:    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER7],
omap2.c:    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER8],
omap2.c:    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER9],
omap2.c:    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER10],
omap2.c:    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER11],
omap2.c:    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),
omap2.c:                    s->irq[0][OMAP_INT_24XX_GPTIMER12],
omap2.c:    omap_tap_init(omap_l4ta(s->l4, 2), s);
omap2.c:    omap_synctimer_init(omap_l4tao(s->l4, 2), s,
omap2.c:                    omap_findclk(s, "clk32-kHz"),
omap2.c:    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),
omap2.c:                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],
omap2.c:                    &s->drq[OMAP24XX_DMA_I2C1_TX],
omap2.c:    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),
omap2.c:                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],
omap2.c:                    &s->drq[OMAP24XX_DMA_I2C2_TX],
omap2.c:    s->gpif = omap2_gpio_init(omap_l4ta(s->l4, 3),
omap2.c:                    &s->irq[0][OMAP_INT_24XX_GPIO_BANK1],
omap2.c:    s->sdrc = omap_sdrc_init(0x68009000);
omap2.c:    s->gpmc = omap_gpmc_init(0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ]);
omap2.c:    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,
omap2.c:                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],
omap2.c:                    &s->drq[OMAP24XX_DMA_MMC1_TX],
omap2.c:    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,
omap2.c:                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],
omap2.c:                    &s->drq[OMAP24XX_DMA_SPI1_TX0],
omap2.c:    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,
omap2.c:                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],
omap2.c:                    &s->drq[OMAP24XX_DMA_SPI2_TX0],
omap2.c:    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,
omap2.c:                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],
omap2.c:    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,
omap2.c:                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, "emul_ck"),
omap2.c:    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),
omap2.c:                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],
omap2.c:                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],
omap2.c:     * SystemControlMod	48000000 - 48000fff
omap2.c:     * SystemControlL4	48001000 - 48001fff
omap2.c:     * 32kHz Timer Mod	48004000 - 48004fff
omap2.c:     * 32kHz Timer L4	48005000 - 48005fff
omap2.c:     * PRCM ModA	48008000 - 480087ff
omap2.c:     * PRCM ModB	48008800 - 48008fff
omap2.c:     * PRCM L4		48009000 - 48009fff
omap2.c:     * TEST-BCM Mod	48012000 - 48012fff
omap2.c:     * TEST-BCM L4	48013000 - 48013fff
omap2.c:     * TEST-TAP Mod	48014000 - 48014fff
omap2.c:     * TEST-TAP L4	48015000 - 48015fff
omap2.c:     * GPIO1 Mod	48018000 - 48018fff
omap2.c:     * GPIO Top		48019000 - 48019fff
omap2.c:     * GPIO2 Mod	4801a000 - 4801afff
omap2.c:     * GPIO L4		4801b000 - 4801bfff
omap2.c:     * GPIO3 Mod	4801c000 - 4801cfff
omap2.c:     * GPIO4 Mod	4801e000 - 4801efff
omap2.c:     * WDTIMER1 Mod	48020000 - 48010fff
omap2.c:     * WDTIMER Top	48021000 - 48011fff
omap2.c:     * WDTIMER2 Mod	48022000 - 48012fff
omap2.c:     * WDTIMER L4	48023000 - 48013fff
omap2.c:     * WDTIMER3 Mod	48024000 - 48014fff
omap2.c:     * WDTIMER3 L4	48025000 - 48015fff
omap2.c:     * WDTIMER4 Mod	48026000 - 48016fff
omap2.c:     * WDTIMER4 L4	48027000 - 48017fff
omap2.c:     * GPTIMER1 Mod	48028000 - 48018fff
omap2.c:     * GPTIMER1 L4	48029000 - 48019fff
omap2.c:     * GPTIMER2 Mod	4802a000 - 4801afff
omap2.c:     * GPTIMER2 L4	4802b000 - 4801bfff
omap2.c:     * L4-Config AP	48040000 - 480407ff
omap2.c:     * L4-Config IP	48040800 - 48040fff
omap2.c:     * L4-Config LA	48041000 - 48041fff
omap2.c:     * ARM11ETB Mod	48048000 - 48049fff
omap2.c:     * ARM11ETB L4	4804a000 - 4804afff
omap2.c:     * DISPLAY Top	48050000 - 480503ff
omap2.c:     * DISPLAY DISPC	48050400 - 480507ff
omap2.c:     * DISPLAY RFBI	48050800 - 48050bff
omap2.c:     * DISPLAY VENC	48050c00 - 48050fff
omap2.c:     * DISPLAY L4	48051000 - 48051fff
omap2.c:     * CAMERA Top	48052000 - 480523ff
omap2.c:     * CAMERA core	48052400 - 480527ff
omap2.c:     * CAMERA DMA	48052800 - 48052bff
omap2.c:     * CAMERA MMU	48052c00 - 48052fff
omap2.c:     * CAMERA L4	48053000 - 48053fff
omap2.c:     * SDMA Mod		48056000 - 48056fff
omap2.c:     * SDMA L4		48057000 - 48057fff
omap2.c:     * SSI Top		48058000 - 48058fff
omap2.c:     * SSI GDD		48059000 - 48059fff
omap2.c:     * SSI Port1	4805a000 - 4805afff
omap2.c:     * SSI Port2	4805b000 - 4805bfff
omap2.c:     * SSI L4		4805c000 - 4805cfff
omap2.c:     * USB Mod		4805e000 - 480fefff
omap2.c:     * USB L4		4805f000 - 480fffff
omap2.c:     * WIN_TRACER1 Mod	48060000 - 48060fff
omap2.c:     * WIN_TRACER1 L4	48061000 - 48061fff
omap2.c:     * WIN_TRACER2 Mod	48062000 - 48062fff
omap2.c:     * WIN_TRACER2 L4	48063000 - 48063fff
omap2.c:     * WIN_TRACER3 Mod	48064000 - 48064fff
omap2.c:     * WIN_TRACER3 L4	48065000 - 48065fff
omap2.c:     * WIN_TRACER4 Top	48066000 - 480660ff
omap2.c:     * WIN_TRACER4 ETT	48066100 - 480661ff
omap2.c:     * WIN_TRACER4 WT	48066200 - 480662ff
omap2.c:     * WIN_TRACER4 L4	48067000 - 48067fff
omap2.c:     * XTI Mod		48068000 - 48068fff
omap2.c:     * XTI L4		48069000 - 48069fff
omap2.c:     * UART1 Mod	4806a000 - 4806afff
omap2.c:     * UART1 L4		4806b000 - 4806bfff
omap2.c:     * UART2 Mod	4806c000 - 4806cfff
omap2.c:     * UART2 L4		4806d000 - 4806dfff
omap2.c:     * UART3 Mod	4806e000 - 4806efff
omap2.c:     * UART3 L4		4806f000 - 4806ffff
omap2.c:     * I2C1 Mod		48070000 - 48070fff
omap2.c:     * I2C1 L4		48071000 - 48071fff
omap2.c:     * I2C2 Mod		48072000 - 48072fff
omap2.c:     * I2C2 L4		48073000 - 48073fff
omap2.c:     * McBSP1 Mod	48074000 - 48074fff
omap2.c:     * McBSP1 L4	48075000 - 48075fff
omap2.c:     * McBSP2 Mod	48076000 - 48076fff
omap2.c:     * McBSP2 L4	48077000 - 48077fff
omap2.c:     * GPTIMER3 Mod	48078000 - 48078fff
omap2.c:     * GPTIMER3 L4	48079000 - 48079fff
omap2.c:     * GPTIMER4 Mod	4807a000 - 4807afff
omap2.c:     * GPTIMER4 L4	4807b000 - 4807bfff
omap2.c:     * GPTIMER5 Mod	4807c000 - 4807cfff
omap2.c:     * GPTIMER5 L4	4807d000 - 4807dfff
omap2.c:     * GPTIMER6 Mod	4807e000 - 4807efff
omap2.c:     * GPTIMER6 L4	4807f000 - 4807ffff
omap2.c:     * GPTIMER7 Mod	48080000 - 48080fff
omap2.c:     * GPTIMER7 L4	48081000 - 48081fff
omap2.c:     * GPTIMER8 Mod	48082000 - 48082fff
omap2.c:     * GPTIMER8 L4	48083000 - 48083fff
omap2.c:     * GPTIMER9 Mod	48084000 - 48084fff
omap2.c:     * GPTIMER9 L4	48085000 - 48085fff
omap2.c:     * GPTIMER10 Mod	48086000 - 48086fff
omap2.c:     * GPTIMER10 L4	48087000 - 48087fff
omap2.c:     * GPTIMER11 Mod	48088000 - 48088fff
omap2.c:     * GPTIMER11 L4	48089000 - 48089fff
omap2.c:     * GPTIMER12 Mod	4808a000 - 4808afff
omap2.c:     * GPTIMER12 L4	4808b000 - 4808bfff
omap2.c:     * EAC Mod		48090000 - 48090fff
omap2.c:     * EAC L4		48091000 - 48091fff
omap2.c:     * FAC Mod		48092000 - 48092fff
omap2.c:     * FAC L4		48093000 - 48093fff
omap2.c:     * MAILBOX Mod	48094000 - 48094fff
omap2.c:     * MAILBOX L4	48095000 - 48095fff
omap2.c:     * SPI1 Mod		48098000 - 48098fff
omap2.c:     * SPI1 L4		48099000 - 48099fff
omap2.c:     * SPI2 Mod		4809a000 - 4809afff
omap2.c:     * SPI2 L4		4809b000 - 4809bfff
omap2.c:     * MMC/SDIO Mod	4809c000 - 4809cfff
omap2.c:     * MMC/SDIO L4	4809d000 - 4809dfff
omap2.c:     * MS_PRO Mod	4809e000 - 4809efff
omap2.c:     * MS_PRO L4	4809f000 - 4809ffff
omap2.c:     * RNG Mod		480a0000 - 480a0fff
omap2.c:     * RNG L4		480a1000 - 480a1fff
omap2.c:     * DES3DES Mod	480a2000 - 480a2fff
omap2.c:     * DES3DES L4	480a3000 - 480a3fff
omap2.c:     * SHA1MD5 Mod	480a4000 - 480a4fff
omap2.c:     * SHA1MD5 L4	480a5000 - 480a5fff
omap2.c:     * AES Mod		480a6000 - 480a6fff
omap2.c:     * AES L4		480a7000 - 480a7fff
omap2.c:     * PKA Mod		480a8000 - 480a9fff
omap2.c:     * PKA L4		480aa000 - 480aafff
omap2.c:     * MG Mod		480b0000 - 480b0fff
omap2.c:     * MG L4		480b1000 - 480b1fff
omap2.c:     * HDQ/1-wire Mod	480b2000 - 480b2fff
omap2.c:     * HDQ/1-wire L4	480b3000 - 480b3fff
omap2.c:     * MPU interrupt	480fe000 - 480fefff
omap2.c:     * STI channel base	54000000 - 5400ffff
omap2.c:     * IVA RAM		5c000000 - 5c01ffff
omap2.c:     * IVA ROM		5c020000 - 5c027fff
omap2.c:     * IMG_BUF_A	5c040000 - 5c040fff
omap2.c:     * IMG_BUF_B	5c042000 - 5c042fff
omap2.c:     * VLCDS		5c048000 - 5c0487ff
omap2.c:     * IMX_COEF		5c049000 - 5c04afff
omap2.c:     * IMX_CMD		5c051000 - 5c051fff
omap2.c:     * VLCDQ		5c053000 - 5c0533ff
omap2.c:     * VLCDH		5c054000 - 5c054fff
omap2.c:     * SEQ_CMD		5c055000 - 5c055fff
omap2.c:     * IMX_REG		5c056000 - 5c0560ff
omap2.c:     * VLCD_REG		5c056100 - 5c0561ff
omap2.c:     * SEQ_REG		5c056200 - 5c0562ff
omap2.c:     * IMG_BUF_REG	5c056300 - 5c0563ff
omap2.c:     * SEQIRQ_REG	5c056400 - 5c0564ff
omap2.c:     * OCP_REG		5c060000 - 5c060fff
omap2.c:     * SYSC_REG		5c070000 - 5c070fff
omap2.c:     * MMU_REG		5d000000 - 5d000fff
omap2.c:     * sDMA R		68000400 - 680005ff
omap2.c:     * sDMA W		68000600 - 680007ff
omap2.c:     * Display Control	68000800 - 680009ff
omap2.c:     * DSP subsystem	68000a00 - 68000bff
omap2.c:     * MPU subsystem	68000c00 - 68000dff
omap2.c:     * IVA subsystem	68001000 - 680011ff
omap2.c:     * USB		68001200 - 680013ff
omap2.c:     * Camera		68001400 - 680015ff
omap2.c:     * VLYNQ (firewall)	68001800 - 68001bff
omap2.c:     * VLYNQ		68001e00 - 68001fff
omap2.c:     * SSI		68002000 - 680021ff
omap2.c:     * L4		68002400 - 680025ff
omap2.c:     * DSP (firewall)	68002800 - 68002bff
omap2.c:     * DSP subsystem	68002e00 - 68002fff
omap2.c:     * IVA (firewall)	68003000 - 680033ff
omap2.c:     * IVA		68003600 - 680037ff
omap2.c:     * GFX		68003a00 - 68003bff
omap2.c:     * CMDWR emulation	68003c00 - 68003dff
omap2.c:     * SMS		68004000 - 680041ff
omap2.c:     * OCM		68004200 - 680043ff
omap2.c:     * GPMC		68004400 - 680045ff
omap2.c:     * RAM (firewall)	68005000 - 680053ff
omap2.c:     * RAM (err login)	68005400 - 680057ff
omap2.c:     * ROM (firewall)	68005800 - 68005bff
omap2.c:     * ROM (err login)	68005c00 - 68005fff
omap2.c:     * GPMC (firewall)	68006000 - 680063ff
omap2.c:     * GPMC (err login)	68006400 - 680067ff
omap2.c:     * SMS (err login)	68006c00 - 68006fff
omap2.c:     * SMS registers	68008000 - 68008fff
omap2.c:     * SDRC registers	68009000 - 68009fff
omap_clk.c: * Copyright (C) 2006-2008 Andrzej Zaborowski  <balrog@zabor.org>
omap_clk.c: * Clocks data comes in part from arch/arm/mach-omap1/clock.h in Linux.
omap_clk.c:    /* No-idle controlled by "tc_ck" */
omap_clk.c:    /* No-idle controlled by "tc_ck" */
omap_clk.c:    /* No-idle controlled by "tc_ck" */
omap_clk.c:    /* OTG_SYSCON_2.OTG_PADEN == 0 (not 1510-compatible) */
omap_clk.c:    .name	= "clk32-kHz",
omap_clk.c:    /* non-ULPD clocks */
omap_clk.c:    for (i = clk->users; *i; i ++);
omap_clk.c:    for (i = mpu->clks; i->name; i ++)
omap_clk.c:        if (!strcmp(i->name, name) || (i->alias && !strcmp(i->alias, name)))
omap_clk.c:    clk->usecount ++;
omap_clk.c:    if (!(clk->usecount --))
omap_clk.c:        hw_error("%s: %s is not in use\n", __FUNCTION__, clk->name);
omap_clk.c:    if (clk->parent)
omap_clk.c:        parent = clk->parent->running;
omap_clk.c:    running = parent && (clk->enabled ||
omap_clk.c:                    ((clk->flags & ALWAYS_ENABLED) && clk->usecount));
omap_clk.c:    if (clk->running != running) {
omap_clk.c:        clk->running = running;
omap_clk.c:        for (user = clk->users; *user; user ++)
omap_clk.c:        for (i = clk->child1; i; i = i->sibling)
omap_clk.c:    clk->rate = muldiv64(rate, mult, div);
omap_clk.c:    if (clk->running)
omap_clk.c:        for (user = clk->users; *user; user ++)
omap_clk.c:    for (i = clk->child1; i; i = i->sibling)
omap_clk.c:                        div * i->divisor, mult * i->multiplier);
omap_clk.c:    for (i = clk; i->parent; i = i->parent) {
omap_clk.c:        div *= i->divisor;
omap_clk.c:        mult *= i->multiplier;
omap_clk.c:    omap_clk_rate_update_full(clk, i->rate, div, mult);
omap_clk.c:    if (clk->parent) {
omap_clk.c:        for (p = &clk->parent->child1; *p != clk; p = &(*p)->sibling);
omap_clk.c:        *p = clk->sibling;
omap_clk.c:    clk->parent = parent;
omap_clk.c:        clk->sibling = parent->child1;
omap_clk.c:        parent->child1 = clk;
omap_clk.c:        clk->sibling = NULL;
omap_clk.c:    clk->enabled = on;
omap_clk.c:    clk->divisor = divide;
omap_clk.c:    clk->multiplier = multiply;
omap_clk.c:    return clk->rate;
omap_clk.c:        if ((*i)->flags & flag)
omap_clk.c:    mpu->clks = (struct clk *) qemu_mallocz(sizeof(struct clk) * (count + 1));
omap_clk.c:    for (i = onchip_clks, j = mpu->clks; *i; i ++)
omap_clk.c:        if ((*i)->flags & flag) {
omap_clk.c:            for (k = mpu->clks; k < j; k ++)
omap_clk.c:                if (j->parent && !strcmp(j->parent->name, k->name)) {
omap_clk.c:                    j->parent = k;
omap_clk.c:                    j->sibling = k->child1;
omap_clk.c:                    k->child1 = j;
omap_clk.c:                } else if (k->parent && !strcmp(k->parent->name, j->name)) {
omap_clk.c:                    k->parent = j;
omap_clk.c:                    k->sibling = j->child1;
omap_clk.c:                    j->child1 = k;
omap_clk.c:            j->divisor = j->divisor ?: 1;
omap_clk.c:            j->multiplier = j->multiplier ?: 1;
omap_clk.c:    for (j = mpu->clks; count --; j ++) {
omap_dma.c: * Copyright (C) 2006-2008 Andrzej Zaborowski  <balrog@zabor.org>
omap_dma.c: * Copyright (C) 2007-2008 Lauro Ramos Venancio  <lauro.venancio@indt.org.br>
omap_dma.c:#include "qemu-common.h"
omap_dma.c:#include "qemu-timer.h"
omap_dma.c:    return s->intr_update(s);
omap_dma.c:    struct omap_dma_reg_set_s *a = &ch->active_set;
omap_dma.c:    int omap_3_1 = !ch->omap_3_1_compatible_disable;
omap_dma.c:    a->src = ch->addr[0];
omap_dma.c:    a->dest = ch->addr[1];
omap_dma.c:    a->frames = ch->frames;
omap_dma.c:    a->elements = ch->elements;
omap_dma.c:    a->pck_elements = ch->frame_index[!ch->src_sync];
omap_dma.c:    a->frame = 0;
omap_dma.c:    a->element = 0;
omap_dma.c:    a->pck_element = 0;
omap_dma.c:    if (unlikely(!ch->elements || !ch->frames)) {
omap_dma.c:        switch (ch->mode[i]) {
omap_dma.c:            a->elem_delta[i] = 0;
omap_dma.c:            a->frame_delta[i] = 0;
omap_dma.c:            a->elem_delta[i] = ch->data_type;
omap_dma.c:            a->frame_delta[i] = 0;
omap_dma.c:            a->elem_delta[i] = ch->data_type +
omap_dma.c:                    ch->element_index[omap_3_1 ? 0 : i] - 1;
omap_dma.c:            a->frame_delta[i] = 0;
omap_dma.c:            a->elem_delta[i] = ch->data_type +
omap_dma.c:                    ch->element_index[omap_3_1 ? 0 : i] - 1;
omap_dma.c:            a->frame_delta[i] = ch->frame_index[omap_3_1 ? 0 : i] -
omap_dma.c:                    ch->element_index[omap_3_1 ? 0 : i];
omap_dma.c:    normal = !ch->transparent_copy && !ch->constant_fill &&
omap_dma.c:            /* FIFO is big-endian so either (ch->endian[n] == 1) OR
omap_dma.c:             * (ch->endian_lock[n] == 1) mean no endianism conversion.  */
omap_dma.c:            (ch->endian[0] | ch->endian_lock[0]) ==
omap_dma.c:            (ch->endian[1] | ch->endian_lock[1]);
omap_dma.c:        /* TODO: for a->frame_delta[i] > 0 still use the fast path, just
omap_dma.c:        if (!a->elem_delta[i] && normal &&
omap_dma.c:                        (a->frames == 1 || !a->frame_delta[i]))
omap_dma.c:            ch->dma->type[i] = soc_dma_access_const;
omap_dma.c:        else if (a->elem_delta[i] == ch->data_type && normal &&
omap_dma.c:                        (a->frames == 1 || !a->frame_delta[i]))
omap_dma.c:            ch->dma->type[i] = soc_dma_access_linear;
omap_dma.c:            ch->dma->type[i] = soc_dma_access_other;
omap_dma.c:        ch->dma->vaddr[i] = ch->addr[i];
omap_dma.c:    soc_dma_ch_update(ch->dma);
omap_dma.c:    if (!ch->active) {
omap_dma.c:        if (ch->set_update) {
omap_dma.c:            ch->set_update = 0;
omap_dma.c:        ch->active = 1;
omap_dma.c:        soc_dma_set_request(ch->dma, 1);
omap_dma.c:        if (ch->sync)
omap_dma.c:            ch->status |= SYNC;
omap_dma.c:    ch->cpc = ch->active_set.dest & 0xffff;
omap_dma.c:    if (ch->pending_request && !ch->waiting_end_prog && ch->enable) {
omap_dma.c:        ch->pending_request = 0;
omap_dma.c:    if (ch->sync && ch->enable && (s->dma->drqbmp & (1 << ch->sync)))
omap_dma.c:    if (ch->active) {
omap_dma.c:        ch->active = 0;
omap_dma.c:        ch->status &= ~SYNC;
omap_dma.c:        soc_dma_set_request(ch->dma, 0);
omap_dma.c:    if (!ch->enable) {
omap_dma.c:        ch->enable = 1;
omap_dma.c:        ch->waiting_end_prog = 0;
omap_dma.c:        /* TODO: theoretically if ch->sync && ch->prefetch &&
omap_dma.c:         * !s->dma->drqbmp[ch->sync], we should also activate and fetch
omap_dma.c:        if ((!ch->sync) || (s->dma->drqbmp & (1 << ch->sync)))
omap_dma.c:    if (ch->enable) {
omap_dma.c:        ch->enable = 0;
omap_dma.c:        ch->pending_request = 0;
omap_dma.c:    if (ch->waiting_end_prog) {
omap_dma.c:        ch->waiting_end_prog = 0;
omap_dma.c:        if (!ch->sync || ch->pending_request) {
omap_dma.c:            ch->pending_request = 0;
omap_dma.c:    struct omap_dma_channel_s *ch = s->ch;
omap_dma.c:    struct omap_dma_channel_s *ch = s->ch;
omap_dma.c:    for (i = s->chans; i; ch ++, i --)
omap_dma.c:        if (ch->status)
omap_dma.c:            qemu_irq_raise(ch->irq);
omap_dma.c:    s->omap_3_1_mapping_disabled = 0;
omap_dma.c:    s->chans = 9;
omap_dma.c:    s->intr_update = omap_dma_interrupts_3_1_update;
omap_dma.c:    s->omap_3_1_mapping_disabled = 1;
omap_dma.c:    s->chans = 16;
omap_dma.c:    s->intr_update = omap_dma_interrupts_3_2_update;
omap_dma.c:    struct omap_dma_channel_s *ch = s->ch;
omap_dma.c:    for (channel = 0; channel < s->chans; channel ++, ch ++) {
omap_dma.c:        if (ch->enable && ch->sync == request) {
omap_dma.c:            if (!ch->active)
omap_dma.c:            else if (!ch->pending_request)
omap_dma.c:                ch->pending_request = 1;
omap_dma.c:                ch->status |= EVENT_DROP_INTR;
omap_dma.c:    struct omap_dma_channel_s *ch = dma->opaque;
omap_dma.c:    struct omap_dma_reg_set_s *a = &ch->active_set;
omap_dma.c:    int bytes = dma->bytes;
omap_dma.c:    uint16_t status = ch->status;
omap_dma.c:        if (!ch->constant_fill)
omap_dma.c:            cpu_physical_memory_read(a->src, value, ch->data_type);
omap_dma.c:            *(uint32_t *) value = ch->color;
omap_dma.c:        if (!ch->transparent_copy || *(uint32_t *) value != ch->color)
omap_dma.c:            cpu_physical_memory_write(a->dest, value, ch->data_type);
omap_dma.c:        a->src += a->elem_delta[0];
omap_dma.c:        a->dest += a->elem_delta[1];
omap_dma.c:        a->element ++;
omap_dma.c:        if (a->element == a->elements) {
omap_dma.c:            a->element = 0;
omap_dma.c:            a->src += a->frame_delta[0];
omap_dma.c:            a->dest += a->frame_delta[1];
omap_dma.c:            a->frame ++;
omap_dma.c:            if (!ch->sync)
omap_dma.c:                ch->cpc = a->dest & 0xffff;
omap_dma.c:    } while ((bytes -= ch->data_type));
omap_dma.c:        if (ch->sync && !ch->fs && !ch->bs)
omap_dma.c:        if (a->element == 1 && a->frame == a->frames - 1)
omap_dma.c:            if (ch->interrupts & LAST_FRAME_INTR)
omap_dma.c:                ch->status |= LAST_FRAME_INTR;
omap_dma.c:        if (a->element == (a->elements >> 1))
omap_dma.c:            if (ch->interrupts & HALF_FRAME_INTR)
omap_dma.c:                ch->status |= HALF_FRAME_INTR;
omap_dma.c:        if (ch->fs && ch->bs) {
omap_dma.c:            a->pck_element ++;
omap_dma.c:            if (a->pck_element == a->pck_elements) {
omap_dma.c:                a->pck_element = 0;
omap_dma.c:                if ((ch->interrupts & END_PKT_INTR) && !ch->src_sync)
omap_dma.c:                    ch->status |= END_PKT_INTR;
omap_dma.c:                /* If the channel is packet-synchronized, deactivate it */
omap_dma.c:                if (ch->sync)
omap_dma.c:        if (a->element == a->elements) {
omap_dma.c:            a->element = 0;
omap_dma.c:            a->src += a->frame_delta[0];
omap_dma.c:            a->dest += a->frame_delta[1];
omap_dma.c:            a->frame ++;
omap_dma.c:            if (ch->sync && ch->fs && !ch->bs)
omap_dma.c:            if (!ch->sync)
omap_dma.c:                ch->cpc = a->dest & 0xffff;
omap_dma.c:            if (ch->interrupts & END_FRAME_INTR)
omap_dma.c:                ch->status |= END_FRAME_INTR;
omap_dma.c:            if (a->frame == a->frames) {
omap_dma.c:                if (ch->omap_3_1_compatible_disable) {
omap_dma.c:                    if (ch->link_enabled)
omap_dma.c:                                        &s->ch[ch->link_next_ch]);
omap_dma.c:                    if (!ch->auto_init)
omap_dma.c:                    else if (ch->repeat || ch->end_prog)
omap_dma.c:                        ch->waiting_end_prog = 1;
omap_dma.c:                if (ch->interrupts & END_BLOCK_INTR)
omap_dma.c:                    ch->status |= END_BLOCK_INTR;
omap_dma.c:    } while (status == ch->status && ch->active);
omap_dma.c:    struct omap_dma_channel_s *ch = dma->opaque;
omap_dma.c:    struct omap_dma_s *s = dma->dma->opaque;
omap_dma.c:    a = &ch->active_set;
omap_dma.c:    src_p = &s->mpu->port[ch->port[0]];
omap_dma.c:    dest_p = &s->mpu->port[ch->port[1]];
omap_dma.c:    if ((!ch->constant_fill && !src_p->addr_valid(s->mpu, a->src)) ||
omap_dma.c:                    (!dest_p->addr_valid(s->mpu, a->dest))) {
omap_dma.c:        /* Bus time-out */
omap_dma.c:        if (ch->interrupts & TIMEOUT_INTR)
omap_dma.c:            ch->status |= TIMEOUT_INTR;
omap_dma.c:        printf("%s: Bus time-out in DMA%i operation\n",
omap_dma.c:                        __FUNCTION__, dma->num);
omap_dma.c:                    ch->sync && !ch->fs && !ch->bs,
omap_dma.c:     * using memcpy() but a->frame_delta is non-zero, try to still do
omap_dma.c:     * transfers using soc_dma but limit min_elems to a->elements - ...
omap_dma.c:                    (ch->interrupts & LAST_FRAME_INTR) &&
omap_dma.c:                    ((a->frame < a->frames - 1) || !a->element),
omap_dma.c:                    (a->frames - a->frame - 2) * a->elements +
omap_dma.c:                    (a->elements - a->element + 1))
omap_dma.c:                    ch->interrupts & HALF_FRAME_INTR,
omap_dma.c:                    (a->elements >> 1) +
omap_dma.c:                    (a->element >= (a->elements >> 1) ? a->elements : 0) -
omap_dma.c:                    a->element)
omap_dma.c:                    ch->sync && ch->fs && (ch->interrupts & END_FRAME_INTR),
omap_dma.c:                    a->elements - a->element)
omap_dma.c:                    ch->sync && ch->fs && !ch->bs,
omap_dma.c:                    a->elements - a->element)
omap_dma.c:                    ch->fs && ch->bs &&
omap_dma.c:                    (ch->interrupts & END_PKT_INTR) && !ch->src_sync,
omap_dma.c:                    a->pck_elements - a->pck_element)
omap_dma.c:                    ch->fs && ch->bs && ch->sync,
omap_dma.c:                    a->pck_elements - a->pck_element)
omap_dma.c:                    (a->frames - a->frame - 1) * a->elements +
omap_dma.c:                    (a->elements - a->element))
omap_dma.c:    dma->bytes = min_elems * ch->data_type;
omap_dma.c:    /* TODO: should all of this only be done if dma->update, and otherwise
omap_dma.c:     * inside omap_dma_transfer_generic below - check what's faster.  */
omap_dma.c:    if (dma->update) {
omap_dma.c:            ch->status |= LAST_FRAME_INTR;
omap_dma.c:            ch->status |= HALF_FRAME_INTR;
omap_dma.c:            ch->status |= END_PKT_INTR;
omap_dma.c:        /* If the channel is packet-synchronized, deactivate it */
omap_dma.c:            ch->status |= END_FRAME_INTR;
omap_dma.c:            if (ch->omap_3_1_compatible_disable) {
omap_dma.c:                if (ch->link_enabled)
omap_dma.c:                    omap_dma_enable_channel(s, &s->ch[ch->link_next_ch]);
omap_dma.c:                if (!ch->auto_init)
omap_dma.c:                else if (ch->repeat || ch->end_prog)
omap_dma.c:                    ch->waiting_end_prog = 1;
omap_dma.c:            if (ch->interrupts & END_BLOCK_INTR)
omap_dma.c:                ch->status |= END_BLOCK_INTR;
omap_dma.c:        if (ch->fs && ch->bs) {
omap_dma.c:            a->pck_element += min_elems;
omap_dma.c:            a->pck_element %= a->pck_elements;
omap_dma.c:        if (dma->update) {
omap_dma.c:            a->element += min_elems;
omap_dma.c:            frames = a->element / a->elements;
omap_dma.c:            a->element = a->element % a->elements;
omap_dma.c:            a->frame += frames;
omap_dma.c:            a->src += min_elems * a->elem_delta[0] + frames * a->frame_delta[0];
omap_dma.c:            a->dest += min_elems * a->elem_delta[1] + frames * a->frame_delta[1];
omap_dma.c:            if (!ch->sync && frames)
omap_dma.c:                ch->cpc = a->dest & 0xffff;
omap_dma.c:    struct omap_dma_s *s = dma->opaque;
omap_dma.c:    soc_dma_reset(s->dma);
omap_dma.c:    if (s->model < omap_dma_4)
omap_dma.c:        s->gcr = 0x0004;
omap_dma.c:        s->gcr = 0x00010010;
omap_dma.c:    s->ocp = 0x00000000;
omap_dma.c:    memset(&s->irqstat, 0, sizeof(s->irqstat));
omap_dma.c:    memset(&s->irqen, 0, sizeof(s->irqen));
omap_dma.c:    s->lcd_ch.src = emiff;
omap_dma.c:    s->lcd_ch.condition = 0;
omap_dma.c:    s->lcd_ch.interrupts = 0;
omap_dma.c:    s->lcd_ch.dual = 0;
omap_dma.c:    if (s->model < omap_dma_4)
omap_dma.c:    for (i = 0; i < s->chans; i ++) {
omap_dma.c:        s->ch[i].suspend = 0;
omap_dma.c:        s->ch[i].prefetch = 0;
omap_dma.c:        s->ch[i].buf_disable = 0;
omap_dma.c:        s->ch[i].src_sync = 0;
omap_dma.c:        memset(&s->ch[i].burst, 0, sizeof(s->ch[i].burst));
omap_dma.c:        memset(&s->ch[i].port, 0, sizeof(s->ch[i].port));
omap_dma.c:        memset(&s->ch[i].mode, 0, sizeof(s->ch[i].mode));
omap_dma.c:        memset(&s->ch[i].frame_index, 0, sizeof(s->ch[i].frame_index));
omap_dma.c:        memset(&s->ch[i].element_index, 0, sizeof(s->ch[i].element_index));
omap_dma.c:        memset(&s->ch[i].endian, 0, sizeof(s->ch[i].endian));
omap_dma.c:        memset(&s->ch[i].endian_lock, 0, sizeof(s->ch[i].endian_lock));
omap_dma.c:        memset(&s->ch[i].translate, 0, sizeof(s->ch[i].translate));
omap_dma.c:        s->ch[i].write_mode = 0;
omap_dma.c:        s->ch[i].data_type = 0;
omap_dma.c:        s->ch[i].transparent_copy = 0;
omap_dma.c:        s->ch[i].constant_fill = 0;
omap_dma.c:        s->ch[i].color = 0x00000000;
omap_dma.c:        s->ch[i].end_prog = 0;
omap_dma.c:        s->ch[i].repeat = 0;
omap_dma.c:        s->ch[i].auto_init = 0;
omap_dma.c:        s->ch[i].link_enabled = 0;
omap_dma.c:        if (s->model < omap_dma_4)
omap_dma.c:            s->ch[i].interrupts = 0x0003;
omap_dma.c:            s->ch[i].interrupts = 0x0000;
omap_dma.c:        s->ch[i].status = 0;
omap_dma.c:        s->ch[i].cstatus = 0;
omap_dma.c:        s->ch[i].active = 0;
omap_dma.c:        s->ch[i].enable = 0;
omap_dma.c:        s->ch[i].sync = 0;
omap_dma.c:        s->ch[i].pending_request = 0;
omap_dma.c:        s->ch[i].waiting_end_prog = 0;
omap_dma.c:        s->ch[i].cpc = 0x0000;
omap_dma.c:        s->ch[i].fs = 0;
omap_dma.c:        s->ch[i].bs = 0;
omap_dma.c:        s->ch[i].omap_3_1_compatible_disable = 0;
omap_dma.c:        memset(&s->ch[i].active_set, 0, sizeof(s->ch[i].active_set));
omap_dma.c:        s->ch[i].priority = 0;
omap_dma.c:        s->ch[i].interleave_disabled = 0;
omap_dma.c:        s->ch[i].type = 0;
omap_dma.c:        *value = (ch->burst[1] << 14) |
omap_dma.c:                (ch->pack[1] << 13) |
omap_dma.c:                (ch->port[1] << 9) |
omap_dma.c:                (ch->burst[0] << 7) |
omap_dma.c:                (ch->pack[0] << 6) |
omap_dma.c:                (ch->port[0] << 2) |
omap_dma.c:                (ch->data_type >> 1);
omap_dma.c:        if (s->model <= omap_dma_3_1)
omap_dma.c:            *value = ch->omap_3_1_compatible_disable << 10;
omap_dma.c:        *value |= (ch->mode[1] << 14) |
omap_dma.c:                (ch->mode[0] << 12) |
omap_dma.c:                (ch->end_prog << 11) |
omap_dma.c:                (ch->repeat << 9) |
omap_dma.c:                (ch->auto_init << 8) |
omap_dma.c:                (ch->enable << 7) |
omap_dma.c:                (ch->priority << 6) |
omap_dma.c:                (ch->fs << 5) | ch->sync;
omap_dma.c:        *value = ch->interrupts;
omap_dma.c:        *value = ch->status;
omap_dma.c:        ch->status &= SYNC;
omap_dma.c:        if (!ch->omap_3_1_compatible_disable && ch->sibling) {
omap_dma.c:            *value |= (ch->sibling->status & 0x3f) << 6;
omap_dma.c:            ch->sibling->status &= SYNC;
omap_dma.c:        qemu_irq_lower(ch->irq);
omap_dma.c:        *value = ch->addr[0] & 0x0000ffff;
omap_dma.c:        *value = ch->addr[0] >> 16;
omap_dma.c:        *value = ch->addr[1] & 0x0000ffff;
omap_dma.c:        *value = ch->addr[1] >> 16;
omap_dma.c:        *value = ch->elements;
omap_dma.c:        *value = ch->frames;
omap_dma.c:        *value = ch->frame_index[0];
omap_dma.c:        *value = ch->element_index[0];
omap_dma.c:        if (ch->omap_3_1_compatible_disable)
omap_dma.c:            *value = ch->active_set.src & 0xffff;	/* CSAC */
omap_dma.c:            *value = ch->cpc;
omap_dma.c:        *value = ch->active_set.dest & 0xffff;	/* CDAC */
omap_dma.c:        *value = ch->element_index[1];
omap_dma.c:        *value = ch->frame_index[1];
omap_dma.c:        *value = ch->color & 0xffff;
omap_dma.c:        *value = ch->color >> 16;
omap_dma.c:        *value = (ch->bs << 2) |
omap_dma.c:                (ch->transparent_copy << 1) |
omap_dma.c:                ch->constant_fill;
omap_dma.c:        *value = (ch->link_enabled << 15) |
omap_dma.c:                (ch->link_next_ch & 0xf);
omap_dma.c:        *value = (ch->interleave_disabled << 15) |
omap_dma.c:                ch->type;
omap_dma.c:        ch->burst[1] = (value & 0xc000) >> 14;
omap_dma.c:        ch->pack[1] = (value & 0x2000) >> 13;
omap_dma.c:        ch->port[1] = (enum omap_dma_port) ((value & 0x1e00) >> 9);
omap_dma.c:        ch->burst[0] = (value & 0x0180) >> 7;
omap_dma.c:        ch->pack[0] = (value & 0x0040) >> 6;
omap_dma.c:        ch->port[0] = (enum omap_dma_port) ((value & 0x003c) >> 2);
omap_dma.c:        ch->data_type = 1 << (value & 3);
omap_dma.c:        if (ch->port[0] >= __omap_dma_port_last)
omap_dma.c:                            ch->port[0]);
omap_dma.c:        if (ch->port[1] >= __omap_dma_port_last)
omap_dma.c:                            ch->port[1]);
omap_dma.c:        ch->mode[1] = (omap_dma_addressing_t) ((value & 0xc000) >> 14);
omap_dma.c:        ch->mode[0] = (omap_dma_addressing_t) ((value & 0x3000) >> 12);
omap_dma.c:        ch->end_prog = (value & 0x0800) >> 11;
omap_dma.c:        if (s->model >= omap_dma_3_2)
omap_dma.c:            ch->omap_3_1_compatible_disable  = (value >> 10) & 0x1;
omap_dma.c:        ch->repeat = (value & 0x0200) >> 9;
omap_dma.c:        ch->auto_init = (value & 0x0100) >> 8;
omap_dma.c:        ch->priority = (value & 0x0040) >> 6;
omap_dma.c:        ch->fs = (value & 0x0020) >> 5;
omap_dma.c:        ch->sync = value & 0x001f;
omap_dma.c:        if (ch->end_prog)
omap_dma.c:        ch->interrupts = value & 0x3f;
omap_dma.c:        ch->addr[0] &= 0xffff0000;
omap_dma.c:        ch->addr[0] |= value;
omap_dma.c:        ch->addr[0] &= 0x0000ffff;
omap_dma.c:        ch->addr[0] |= (uint32_t) value << 16;
omap_dma.c:        ch->addr[1] &= 0xffff0000;
omap_dma.c:        ch->addr[1] |= value;
omap_dma.c:        ch->addr[1] &= 0x0000ffff;
omap_dma.c:        ch->addr[1] |= (uint32_t) value << 16;
omap_dma.c:        ch->elements = value;
omap_dma.c:        ch->frames = value;
omap_dma.c:        ch->frame_index[0] = (int16_t) value;
omap_dma.c:        ch->element_index[0] = (int16_t) value;
omap_dma.c:        ch->element_index[1] = (int16_t) value;
omap_dma.c:        ch->frame_index[1] = (int16_t) value;
omap_dma.c:        ch->color &= 0xffff0000;
omap_dma.c:        ch->color |= value;
omap_dma.c:        ch->color &= 0xffff;
omap_dma.c:        ch->color |= value << 16;
omap_dma.c:        ch->bs = (value >> 2) & 0x1;
omap_dma.c:        ch->transparent_copy = (value >> 1) & 0x1;
omap_dma.c:        ch->constant_fill = value & 0x1;
omap_dma.c:        ch->link_enabled = (value >> 15) & 0x1;
omap_dma.c:            ch->link_enabled = 0;
omap_dma.c:        ch->link_next_ch = value & 0x1f;
omap_dma.c:        ch->interleave_disabled = (value >> 15) & 0x1;
omap_dma.c:        ch->type = value & 0xf;
omap_dma.c:        s->brust_f2 = (value >> 14) & 0x3;
omap_dma.c:        s->pack_f2 = (value >> 13) & 0x1;
omap_dma.c:        s->data_type_f2 = (1 << ((value >> 11) & 0x3));
omap_dma.c:        s->brust_f1 = (value >> 7) & 0x3;
omap_dma.c:        s->pack_f1 = (value >> 6) & 0x1;
omap_dma.c:        s->data_type_f1 = (1 << ((value >> 0) & 0x3));
omap_dma.c:        s->mode_f2 = (value >> 14) & 0x3;
omap_dma.c:        s->mode_f1 = (value >> 12) & 0x3;
omap_dma.c:        s->end_prog = (value >> 11) & 0x1;
omap_dma.c:        s->omap_3_1_compatible_disable = (value >> 10) & 0x1;
omap_dma.c:        s->repeat = (value >> 9) & 0x1;
omap_dma.c:        s->auto_init = (value >> 8) & 0x1;
omap_dma.c:        s->running = (value >> 7) & 0x1;
omap_dma.c:        s->priority = (value >> 6) & 0x1;
omap_dma.c:        s->bs = (value >> 4) & 0x1;
omap_dma.c:        s->dst = (value >> 8) & 0x1;
omap_dma.c:        s->src = ((value >> 6) & 0x3) << 1;
omap_dma.c:        s->condition = 0;
omap_dma.c:        s->interrupts = (value >> 1) & 1;
omap_dma.c:        s->dual = value & 1;
omap_dma.c:        s->src_f1_top &= 0xffff0000;
omap_dma.c:        s->src_f1_top |= 0x0000ffff & value;
omap_dma.c:        s->src_f1_top &= 0x0000ffff;
omap_dma.c:        s->src_f1_top |= value << 16;
omap_dma.c:        s->src_f1_bottom &= 0xffff0000;
omap_dma.c:        s->src_f1_bottom |= 0x0000ffff & value;
omap_dma.c:        s->src_f1_bottom &= 0x0000ffff;
omap_dma.c:        s->src_f1_bottom |= (uint32_t) value << 16;
omap_dma.c:        s->src_f2_top &= 0xffff0000;
omap_dma.c:        s->src_f2_top |= 0x0000ffff & value;
omap_dma.c:        s->src_f2_top &= 0x0000ffff;
omap_dma.c:        s->src_f2_top |= (uint32_t) value << 16;
omap_dma.c:        s->src_f2_bottom &= 0xffff0000;
omap_dma.c:        s->src_f2_bottom |= 0x0000ffff & value;
omap_dma.c:        s->src_f2_bottom &= 0x0000ffff;
omap_dma.c:        s->src_f2_bottom |= (uint32_t) value << 16;
omap_dma.c:        s->element_index_f1 = value;
omap_dma.c:        s->frame_index_f1 &= 0xffff0000;
omap_dma.c:        s->frame_index_f1 |= 0x0000ffff & value;
omap_dma.c:        s->frame_index_f1 &= 0x0000ffff;
omap_dma.c:        s->frame_index_f1 |= (uint32_t) value << 16;
omap_dma.c:        s->element_index_f2 = value;
omap_dma.c:        s->frame_index_f2 &= 0xffff0000;
omap_dma.c:        s->frame_index_f2 |= 0x0000ffff & value;
omap_dma.c:        s->frame_index_f2 &= 0x0000ffff;
omap_dma.c:        s->frame_index_f2 |= (uint32_t) value << 16;
omap_dma.c:        s->elements_f1 = value;
omap_dma.c:        s->frames_f1 = value;
omap_dma.c:        s->elements_f2 = value;
omap_dma.c:        s->frames_f2 = value;
omap_dma.c:        s->lch_type = value & 0xf;
omap_dma.c:        *ret = (s->brust_f2 << 14) |
omap_dma.c:            (s->pack_f2 << 13) |
omap_dma.c:            ((s->data_type_f2 >> 1) << 11) |
omap_dma.c:            (s->brust_f1 << 7) |
omap_dma.c:            (s->pack_f1 << 6) |
omap_dma.c:            ((s->data_type_f1 >> 1) << 0);
omap_dma.c:        *ret = (s->mode_f2 << 14) |
omap_dma.c:            (s->mode_f1 << 12) |
omap_dma.c:            (s->end_prog << 11) |
omap_dma.c:            (s->omap_3_1_compatible_disable << 10) |
omap_dma.c:            (s->repeat << 9) |
omap_dma.c:            (s->auto_init << 8) |
omap_dma.c:            (s->running << 7) |
omap_dma.c:            (s->priority << 6) |
omap_dma.c:            (s->bs << 4);
omap_dma.c:        qemu_irq_lower(s->irq);
omap_dma.c:        *ret = (s->dst << 8) |
omap_dma.c:            ((s->src & 0x6) << 5) |
omap_dma.c:            (s->condition << 3) |
omap_dma.c:            (s->interrupts << 1) |
omap_dma.c:            s->dual;
omap_dma.c:        *ret = s->src_f1_top & 0xffff;
omap_dma.c:        *ret = s->src_f1_top >> 16;
omap_dma.c:        *ret = s->src_f1_bottom & 0xffff;
omap_dma.c:        *ret = s->src_f1_bottom >> 16;
omap_dma.c:        *ret = s->src_f2_top & 0xffff;
omap_dma.c:        *ret = s->src_f2_top >> 16;
omap_dma.c:        *ret = s->src_f2_bottom & 0xffff;
omap_dma.c:        *ret = s->src_f2_bottom >> 16;
omap_dma.c:        *ret = s->element_index_f1;
omap_dma.c:        *ret = s->frame_index_f1 & 0xffff;
omap_dma.c:        *ret = s->frame_index_f1 >> 16;
omap_dma.c:        *ret = s->element_index_f2;
omap_dma.c:        *ret = s->frame_index_f2 & 0xffff;
omap_dma.c:        *ret = s->frame_index_f2 >> 16;
omap_dma.c:        *ret = s->elements_f1;
omap_dma.c:        *ret = s->frames_f1;
omap_dma.c:        *ret = s->elements_f2;
omap_dma.c:        *ret = s->frames_f2;
omap_dma.c:        *ret = s->lch_type;
omap_dma.c:        s->src = (value & 0x40) ? imif : emiff;
omap_dma.c:        s->condition = 0;
omap_dma.c:        s->interrupts = (value >> 1) & 1;
omap_dma.c:        s->dual = value & 1;
omap_dma.c:        s->src_f1_top &= 0xffff0000;
omap_dma.c:        s->src_f1_top |= 0x0000ffff & value;
omap_dma.c:        s->src_f1_top &= 0x0000ffff;
omap_dma.c:        s->src_f1_top |= value << 16;
omap_dma.c:        s->src_f1_bottom &= 0xffff0000;
omap_dma.c:        s->src_f1_bottom |= 0x0000ffff & value;
omap_dma.c:        s->src_f1_bottom &= 0x0000ffff;
omap_dma.c:        s->src_f1_bottom |= value << 16;
omap_dma.c:        s->src_f2_top &= 0xffff0000;
omap_dma.c:        s->src_f2_top |= 0x0000ffff & value;
omap_dma.c:        s->src_f2_top &= 0x0000ffff;
omap_dma.c:        s->src_f2_top |= value << 16;
omap_dma.c:        s->src_f2_bottom &= 0xffff0000;
omap_dma.c:        s->src_f2_bottom |= 0x0000ffff & value;
omap_dma.c:        s->src_f2_bottom &= 0x0000ffff;
omap_dma.c:        s->src_f2_bottom |= value << 16;
omap_dma.c:        i = s->condition;
omap_dma.c:        s->condition = 0;
omap_dma.c:        qemu_irq_lower(s->irq);
omap_dma.c:        *ret = ((s->src == imif) << 6) | (i << 3) |
omap_dma.c:                (s->interrupts << 1) | s->dual;
omap_dma.c:        *ret = s->src_f1_top & 0xffff;
omap_dma.c:        *ret = s->src_f1_top >> 16;
omap_dma.c:        *ret = s->src_f1_bottom & 0xffff;
omap_dma.c:        *ret = s->src_f1_bottom >> 16;
omap_dma.c:        *ret = s->src_f2_top & 0xffff;
omap_dma.c:        *ret = s->src_f2_top >> 16;
omap_dma.c:        *ret = s->src_f2_bottom & 0xffff;
omap_dma.c:        *ret = s->src_f2_bottom >> 16;
omap_dma.c:        s->gcr = value;
omap_dma.c:            omap_dma_reset(s->dma);
omap_dma.c:        *ret = s->gcr;
omap_dma.c:        *ret = s->omap_3_1_mapping_disabled << 3;
omap_dma.c:        *ret = (s->caps[0] >> 16) & 0xffff;
omap_dma.c:        *ret = (s->caps[0] >>  0) & 0xffff;
omap_dma.c:        *ret = (s->caps[1] >> 16) & 0xffff;
omap_dma.c:        *ret = (s->caps[1] >>  0) & 0xffff;
omap_dma.c:        *ret = s->caps[2];
omap_dma.c:        *ret = s->caps[3];
omap_dma.c:        *ret = s->caps[4];
omap_dma.c:        if (s->model <= omap_dma_3_1 || !s->omap_3_1_mapping_disabled) {
omap_dma.c:            if (omap_dma_3_1_lcd_read(&s->lcd_ch, addr, &ret))
omap_dma.c:        if (omap_dma_ch_reg_read(s, &s->ch[ch], reg, &ret))
omap_dma.c:        if (s->model <= omap_dma_3_1)
omap_dma.c:        if (s->model == omap_dma_3_2 && s->omap_3_1_mapping_disabled) {
omap_dma.c:            if (omap_dma_3_2_lcd_read(&s->lcd_ch, addr, &ret))
omap_dma.c:        if (s->model <= omap_dma_3_1 || !s->omap_3_1_mapping_disabled) {
omap_dma.c:            if (omap_dma_3_1_lcd_write(&s->lcd_ch, addr, value))
omap_dma.c:        if (omap_dma_ch_reg_write(s, &s->ch[ch], reg, value))
omap_dma.c:        if (s->model <= omap_dma_3_1)
omap_dma.c:        if (s->model == omap_dma_3_2 && s->omap_3_1_mapping_disabled) {
omap_dma.c:            if (omap_dma_3_2_lcd_write(&s->lcd_ch, addr, value))
omap_dma.c:        if (~s->dma->drqbmp & (1 << drq)) {
omap_dma.c:            s->dma->drqbmp |= 1 << drq;
omap_dma.c:        s->dma->drqbmp &= ~(1 << drq);
omap_dma.c:    s->dma->freq = omap_clk_getrate(s->clk);
omap_dma.c:    for (i = 0; i < s->chans; i ++)
omap_dma.c:        if (s->ch[i].active)
omap_dma.c:            soc_dma_set_request(s->ch[i].dma, on);
omap_dma.c:    switch (s->model) {
omap_dma.c:        s->caps[0] =
omap_dma.c:        s->caps[1] =
omap_dma.c:                (1 << 1);	/* 1-bit palettized capability (DMA 3.2 only) */
omap_dma.c:        s->caps[2] =
omap_dma.c:        s->caps[3] =
omap_dma.c:        s->caps[4] =
omap_dma.c:    s->model = model;
omap_dma.c:    s->mpu = mpu;
omap_dma.c:    s->clk = clk;
omap_dma.c:    s->lcd_ch.irq = lcd_irq;
omap_dma.c:    s->lcd_ch.mpu = mpu;
omap_dma.c:    s->dma = soc_dma_init((model <= omap_dma_3_1) ? 9 : 16);
omap_dma.c:    s->dma->freq = omap_clk_getrate(clk);
omap_dma.c:    s->dma->transfer_fn = omap_dma_transfer_generic;
omap_dma.c:    s->dma->setup_fn = omap_dma_transfer_setup;
omap_dma.c:    s->dma->drq = qemu_allocate_irqs(omap_dma_request, s, 32);
omap_dma.c:    s->dma->opaque = s;
omap_dma.c:    while (num_irqs --)
omap_dma.c:        s->ch[num_irqs].irq = irqs[num_irqs];
omap_dma.c:        s->ch[i].sibling = &s->ch[i + 6];
omap_dma.c:        s->ch[i + 6].sibling = &s->ch[i];
omap_dma.c:    for (i = (model <= omap_dma_3_1) ? 8 : 15; i >= 0; i --) {
omap_dma.c:        s->ch[i].dma = &s->dma->ch[i];
omap_dma.c:        s->dma->ch[i].opaque = &s->ch[i];
omap_dma.c:    omap_clk_adduser(s->clk, qemu_allocate_irqs(omap_dma_clk_update, s, 1)[0]);
omap_dma.c:    omap_dma_reset(s->dma);
omap_dma.c:    mpu->drq = s->dma->drq;
omap_dma.c:    return s->dma;
omap_dma.c:    struct omap_dma_channel_s *ch = s->ch;
omap_dma.c:        if (ch->status) {
omap_dma.c:            ch->cstatus |= ch->status;
omap_dma.c:            ch->status = 0;
omap_dma.c:    if ((s->irqstat[0] |= s->irqen[0] & bmp))
omap_dma.c:        qemu_irq_raise(s->irq[0]);
omap_dma.c:    if ((s->irqstat[1] |= s->irqen[1] & bmp))
omap_dma.c:        qemu_irq_raise(s->irq[1]);
omap_dma.c:    if ((s->irqstat[2] |= s->irqen[2] & bmp))
omap_dma.c:        qemu_irq_raise(s->irq[2]);
omap_dma.c:    if ((s->irqstat[3] |= s->irqen[3] & bmp))
omap_dma.c:        qemu_irq_raise(s->irq[3]);
omap_dma.c:        return s->irqstat[irqn];
omap_dma.c:        return s->irqen[irqn];
omap_dma.c:        return s->ocp;
omap_dma.c:        return s->caps[0];
omap_dma.c:        return s->caps[2];
omap_dma.c:        return s->caps[3];
omap_dma.c:        return s->caps[4];
omap_dma.c:        return s->gcr;
omap_dma.c:        addr -= 0x80;
omap_dma.c:        ch = s->ch + chnum;
omap_dma.c:        addr -= chnum * 0x60;
omap_dma.c:    /* Per-channel registers */
omap_dma.c:        return (ch->buf_disable << 25) |
omap_dma.c:                (ch->src_sync << 24) |
omap_dma.c:                (ch->prefetch << 23) |
omap_dma.c:                ((ch->sync & 0x60) << 14) |
omap_dma.c:                (ch->bs << 18) |
omap_dma.c:                (ch->transparent_copy << 17) |
omap_dma.c:                (ch->constant_fill << 16) |
omap_dma.c:                (ch->mode[1] << 14) |
omap_dma.c:                (ch->mode[0] << 12) |
omap_dma.c:                (ch->suspend << 8) |
omap_dma.c:                (ch->enable << 7) |
omap_dma.c:                (ch->priority << 6) |
omap_dma.c:                (ch->fs << 5) | (ch->sync & 0x1f);
omap_dma.c:        return (ch->link_enabled << 15) | ch->link_next_ch;
omap_dma.c:        return ch->interrupts;
omap_dma.c:        return ch->cstatus;
omap_dma.c:        return (ch->endian[0] << 21) |
omap_dma.c:                (ch->endian_lock[0] << 20) |
omap_dma.c:                (ch->endian[1] << 19) |
omap_dma.c:                (ch->endian_lock[1] << 18) |
omap_dma.c:                (ch->write_mode << 16) |
omap_dma.c:                (ch->burst[1] << 14) |
omap_dma.c:                (ch->pack[1] << 13) |
omap_dma.c:                (ch->translate[1] << 9) |
omap_dma.c:                (ch->burst[0] << 7) |
omap_dma.c:                (ch->pack[0] << 6) |
omap_dma.c:                (ch->translate[0] << 2) |
omap_dma.c:                (ch->data_type >> 1);
omap_dma.c:        return ch->elements;
omap_dma.c:        return ch->frames;
omap_dma.c:        return ch->addr[0];
omap_dma.c:        return ch->addr[1];
omap_dma.c:        return ch->element_index[0];
omap_dma.c:        return ch->frame_index[0];
omap_dma.c:        return ch->element_index[1];
omap_dma.c:        return ch->frame_index[1];
omap_dma.c:        return ch->active_set.src & 0xffff;
omap_dma.c:        return ch->active_set.dest & 0xffff;
omap_dma.c:        return ch->active_set.element;
omap_dma.c:        return ch->active_set.frame;
omap_dma.c:        return ch->color;
omap_dma.c:        s->irqstat[irqn] &= ~value;
omap_dma.c:        if (!s->irqstat[irqn])
omap_dma.c:            qemu_irq_lower(s->irq[irqn]);
omap_dma.c:        s->irqen[irqn] = value;
omap_dma.c:            omap_dma_reset(s->dma);
omap_dma.c:        s->ocp = value & 0x3321;
omap_dma.c:        if (((s->ocp >> 12) & 3) == 3)				/* MIDLEMODE */
omap_dma.c:        s->gcr = value & 0x00ff00ff;
omap_dma.c:        addr -= 0x80;
omap_dma.c:        ch = s->ch + chnum;
omap_dma.c:        addr -= chnum * 0x60;
omap_dma.c:    /* Per-channel registers */
omap_dma.c:        ch->buf_disable = (value >> 25) & 1;
omap_dma.c:        ch->src_sync = (value >> 24) & 1;	/* XXX For CamDMA must be 1 */
omap_dma.c:        if (ch->buf_disable && !ch->src_sync)
omap_dma.c:        ch->prefetch = (value >> 23) & 1;
omap_dma.c:        ch->bs = (value >> 18) & 1;
omap_dma.c:        ch->transparent_copy = (value >> 17) & 1;
omap_dma.c:        ch->constant_fill = (value >> 16) & 1;
omap_dma.c:        ch->mode[1] = (omap_dma_addressing_t) ((value & 0xc000) >> 14);
omap_dma.c:        ch->mode[0] = (omap_dma_addressing_t) ((value & 0x3000) >> 12);
omap_dma.c:        ch->suspend = (value & 0x0100) >> 8;
omap_dma.c:        ch->priority = (value & 0x0040) >> 6;
omap_dma.c:        ch->fs = (value & 0x0020) >> 5;
omap_dma.c:        if (ch->fs && ch->bs && ch->mode[0] && ch->mode[1])
omap_dma.c:                            "must be constant-addressed\n", __FUNCTION__);
omap_dma.c:        ch->sync = (value & 0x001f) | ((value >> 14) & 0x0060);
omap_dma.c:        ch->link_enabled = (value >> 15) & 0x1;
omap_dma.c:        ch->link_next_ch = value & 0x1f;
omap_dma.c:        ch->interrupts = value & 0x09be;
omap_dma.c:        ch->cstatus &= ~value;
omap_dma.c:        ch->endian[0] =(value >> 21) & 1;
omap_dma.c:        ch->endian_lock[0] =(value >> 20) & 1;
omap_dma.c:        ch->endian[1] =(value >> 19) & 1;
omap_dma.c:        ch->endian_lock[1] =(value >> 18) & 1;
omap_dma.c:        if (ch->endian[0] != ch->endian[1])
omap_dma.c:        ch->write_mode = (value >> 16) & 3;
omap_dma.c:        ch->burst[1] = (value & 0xc000) >> 14;
omap_dma.c:        ch->pack[1] = (value & 0x2000) >> 13;
omap_dma.c:        ch->translate[1] = (value & 0x1e00) >> 9;
omap_dma.c:        ch->burst[0] = (value & 0x0180) >> 7;
omap_dma.c:        ch->pack[0] = (value & 0x0040) >> 6;
omap_dma.c:        ch->translate[0] = (value & 0x003c) >> 2;
omap_dma.c:        if (ch->translate[0] | ch->translate[1])
omap_dma.c:        ch->data_type = 1 << (value & 3);
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->elements = value & 0xffffff;
omap_dma.c:        ch->frames = value & 0xffff;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->addr[0] = (target_phys_addr_t) (uint32_t) value;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->addr[1] = (target_phys_addr_t) (uint32_t) value;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->element_index[0] = (int16_t) value;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->frame_index[0] = (int32_t) value;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->element_index[1] = (int16_t) value;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->frame_index[1] = (int32_t) value;
omap_dma.c:        ch->set_update = 1;
omap_dma.c:        ch->color = value;
omap_dma.c:    s->model = omap_dma_4;
omap_dma.c:    s->chans = chans;
omap_dma.c:    s->mpu = mpu;
omap_dma.c:    s->clk = fclk;
omap_dma.c:    s->dma = soc_dma_init(s->chans);
omap_dma.c:    s->dma->freq = omap_clk_getrate(fclk);
omap_dma.c:    s->dma->transfer_fn = omap_dma_transfer_generic;
omap_dma.c:    s->dma->setup_fn = omap_dma_transfer_setup;
omap_dma.c:    s->dma->drq = qemu_allocate_irqs(omap_dma_request, s, 64);
omap_dma.c:    s->dma->opaque = s;
omap_dma.c:    for (i = 0; i < s->chans; i ++) {
omap_dma.c:        s->ch[i].dma = &s->dma->ch[i];
omap_dma.c:        s->dma->ch[i].opaque = &s->ch[i];
omap_dma.c:    memcpy(&s->irq, irqs, sizeof(s->irq));
omap_dma.c:    s->intr_update = omap_dma_interrupts_4_update;
omap_dma.c:    omap_clk_adduser(s->clk, qemu_allocate_irqs(omap_dma_clk_update, s, 1)[0]);
omap_dma.c:    omap_dma_reset(s->dma);
omap_dma.c:    omap_dma_clk_update(s, 0, !!s->dma->freq);
omap_dma.c:    mpu->drq = s->dma->drq;
omap_dma.c:    return s->dma;
omap_dma.c:    struct omap_dma_s *s = dma->opaque;
omap_dma.c:    return &s->lcd_ch;
omap_dss.c:    qemu_set_irq(s->irq, s->dispc.irqst & s->dispc.irqen);
omap_dss.c:    s->rfbi.idlemode = 0;
omap_dss.c:    s->rfbi.control = 2;
omap_dss.c:    s->rfbi.enable = 0;
omap_dss.c:    s->rfbi.pixels = 0;
omap_dss.c:    s->rfbi.skiplines = 0;
omap_dss.c:    s->rfbi.busy = 0;
omap_dss.c:    s->rfbi.config[0] = 0x00310000;
omap_dss.c:    s->rfbi.config[1] = 0x00310000;
omap_dss.c:    s->rfbi.time[0] = 0;
omap_dss.c:    s->rfbi.time[1] = 0;
omap_dss.c:    s->rfbi.time[2] = 0;
omap_dss.c:    s->rfbi.time[3] = 0;
omap_dss.c:    s->rfbi.data[0] = 0;
omap_dss.c:    s->rfbi.data[1] = 0;
omap_dss.c:    s->rfbi.data[2] = 0;
omap_dss.c:    s->rfbi.data[3] = 0;
omap_dss.c:    s->rfbi.data[4] = 0;
omap_dss.c:    s->rfbi.data[5] = 0;
omap_dss.c:    s->rfbi.vsync = 0;
omap_dss.c:    s->rfbi.hsync = 0;
omap_dss.c:    s->autoidle = 0;
omap_dss.c:    s->control = 0;
omap_dss.c:    s->enable = 0;
omap_dss.c:    s->dig.enable = 0;
omap_dss.c:    s->dig.nx = 1;
omap_dss.c:    s->dig.ny = 1;
omap_dss.c:    s->lcd.enable = 0;
omap_dss.c:    s->lcd.nx = 1;
omap_dss.c:    s->lcd.ny = 1;
omap_dss.c:    s->dispc.idlemode = 0;
omap_dss.c:    s->dispc.irqst = 0;
omap_dss.c:    s->dispc.irqen = 0;
omap_dss.c:    s->dispc.control = 0;
omap_dss.c:    s->dispc.config = 0;
omap_dss.c:    s->dispc.capable = 0x161;
omap_dss.c:    s->dispc.timing[0] = 0;
omap_dss.c:    s->dispc.timing[1] = 0;
omap_dss.c:    s->dispc.timing[2] = 0;
omap_dss.c:    s->dispc.timing[3] = 0;
omap_dss.c:    s->dispc.line = 0;
omap_dss.c:    s->dispc.bg[0] = 0;
omap_dss.c:    s->dispc.bg[1] = 0;
omap_dss.c:    s->dispc.trans[0] = 0;
omap_dss.c:    s->dispc.trans[1] = 0;
omap_dss.c:    s->dispc.l[0].enable = 0;
omap_dss.c:    s->dispc.l[0].bpp = 0;
omap_dss.c:    s->dispc.l[0].addr[0] = 0;
omap_dss.c:    s->dispc.l[0].addr[1] = 0;
omap_dss.c:    s->dispc.l[0].addr[2] = 0;
omap_dss.c:    s->dispc.l[0].posx = 0;
omap_dss.c:    s->dispc.l[0].posy = 0;
omap_dss.c:    s->dispc.l[0].nx = 1;
omap_dss.c:    s->dispc.l[0].ny = 1;
omap_dss.c:    s->dispc.l[0].attr = 0;
omap_dss.c:    s->dispc.l[0].tresh = 0;
omap_dss.c:    s->dispc.l[0].rowinc = 1;
omap_dss.c:    s->dispc.l[0].colinc = 1;
omap_dss.c:    s->dispc.l[0].wininc = 0;
omap_dss.c:        return s->autoidle;
omap_dss.c:        return s->control;
omap_dss.c:        /* TODO: fake some values when appropriate s->control bits are set */
omap_dss.c:        return 1 + (s->control & 1);
omap_dss.c:        s->autoidle = value & 1;
omap_dss.c:        s->control = value & 0x3dd;
omap_dss.c:        return s->dispc.idlemode;
omap_dss.c:        return s->dispc.irqst;
omap_dss.c:        return s->dispc.irqen;
omap_dss.c:        return s->dispc.control;
omap_dss.c:        return s->dispc.config;
omap_dss.c:        return s->dispc.capable;
omap_dss.c:        return s->dispc.bg[0];
omap_dss.c:        return s->dispc.bg[1];
omap_dss.c:        return s->dispc.trans[0];
omap_dss.c:        return s->dispc.trans[1];
omap_dss.c:        return s->dispc.line;
omap_dss.c:        return s->dispc.timing[0];
omap_dss.c:        return s->dispc.timing[1];
omap_dss.c:        return s->dispc.timing[2];
omap_dss.c:        return s->dispc.timing[3];
omap_dss.c:        return ((s->dig.ny - 1) << 16) | (s->dig.nx - 1);
omap_dss.c:        return ((s->lcd.ny - 1) << 16) | (s->lcd.nx - 1);
omap_dss.c:        return s->dispc.l[0].addr[0];
omap_dss.c:        return s->dispc.l[0].addr[1];
omap_dss.c:        return (s->dispc.l[0].posy << 16) | s->dispc.l[0].posx;
omap_dss.c:        return ((s->dispc.l[0].ny - 1) << 16) | (s->dispc.l[0].nx - 1);
omap_dss.c:        return s->dispc.l[0].attr;
omap_dss.c:        return s->dispc.l[0].tresh;
omap_dss.c:        return s->dispc.l[0].rowinc;
omap_dss.c:        return s->dispc.l[0].colinc;
omap_dss.c:        return s->dispc.l[0].wininc;
omap_dss.c:        return s->dispc.l[0].addr[2];
omap_dss.c:        s->dispc.idlemode = value & 0x301b;
omap_dss.c:        s->dispc.irqst &= ~value;
omap_dss.c:        s->dispc.irqen = value & 0xffff;
omap_dss.c:        s->dispc.control = value & 0x07ff9fff;
omap_dss.c:        s->dig.enable = (value >> 1) & 1;
omap_dss.c:        s->lcd.enable = (value >> 0) & 1;
omap_dss.c:            if (~((s->dispc.l[1].attr | s->dispc.l[2].attr) & 1))
omap_dss.c:             * s->dispc.config
omap_dss.c:             * s->dispc.capable
omap_dss.c:             * s->dispc.bg[0]
omap_dss.c:             * s->dispc.bg[1]
omap_dss.c:             * s->dispc.trans[0]
omap_dss.c:             * s->dispc.trans[1]
omap_dss.c:             * s->dispc.line
omap_dss.c:             * s->dispc.timing[0]
omap_dss.c:             * s->dispc.timing[1]
omap_dss.c:             * s->dispc.timing[2]
omap_dss.c:             * s->dispc.timing[3]
omap_dss.c:             * s->lcd.nx
omap_dss.c:             * s->lcd.ny
omap_dss.c:             * s->dig.nx
omap_dss.c:             * s->dig.ny
omap_dss.c:             * s->dispc.l[0].addr[0]
omap_dss.c:             * s->dispc.l[0].addr[1]
omap_dss.c:             * s->dispc.l[0].addr[2]
omap_dss.c:             * s->dispc.l[0].posx
omap_dss.c:             * s->dispc.l[0].posy
omap_dss.c:             * s->dispc.l[0].nx
omap_dss.c:             * s->dispc.l[0].ny
omap_dss.c:             * s->dispc.l[0].tresh
omap_dss.c:             * s->dispc.l[0].rowinc
omap_dss.c:             * s->dispc.l[0].colinc
omap_dss.c:             * s->dispc.l[0].wininc
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.config = value & 0x3fff;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.capable = value & 0x3ff;
omap_dss.c:        s->dispc.bg[0] = value & 0xffffff;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.bg[1] = value & 0xffffff;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.trans[0] = value & 0xffffff;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.trans[1] = value & 0xffffff;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.line = value & 0x7ff;
omap_dss.c:        s->dispc.timing[0] = value & 0x0ff0ff3f;
omap_dss.c:        s->dispc.timing[1] = value & 0x0ff0ff3f;
omap_dss.c:        s->dispc.timing[2] = value & 0x0003ffff;
omap_dss.c:        s->dispc.timing[3] = value & 0x00ff00ff;
omap_dss.c:        s->dig.nx = ((value >>  0) & 0x7ff) + 1;		/* PPL */
omap_dss.c:        s->dig.ny = ((value >> 16) & 0x7ff) + 1;		/* LPP */
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->lcd.nx = ((value >>  0) & 0x7ff) + 1;		/* PPL */
omap_dss.c:        s->lcd.ny = ((value >> 16) & 0x7ff) + 1;		/* LPP */
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].addr[0] = (target_phys_addr_t) value;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].addr[1] = (target_phys_addr_t) value;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].posx = ((value >>  0) & 0x7ff);		/* GFXPOSX */
omap_dss.c:        s->dispc.l[0].posy = ((value >> 16) & 0x7ff);		/* GFXPOSY */
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].nx = ((value >>  0) & 0x7ff) + 1;		/* GFXSIZEX */
omap_dss.c:        s->dispc.l[0].ny = ((value >> 16) & 0x7ff) + 1;		/* GFXSIZEY */
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].attr = value & 0x7ff;
omap_dss.c:            fprintf(stderr, "%s: Big-endian pixel format not supported\n",
omap_dss.c:        s->dispc.l[0].enable = value & 1;
omap_dss.c:        s->dispc.l[0].bpp = (value >> 1) & 0xf;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].tresh = value & 0x01ff01ff;
omap_dss.c:        s->dispc.l[0].rowinc = value;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].colinc = value;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:        s->dispc.l[0].wininc = value;
omap_dss.c:        s->dispc.l[0].addr[2] = (target_phys_addr_t) value;
omap_dss.c:        s->dispc.invalidate = 1;
omap_dss.c:    if (!s->rfbi.busy)
omap_dss.c:    /* TODO: in non-Bypass mode we probably need to just deassert the DRQ.  */
omap_dss.c:    s->rfbi.busy = 0;
omap_dss.c:    if (!s->rfbi.enable || s->rfbi.busy)
omap_dss.c:    if (s->rfbi.control & (1 << 1)) {				/* BYPASS */
omap_dss.c:        /* TODO: in non-Bypass mode we probably need to just assert the
omap_dss.c:    if (!(s->dispc.control & (1 << 11)))			/* RFBIMODE */
omap_dss.c:    s->rfbi.busy = 1;
omap_dss.c:    len = s->rfbi.pixels * 2;
omap_dss.c:    data_addr = s->dispc.l[0].addr[0];
omap_dss.c:    if (data && len != s->rfbi.pixels * 2) {
omap_dss.c:        len = s->rfbi.pixels * 2;
omap_dss.c:    s->rfbi.pixels = 0;
omap_dss.c:    pitch = s->dispc.l[0].nx + (s->dispc.l[0].rowinc - 1) / 2;
omap_dss.c:    if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])
omap_dss.c:        s->rfbi.chip[0]->block(s->rfbi.chip[0]->opaque, 1, data, len, pitch);
omap_dss.c:    if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])
omap_dss.c:        s->rfbi.chip[1]->block(s->rfbi.chip[1]->opaque, 1, data, len, pitch);
omap_dss.c:    s->dispc.irqst |= 1;					/* FRAMEDONE */
omap_dss.c:        return s->rfbi.idlemode;
omap_dss.c:        return 1 | (s->rfbi.busy << 8);				/* RESETDONE */
omap_dss.c:        return s->rfbi.control;
omap_dss.c:        return s->rfbi.pixels;
omap_dss.c:        return s->rfbi.skiplines;
omap_dss.c:        return s->rfbi.rxbuf;
omap_dss.c:        return s->rfbi.config[0];
omap_dss.c:        return s->rfbi.time[0];
omap_dss.c:        return s->rfbi.time[1];
omap_dss.c:        return s->rfbi.data[0];
omap_dss.c:        return s->rfbi.data[1];
omap_dss.c:        return s->rfbi.data[2];
omap_dss.c:        return s->rfbi.config[1];
omap_dss.c:        return s->rfbi.time[2];
omap_dss.c:        return s->rfbi.time[3];
omap_dss.c:        return s->rfbi.data[3];
omap_dss.c:        return s->rfbi.data[4];
omap_dss.c:        return s->rfbi.data[5];
omap_dss.c:        return s->rfbi.vsync;
omap_dss.c:        return s->rfbi.hsync;
omap_dss.c:        s->rfbi.idlemode = value & 0x19;
omap_dss.c:        s->rfbi.control = value & 0xf;
omap_dss.c:        s->rfbi.enable = value & 1;
omap_dss.c:                        !(s->rfbi.config[0] & s->rfbi.config[1] & 0xc))
omap_dss.c:        s->rfbi.pixels = value;
omap_dss.c:        s->rfbi.skiplines = value & 0x7ff;
omap_dss.c:        if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])
omap_dss.c:            s->rfbi.chip[0]->write(s->rfbi.chip[0]->opaque, 0, value & 0xffff);
omap_dss.c:        if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])
omap_dss.c:            s->rfbi.chip[1]->write(s->rfbi.chip[1]->opaque, 0, value & 0xffff);
omap_dss.c:        if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])
omap_dss.c:            s->rfbi.chip[0]->write(s->rfbi.chip[0]->opaque, 1, value & 0xffff);
omap_dss.c:        if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])
omap_dss.c:            s->rfbi.chip[1]->write(s->rfbi.chip[1]->opaque, 1, value & 0xffff);
omap_dss.c:        /* TODO: take into account the format set up in s->rfbi.config[?] and
omap_dss.c:         * s->rfbi.data[?], but special-case the most usual scenario so that
omap_dss.c:        if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0]) {
omap_dss.c:            s->rfbi.chip[0]->write(s->rfbi.chip[0]->opaque, 1, value & 0xffff);
omap_dss.c:            s->rfbi.chip[0]->write(s->rfbi.chip[0]->opaque, 1, value >> 16);
omap_dss.c:        if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1]) {
omap_dss.c:            s->rfbi.chip[1]->write(s->rfbi.chip[1]->opaque, 1, value & 0xffff);
omap_dss.c:            s->rfbi.chip[1]->write(s->rfbi.chip[1]->opaque, 1, value >> 16);
omap_dss.c:        if (!-- s->rfbi.pixels)
omap_dss.c:        if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])
omap_dss.c:            s->rfbi.rxbuf = s->rfbi.chip[0]->read(s->rfbi.chip[0]->opaque, 1);
omap_dss.c:        else if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])
omap_dss.c:            s->rfbi.rxbuf = s->rfbi.chip[0]->read(s->rfbi.chip[0]->opaque, 1);
omap_dss.c:        if (!-- s->rfbi.pixels)
omap_dss.c:        if ((s->rfbi.control & (1 << 2)) && s->rfbi.chip[0])
omap_dss.c:            s->rfbi.rxbuf = s->rfbi.chip[0]->read(s->rfbi.chip[0]->opaque, 0);
omap_dss.c:        else if ((s->rfbi.control & (1 << 3)) && s->rfbi.chip[1])
omap_dss.c:            s->rfbi.rxbuf = s->rfbi.chip[0]->read(s->rfbi.chip[0]->opaque, 0);
omap_dss.c:        if (!-- s->rfbi.pixels)
omap_dss.c:        s->rfbi.config[0] = value & 0x003f1fff;
omap_dss.c:        s->rfbi.time[0] = value & 0x3fffffff;
omap_dss.c:        s->rfbi.time[1] = value & 0x0fffffff;
omap_dss.c:        s->rfbi.data[0] = value & 0x0f1f0f1f;
omap_dss.c:        s->rfbi.data[1] = value & 0x0f1f0f1f;
omap_dss.c:        s->rfbi.data[2] = value & 0x0f1f0f1f;
omap_dss.c:        s->rfbi.config[1] = value & 0x003f1fff;
omap_dss.c:        s->rfbi.time[2] = value & 0x3fffffff;
omap_dss.c:        s->rfbi.time[3] = value & 0x0fffffff;
omap_dss.c:        s->rfbi.data[3] = value & 0x0f1f0f1f;
omap_dss.c:        s->rfbi.data[4] = value & 0x0f1f0f1f;
omap_dss.c:        s->rfbi.data[5] = value & 0x0f1f0f1f;
omap_dss.c:        s->rfbi.vsync = value & 0xffff;
omap_dss.c:        s->rfbi.hsync = value & 0xffff;
omap_dss.c:    s->irq = irq;
omap_dss.c:    s->drq = drq;
omap_dss.c:    s->state = graphic_console_init(omap_update_display,
omap_dss.c:    s->rfbi.chip[cs] = chip;
omap.h: * Copyright (C) 2006-2008 Andrzej Zaborowski  <balrog@zabor.org>
omap.h: * See /usr/include/asm-arm/arch-omap/irqs.h in Linux.
omap.h: * Common OMAP-15xx IRQ numbers for level 1 interrupt handler
omap.h: * OMAP-1510 specific IRQ numbers for level 1 interrupt handler
omap.h: * OMAP-310 specific IRQ numbers for level 1 interrupt handler
omap.h: * OMAP-1610 specific IRQ numbers for level 1 interrupt handler
omap.h: * OMAP-730 specific IRQ numbers for level 1 interrupt handler
omap.h: * OMAP-1510 specific IRQ numbers for level 2 interrupt handler
omap.h: * OMAP-310 specific IRQ numbers for level 2 interrupt handler
omap.h: * OMAP-1610 specific IRQ numbers for level 2 interrupt handler
omap.h: * OMAP-730 specific IRQ numbers for level 2 interrupt handler
omap.h: * OMAP-24xx common IRQ numbers
omap.h: * See /usr/include/asm-arm/arch-omap/dma.h in Linux.
omap.h:# define cpu_is_omap310(cpu)		(cpu->mpu_model == omap310)
omap.h:# define cpu_is_omap1510(cpu)		(cpu->mpu_model == omap1510)
omap.h:# define cpu_is_omap1610(cpu)		(cpu->mpu_model == omap1610)
omap.h:# define cpu_is_omap1710(cpu)		(cpu->mpu_model == omap1710)
omap.h:# define cpu_is_omap2410(cpu)		(cpu->mpu_model == omap2410)
omap.h:# define cpu_is_omap2420(cpu)		(cpu->mpu_model == omap2420)
omap.h:# define cpu_is_omap2430(cpu)		(cpu->mpu_model == omap2430)
omap.h:# define cpu_is_omap3430(cpu)		(cpu->mpu_model == omap3430)
omap.h:    /* MPUI-TIPB peripherals */
omap.h:    /* OMAP2-only peripherals */
omap.h:        fprintf(stderr, "%s: Read-only register " OMAP_FMT_plx "\n",	\
omap.h:/* OMAP-specific Linux bootloader tags for the ATAG_BOARD area
omap.h:   (Board-specifc tags are not here)  */
omap.h:        fprintf(stderr, "%s: 8-bit register " OMAP_FMT_plx "\n",	\
omap.h:        fprintf(stderr, "%s: 16-bit register " OMAP_FMT_plx "\n",	\
omap.h:        fprintf(stderr, "%s: 32-bit register " OMAP_FMT_plx "\n",	\
omap.h:    s->in ++;
omap.h:    ret = s->mem_read[0](s->opaque, addr);
omap.h:    s->in --;
omap.h:    if (!s->in)
omap.h:        fprintf(stderr, "%08x ---> %02x\n", (uint32_t) addr, ret);
omap.h:    s->in ++;
omap.h:    ret = s->mem_read[1](s->opaque, addr);
omap.h:    s->in --;
omap.h:    if (!s->in)
omap.h:        fprintf(stderr, "%08x ---> %04x\n", (uint32_t) addr, ret);
omap.h:    s->in ++;
omap.h:    ret = s->mem_read[2](s->opaque, addr);
omap.h:    s->in --;
omap.h:    if (!s->in)
omap.h:        fprintf(stderr, "%08x ---> %08x\n", (uint32_t) addr, ret);
omap.h:    if (!s->in)
omap.h:        fprintf(stderr, "%08x <--- %02x\n", (uint32_t) addr, value);
omap.h:    s->in ++;
omap.h:    s->mem_write[0](s->opaque, addr, value);
omap.h:    s->in --;
omap.h:    if (!s->in)
omap.h:        fprintf(stderr, "%08x <--- %04x\n", (uint32_t) addr, value);
omap.h:    s->in ++;
omap.h:    s->mem_write[1](s->opaque, addr, value);
omap.h:    s->in --;
omap.h:    if (!s->in)
omap.h:        fprintf(stderr, "%08x <--- %08x\n", (uint32_t) addr, value);
omap.h:    s->in ++;
omap.h:    s->mem_write[2](s->opaque, addr, value);
omap.h:    s->in --;
omap.h:    s->mem_read = mem_read;
omap.h:    s->mem_write = mem_write;
omap.h:    s->opaque = opaque;
omap.h:    s->in = 0;
omap_i2c.c: * TI OMAP on-chip I2C controller.  Only "new I2C" mode supported.
omap_i2c.c:    qemu_set_irq(s->irq, s->stat & s->mask);
omap_i2c.c:    if ((s->dma >> 15) & 1)					/* RDMA_EN */
omap_i2c.c:        qemu_set_irq(s->drq[0], (s->stat >> 3) & 1);		/* RRDY */
omap_i2c.c:    if ((s->dma >> 7) & 1)					/* XDMA_EN */
omap_i2c.c:        qemu_set_irq(s->drq[1], (s->stat >> 4) & 1);		/* XRDY */
omap_i2c.c:    if (!i2c_bus_busy(s->bus))
omap_i2c.c:    if ((s->control >> 2) & 1) {				/* RM */
omap_i2c.c:        if ((s->control >> 1) & 1) {				/* STP */
omap_i2c.c:            i2c_end_transfer(s->bus);
omap_i2c.c:            s->control &= ~(1 << 1);				/* STP */
omap_i2c.c:            s->count_cur = s->count;
omap_i2c.c:            s->txlen = 0;
omap_i2c.c:        } else if ((s->control >> 9) & 1) {			/* TRX */
omap_i2c.c:            while (ack && s->txlen)
omap_i2c.c:                ack = (i2c_send(s->bus,
omap_i2c.c:                                        (s->fifo >> ((-- s->txlen) << 3)) &
omap_i2c.c:            s->stat |= 1 << 4;					/* XRDY */
omap_i2c.c:            while (s->rxlen < 4)
omap_i2c.c:                s->fifo |= i2c_recv(s->bus) << ((s->rxlen ++) << 3);
omap_i2c.c:            s->stat |= 1 << 3;					/* RRDY */
omap_i2c.c:        if ((s->control >> 9) & 1) {				/* TRX */
omap_i2c.c:            while (ack && s->count_cur && s->txlen) {
omap_i2c.c:                ack = (i2c_send(s->bus,
omap_i2c.c:                                        (s->fifo >> ((-- s->txlen) << 3)) &
omap_i2c.c:                s->count_cur --;
omap_i2c.c:            if (ack && s->count_cur)
omap_i2c.c:                s->stat |= 1 << 4;				/* XRDY */
omap_i2c.c:                s->stat &= ~(1 << 4);				/* XRDY */
omap_i2c.c:            if (!s->count_cur) {
omap_i2c.c:                s->stat |= 1 << 2;				/* ARDY */
omap_i2c.c:                s->control &= ~(1 << 10);			/* MST */
omap_i2c.c:            while (s->count_cur && s->rxlen < 4) {
omap_i2c.c:                s->fifo |= i2c_recv(s->bus) << ((s->rxlen ++) << 3);
omap_i2c.c:                s->count_cur --;
omap_i2c.c:            if (s->rxlen)
omap_i2c.c:                s->stat |= 1 << 3;				/* RRDY */
omap_i2c.c:                s->stat &= ~(1 << 3);				/* RRDY */
omap_i2c.c:        if (!s->count_cur) {
omap_i2c.c:            if ((s->control >> 1) & 1) {			/* STP */
omap_i2c.c:                i2c_end_transfer(s->bus);
omap_i2c.c:                s->control &= ~(1 << 1);			/* STP */
omap_i2c.c:                s->count_cur = s->count;
omap_i2c.c:                s->txlen = 0;
omap_i2c.c:                s->stat |= 1 << 2;				/* ARDY */
omap_i2c.c:                s->control &= ~(1 << 10);			/* MST */
omap_i2c.c:    s->stat |= (!ack) << 1;					/* NACK */
omap_i2c.c:        s->control &= ~(1 << 1);				/* STP */
omap_i2c.c:    s->mask = 0;
omap_i2c.c:    s->stat = 0;
omap_i2c.c:    s->dma = 0;
omap_i2c.c:    s->count = 0;
omap_i2c.c:    s->count_cur = 0;
omap_i2c.c:    s->fifo = 0;
omap_i2c.c:    s->rxlen = 0;
omap_i2c.c:    s->txlen = 0;
omap_i2c.c:    s->control = 0;
omap_i2c.c:    s->addr[0] = 0;
omap_i2c.c:    s->addr[1] = 0;
omap_i2c.c:    s->divider = 0;
omap_i2c.c:    s->times[0] = 0;
omap_i2c.c:    s->times[1] = 0;
omap_i2c.c:    s->test = 0;
omap_i2c.c:        return s->revision;					/* REV */
omap_i2c.c:        return s->mask;
omap_i2c.c:        return s->stat | (i2c_bus_busy(s->bus) << 12);
omap_i2c.c:        if (s->revision >= OMAP2_INTR_REV)
omap_i2c.c:        ret = ffs(s->stat & s->mask);
omap_i2c.c:            s->stat ^= 1 << (ret - 1);
omap_i2c.c:        return (s->control >> 15) & 1;				/* I2C_EN */
omap_i2c.c:        return s->dma;
omap_i2c.c:        return s->count_cur;					/* DCOUNT */
omap_i2c.c:        if (s->control & (1 << 14)) {				/* BE */
omap_i2c.c:            ret |= ((s->fifo >> 0) & 0xff) << 8;
omap_i2c.c:            ret |= ((s->fifo >> 8) & 0xff) << 0;
omap_i2c.c:            ret |= ((s->fifo >> 8) & 0xff) << 8;
omap_i2c.c:            ret |= ((s->fifo >> 0) & 0xff) << 0;
omap_i2c.c:        if (s->rxlen == 1) {
omap_i2c.c:            s->stat |= 1 << 15;					/* SBD */
omap_i2c.c:            s->rxlen = 0;
omap_i2c.c:        } else if (s->rxlen > 1) {
omap_i2c.c:            if (s->rxlen > 2)
omap_i2c.c:                s->fifo >>= 16;
omap_i2c.c:            s->rxlen -= 2;
omap_i2c.c:            /* XXX: remote access (qualifier) error - what's that?  */;
omap_i2c.c:        if (!s->rxlen) {
omap_i2c.c:            s->stat &= ~(1 << 3);				/* RRDY */
omap_i2c.c:            if (((s->control >> 10) & 1) &&			/* MST */
omap_i2c.c:                            ((~s->control >> 9) & 1)) {		/* TRX */
omap_i2c.c:                s->stat |= 1 << 2;				/* ARDY */
omap_i2c.c:                s->control &= ~(1 << 10);			/* MST */
omap_i2c.c:        s->stat &= ~(1 << 11);					/* ROVR */
omap_i2c.c:        return s->control;
omap_i2c.c:        return s->addr[0];
omap_i2c.c:        return s->addr[1];
omap_i2c.c:        return s->divider;
omap_i2c.c:        return s->times[0];
omap_i2c.c:        return s->times[1];
omap_i2c.c:        if (s->test & (1 << 15)) {				/* ST_EN */
omap_i2c.c:            s->test ^= 0xa;
omap_i2c.c:            return s->test;
omap_i2c.c:            return s->test & ~0x300f;
omap_i2c.c:        s->mask = value & (s->revision < OMAP2_GC_REV ? 0x1f : 0x3f);
omap_i2c.c:        if (s->revision < OMAP2_INTR_REV) {
omap_i2c.c:        s->stat &= ~(value & 0x27);
omap_i2c.c:        s->dma = value & 0x8080;
omap_i2c.c:            s->mask &= ~(1 << 3);				/* RRDY_IE */
omap_i2c.c:            s->mask &= ~(1 << 4);				/* XRDY_IE */
omap_i2c.c:        s->count = value;					/* DCOUNT */
omap_i2c.c:        if (s->txlen > 2) {
omap_i2c.c:            /* XXX: remote access (qualifier) error - what's that?  */
omap_i2c.c:        s->fifo <<= 16;
omap_i2c.c:        s->txlen += 2;
omap_i2c.c:        if (s->control & (1 << 14)) {				/* BE */
omap_i2c.c:            s->fifo |= ((value >> 8) & 0xff) << 8;
omap_i2c.c:            s->fifo |= ((value >> 0) & 0xff) << 0;
omap_i2c.c:            s->fifo |= ((value >> 0) & 0xff) << 8;
omap_i2c.c:            s->fifo |= ((value >> 8) & 0xff) << 0;
omap_i2c.c:        s->stat &= ~(1 << 10);					/* XUDF */
omap_i2c.c:        if (s->txlen > 2)
omap_i2c.c:            s->stat &= ~(1 << 4);				/* XRDY */
omap_i2c.c:        if (s->revision < OMAP2_INTR_REV) {
omap_i2c.c:        s->control = value & 0xcf87;
omap_i2c.c:            if (s->revision < OMAP2_INTR_REV)
omap_i2c.c:            fprintf(stderr, "%s: 10-bit addressing mode not supported\n",
omap_i2c.c:            nack = !!i2c_start_transfer(s->bus, s->addr[1],	/* SA */
omap_i2c.c:            s->stat |= nack << 1;				/* NACK */
omap_i2c.c:            s->control &= ~(1 << 0);				/* STT */
omap_i2c.c:            s->fifo = 0;
omap_i2c.c:                s->control &= ~(1 << 1);			/* STP */
omap_i2c.c:                s->count_cur = s->count;
omap_i2c.c:        s->addr[0] = value & 0x3ff;
omap_i2c.c:        s->addr[1] = value & 0x3ff;
omap_i2c.c:        s->divider = value;
omap_i2c.c:        s->times[0] = value;
omap_i2c.c:        s->times[1] = value;
omap_i2c.c:        s->test = value & 0xf80f;
omap_i2c.c:            if (s->revision >= OMAP2_INTR_REV) {
omap_i2c.c:                s->stat |= 0x3f;
omap_i2c.c:        if (s->txlen > 2) {
omap_i2c.c:            /* XXX: remote access (qualifier) error - what's that?  */
omap_i2c.c:        s->fifo <<= 8;
omap_i2c.c:        s->txlen += 1;
omap_i2c.c:        s->fifo |= value & 0xff;
omap_i2c.c:        s->stat &= ~(1 << 10);					/* XUDF */
omap_i2c.c:        if (s->txlen > 2)
omap_i2c.c:            s->stat &= ~(1 << 4);				/* XRDY */
omap_i2c.c:    s->revision = 0x11;
omap_i2c.c:    s->irq = irq;
omap_i2c.c:    s->drq[0] = dma[0];
omap_i2c.c:    s->drq[1] = dma[1];
omap_i2c.c:    s->bus = i2c_init_bus(NULL, "i2c");
omap_i2c.c:    s->revision = 0x34;
omap_i2c.c:    s->irq = irq;
omap_i2c.c:    s->drq[0] = dma[0];
omap_i2c.c:    s->drq[1] = dma[1];
omap_i2c.c:    s->bus = i2c_init_bus(NULL, "i2c");
omap_i2c.c:    return s->bus;
omap_lcdc.c: * Copyright (C) 2006-2007 Andrzej Zaborowski  <balrog@zabor.org>
omap_lcdc.c:    if (s->frame_done && (s->interrupts & 1)) {
omap_lcdc.c:        qemu_irq_raise(s->irq);
omap_lcdc.c:    if (s->palette_done && (s->interrupts & 2)) {
omap_lcdc.c:        qemu_irq_raise(s->irq);
omap_lcdc.c:    if (s->sync_error) {
omap_lcdc.c:        qemu_irq_raise(s->irq);
omap_lcdc.c:    qemu_irq_lower(s->irq);
omap_lcdc.c:    if (!omap_lcd || omap_lcd->plm == 1 ||
omap_lcdc.c:                    !omap_lcd->enable || !ds_get_bits_per_pixel(omap_lcd->state))
omap_lcdc.c:    if (omap_lcd->plm != 2) {
omap_lcdc.c:        cpu_physical_memory_read(omap_lcd->dma->phys_framebuffer[
omap_lcdc.c:                                  omap_lcd->dma->current_frame],
omap_lcdc.c:                                 (void *)omap_lcd->palette, 0x200);
omap_lcdc.c:        switch (omap_lcd->palette[0] >> 12 & 7) {
omap_lcdc.c:    switch ((omap_lcd->palette[0] >> 12) & 7) {
omap_lcdc.c:        draw_line = draw_line_table2[ds_get_bits_per_pixel(omap_lcd->state)];
omap_lcdc.c:        draw_line = draw_line_table4[ds_get_bits_per_pixel(omap_lcd->state)];
omap_lcdc.c:        draw_line = draw_line_table8[ds_get_bits_per_pixel(omap_lcd->state)];
omap_lcdc.c:        if (!omap_lcd->tft)
omap_lcdc.c:            draw_line = draw_line_table12[ds_get_bits_per_pixel(omap_lcd->state)];
omap_lcdc.c:            draw_line = draw_line_table16[ds_get_bits_per_pixel(omap_lcd->state)];
omap_lcdc.c:    width = omap_lcd->width;
omap_lcdc.c:    if (width != ds_get_width(omap_lcd->state) ||
omap_lcdc.c:            omap_lcd->height != ds_get_height(omap_lcd->state)) {
omap_lcdc.c:        qemu_console_resize(omap_lcd->state,
omap_lcdc.c:                            omap_lcd->width, omap_lcd->height);
omap_lcdc.c:        omap_lcd->invalidate = 1;
omap_lcdc.c:    if (omap_lcd->dma->current_frame == 0)
omap_lcdc.c:        size = omap_lcd->dma->src_f1_bottom - omap_lcd->dma->src_f1_top;
omap_lcdc.c:        size = omap_lcd->dma->src_f2_bottom - omap_lcd->dma->src_f2_top;
omap_lcdc.c:    if (frame_offset + ((width * omap_lcd->height * bpp) >> 3) > size + 2) {
omap_lcdc.c:        omap_lcd->sync_error = 1;
omap_lcdc.c:        omap_lcd->enable = 0;
omap_lcdc.c:    frame_base = omap_lcd->dma->phys_framebuffer[
omap_lcdc.c:            omap_lcd->dma->current_frame] + frame_offset;
omap_lcdc.c:    omap_lcd->dma->condition |= 1 << omap_lcd->dma->current_frame;
omap_lcdc.c:    if (omap_lcd->dma->interrupts & 1)
omap_lcdc.c:        qemu_irq_raise(omap_lcd->dma->irq);
omap_lcdc.c:    if (omap_lcd->dma->dual)
omap_lcdc.c:        omap_lcd->dma->current_frame ^= 1;
omap_lcdc.c:    if (!ds_get_bits_per_pixel(omap_lcd->state))
omap_lcdc.c:    height = omap_lcd->height;
omap_lcdc.c:    if (omap_lcd->subpanel & (1 << 31)) {
omap_lcdc.c:        if (omap_lcd->subpanel & (1 << 29))
omap_lcdc.c:            first = (omap_lcd->subpanel >> 16) & 0x3ff;
omap_lcdc.c:            height = (omap_lcd->subpanel >> 16) & 0x3ff;
omap_lcdc.c:    linesize = ds_get_linesize(omap_lcd->state);
omap_lcdc.c:    framebuffer_update_display(omap_lcd->state,
omap_lcdc.c:                               omap_lcd->invalidate,
omap_lcdc.c:                               draw_line, omap_lcd->palette,
omap_lcdc.c:        dpy_update(omap_lcd->state, 0, first, width, last - first + 1);
omap_lcdc.c:    omap_lcd->invalidate = 0;
omap_lcdc.c:        return -1;
omap_lcdc.c:    if (omap_lcd && ds_get_data(omap_lcd->state))
omap_lcdc.c:        ppm_save(filename, ds_get_data(omap_lcd->state),
omap_lcdc.c:                omap_lcd->width, omap_lcd->height,
omap_lcdc.c:                ds_get_linesize(omap_lcd->state));
omap_lcdc.c:    omap_lcd->invalidate = 1;
omap_lcdc.c:    if (!s->enable) {
omap_lcdc.c:        s->dma->current_frame = -1;
omap_lcdc.c:        s->sync_error = 0;
omap_lcdc.c:        if (s->plm != 1)
omap_lcdc.c:            s->frame_done = 1;
omap_lcdc.c:    if (s->dma->current_frame == -1) {
omap_lcdc.c:        s->frame_done = 0;
omap_lcdc.c:        s->palette_done = 0;
omap_lcdc.c:        s->dma->current_frame = 0;
omap_lcdc.c:    if (!s->dma->mpu->port[s->dma->src].addr_valid(s->dma->mpu,
omap_lcdc.c:                            s->dma->src_f1_top) ||
omap_lcdc.c:                    !s->dma->mpu->port[
omap_lcdc.c:                    s->dma->src].addr_valid(s->dma->mpu,
omap_lcdc.c:                            s->dma->src_f1_bottom) ||
omap_lcdc.c:                    (s->dma->dual &&
omap_lcdc.c:                     (!s->dma->mpu->port[
omap_lcdc.c:                      s->dma->src].addr_valid(s->dma->mpu,
omap_lcdc.c:                              s->dma->src_f2_top) ||
omap_lcdc.c:                      !s->dma->mpu->port[
omap_lcdc.c:                      s->dma->src].addr_valid(s->dma->mpu,
omap_lcdc.c:                              s->dma->src_f2_bottom)))) {
omap_lcdc.c:        s->dma->condition |= 1 << 2;
omap_lcdc.c:        if (s->dma->interrupts & (1 << 1))
omap_lcdc.c:            qemu_irq_raise(s->dma->irq);
omap_lcdc.c:        s->enable = 0;
omap_lcdc.c:    s->dma->phys_framebuffer[0] = s->dma->src_f1_top;
omap_lcdc.c:    s->dma->phys_framebuffer[1] = s->dma->src_f2_top;
omap_lcdc.c:    if (s->plm != 2 && !s->palette_done) {
omap_lcdc.c:            s->dma->phys_framebuffer[s->dma->current_frame],
omap_lcdc.c:            (void *)s->palette, 0x200);
omap_lcdc.c:        s->palette_done = 1;
omap_lcdc.c:        return (s->tft << 23) | (s->plm << 20) |
omap_lcdc.c:                (s->tft << 7) | (s->interrupts << 3) |
omap_lcdc.c:                (s->mono << 1) | s->enable | s->ctrl | 0xfe000c34;
omap_lcdc.c:        return (s->timing[0] << 10) | (s->width - 1) | 0x0000000f;
omap_lcdc.c:        return (s->timing[1] << 10) | (s->height - 1);
omap_lcdc.c:        return s->timing[2] | 0xfc000000;
omap_lcdc.c:        return (s->palette_done << 6) | (s->sync_error << 2) | s->frame_done;
omap_lcdc.c:        return s->subpanel;
omap_lcdc.c:        s->plm = (value >> 20) & 3;
omap_lcdc.c:        s->tft = (value >> 7) & 1;
omap_lcdc.c:        s->interrupts = (value >> 3) & 3;
omap_lcdc.c:        s->mono = (value >> 1) & 1;
omap_lcdc.c:        s->ctrl = value & 0x01cff300;
omap_lcdc.c:        if (s->enable != (value & 1)) {
omap_lcdc.c:            s->enable = value & 1;
omap_lcdc.c:        s->timing[0] = value >> 10;
omap_lcdc.c:        s->width = (value & 0x3ff) + 1;
omap_lcdc.c:        s->timing[1] = value >> 10;
omap_lcdc.c:        s->height = (value & 0x3ff) + 1;
omap_lcdc.c:        s->timing[2] = value;
omap_lcdc.c:        s->subpanel = value & 0xa1ffffff;
omap_lcdc.c:    s->dma->current_frame = -1;
omap_lcdc.c:    s->plm = 0;
omap_lcdc.c:    s->tft = 0;
omap_lcdc.c:    s->mono = 0;
omap_lcdc.c:    s->enable = 0;
omap_lcdc.c:    s->width = 0;
omap_lcdc.c:    s->height = 0;
omap_lcdc.c:    s->interrupts = 0;
omap_lcdc.c:    s->timing[0] = 0;
omap_lcdc.c:    s->timing[1] = 0;
omap_lcdc.c:    s->timing[2] = 0;
omap_lcdc.c:    s->subpanel = 0;
omap_lcdc.c:    s->palette_done = 0;
omap_lcdc.c:    s->frame_done = 0;
omap_lcdc.c:    s->sync_error = 0;
omap_lcdc.c:    s->invalidate = 1;
omap_lcdc.c:    s->subpanel = 0;
omap_lcdc.c:    s->ctrl = 0;
omap_lcdc.c:    s->irq = irq;
omap_lcdc.c:    s->dma = dma;
omap_lcdc.c:    s->imif_base = imif_base;
omap_lcdc.c:    s->emiff_base = emiff_base;
omap_lcdc.c:    s->state = graphic_console_init(omap_update_display,
omap_lcd_template.h: * 2-bit colour
omap_lcd_template.h:        width -= 4;
omap_lcd_template.h: * 4-bit colour
omap_lcd_template.h:        width -= 2;
omap_lcd_template.h: * 8-bit colour
omap_lcd_template.h:    } while (-- width != 0);
omap_lcd_template.h: * 12-bit colour
omap_lcd_template.h:    } while (-- width != 0);
omap_lcd_template.h: * 16-bit colour
omap_lcd_template.h:    } while (-- width != 0);
omap_mmc.c: * OMAP on-chip MMC/SD host emulation.
omap_mmc.c: * Copyright (C) 2006-2007 Andrzej Zaborowski  <balrog@zabor.org>
omap_mmc.c:    qemu_set_irq(s->irq, !!(s->status & s->mask));
omap_mmc.c:    if (!host->transfer && !host->fifo_len) {
omap_mmc.c:        host->status &= 0xf3ff;
omap_mmc.c:    if (host->fifo_len > host->af_level && host->ddir) {
omap_mmc.c:        if (host->rx_dma) {
omap_mmc.c:            host->status &= 0xfbff;
omap_mmc.c:            qemu_irq_raise(host->dma[1]);
omap_mmc.c:            host->status |= 0x0400;
omap_mmc.c:        host->status &= 0xfbff;
omap_mmc.c:        qemu_irq_lower(host->dma[1]);
omap_mmc.c:    if (host->fifo_len < host->ae_level && !host->ddir) {
omap_mmc.c:        if (host->tx_dma) {
omap_mmc.c:            host->status &= 0xf7ff;
omap_mmc.c:            qemu_irq_raise(host->dma[0]);
omap_mmc.c:            host->status |= 0x0800;
omap_mmc.c:        qemu_irq_lower(host->dma[0]);
omap_mmc.c:        host->status &= 0xf7ff;
omap_mmc.c:    sd_r1b = -1,
omap_mmc.c:        host->status |= 0x0001;
omap_mmc.c:        host->fifo_start = 0;
omap_mmc.c:        host->fifo_len = 0;
omap_mmc.c:        host->transfer = 1;
omap_mmc.c:        host->ddir = dir;
omap_mmc.c:        host->transfer = 0;
omap_mmc.c:    request.arg = host->arg;
omap_mmc.c:    rsplen = sd_do_command(host->card, &request, response);
omap_mmc.c:        if (host->sdio & (1 << 13))
omap_mmc.c:            host->status &= 0xe000;
omap_mmc.c:            host->status |= 0x1000;
omap_mmc.c:        host->status |= 0x4000;
omap_mmc.c:        host->status &= 0xb000;
omap_mmc.c:            host->rsp[~rsplen & 7] = response[(rsplen << 1) | 1] |
omap_mmc.c:        host->status |= 0x0080;
omap_mmc.c:        host->status |= 0x0005;	/* Makes it more real */
omap_mmc.c:        host->status |= 0x0001;
omap_mmc.c:    if (!host->transfer)
omap_mmc.c:        if (host->ddir) {
omap_mmc.c:            if (host->fifo_len > host->af_level)
omap_mmc.c:            value = sd_read_data(host->card);
omap_mmc.c:            host->fifo[(host->fifo_start + host->fifo_len) & 31] = value;
omap_mmc.c:            if (-- host->blen_counter) {
omap_mmc.c:                value = sd_read_data(host->card);
omap_mmc.c:                host->fifo[(host->fifo_start + host->fifo_len) & 31] |=
omap_mmc.c:                host->blen_counter --;
omap_mmc.c:            host->fifo_len ++;
omap_mmc.c:            if (!host->fifo_len)
omap_mmc.c:            value = host->fifo[host->fifo_start] & 0xff;
omap_mmc.c:            sd_write_data(host->card, value);
omap_mmc.c:            if (-- host->blen_counter) {
omap_mmc.c:                value = host->fifo[host->fifo_start] >> 8;
omap_mmc.c:                sd_write_data(host->card, value);
omap_mmc.c:                host->blen_counter --;
omap_mmc.c:            host->fifo_start ++;
omap_mmc.c:            host->fifo_len --;
omap_mmc.c:            host->fifo_start &= 31;
omap_mmc.c:        if (host->blen_counter == 0) {
omap_mmc.c:            host->nblk_counter --;
omap_mmc.c:            host->blen_counter = host->blen;
omap_mmc.c:            if (host->nblk_counter == 0) {
omap_mmc.c:                host->nblk_counter = host->nblk;
omap_mmc.c:                host->transfer = 0;
omap_mmc.c:                host->status |= 0x0008;
omap_mmc.c:    host->last_cmd = 0;
omap_mmc.c:    memset(host->rsp, 0, sizeof(host->rsp));
omap_mmc.c:    host->arg = 0;
omap_mmc.c:    host->dw = 0;
omap_mmc.c:    host->mode = 0;
omap_mmc.c:    host->enable = 0;
omap_mmc.c:    host->status = 0;
omap_mmc.c:    host->mask = 0;
omap_mmc.c:    host->cto = 0;
omap_mmc.c:    host->dto = 0;
omap_mmc.c:    host->fifo_len = 0;
omap_mmc.c:    host->blen = 0;
omap_mmc.c:    host->blen_counter = 0;
omap_mmc.c:    host->nblk = 0;
omap_mmc.c:    host->nblk_counter = 0;
omap_mmc.c:    host->tx_dma = 0;
omap_mmc.c:    host->rx_dma = 0;
omap_mmc.c:    host->ae_level = 0x00;
omap_mmc.c:    host->af_level = 0x1f;
omap_mmc.c:    host->transfer = 0;
omap_mmc.c:    host->cdet_wakeup = 0;
omap_mmc.c:    host->cdet_enable = 0;
omap_mmc.c:    qemu_set_irq(host->coverswitch, host->cdet_state);
omap_mmc.c:    host->clkdiv = 0;
omap_mmc.c:        return s->last_cmd;
omap_mmc.c:        return s->arg & 0x0000ffff;
omap_mmc.c:        return s->arg >> 16;
omap_mmc.c:        return (s->dw << 15) | (s->mode << 12) | (s->enable << 11) | 
omap_mmc.c:                (s->be << 10) | s->clkdiv;
omap_mmc.c:        return s->status;
omap_mmc.c:        return s->mask;
omap_mmc.c:        return s->cto;
omap_mmc.c:        return s->dto;
omap_mmc.c:        /* TODO: support 8-bit access */
omap_mmc.c:        i = s->fifo[s->fifo_start];
omap_mmc.c:        if (s->fifo_len == 0) {
omap_mmc.c:        s->fifo_start ++;
omap_mmc.c:        s->fifo_len --;
omap_mmc.c:        s->fifo_start &= 31;
omap_mmc.c:        return s->blen_counter;
omap_mmc.c:        return s->nblk_counter;
omap_mmc.c:        return (s->rx_dma << 15) | (s->af_level << 8) |
omap_mmc.c:            (s->tx_dma << 7) | s->ae_level;
omap_mmc.c:        return (s->cdet_wakeup << 2) | (s->cdet_enable) | s->sdio;
omap_mmc.c:        return s->rev;
omap_mmc.c:        return s->rsp[(offset - 0x40) >> 2];
omap_mmc.c:    /* OMAP2-specific */
omap_mmc.c:        if (!s->enable)
omap_mmc.c:        s->last_cmd = value;
omap_mmc.c:            s->rsp[i] = 0x0000;
omap_mmc.c:        s->arg &= 0xffff0000;
omap_mmc.c:        s->arg |= 0x0000ffff & value;
omap_mmc.c:        s->arg &= 0x0000ffff;
omap_mmc.c:        s->arg |= value << 16;
omap_mmc.c:        s->dw = (value >> 15) & 1;
omap_mmc.c:        s->mode = (value >> 12) & 3;
omap_mmc.c:        s->enable = (value >> 11) & 1;
omap_mmc.c:        s->be = (value >> 10) & 1;
omap_mmc.c:        s->clkdiv = (value >> 0) & (s->rev >= 2 ? 0x3ff : 0xff);
omap_mmc.c:        if (s->mode != 0)
omap_mmc.c:            printf("SD mode %i unimplemented!\n", s->mode);
omap_mmc.c:        if (s->be != 0)
omap_mmc.c:        if (s->dw != 0 && s->lines < 4)
omap_mmc.c:            printf("4-bit SD bus enabled\n");
omap_mmc.c:        if (!s->enable)
omap_mmc.c:        s->status &= ~value;
omap_mmc.c:        s->mask = value & 0x7fff;
omap_mmc.c:        s->cto = value & 0xff;
omap_mmc.c:        if (s->cto > 0xfd && s->rev <= 1)
omap_mmc.c:        s->dto = value & 0xffff;
omap_mmc.c:        /* TODO: support 8-bit access */
omap_mmc.c:        if (s->fifo_len == 32)
omap_mmc.c:        s->fifo[(s->fifo_start + s->fifo_len) & 31] = value;
omap_mmc.c:        s->fifo_len ++;
omap_mmc.c:        s->blen = (value & 0x07ff) + 1;
omap_mmc.c:        s->blen_counter = s->blen;
omap_mmc.c:        s->nblk = (value & 0x07ff) + 1;
omap_mmc.c:        s->nblk_counter = s->nblk;
omap_mmc.c:        s->blen_counter = s->blen;
omap_mmc.c:        s->rx_dma = (value >> 15) & 1;
omap_mmc.c:        s->af_level = (value >> 8) & 0x1f;
omap_mmc.c:        s->tx_dma = (value >> 7) & 1;
omap_mmc.c:        s->ae_level = value & 0x1f;
omap_mmc.c:        if (s->rx_dma)
omap_mmc.c:            s->status &= 0xfbff;
omap_mmc.c:        if (s->tx_dma)
omap_mmc.c:            s->status &= 0xf7ff;
omap_mmc.c:        s->sdio = value & (s->rev >= 2 ? 0xfbf3 : 0x2020);
omap_mmc.c:        s->cdet_wakeup = (value >> 9) & 1;
omap_mmc.c:        s->cdet_enable = (value >> 2) & 1;
omap_mmc.c:    /* OMAP2-specific */
omap_mmc.c:    if (!host->cdet_state && level) {
omap_mmc.c:        host->status |= 0x0002;
omap_mmc.c:        if (host->cdet_wakeup)
omap_mmc.c:            /* TODO: Assert wake-up */;
omap_mmc.c:    if (host->cdet_state != level) {
omap_mmc.c:        qemu_set_irq(host->coverswitch, level);
omap_mmc.c:        host->cdet_state = level;
omap_mmc.c:    s->irq = irq;
omap_mmc.c:    s->dma = dma;
omap_mmc.c:    s->clk = clk;
omap_mmc.c:    s->lines = 1;	/* TODO: needs to be settable per-board */
omap_mmc.c:    s->rev = 1;
omap_mmc.c:    s->card = sd_init(bd, 0);
omap_mmc.c:    s->irq = irq;
omap_mmc.c:    s->dma = dma;
omap_mmc.c:    s->clk = fclk;
omap_mmc.c:    s->lines = 4;
omap_mmc.c:    s->rev = 2;
omap_mmc.c:    s->card = sd_init(bd, 0);
omap_mmc.c:    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];
omap_mmc.c:    sd_set_cb(s->card, NULL, s->cdet);
omap_mmc.c:    if (s->cdet) {
omap_mmc.c:        sd_set_cb(s->card, ro, s->cdet);
omap_mmc.c:        s->coverswitch = cover;
omap_mmc.c:        qemu_set_irq(cover, s->cdet_state);
omap_mmc.c:        sd_set_cb(s->card, ro, cover);
omap_mmc.c:    sd_enable(s->card, enable);
omap_sx1.c: * 	Jean-Christophe PLAGNIOL-VILLARD <plagnioj@jcrosoft.com>
omap_sx1.c: * Copyright (C) 2006-2007 Andrzej Zaborowski <balrog@zabor.org>
omap_sx1.c:#include "arm-misc.h"
omap_sx1.c:/* - ARM OMAP310 processor
omap_sx1.c: * - SRAM                192 kB
omap_sx1.c: * - SDRAM                32 MB at 0x10000000
omap_sx1.c: * - Boot flash           16 MB at 0x00000000
omap_sx1.c: * - Application flash     8 MB at 0x04000000
omap_sx1.c: * - 3 serial ports
omap_sx1.c: * - 1 SecureDigital
omap_sx1.c: * - 1 LCD display
omap_sx1.c: * - 1 RTC
omap_sx1.c:/* - ARM OMAP310 processor
omap_sx1.c: * - SRAM                192 kB
omap_sx1.c: * - SDRAM                32 MB at 0x10000000
omap_sx1.c: * - Boot flash           32 MB at 0x00000000
omap_sx1.c: * - 3 serial ports
omap_sx1.c: * - 1 SecureDigital
omap_sx1.c: * - 1 LCD display
omap_sx1.c: * - 1 RTC
omap_sx1.c:                    OMAP_CS0_SIZE - flash_size, io);
omap_sx1.c:            dinfo->bdrv, sector_size, flash_size / sector_size,
omap_sx1.c:                        OMAP_CS1_SIZE - flash1_size, io);
omap_sx1.c:            dinfo->bdrv, sector_size, flash1_size / sector_size,
omap_sx1.c:        cpu->env->regs[15] = sx1_binfo.loader_start;
omap_sx1.c:        arm_load_kernel(cpu->env, &sx1_binfo);
omap_sx1.c:        cpu->env->regs[15] = 0x00000000;
omap_sx1.c:    .name = "sx1-v1",
onenand.c:#include "qemu-common.h"
onenand.c:/* 11 for 2kB-page OneNAND ("2nd generation") and 10 for 1kB-page chips */
onenand.c:    s->base = new;
onenand.c:    cpu_register_physical_memory(s->base + (0x0000 << s->shift),
onenand.c:                    0x0200 << s->shift, s->iomemtype);
onenand.c:    cpu_register_physical_memory(s->base + (0x0200 << s->shift),
onenand.c:                    0xbe00 << s->shift,
onenand.c:                    (s->ram +(0x0200 << s->shift)) | IO_MEM_RAM);
onenand.c:    if (s->iomemtype)
onenand.c:        cpu_register_physical_memory_offset(s->base + (0xc000 << s->shift),
onenand.c:                    0x4000 << s->shift, s->iomemtype, (0xc000 << s->shift));
onenand.c:    cpu_register_physical_memory(s->base,
onenand.c:                    0x10000 << s->shift, IO_MEM_UNASSIGNED);
onenand.c:    qemu_set_irq(s->intr, ((s->intstatus >> 15) ^ (~s->config[0] >> 6)) & 1);
onenand.c:    memset(&s->addr, 0, sizeof(s->addr));
onenand.c:    s->command = 0;
onenand.c:    s->count = 1;
onenand.c:    s->bufaddr = 0;
onenand.c:    s->config[0] = 0x40c0;
onenand.c:    s->config[1] = 0x0000;
onenand.c:    qemu_irq_raise(s->rdy);
onenand.c:    s->status = 0x0000;
onenand.c:    s->intstatus = cold ? 0x8080 : 0x8010;
onenand.c:    s->unladdr[0] = 0;
onenand.c:    s->unladdr[1] = 0;
onenand.c:    s->wpstatus = 0x0002;
onenand.c:    s->cycle = 0;
onenand.c:    s->otpmode = 0;
onenand.c:    s->bdrv_cur = s->bdrv;
onenand.c:    s->current = s->image;
onenand.c:    s->secs_cur = s->secs;
onenand.c:        memset(s->blockwp, ONEN_LOCK_LOCKED, s->blocks);
onenand.c:        if (s->bdrv && bdrv_read(s->bdrv, 0, s->boot[0], 8) < 0)
onenand.c:    if (s->bdrv_cur)
onenand.c:        return bdrv_read(s->bdrv_cur, sec, dest, secn) < 0;
onenand.c:    else if (sec + secn > s->secs_cur)
onenand.c:    memcpy(dest, s->current + (sec << 9), secn << 9);
onenand.c:    if (s->bdrv_cur)
onenand.c:        return bdrv_write(s->bdrv_cur, sec, src, secn) < 0;
onenand.c:    else if (sec + secn > s->secs_cur)
onenand.c:    memcpy(s->current + (sec << 9), src, secn << 9);
onenand.c:    if (s->bdrv_cur) {
onenand.c:        if (bdrv_read(s->bdrv_cur, s->secs_cur + (sec >> 5), buf, 1) < 0)
onenand.c:    } else if (sec + secn > s->secs_cur)
onenand.c:        memcpy(dest, s->current + (s->secs_cur << 9) + (sec << 4), secn << 4);
onenand.c:    if (s->bdrv_cur) {
onenand.c:        if (bdrv_read(s->bdrv_cur, s->secs_cur + (sec >> 5), buf, 1) < 0)
onenand.c:        return bdrv_write(s->bdrv_cur, s->secs_cur + (sec >> 5), buf, 1) < 0;
onenand.c:    } else if (sec + secn > s->secs_cur)
onenand.c:    memcpy(s->current + (s->secs_cur << 9) + (sec << 4), src, secn << 4);
onenand.c:    for (; num > 0; num --, sec ++) {
onenand.c:    sec = (s->addr[page] & 3) +			\
onenand.c:            ((((s->addr[page] >> 2) & 0x3f) +	\
onenand.c:              (((s->addr[block] & 0xfff) |	\
onenand.c:                (s->addr[block] >> 15 ?		\
onenand.c:                 s->density_mask : 0)) << 6)) << (PAGE_SHIFT - 9));
onenand.c:    buf = (s->bufaddr & 8) ?			\
onenand.c:            s->data[(s->bufaddr >> 2) & 1][0] : s->boot[0];	\
onenand.c:    buf += (s->bufaddr & 3) << 9;
onenand.c:    buf = (s->bufaddr & 8) ?			\
onenand.c:            s->data[(s->bufaddr >> 2) & 1][1] : s->boot[1];	\
onenand.c:    buf += (s->bufaddr & 3) << 4;
onenand.c:        if (onenand_load_main(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;
onenand.c:        if (onenand_load_spare(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;
onenand.c:        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)
onenand.c:         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;
onenand.c:        if (onenand_load_spare(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_LOAD;
onenand.c:        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)
onenand.c:         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_LOAD;
onenand.c:        if (onenand_prog_main(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;
onenand.c:        if (onenand_prog_spare(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;
onenand.c:        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)
onenand.c:         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_PROG;
onenand.c:        if (onenand_prog_spare(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;
onenand.c:        /* TODO: if (s->bufaddr & 3) + s->count was > 4 (2k-pages)
onenand.c:         * or    if (s->bufaddr & 1) + s->count was > 2 (1k-pages)
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_PROG;
onenand.c:    case 0x1b:	/* Copy-back program */
onenand.c:        if (onenand_load_main(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;
onenand.c:        if (onenand_prog_main(s, sec, s->count, buf))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_PROG;
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_PROG;
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {
onenand.c:            if (b >= s->blocks) {
onenand.c:                s->status |= ONEN_ERR_CMD;
onenand.c:            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)
onenand.c:            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:        for (b = 0; b < s->blocks; b ++) {
onenand.c:            if (b >= s->blocks) {
onenand.c:                s->status |= ONEN_ERR_CMD;
onenand.c:            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)
onenand.c:            s->wpstatus = s->blockwp[b] = ONEN_LOCK_UNLOCKED;
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {
onenand.c:            if (b >= s->blocks) {
onenand.c:                s->status |= ONEN_ERR_CMD;
onenand.c:            if (s->blockwp[b] == ONEN_LOCK_LOCKTIGHTEN)
onenand.c:            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKED;
onenand.c:    case 0x2c:	/* Lock-tight NAND array block(s) */
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:        for (b = s->unladdr[0]; b <= s->unladdr[1]; b ++) {
onenand.c:            if (b >= s->blocks) {
onenand.c:                s->status |= ONEN_ERR_CMD;
onenand.c:            if (s->blockwp[b] == ONEN_LOCK_UNLOCKED)
onenand.c:            s->wpstatus = s->blockwp[b] = ONEN_LOCK_LOCKTIGHTEN;
onenand.c:    case 0x71:	/* Erase-Verify-Read */
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:    case 0x95:	/* Multi-block erase */
onenand.c:        qemu_irq_pulse(s->intr);
onenand.c:        sec = ((s->addr[ONEN_BUF_BLOCK] & 0xfff) |
onenand.c:                        (s->addr[ONEN_BUF_BLOCK] >> 15 ? s->density_mask : 0))
onenand.c:                << (BLOCK_SHIFT - 9);
onenand.c:        if (onenand_erase(s, sec, 1 << (BLOCK_SHIFT - 9)))
onenand.c:            s->status |= ONEN_ERR_CMD | ONEN_ERR_ERASE;
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;
onenand.c:        s->intstatus |= ONEN_INT | ONEN_INT_ERASE;
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:        s->bdrv_cur = NULL;
onenand.c:        s->current = s->otp;
onenand.c:        s->secs_cur = 1 << (BLOCK_SHIFT - 9);
onenand.c:        s->addr[ONEN_BUF_BLOCK] = 0;
onenand.c:        s->otpmode = 1;
onenand.c:        s->status |= ONEN_ERR_CMD;
onenand.c:        s->intstatus |= ONEN_INT;
onenand.c:    int offset = addr >> s->shift;
onenand.c:        return lduw_le_p(s->boot[0] + addr);
onenand.c:        return (s->id >> 16) & 0xff;
onenand.c:        return (s->id >>  8) & 0xff;
onenand.c:        return (s->id >>  0) & 0xff;
onenand.c:        return s->addr[offset - 0xf100];
onenand.c:        return (s->bufaddr << 8) | ((s->count - 1) & (1 << (PAGE_SHIFT - 10)));
onenand.c:        return s->command;
onenand.c:        return s->config[0] & 0xffe0;
onenand.c:        return s->config[1];
onenand.c:        return s->status;
onenand.c:        return s->intstatus;
onenand.c:        return s->unladdr[0];
onenand.c:        return s->unladdr[1];
onenand.c:        return s->wpstatus;
onenand.c:    int offset = addr >> s->shift;
onenand.c:        if (s->cycle) {
onenand.c:            s->cycle = 0;
onenand.c:                                1 << (PAGE_SHIFT - 9), s->data[0][0]);
onenand.c:                s->addr[ONEN_BUF_PAGE] += 4;
onenand.c:                s->addr[ONEN_BUF_PAGE] &= 0xff;
onenand.c:            s->cycle = 1;
onenand.c:            memset(s->boot[0], 0, 3 << s->shift);
onenand.c:            s->boot[0][0 << s->shift] = (s->id >> 16) & 0xff;
onenand.c:            s->boot[0][1 << s->shift] = (s->id >>  8) & 0xff;
onenand.c:            s->boot[0][2 << s->shift] = s->wpstatus & 0xff;
onenand.c:        s->addr[offset - 0xf100] = value;
onenand.c:        s->bufaddr = (value >> 8) & 0xf;
onenand.c:            s->count = (value & 3) ?: 4;
onenand.c:            s->count = (value & 1) ?: 2;
onenand.c:        if (s->intstatus & (1 << 15))
onenand.c:        s->command = value;
onenand.c:        onenand_command(s, s->command);
onenand.c:        s->config[0] = value;
onenand.c:        qemu_set_irq(s->rdy, (s->config[0] >> 7) & 1);
onenand.c:        s->config[1] = value;
onenand.c:        s->intstatus &= value;
onenand.c:        if ((1 << 15) & ~s->intstatus)
onenand.c:            s->status &= ~(ONEN_ERR_CMD | ONEN_ERR_ERASE |
onenand.c:        s->unladdr[0] = value & (s->blocks - 1);
onenand.c:        s->unladdr[1] = value & (s->blocks - 1);
onenand.c:        s->unladdr[1] = value & (s->blocks - 1);
onenand.c:    s->shift = regshift;
onenand.c:    s->intr = irq;
onenand.c:    s->rdy = NULL;
onenand.c:    s->id = id;
onenand.c:    s->blocks = size >> BLOCK_SHIFT;
onenand.c:    s->secs = size >> 9;
onenand.c:    s->blockwp = qemu_malloc(s->blocks);
onenand.c:    s->density_mask = (id & (1 << 11)) ? (1 << (6 + ((id >> 12) & 7))) : 0;
onenand.c:    s->iomemtype = cpu_register_io_memory(onenand_readfn,
onenand.c:        s->image = memset(qemu_malloc(size + (size >> 5)),
onenand.c:        s->bdrv = dinfo->bdrv;
onenand.c:    s->otp = memset(qemu_malloc((64 + 2) << PAGE_SHIFT),
onenand.c:    s->ram = qemu_ram_alloc(0xc000 << s->shift);
onenand.c:    ram = qemu_get_ram_ptr(s->ram);
onenand.c:    s->boot[0] = ram + (0x0000 << s->shift);
onenand.c:    s->boot[1] = ram + (0x8000 << s->shift);
onenand.c:    s->data[0][0] = ram + ((0x0200 + (0 << (PAGE_SHIFT - 1))) << s->shift);
onenand.c:    s->data[0][1] = ram + ((0x8010 + (0 << (PAGE_SHIFT - 6))) << s->shift);
onenand.c:    s->data[1][0] = ram + ((0x0200 + (1 << (PAGE_SHIFT - 1))) << s->shift);
onenand.c:    s->data[1][1] = ram + ((0x8010 + (1 << (PAGE_SHIFT - 6))) << s->shift);
onenand.c:    return s->otp;
openpic.c: * - Intel GW80314 I/O companion chip developer's manual
openpic.c: * - Motorola MPC8245 & MPC8540 user manuals.
openpic.c: * - Motorola MCP750 (aka Raven) programmer manual.
openpic.c: * - Motorola Harrier programmer manuel
openpic.c:(((_bits_) + (sizeof(uint32_t) * 8) - 1) / (sizeof(uint32_t) * 8))
openpic.c:#define IPVP_VECTOR_MASK       ((1 << VECTOR_BITS) - 1)
openpic.c:    if (opp->need_swap)
openpic.c:    set_bit(q->queue, n_IRQ);
openpic.c:    reset_bit(q->queue, n_IRQ);
openpic.c:    return test_bit(q->queue, n_IRQ);
openpic.c:    next = -1;
openpic.c:    priority = -1;
openpic.c:    for (i = 0; i < opp->max_irq; i++) {
openpic.c:                    i, IPVP_PRIORITY(opp->src[i].ipvp), priority);
openpic.c:	    if (IPVP_PRIORITY(opp->src[i].ipvp) > priority) {
openpic.c:		priority = IPVP_PRIORITY(opp->src[i].ipvp);
openpic.c:    q->next = next;
openpic.c:    q->priority = priority;
openpic.c:    if (q->next == -1) {
openpic.c:    return q->next;
openpic.c:    dst = &opp->dst[n_CPU];
openpic.c:    src = &opp->src[n_IRQ];
openpic.c:    priority = IPVP_PRIORITY(src->ipvp);
openpic.c:    if (priority <= dst->pctp) {
openpic.c:    if (IRQ_testbit(&dst->raised, n_IRQ)) {
openpic.c:    set_bit(&src->ipvp, IPVP_ACTIVITY);
openpic.c:    IRQ_setbit(&dst->raised, n_IRQ);
openpic.c:    if (priority < dst->raised.priority) {
openpic.c:                __func__, n_IRQ, dst->raised.next, n_CPU);
openpic.c:    IRQ_get_next(opp, &dst->raised);
openpic.c:    if (IRQ_get_next(opp, &dst->servicing) != -1 &&
openpic.c:        priority <= dst->servicing.priority) {
openpic.c:                __func__, n_IRQ, dst->servicing.next, n_CPU);
openpic.c:    opp->irq_raise(opp, n_CPU, src);
openpic.c:    src = &opp->src[n_IRQ];
openpic.c:    if (!src->pending) {
openpic.c:    if (test_bit(&src->ipvp, IPVP_MASK)) {
openpic.c:    if (IPVP_PRIORITY(src->ipvp) == 0) {
openpic.c:    if (test_bit(&src->ipvp, IPVP_ACTIVITY)) {
openpic.c:    if (src->ide == 0x00000000) {
openpic.c:    if (src->ide == (1 << src->last_cpu)) {
openpic.c:        IRQ_local_pipe(opp, src->last_cpu, n_IRQ);
openpic.c:    } else if (!test_bit(&src->ipvp, IPVP_MODE)) {
openpic.c:        for (i = 0; i < opp->nb_cpus; i++) {
openpic.c:            if (test_bit(&src->ide, i))
openpic.c:        for (i = src->last_cpu + 1; i != src->last_cpu; i++) {
openpic.c:            if (i == opp->nb_cpus)
openpic.c:            if (test_bit(&src->ide, i)) {
openpic.c:                src->last_cpu = i;
openpic.c:    src = &opp->src[n_IRQ];
openpic.c:            n_IRQ, level, src->ipvp);
openpic.c:    if (test_bit(&src->ipvp, IPVP_SENSE)) {
openpic.c:        /* level-sensitive irq */
openpic.c:        src->pending = level;
openpic.c:            reset_bit(&src->ipvp, IPVP_ACTIVITY);
openpic.c:        /* edge-sensitive irq */
openpic.c:            src->pending = 1;
openpic.c:    opp->glbc = 0x80000000;
openpic.c:    opp->frep = ((OPENPIC_EXT_IRQ - 1) << 16) | ((MAX_CPU - 1) << 8) | VID;
openpic.c:    opp->veni = VENI;
openpic.c:    opp->pint = 0x00000000;
openpic.c:    opp->spve = 0x000000FF;
openpic.c:    opp->tifr = 0x003F7A00;
openpic.c:    opp->micr = 0x00000000;
openpic.c:    for (i = 0; i < opp->max_irq; i++) {
openpic.c:	opp->src[i].ipvp = 0xA0000000;
openpic.c:	opp->src[i].ide  = 0x00000000;
openpic.c:	opp->dst[i].pctp      = 0x0000000F;
openpic.c:	opp->dst[i].pcsr      = 0x00000000;
openpic.c:	memset(&opp->dst[i].raised, 0, sizeof(IRQ_queue_t));
openpic.c:	memset(&opp->dst[i].servicing, 0, sizeof(IRQ_queue_t));
openpic.c:	opp->timers[i].ticc = 0x00000000;
openpic.c:	opp->timers[i].tibc = 0x80000000;
openpic.c:    opp->dar = 0x00000000;
openpic.c:	opp->doorbells[i].dmr  = 0x00000000;
openpic.c:	opp->mailboxes[i].mbr   = 0x00000000;
openpic.c:    opp->glbc = 0x00000000;
openpic.c:	retval = opp->src[n_IRQ].ipvp;
openpic.c:	retval = opp->src[n_IRQ].ide;
openpic.c:        /* ACTIVITY bit is read-only */
openpic.c:	opp->src[n_IRQ].ipvp =
openpic.c:            (opp->src[n_IRQ].ipvp & 0x40000000) |
openpic.c:        DPRINTF("Set IPVP %d to 0x%08x -> 0x%08x\n",
openpic.c:                n_IRQ, val, opp->src[n_IRQ].ipvp);
openpic.c:        tmp |= val & ((1 << MAX_CPU) - 1);
openpic.c:	opp->src[n_IRQ].ide = tmp;
openpic.c:        DPRINTF("Set IDE %d to 0x%08x\n", n_IRQ, opp->src[n_IRQ].ide);
openpic.c:	retval = opp->doorbells[n_dbl].dmr;
openpic.c:	opp->doorbells[n_dbl].dmr = value;
openpic.c:	retval = opp->mailboxes[n_mbx].mbr;
openpic.c:	opp->mailboxes[n_mbx].mbr = value;
openpic.c:        if (val & 0x80000000 && opp->reset)
openpic.c:            opp->reset(opp);
openpic.c:        opp->glbc = val & ~0x80000000;
openpic.c:        for (idx = 0; idx < opp->nb_cpus; idx++) {
openpic.c:            if ((val & (1 << idx)) && !(opp->pint & (1 << idx))) {
openpic.c:                dst = &opp->dst[idx];
openpic.c:                qemu_irq_raise(dst->irqs[OPENPIC_OUTPUT_RESET]);
openpic.c:            } else if (!(val & (1 << idx)) && (opp->pint & (1 << idx))) {
openpic.c:                dst = &opp->dst[idx];
openpic.c:                qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_RESET]);
openpic.c:        opp->pint = val;
openpic.c:            idx = (addr - 0xA0) >> 4;
openpic.c:            write_IRQreg(opp, opp->irq_ipi0 + idx, IRQ_IPVP, val);
openpic.c:        opp->spve = val & 0x000000FF;
openpic.c:        opp->tifr = val;
openpic.c:        retval = opp->frep;
openpic.c:        retval = opp->glbc;
openpic.c:        retval = opp->veni;
openpic.c:            idx = (addr - 0xA0) >> 4;
openpic.c:            retval = read_IRQreg(opp, opp->irq_ipi0 + idx, IRQ_IPVP);
openpic.c:        retval = opp->spve;
openpic.c:        retval = opp->tifr;
openpic.c:    addr -= 0x1100;
openpic.c:	if ((opp->timers[idx].ticc & 0x80000000) != 0 &&
openpic.c:            (opp->timers[idx].tibc & 0x80000000) != 0)
openpic.c:	    opp->timers[idx].ticc &= ~0x80000000;
openpic.c:	opp->timers[idx].tibc = val;
openpic.c:        write_IRQreg(opp, opp->irq_tim0 + idx, IRQ_IPVP, val);
openpic.c:        write_IRQreg(opp, opp->irq_tim0 + idx, IRQ_IDE, val);
openpic.c:    addr -= 0x1100;
openpic.c:	retval = opp->timers[idx].ticc;
openpic.c:	retval = opp->timers[idx].tibc;
openpic.c:        retval = read_IRQreg(opp, opp->irq_tim0 + idx, IRQ_IPVP);
openpic.c:        retval = read_IRQreg(opp, opp->irq_tim0 + idx, IRQ_IDE);
openpic.c:    dst = &opp->dst[idx];
openpic.c:        idx = (addr - 0x40) >> 4;
openpic.c:        write_IRQreg(opp, opp->irq_ipi0 + idx, IRQ_IDE, val);
openpic.c:        openpic_set_irq(opp, opp->irq_ipi0 + idx, 1);
openpic.c:        openpic_set_irq(opp, opp->irq_ipi0 + idx, 0);
openpic.c:	dst->pctp = val & 0x0000000F;
openpic.c:	/* Read-only register */
openpic.c:	/* Read-only register */
openpic.c:	s_IRQ = IRQ_get_next(opp, &dst->servicing);
openpic.c:	IRQ_resetbit(&dst->servicing, s_IRQ);
openpic.c:	dst->servicing.next = -1;
openpic.c:	s_IRQ = IRQ_get_next(opp, &dst->servicing);
openpic.c:        n_IRQ = IRQ_get_next(opp, &dst->raised);
openpic.c:        src = &opp->src[n_IRQ];
openpic.c:        if (n_IRQ != -1 &&
openpic.c:            (s_IRQ == -1 ||
openpic.c:             IPVP_PRIORITY(src->ipvp) > dst->servicing.priority)) {
openpic.c:            opp->irq_raise(opp, idx, src);
openpic.c:    dst = &opp->dst[idx];
openpic.c:	retval = dst->pctp;
openpic.c:        qemu_irq_lower(dst->irqs[OPENPIC_OUTPUT_INT]);
openpic.c:	n_IRQ = IRQ_get_next(opp, &dst->raised);
openpic.c:	if (n_IRQ == -1) {
openpic.c:            retval = IPVP_VECTOR(opp->spve);
openpic.c:	    src = &opp->src[n_IRQ];
openpic.c:	    if (!test_bit(&src->ipvp, IPVP_ACTIVITY) ||
openpic.c:		!(IPVP_PRIORITY(src->ipvp) > dst->pctp)) {
openpic.c:		/* - Spurious level-sensitive IRQ
openpic.c:		 * - Priorities has been changed
openpic.c:		reset_bit(&src->ipvp, IPVP_ACTIVITY);
openpic.c:		retval = IPVP_VECTOR(opp->spve);
openpic.c:		IRQ_setbit(&dst->servicing, n_IRQ);
openpic.c:		retval = IPVP_VECTOR(src->ipvp);
openpic.c:	    IRQ_resetbit(&dst->raised, n_IRQ);
openpic.c:	    dst->raised.next = -1;
openpic.c:	    if (!test_bit(&src->ipvp, IPVP_SENSE)) {
openpic.c:                /* edge-sensitive IRQ */
openpic.c:		reset_bit(&src->ipvp, IPVP_ACTIVITY);
openpic.c:                src->pending = 0;
openpic.c:        idx = (addr - 0x40) >> 4;
openpic.c:        retval = read_IRQreg(opp, opp->irq_ipi0 + idx, IRQ_IDE);
openpic.c:    return -1;
openpic.c:    cpu_register_physical_memory(addr, 0x40000, opp->mem_index);
openpic.c:        qemu_put_be32s(f, &q->queue[i]);
openpic.c:    qemu_put_sbe32s(f, &q->next);
openpic.c:    qemu_put_sbe32s(f, &q->priority);
openpic.c:    qemu_put_be32s(f, &opp->frep);
openpic.c:    qemu_put_be32s(f, &opp->glbc);
openpic.c:    qemu_put_be32s(f, &opp->micr);
openpic.c:    qemu_put_be32s(f, &opp->veni);
openpic.c:    qemu_put_be32s(f, &opp->pint);
openpic.c:    qemu_put_be32s(f, &opp->spve);
openpic.c:    qemu_put_be32s(f, &opp->tifr);
openpic.c:    for (i = 0; i < opp->max_irq; i++) {
openpic.c:        qemu_put_be32s(f, &opp->src[i].ipvp);
openpic.c:        qemu_put_be32s(f, &opp->src[i].ide);
openpic.c:        qemu_put_sbe32s(f, &opp->src[i].type);
openpic.c:        qemu_put_sbe32s(f, &opp->src[i].last_cpu);
openpic.c:        qemu_put_sbe32s(f, &opp->src[i].pending);
openpic.c:    qemu_put_sbe32s(f, &opp->nb_cpus);
openpic.c:    for (i = 0; i < opp->nb_cpus; i++) {
openpic.c:        qemu_put_be32s(f, &opp->dst[i].tfrr);
openpic.c:        qemu_put_be32s(f, &opp->dst[i].pctp);
openpic.c:        qemu_put_be32s(f, &opp->dst[i].pcsr);
openpic.c:        openpic_save_IRQ_queue(f, &opp->dst[i].raised);
openpic.c:        openpic_save_IRQ_queue(f, &opp->dst[i].servicing);
openpic.c:        qemu_put_be32s(f, &opp->timers[i].ticc);
openpic.c:        qemu_put_be32s(f, &opp->timers[i].tibc);
openpic.c:    qemu_put_be32s(f, &opp->dar);
openpic.c:        qemu_put_be32s(f, &opp->doorbells[i].dmr);
openpic.c:        qemu_put_be32s(f, &opp->mailboxes[i].mbr);
openpic.c:    pci_device_save(&opp->pci_dev, f);
openpic.c:        qemu_get_be32s(f, &q->queue[i]);
openpic.c:    qemu_get_sbe32s(f, &q->next);
openpic.c:    qemu_get_sbe32s(f, &q->priority);
openpic.c:        return -EINVAL;
openpic.c:    qemu_get_be32s(f, &opp->frep);
openpic.c:    qemu_get_be32s(f, &opp->glbc);
openpic.c:    qemu_get_be32s(f, &opp->micr);
openpic.c:    qemu_get_be32s(f, &opp->veni);
openpic.c:    qemu_get_be32s(f, &opp->pint);
openpic.c:    qemu_get_be32s(f, &opp->spve);
openpic.c:    qemu_get_be32s(f, &opp->tifr);
openpic.c:    for (i = 0; i < opp->max_irq; i++) {
openpic.c:        qemu_get_be32s(f, &opp->src[i].ipvp);
openpic.c:        qemu_get_be32s(f, &opp->src[i].ide);
openpic.c:        qemu_get_sbe32s(f, &opp->src[i].type);
openpic.c:        qemu_get_sbe32s(f, &opp->src[i].last_cpu);
openpic.c:        qemu_get_sbe32s(f, &opp->src[i].pending);
openpic.c:    qemu_get_sbe32s(f, &opp->nb_cpus);
openpic.c:    for (i = 0; i < opp->nb_cpus; i++) {
openpic.c:        qemu_get_be32s(f, &opp->dst[i].tfrr);
openpic.c:        qemu_get_be32s(f, &opp->dst[i].pctp);
openpic.c:        qemu_get_be32s(f, &opp->dst[i].pcsr);
openpic.c:        openpic_load_IRQ_queue(f, &opp->dst[i].raised);
openpic.c:        openpic_load_IRQ_queue(f, &opp->dst[i].servicing);
openpic.c:        qemu_get_be32s(f, &opp->timers[i].ticc);
openpic.c:        qemu_get_be32s(f, &opp->timers[i].tibc);
openpic.c:    qemu_get_be32s(f, &opp->dar);
openpic.c:        qemu_get_be32s(f, &opp->doorbells[i].dmr);
openpic.c:        qemu_get_be32s(f, &opp->mailboxes[i].mbr);
openpic.c:    return pci_device_load(&opp->pci_dev, f);
openpic.c:    qemu_irq_raise(opp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);
openpic.c:                                               -1, NULL, NULL);
openpic.c:        pci_conf = opp->pci_dev.config;
openpic.c:    opp->mem_index = cpu_register_io_memory(openpic_read,
openpic.c:    opp->nb_cpus = nb_cpus;
openpic.c:    opp->max_irq = OPENPIC_MAX_IRQ;
openpic.c:    opp->irq_ipi0 = OPENPIC_IRQ_IPI0;
openpic.c:    opp->irq_tim0 = OPENPIC_IRQ_TIM0;
openpic.c:        opp->src[i].type = IRQ_EXTERNAL;
openpic.c:        opp->src[i].type = IRQ_SPECIAL;
openpic.c:        opp->src[i].type = IRQ_TIMER;
openpic.c:        opp->src[i].type = IRQ_INTERNAL;
openpic.c:        opp->dst[i].irqs = irqs[i];
openpic.c:    opp->irq_out = irq_out;
openpic.c:    opp->need_swap = 1;
openpic.c:    opp->irq_raise = openpic_irq_raise;
openpic.c:    opp->reset = openpic_reset;
openpic.c:        *pmem_index = opp->mem_index;
openpic.c:    return qemu_allocate_irqs(openpic_set_irq, opp, opp->max_irq);
openpic.c:    int n_ci = IDR_CI0 - n_CPU;
openpic.c:    if(test_bit(&src->ide, n_ci)) {
openpic.c:        qemu_irq_raise(mpp->dst[n_CPU].irqs[OPENPIC_OUTPUT_CINT]);
openpic.c:        qemu_irq_raise(mpp->dst[n_CPU].irqs[OPENPIC_OUTPUT_INT]);
openpic.c:    mpp->glbc = 0x80000000;
openpic.c:    mpp->frep = 0x004f0002;
openpic.c:    mpp->veni = VENI;
openpic.c:    mpp->pint = 0x00000000;
openpic.c:    mpp->spve = 0x0000FFFF;
openpic.c:    for (i = 0; i < mpp->max_irq; i++) {
openpic.c:        mpp->src[i].ipvp = 0x80800000;
openpic.c:        mpp->src[i].ide  = 0x00000001;
openpic.c:        mpp->dst[i].pctp      = 0x0000000F;
openpic.c:        mpp->dst[i].tfrr      = 0x00000000;
openpic.c:        memset(&mpp->dst[i].raised, 0, sizeof(IRQ_queue_t));
openpic.c:        mpp->dst[i].raised.next = -1;
openpic.c:        memset(&mpp->dst[i].servicing, 0, sizeof(IRQ_queue_t));
openpic.c:        mpp->dst[i].servicing.next = -1;
openpic.c:        mpp->timers[i].ticc = 0x00000000;
openpic.c:        mpp->timers[i].tibc = 0x80000000;
openpic.c:    mpp->glbc = 0x00000000;
openpic.c:        if ((mpp->timers[idx].ticc & 0x80000000) != 0 &&
openpic.c:            (mpp->timers[idx].tibc & 0x80000000) != 0)
openpic.c:            mpp->timers[idx].ticc &= ~0x80000000;
openpic.c:        mpp->timers[idx].tibc = val;
openpic.c:            mpp->dst[cpu].tfrr = val;
openpic.c:        retval = mpp->timers[idx].ticc;
openpic.c:        retval = mpp->timers[idx].tibc;
openpic.c:            retval = mpp->dst[cpu].tfrr;
openpic.c:    addr -= MPIC_EXT_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_EXT_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_INT_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_INT_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_MSG_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_MSG_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_MSI_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    addr -= MPIC_MSI_REG_START & (TARGET_PAGE_SIZE - 1);
openpic.c:    mpp->nb_cpus = nb_cpus;
openpic.c:    mpp->max_irq = MPIC_MAX_IRQ;
openpic.c:    mpp->irq_ipi0 = MPIC_IPI_IRQ;
openpic.c:    mpp->irq_tim0 = MPIC_TMR_IRQ;
openpic.c:        mpp->dst[i].irqs = irqs[i];
openpic.c:    mpp->irq_out = irq_out;
openpic.c:    mpp->need_swap = 0;    /* MPIC has the same endian as target */
openpic.c:    mpp->irq_raise = mpic_irq_raise;
openpic.c:    mpp->reset = mpic_reset;
openpic.c:    return qemu_allocate_irqs(openpic_set_irq, mpp, mpp->max_irq);
palm.c: * Copyright (C) 2006-2007 Andrzej Zaborowski  <balrog@zabor.org>
palm.c:#include "arm-misc.h"
palm.c:    .a = { -5909, 8, 22465308, 104, 7644, -1219972, 65536 },
palm.c:    tsc = tsc2102_init(omap_gpio_in_get(cpu->gpio)[PALMTE_PINTDAV_GPIO]);
palm.c:    omap_uwire_attach(cpu->microwire, tsc, 0);
palm.c:    omap_mcbsp_i2s_attach(cpu->mcbsp1, tsc210x_codec(tsc));
palm.c:    [0 ... 0x7f] = { -1, -1 },
palm.c:    [0x3b] = { 0, 0 },	/* F1	-> Calendar */
palm.c:    [0x3c] = { 1, 0 },	/* F2	-> Contacts */
palm.c:    [0x3d] = { 2, 0 },	/* F3	-> Tasks List */
palm.c:    [0x3e] = { 3, 0 },	/* F4	-> Note Pad */
palm.c:    [0x01] = { 4, 0 },	/* Esc	-> Power */
palm.c:    [0x39] = { 4, 1 },	/* Spc	-> Centre */
palm.c:    if (palmte_keymap[keycode & 0x7f].row != -1)
palm.c:        omap_mpuio_key(cpu->mpuio,
palm.c:                        __FUNCTION__, line - 1, level ? "high" : "low");
palm.c:                        __FUNCTION__, line - 4, level ? "high" : "low");
palm.c:    omap_mmc_handlers(cpu->mmc,
palm.c:                    omap_gpio_in_get(cpu->gpio)[PALMTE_MMC_WP_GPIO],
palm.c:                    qemu_irq_invert(omap_mpuio_in_get(cpu->mpuio)
palm.c:    omap_gpio_out_set(cpu->gpio, PALMTE_MMC_POWER_GPIO,	misc_gpio[0]);
palm.c:    omap_gpio_out_set(cpu->gpio, PALMTE_SPEAKER_GPIO,	misc_gpio[1]);
palm.c:    omap_gpio_out_set(cpu->gpio, 11,			misc_gpio[2]);
palm.c:    omap_gpio_out_set(cpu->gpio, 12,			misc_gpio[3]);
palm.c:    omap_gpio_out_set(cpu->gpio, 13,			misc_gpio[4]);
palm.c:    omap_mpuio_out_set(cpu->mpuio, 1,			misc_gpio[5]);
palm.c:    omap_mpuio_out_set(cpu->mpuio, 3,			misc_gpio[6]);
palm.c:    qemu_irq_lower(omap_gpio_in_get(cpu->gpio)[PALMTE_USBDETECT_GPIO]);
palm.c:    qemu_irq_lower(omap_gpio_in_get(cpu->gpio)[PALMTE_USB_OR_DC_GPIO]);
palm.c:    qemu_irq_lower(omap_gpio_in_get(cpu->gpio)[4]);
palm.c:    qemu_irq_lower(omap_gpio_in_get(cpu->gpio)[PALMTE_HEADPHONES_GPIO]);
palm.c:    qemu_irq_lower(omap_mpuio_in_get(cpu->mpuio)[PALMTE_DC_GPIO]);
palm.c:    qemu_irq_raise(omap_mpuio_in_get(cpu->mpuio)[6]);
palm.c:    qemu_irq_raise(omap_mpuio_in_get(cpu->mpuio)[7]);
palm.c:    qemu_irq_raise(omap_mpuio_in_get(cpu->mpuio)[11]);
palm.c:                    OMAP_CS0_SIZE - flash_size, io);
palm.c:            cpu->env->regs[15] = 0x00000000;
palm.c:        cpu->env->regs[15] = palmte_binfo.loader_start;
palm.c:        arm_load_kernel(cpu->env, &palmte_binfo);
palm.c:    ds->surface = qemu_resize_displaysurface(ds, 320, 320);
parallel.c: * Copyright (c) 2003-2005 Fabrice Bellard
parallel.c:#include "qemu-char.h"
parallel.c:    /* Memory-mapped interface */
parallel.c:    if (s->irq_pending)
parallel.c:        qemu_irq_raise(s->irq);
parallel.c:        qemu_irq_lower(s->irq);
parallel.c:        s->dataw = val;
parallel.c:            s->status = PARA_STS_BUSY;
parallel.c:            s->status |= PARA_STS_ACK;
parallel.c:            s->status |= PARA_STS_ONLINE;
parallel.c:            s->status |= PARA_STS_ERROR;
parallel.c:                s->status &= ~PARA_STS_BUSY;
parallel.c:                if ((s->control & PARA_CTR_STROBE) == 0)
parallel.c:                    qemu_chr_write(s->chr, &s->dataw, 1);
parallel.c:                if (s->control & PARA_CTR_INTEN) {
parallel.c:                    s->irq_pending = 1;
parallel.c:        s->control = val;
parallel.c:    s->last_read_offset = ~0U;
parallel.c:        if (s->dataw == val)
parallel.c:        qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_WRITE_DATA, &parm);
parallel.c:        s->dataw = val;
parallel.c:            s->epp_timeout = 0;
parallel.c:        if (s->control == val)
parallel.c:        if ((val & PARA_CTR_DIR) != (s->control & PARA_CTR_DIR)) {
parallel.c:            qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_DATA_DIR, &dir);
parallel.c:        qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_WRITE_CONTROL, &parm);
parallel.c:        s->control = val;
parallel.c:        if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != PARA_CTR_INIT)
parallel.c:            if (qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_WRITE_ADDR, &ioarg)) {
parallel.c:                s->epp_timeout = 1;
parallel.c:        if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != PARA_CTR_INIT)
parallel.c:            if (qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_WRITE, &ioarg)) {
parallel.c:                s->epp_timeout = 1;
parallel.c:    if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != PARA_CTR_INIT) {
parallel.c:    err = qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_WRITE, &ioarg);
parallel.c:        s->epp_timeout = 1;
parallel.c:    if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != PARA_CTR_INIT) {
parallel.c:    err = qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_WRITE, &ioarg);
parallel.c:        s->epp_timeout = 1;
parallel.c:        if (s->control & PARA_CTR_DIR)
parallel.c:            ret = s->datar;
parallel.c:            ret = s->dataw;
parallel.c:        ret = s->status;
parallel.c:        s->irq_pending = 0;
parallel.c:        if ((s->status & PARA_STS_BUSY) == 0 && (s->control & PARA_CTR_STROBE) == 0) {
parallel.c:            if (s->status & PARA_STS_ACK)
parallel.c:                s->status &= ~PARA_STS_ACK;
parallel.c:                s->status |= PARA_STS_ACK;
parallel.c:                s->status |= PARA_STS_BUSY;
parallel.c:        ret = s->control;
parallel.c:        qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_READ_DATA, &ret);
parallel.c:        if (s->last_read_offset != addr || s->datar != ret)
parallel.c:        s->datar = ret;
parallel.c:        qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_READ_STATUS, &ret);
parallel.c:        if (s->epp_timeout)
parallel.c:        if (s->last_read_offset != addr || s->status != ret)
parallel.c:        s->status = ret;
parallel.c:        /* s->control has some bits fixed to 1. It is zero only when
parallel.c:        if (s->control == 0) {
parallel.c:            qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_READ_CONTROL, &ret);
parallel.c:            if (s->last_read_offset != addr)
parallel.c:            s->control = ret;
parallel.c:            ret = s->control;
parallel.c:            if (s->last_read_offset != addr)
parallel.c:        if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != (PARA_CTR_DIR|PARA_CTR_INIT))
parallel.c:            if (qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_READ_ADDR, &ioarg)) {
parallel.c:                s->epp_timeout = 1;
parallel.c:        if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != (PARA_CTR_DIR|PARA_CTR_INIT))
parallel.c:            if (qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_READ, &ioarg)) {
parallel.c:                s->epp_timeout = 1;
parallel.c:    s->last_read_offset = addr;
parallel.c:    if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != (PARA_CTR_DIR|PARA_CTR_INIT)) {
parallel.c:    err = qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_READ, &ioarg);
parallel.c:        s->epp_timeout = 1;
parallel.c:    if ((s->control & (PARA_CTR_DIR|PARA_CTR_SIGNAL)) != (PARA_CTR_DIR|PARA_CTR_INIT)) {
parallel.c:    err = qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_EPP_READ, &ioarg);
parallel.c:        s->epp_timeout = 1;
parallel.c:    s->datar = ~0;
parallel.c:    s->dataw = ~0;
parallel.c:    s->status = PARA_STS_BUSY;
parallel.c:    s->status |= PARA_STS_ACK;
parallel.c:    s->status |= PARA_STS_ONLINE;
parallel.c:    s->status |= PARA_STS_ERROR;
parallel.c:    s->status |= PARA_STS_TMOUT;
parallel.c:    s->control = PARA_CTR_SELECT;
parallel.c:    s->control |= PARA_CTR_INIT;
parallel.c:    s->control |= 0xc0;
parallel.c:    s->irq_pending = 0;
parallel.c:    s->hw_driver = 0;
parallel.c:    s->epp_timeout = 0;
parallel.c:    s->last_read_offset = ~0U;
parallel.c:    ParallelState *s = &isa->state;
parallel.c:    if (!s->chr) {
parallel.c:    if (isa->index == -1)
parallel.c:        isa->index = index;
parallel.c:    if (isa->index >= MAX_PARALLEL_PORTS)
parallel.c:        return -1;
parallel.c:    if (isa->iobase == -1)
parallel.c:        isa->iobase = isa_parallel_io[isa->index];
parallel.c:    base = isa->iobase;
parallel.c:    isa_init_irq(dev, &s->irq, isa->isairq);
parallel.c:    if (qemu_chr_ioctl(s->chr, CHR_IOCTL_PP_READ_STATUS, &dummy) == 0) {
parallel.c:        s->hw_driver = 1;
parallel.c:        s->status = dummy;
parallel.c:    if (s->hw_driver) {
parallel.c:    dev = isa_create("isa-parallel");
parallel.c:    qdev_prop_set_uint32(&dev->qdev, "index", index);
parallel.c:    qdev_prop_set_chr(&dev->qdev, "chardev", chr);
parallel.c:    if (qdev_init(&dev->qdev) < 0)
parallel.c:    return &DO_UPCAST(ISAParallelState, dev, dev)->state;
parallel.c:    return parallel_ioport_read_sw(s, addr >> s->it_shift) & 0xFF;
parallel.c:    parallel_ioport_write_sw(s, addr >> s->it_shift, value & 0xFF);
parallel.c:    return parallel_ioport_read_sw(s, addr >> s->it_shift) & 0xFFFF;
parallel.c:    parallel_ioport_write_sw(s, addr >> s->it_shift, value & 0xFFFF);
parallel.c:    return parallel_ioport_read_sw(s, addr >> s->it_shift);
parallel.c:    parallel_ioport_write_sw(s, addr >> s->it_shift, value);
parallel.c:    s->irq = irq;
parallel.c:    s->chr = chr;
parallel.c:    s->it_shift = it_shift;
parallel.c:    .qdev.name  = "isa-parallel",
parallel.c:        DEFINE_PROP_UINT32("index", ISAParallelState, index,   -1),
parallel.c:        DEFINE_PROP_HEX32("iobase", ISAParallelState, iobase,  -1),
pc.c: * Copyright (c) 2003-2004 Fabrice Bellard
pc.c:#include "usb-uhci.h"
pc.c:#include "usb-ohci.h"
pc.c:#include "device-assignment.h"
pc.c:#include "qemu-kvm.h"
pc.c:        qemu_set_irq(isa->i8259[n], level);
pc.c:    if (isa->ioapic)
pc.c:        qemu_set_irq(isa->ioapic[n], level);
pc.c:        i440fx_set_smm(i440fx_state, (env->hflags >> HF_SMM_SHIFT) & 1);
pc.c:        return -1;
pc.c:    if (env->apic_state) {
pc.c:            env = env->next_cpu;
pc.c:        return 0x03; /* CD-ROM boot */
pc.c:    val = (ram_size / 1024) - 1024;
pc.c:        val = (ram_size / 65536) - ((16 * 1024 * 1024) / 65536);
pc.c:    rtc_set_memory(s, 0x5f, smp_cpus - 1);
pc.c:        cmos_init_hd(0x19, 0x1b, hd_table[0]->bdrv);
pc.c:        cmos_init_hd(0x1a, 0x24, hd_table[1]->bdrv);
pc.c:            translation = bdrv_get_translation_hint(hd_table[i]->bdrv);
pc.c:                bdrv_get_geometry_hint(hd_table[i]->bdrv, &cylinders, &heads, &sectors);
pc.c:                translation--;
pc.c:    return ((first_cpu->a20_mask >> 20) & 1);
pc.c:     * of nodes, one word for each VCPU->node and one word for each node to
pc.c:       The header is 12x32bit long, so the latest entry may be 8192 - 48. */
pc.c:    for (i = 0; i < (8192 - 48); i += 4) {
pc.c:        mb_kernel_size = elf_high - elf_low;
pc.c:        fprintf(stderr, "qemu: loading multiboot-elf kernel (%#x bytes) with entry %#zx\n",
pc.c:        uint32_t mb_kernel_text_offset = i - (mh_header_addr - mh_load_addr);
pc.c:        mb_kernel_size = get_file_size(f) - mb_kernel_text_offset;
pc.c:                    sizeof(bootinfo) - mb_mod_cmdline,
pc.c:            mb_mod_start = (mb_mod_start + mb_mod_length + (TARGET_PAGE_SIZE - 1))
pc.c:                                          mb_mod_end - mh_load_addr);
pc.c:                       mb_kernel_data + mb_mod_start - mh_load_addr);
pc.c:    stl_p(bootinfo + 12, 0x8001ffff); /* XXX: use the -boot switch? */
pc.c:    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, mb_mod_end - mh_load_addr);
pc.c:                     mb_mod_end - mh_load_addr);
pc.c:	cmdline_addr = 0x9a000 - cmdline_size;
pc.c:	cmdline_addr = 0x9a000 - cmdline_size;
pc.c:    if (initrd_max >= max_ram_size-ACPI_DATA_SIZE)
pc.c:    	initrd_max = max_ram_size-ACPI_DATA_SIZE-1;
pc.c:	stw_p(header+0x22, cmdline_addr-real_addr);
pc.c:	stw_p(header+0x224, cmdline_addr-real_addr-0x200);
pc.c:        initrd_addr = (initrd_max-initrd_size) & ~4095;
pc.c:    kernel_size -= setup_size;
pc.c:    for (c = soundhw; c->name; ++c) {
pc.c:        if (c->enabled) {
pc.c:            if (c->isa) {
pc.c:                c->init.init_isa(pic);
pc.c:                    c->init.init_pci(pci_bus);
pc.c:    return env->cpuid_apic_id == 0;
pc.c:    env->kvm_cpu_state.regs_modified = 1;
pc.c:    if ((env->cpuid_features & CPUID_APIC) || smp_cpus > 1) {
pc.c:        env->cpuid_apic_id = env->cpu_index;
pc.c:    int piix3_devfn = -1;
pc.c:        above_4g_mem_size = ram_size - 0xe0000000;
pc.c:                 below_4g_mem_size - 0x100000,
pc.c:        hw_error("To much RAM for 32-bit physical address");
pc.c:        bios_size = -1;
pc.c:    ret = rom_add_file_fixed(bios_name, (uint32_t)(-bios_size));
pc.c:    cpu_register_physical_memory(0xd0000, (192 * 1024) - isa_bios_size,
pc.c:    cpu_register_physical_memory(0x100000 - isa_bios_size,
pc.c:                                 (bios_offset + bios_size - isa_bios_size) /* | IO_MEM_ROM */);
pc.c:    cpu_register_physical_memory((uint32_t)(-bios_size),
pc.c:        isa_irq_state->i8259 = i8259;
pc.c:        isa_irq_state->ioapic = ioapic_init();
pc.c:        if (!pci_enabled || (nd->model && strcmp(nd->model, "ne2k_isa") == 0))
pc.c:            eeprom = qdev_create((BusState *)smbus, "smbus-eeprom");
pc.c:            pci_create_simple(pci_bus, -1, "lsi53c895a");
pc.c:	if (info->type != IF_IDE && info->type != IF_VIRTIO) {
pc.c:	    bdrv_guess_geometry(info->bdrv, &cyls, &heads, &secs);
pc.c:	    bdrv_set_geometry_hint(info->bdrv, cyls, heads, secs);
pc.c:	extboot_init(info->bdrv, 1);
pc.c:                pci_create_simple(pci_bus, -1, "virtio-console-pci");
pc.c:    .name = "pc-0.12",
pc.c:    .name = "pc-0.11",
pc.c:            .driver   = "virtio-blk-pci",
pc.c:            .driver   = "ide-drive",
pc.c:            .driver   = "scsi-disk",
pc.c:    .name = "pc-0.10",
pc.c:            .driver   = "virtio-blk-pci",
pc.c:            .driver   = "virtio-console-pci",
pc.c:            .driver   = "virtio-net-pci",
pc.c:            .driver   = "virtio-blk-pci",
pc.c:            .driver   = "ide-drive",
pc.c:            .driver   = "scsi-disk",
pc.c:    .desc = "ISA-only PC",
pc.h:#include "qemu-common.h"
pc.h:/* PC-style peripherals (also used by other machines).  */
pc.h:/* i8254-kvm.c */
pci.c:#include "qemu-kvm.h"
pci.c:#include "device-assignment.h"
pci.c:        DEFINE_PROP_PCI_DEVFN("addr", PCIDevice, devfn, -1),
pci.c:    type = d->config[PCI_HEADER_TYPE] & ~PCI_HEADER_TYPE_MULTI_FUNCTION;
pci.c:	return (d->irq_state >> irq_num) & 0x1;
pci.c:	d->irq_state &= ~(0x1 << irq_num);
pci.c:	d->irq_state |= level << irq_num;
pci.c:        bus = pci_dev->bus;
pci.c:        irq_num = bus->map_irq(pci_dev, irq_num);
pci.c:        if (bus->set_irq)
pci.c:        pci_dev = bus->parent_dev;
pci.c:    bus->irq_count[irq_num] += change;
pci.c:    bus->set_irq(bus->irq_opaque, irq_num, bus->irq_count[irq_num] != 0);
pci.c:    if (dev->irq_state) {
pci.c:        dev->config[PCI_STATUS] |= PCI_STATUS_INTERRUPT;
pci.c:        dev->config[PCI_STATUS] &= ~PCI_STATUS_INTERRUPT;
pci.c:    dev->irq_state = 0;
pci.c:    dev->config[PCI_COMMAND] &= ~(PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
pci.c:    dev->config[PCI_CACHE_LINE_SIZE] = 0x0;
pci.c:    dev->config[PCI_INTERRUPT_LINE] = 0x0;
pci.c:        if (!dev->io_regions[r].size) {
pci.c:        pci_set_long(dev->config + pci_bar(dev, r), dev->io_regions[r].type);
pci.c:    for (i = 0; i < bus->nirq; i++) {
pci.c:        bus->irq_count[i] = 0;
pci.c:    for (i = 0; i < ARRAY_SIZE(bus->devices); ++i) {
pci.c:        if (bus->devices[i]) {
pci.c:            pci_device_reset(bus->devices[i]);
pci.c:    host->domain = domain;
pci.c:    host->bus = bus;
pci.c:        if (host->domain == domain) {
pci.c:            return host->bus;
pci.c:    qbus_create_inplace(&bus->qbus, &pci_bus_info, parent, name);
pci.c:    bus->devfn_min = devfn_min;
pci.c:    QLIST_INIT(&bus->child);
pci.c:    vmstate_register(-1, &vmstate_pcibus, bus);
pci.c:    bus->qbus.qdev_allocated = 1;
pci.c:    bus->set_irq = set_irq;
pci.c:    bus->map_irq = map_irq;
pci.c:    bus->irq_opaque = irq_opaque;
pci.c:    bus->nirq = nirq;
pci.c:    bus->irq_count = qemu_mallocz(nirq * sizeof(bus->irq_count[0]));
pci.c:    bus->qbus.allow_hotplug = 1;
pci.c:    bus->hotplug = hotplug;
pci.c:    qbus_create_inplace(&bus->qbus, &pci_bus_info, &dev->qdev, name);
pci.c:    bus->map_irq = map_irq;
pci.c:    bus->parent_dev = dev;
pci.c:    QLIST_INIT(&bus->child);
pci.c:    QLIST_INSERT_HEAD(&parent->child, bus, sibling);
pci.c:    assert(QLIST_EMPTY(&bus->child));
pci.c:    if (!s->parent_dev)
pci.c:    return s->parent_dev->config[PCI_SECONDARY_BUS];
pci.c:        if ((config[i] ^ s->config[i]) & s->cmask[i] & ~s->wmask[i]) {
pci.c:            return -EINVAL;
pci.c:    memcpy(s->config, config, size);
pci.c:            return -EINVAL;
pci.c:    s->config[PCI_STATUS] &= ~PCI_STATUS_INTERRUPT;
pci.c:    ret = vmstate_load_state(f, pci_get_vmstate(s), s, s->version_id);
pci.c:    id = (void*)(&pci_dev->config[PCI_SUBVENDOR_ID]);
pci.c: * Parse [[<domain>:]<bus>:]<slot>, return -1 on error
pci.c:	return -1;
pci.c:	    return -1;
pci.c:		return -1;
pci.c:	return -1;
pci.c:	return -1;
pci.c:	return -1;
pci.c: * -pcidevice host=bus:dev.func
pci.c: * Parse <bus>:<slot>.<func> return -1 on error
pci.c:	return -1;
pci.c:	    return -1;
pci.c:		return -1;
pci.c:	    return -1;
pci.c:	return -1;
pci.c:	return -1;
pci.c:	return -1;
pci.c:        return -1;
pci.c:        *devfnp = -1;
pci.c:    pci_set_word(dev->cmask + PCI_VENDOR_ID, 0xffff);
pci.c:    pci_set_word(dev->cmask + PCI_DEVICE_ID, 0xffff);
pci.c:    dev->cmask[PCI_STATUS] = PCI_STATUS_CAP_LIST;
pci.c:    dev->cmask[PCI_REVISION_ID] = 0xff;
pci.c:    dev->cmask[PCI_CLASS_PROG] = 0xff;
pci.c:    pci_set_word(dev->cmask + PCI_CLASS_DEVICE, 0xffff);
pci.c:    dev->cmask[PCI_HEADER_TYPE] = 0xff;
pci.c:    dev->cmask[PCI_CAPABILITY_LIST] = 0xff;
pci.c:    dev->wmask[PCI_CACHE_LINE_SIZE] = 0xff;
pci.c:    dev->wmask[PCI_INTERRUPT_LINE] = 0xff;
pci.c:    pci_set_word(dev->wmask + PCI_COMMAND,
pci.c:    memset(dev->wmask + PCI_CONFIG_HEADER_SIZE, 0xff,
pci.c:           config_size - PCI_CONFIG_HEADER_SIZE);
pci.c:    memset(d->wmask + PCI_PRIMARY_BUS, 0xff, 4);
pci.c:    d->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff;
pci.c:    d->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff;
pci.c:    pci_set_word(d->wmask + PCI_MEMORY_BASE,
pci.c:    pci_set_word(d->wmask + PCI_MEMORY_LIMIT,
pci.c:    pci_set_word(d->wmask + PCI_PREF_MEMORY_BASE,
pci.c:    pci_set_word(d->wmask + PCI_PREF_MEMORY_LIMIT,
pci.c:    memset(d->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8);
pci.c:    pci_set_word(d->wmask + PCI_BRIDGE_CONTROL, 0xffff);
pci.c:    pci_dev->config = qemu_mallocz(config_size);
pci.c:    pci_dev->cmask = qemu_mallocz(config_size);
pci.c:    pci_dev->wmask = qemu_mallocz(config_size);
pci.c:    pci_dev->used = qemu_mallocz(config_size);
pci.c:    qemu_free(pci_dev->config);
pci.c:    qemu_free(pci_dev->cmask);
pci.c:    qemu_free(pci_dev->wmask);
pci.c:    qemu_free(pci_dev->used);
pci.c:/* -1 for devfn means auto assign */
pci.c:        for(devfn = bus->devfn_min ; devfn < ARRAY_SIZE(bus->devices);
pci.c:            if (!bus->devices[devfn])
pci.c:    } else if (bus->devices[devfn]) {
pci.c:                 name, bus->devices[devfn]->name);
pci.c:    pci_dev->bus = bus;
pci.c:    pci_dev->devfn = devfn;
pci.c:    pstrcpy(pci_dev->name, sizeof(pci_dev->name), name);
pci.c:    pci_dev->irq_state = 0;
pci.c:    pci_dev->config_read = config_read;
pci.c:    pci_dev->config_write = config_write;
pci.c:    bus->devices[devfn] = pci_dev;
pci.c:    pci_dev->irq = qemu_allocate_irqs(pci_set_irq, pci_dev, PCI_NUM_PINS);
pci.c:    pci_dev->version_id = 2; /* Current pci device vmstate version */
pci.c:        r = &pci_dev->io_regions[i];
pci.c:        if (!r->size || r->addr == PCI_BAR_UNMAPPED)
pci.c:        if (r->type == PCI_BASE_ADDRESS_SPACE_IO) {
pci.c:            isa_unassign_ioport(r->addr, r->filtered_size);
pci.c:            cpu_register_physical_memory(pci_to_cpu_addr(r->addr),
pci.c:                                                     r->filtered_size,
pci.c:    PCIDeviceInfo *info = DO_UPCAST(PCIDeviceInfo, qdev, dev->info);
pci.c:    if (info->exit)
pci.c:        ret = info->exit(pci_dev);
pci.c:    qemu_free_irqs(pci_dev->irq);
pci.c:    pci_dev->bus->devices[pci_dev->devfn] = NULL;
pci.c:    if (size & (size-1)) {
pci.c:    r = &pci_dev->io_regions[region_num];
pci.c:    r->addr = PCI_BAR_UNMAPPED;
pci.c:    r->size = size;
pci.c:    r->filtered_size = size;
pci.c:    r->type = type;
pci.c:    r->map_func = map_func;
pci.c:    wmask = ~(size - 1);
pci.c:    pci_set_long(pci_dev->config + addr, type);
pci.c:    if (!(r->type & PCI_BASE_ADDRESS_SPACE_IO) &&
pci.c:        r->type & PCI_BASE_ADDRESS_MEM_TYPE_64) {
pci.c:        pci_set_quad(pci_dev->wmask + addr, wmask);
pci.c:        pci_set_quad(pci_dev->cmask + addr, ~0ULL);
pci.c:        pci_set_long(pci_dev->wmask + addr, wmask & 0xffffffff);
pci.c:        pci_set_long(pci_dev->cmask + addr, 0xffffffff);
pci.c:    val = ((uint32_t)d->config[base] & PCI_IO_RANGE_MASK) << 8;
pci.c:    if (d->config[base] & PCI_IO_RANGE_TYPE_32) {
pci.c:        val |= (uint32_t)pci_get_word(d->config + base_upper16) << 16;
pci.c:    return ((pcibus_t)pci_get_word(d->config + base) & PCI_MEMORY_RANGE_MASK)
pci.c:    tmp = (pcibus_t)pci_get_word(d->config + base);
pci.c:        val |= (pcibus_t)pci_get_long(d->config + upper) << 32;
pci.c:    pcibus_t limit = *addr + *size - 1;
pci.c:    for (br = d->bus->parent_dev; br; br = br->bus->parent_dev) {
pci.c:        uint16_t cmd = pci_get_word(d->config + PCI_COMMAND);
pci.c:    *size = limit - base + 1;
pci.c:    uint16_t cmd = pci_get_word(d->config + PCI_COMMAND);
pci.c:        new_addr = pci_get_long(d->config + bar) & ~(size - 1);
pci.c:        last_addr = new_addr + size - 1;
pci.c:        new_addr = pci_get_quad(d->config + bar);
pci.c:        new_addr = pci_get_long(d->config + bar);
pci.c:    new_addr &= ~(size - 1);
pci.c:    last_addr = new_addr + size - 1;
pci.c:        r = &d->io_regions[i];
pci.c:        if (!r->size)
pci.c:        new_addr = pci_bar_address(d, i, r->type, r->size);
pci.c:        filtered_size = r->size;
pci.c:            pci_bridge_filter(d, &new_addr, &filtered_size, r->type);
pci.c:        if (new_addr == r->addr && filtered_size == r->filtered_size)
pci.c:        if (r->addr != PCI_BAR_UNMAPPED) {
pci.c:            if (r->type & PCI_BASE_ADDRESS_SPACE_IO) {
pci.c:                class = pci_get_word(d->config + PCI_CLASS_DEVICE);
pci.c:                if (class == 0x0101 && r->size == 4) {
pci.c:                    isa_unassign_ioport(r->addr + 2, 1);
pci.c:                    isa_unassign_ioport(r->addr, r->filtered_size);
pci.c:                cpu_register_physical_memory(pci_to_cpu_addr(r->addr),
pci.c:                                             r->filtered_size,
pci.c:                qemu_unregister_coalesced_mmio(r->addr, r->filtered_size);
pci.c:        r->addr = new_addr;
pci.c:        r->filtered_size = filtered_size;
pci.c:        if (r->addr != PCI_BAR_UNMAPPED) {
pci.c:             * filtered_size == size and addr & ~(size - 1) == addr.
pci.c:             * addr & (size - 1) != 0.
pci.c:            r->map_func(d, i, r->addr, r->filtered_size, r->type);
pci.c:    len = MIN(len, pci_config_size(d) - address);
pci.c:    memcpy(&val, d->config + address, len);
pci.c:        return d->cap.config_read(d, address, len);
pci.c:        pci_dev->config[address + i] = val & 0xff;
pci.c:    if (pci_dev->cap.supported && address >= pci_dev->cap.start &&
pci.c:            (address + len) < pci_dev->cap.start + pci_dev->cap.length)
pci.c:        d->cap.config_write(d, addr, val, l);
pci.c:        uint8_t wmask = d->wmask[addr + i];
pci.c:        d->config[addr + i] = (d->config[addr + i] & ~wmask) | (val & wmask);
pci.c:    change = level - pci_irq_state(pci_dev, irq_num);
pci.c:    return pci_dev->bus->map_irq(pci_dev, pin);
pci.c:                   pci_bus_num(d->bus),
pci.c:                   PCI_SLOT(d->devfn), PCI_FUNC(d->devfn));
pci.c:    class = pci_get_word(d->config + PCI_CLASS_DEVICE);
pci.c:    while (desc->desc && class != desc->class)
pci.c:    if (desc->desc) {
pci.c:        monitor_printf(mon, "%s", desc->desc);
pci.c:           pci_get_word(d->config + PCI_VENDOR_ID),
pci.c:           pci_get_word(d->config + PCI_DEVICE_ID));
pci.c:    if (d->config[PCI_INTERRUPT_PIN] != 0) {
pci.c:                       d->config[PCI_INTERRUPT_LINE]);
pci.c:        monitor_printf(mon, "      BUS %d.\n", d->config[0x19]);
pci.c:                       d->config[PCI_SECONDARY_BUS]);
pci.c:                       d->config[PCI_SUBORDINATE_BUS]);
pci.c:        r = &d->io_regions[i];
pci.c:        if (r->size != 0) {
pci.c:            if (r->type & PCI_BASE_ADDRESS_SPACE_IO) {
pci.c:                               r->addr, r->addr + r->size - 1);
pci.c:                const char *type = r->type & PCI_BASE_ADDRESS_MEM_TYPE_64 ?
pci.c:                    r->type & PCI_BASE_ADDRESS_MEM_PREFETCH ?
pci.c:                               r->addr, r->addr + r->size - 1);
pci.c:    monitor_printf(mon, "      id \"%s\"\n", d->qdev.id ? d->qdev.id : "");
pci.c:    if (class == 0x0604 && d->config[0x19] != 0) {
pci.c:        pci_for_each_device(bus, d->config[0x19], pci_info_device);
pci.c:    for(devfn = 0; devfn < ARRAY_SIZE(bus->devices); devfn++) {
pci.c:        d = bus->devices[devfn];
pci.c:        pci_for_each_device(host->bus, 0, pci_info_device);
pci.c:    "virtio-net-pci",
pci.c:    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;
pci.c:    dev = &pci_dev->qdev;
pci.c:    if (nd->name)
pci.c:        dev->id = qemu_strdup(nd->name);
pci.c:    if (qemu_show_nic_models(nd->model, pci_nic_models))
pci.c:    QLIST_FOREACH(child, &b->child, sibling) {
pci.c:        pci_bridge_update_mappings(d->bus);
pci.c:    QLIST_FOREACH(sec, &bus->child, sibling) {
pci.c:        if (!bus->parent_dev /* pci host bridge */
pci.c:                bus->parent_dev->config[PCI_SUBORDINATE_BUS])) {
pci.c:    return bus->devices[PCI_DEVFN(slot, function)];
pci.c:    pci_config_set_vendor_id(s->dev.config, s->vid);
pci.c:    pci_config_set_device_id(s->dev.config, s->did);
pci.c:    pci_set_word(dev->config + PCI_STATUS,
pci.c:    pci_config_set_class(dev->config, PCI_CLASS_BRIDGE_PCI);
pci.c:    dev->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_BRIDGE;
pci.c:    pci_set_word(dev->config + PCI_SEC_STATUS,
pci.c:    PCIBus *bus = &s->bus;
pci.c:    dev = pci_create(bus, devfn, "pci-bridge");
pci.c:    qdev_prop_set_uint32(&dev->qdev, "vendorid", vid);
pci.c:    qdev_prop_set_uint32(&dev->qdev, "deviceid", did);
pci.c:    qdev_init_nofail(&dev->qdev);
pci.c:    pci_register_secondary_bus(bus, &s->bus, &s->dev, map_irq, name);
pci.c:    return &s->bus;
pci.c:    return bus->parent_dev;
pci.c:    if (info->is_express) {
pci.c:        pci_dev->cap_present |= QEMU_PCI_CAP_EXPRESS;
pci.c:    devfn = pci_dev->devfn;
pci.c:    pci_dev = do_pci_register_device(pci_dev, bus, base->name, devfn,
pci.c:                                     info->config_read, info->config_write,
pci.c:                                     info->header_type);
pci.c:        return -1;
pci.c:    rc = info->init(pci_dev);
pci.c:    if (pci_dev->romfile == NULL && info->romfile != NULL)
pci.c:        pci_dev->romfile = qemu_strdup(info->romfile);
pci.c:    if (qdev->hotplugged)
pci.c:        bus->hotplug(pci_dev, 1);
pci.c:    dev->bus->hotplug(dev, 0);
pci.c:    info->qdev.init = pci_qdev_init;
pci.c:    info->qdev.unplug = pci_unplug_device;
pci.c:    info->qdev.exit = pci_unregister_device;
pci.c:    info->qdev.bus_info = &pci_bus_info;
pci.c:    qdev_register(&info->qdev);
pci.c:    while (info->qdev.name) {
pci.c:    dev = qdev_create(&bus->qbus, name);
pci.c:    qdev_init_nofail(&dev->qdev);
pci.c:        return -ENODEV;
pci.c:    pci_dev->config[0x06] |= 0x10; // status = capabilities
pci.c:	pci_dev->cap.start = PCI_CAPABILITY_CONFIG_DEFAULT_START_ADDR;
pci.c:        pci_dev->cap.start = config_start;
pci.c:        return -EINVAL;
pci.c:        pci_dev->cap.config_read = config_read;
pci.c:        pci_dev->cap.config_read = pci_default_cap_read_config;
pci.c:        pci_dev->cap.config_write = config_write;
pci.c:        pci_dev->cap.config_write = pci_default_cap_write_config;
pci.c:    pci_dev->cap.supported = 1;
pci.c:    pci_dev->config[PCI_CAPABILITY_LIST] = pci_dev->cap.start;
pci.c:        if (pdev->used[i])
pci.c:        else if (i - offset + 1 == size)
pci.c:    if (!(pdev->config[PCI_STATUS] & PCI_STATUS_CAP_LIST))
pci.c:    for (prev = PCI_CAPABILITY_LIST; (next = pdev->config[prev]);
pci.c:        if (pdev->config[next + PCI_CAP_LIST_ID] == cap_id)
pci.c:    cpu_register_physical_memory(addr, size, pdev->rom_offset);
pci.c:    if (!pdev->romfile)
pci.c:    if (strlen(pdev->romfile) == 0)
pci.c:    if (!pdev->rom_bar) {
pci.c:        int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE);
pci.c:            rom_add_vga(pdev->romfile);
pci.c:            rom_add_option(pdev->romfile);
pci.c:    path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile);
pci.c:        path = qemu_strdup(pdev->romfile);
pci.c:                   pdev->romfile);
pci.c:        return -1;
pci.c:    if (size & (size - 1)) {
pci.c:    pdev->rom_offset = qemu_ram_alloc(size);
pci.c:    ptr = qemu_get_ram_ptr(pdev->rom_offset);
pci.c:    uint8_t *config = pdev->config + offset;
pci.c:        return -ENOSPC;
pci.c:    config[PCI_CAP_LIST_NEXT] = pdev->config[PCI_CAPABILITY_LIST];
pci.c:    pdev->config[PCI_CAPABILITY_LIST] = offset;
pci.c:    pdev->config[PCI_STATUS] |= PCI_STATUS_CAP_LIST;
pci.c:    memset(pdev->used + offset, 0xFF, size);
pci.c:    /* Make capability read-only by default */
pci.c:    memset(pdev->wmask + offset, 0, size);
pci.c:    memset(pdev->cmask + offset, 0xFF, size);
pci.c:    pdev->config[prev] = pdev->config[offset + PCI_CAP_LIST_NEXT];
pci.c:    memset(pdev->wmask + offset, 0xff, size);
pci.c:    /* Clear cmask as device-specific registers can't be checked */
pci.c:    memset(pdev->cmask + offset, 0, size);
pci.c:    memset(pdev->used + offset, 0, size);
pci.c:    if (!pdev->config[PCI_CAPABILITY_LIST])
pci.c:        pdev->config[PCI_STATUS] &= ~PCI_STATUS_CAP_LIST;
pci.c:    memset(pdev->used + offset, 0xff, size);
pci.c:    class = pci_get_word(d->config + PCI_CLASS_DEVICE);
pci.c:    while (desc->desc && class != desc->class)
pci.c:    if (desc->desc) {
pci.c:        snprintf(ctxt, sizeof(ctxt), "%s", desc->desc);
pci.c:                   d->config[PCI_SECONDARY_BUS],
pci.c:                   PCI_SLOT(d->devfn), PCI_FUNC(d->devfn),
pci.c:                   pci_get_word(d->config + PCI_VENDOR_ID),
pci.c:                   pci_get_word(d->config + PCI_DEVICE_ID),
pci.c:                   pci_get_word(d->config + PCI_SUBSYSTEM_VENDOR_ID),
pci.c:                   pci_get_word(d->config + PCI_SUBSYSTEM_ID));
pci.c:        r = &d->io_regions[i];
pci.c:        if (!r->size)
pci.c:                       i, r->type & PCI_BASE_ADDRESS_SPACE_IO ? "i/o" : "mem",
pci.c:                       r->addr, r->addr + r->size - 1);
pci.c:    .qdev.name    = "pci-bridge",
pcie_host.c: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
pcie_host.c: * bit 20 - 28: bus number
pcie_host.c: * bit 15 - 19: device number
pcie_host.c: * bit 12 - 14: function number
pcie_host.c: * bit  0 - 11: offset in configuration space of a given device
pcie_host.c:    pci_dev->config_write(pci_dev,
pcie_host.c:    return pci_dev->config_read(pci_dev, PCIE_MMCFG_CONFOFFSET(addr), len);
pcie_host.c:    pcie_mmcfg_data_write(e->pci.bus, addr - e->base_addr, value, 1);
pcie_host.c:    pcie_mmcfg_data_write(e->pci.bus, addr - e->base_addr, value, 2);
pcie_host.c:    pcie_mmcfg_data_write(e->pci.bus, addr - e->base_addr, value, 4);
pcie_host.c:    return pcie_mmcfg_data_read(e->pci.bus, addr - e->base_addr, 1);
pcie_host.c:    return pcie_mmcfg_data_read(e->pci.bus, addr - e->base_addr, 2);
pcie_host.c:    return pcie_mmcfg_data_read(e->pci.bus, addr - e->base_addr, 4);
pcie_host.c:#define PCIE_BASE_ADDR_UNMAPPED  ((target_phys_addr_t)-1ULL)
pcie_host.c:    e->base_addr = PCIE_BASE_ADDR_UNMAPPED;
pcie_host.c:    e->mmio_index =
pcie_host.c:    if (e->mmio_index < 0) {
pcie_host.c:        return -1;
pcie_host.c:    if (e->base_addr != PCIE_BASE_ADDR_UNMAPPED) {
pcie_host.c:        cpu_register_physical_memory(e->base_addr, e->size, IO_MEM_UNASSIGNED);
pcie_host.c:        e->base_addr = PCIE_BASE_ADDR_UNMAPPED;
pcie_host.c:    assert(!(size & (size - 1)));       /* power of 2 */
pcie_host.c:    e->base_addr = addr;
pcie_host.c:    e->size = size;
pcie_host.c:    cpu_register_physical_memory(e->base_addr, e->size, e->mmio_index);
pcie_host.h: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
pci.h:#include "qemu-common.h"
pci.h:/* QEMU-specific Vendor and Device ID definitions */
pci.h:/* Red Hat / Qumranet (for QEMU) -- see pci-ids.txt */
pci.h:    pcibus_t addr; /* current PCI mapping address. -1 means not mapped */
pci.h:#define PCI_NUM_PINS 4 /* A-D */
pci.h:    /* IRQ objects for the INTA-INTD pins.  */
pci.h:    /* Offset of MSI-X capability in config space */
pci.h:    /* MSI-X entries */
pci.h:    /* Reference-count for entries actually in use by driver. */
pci.h:    /* Region including the MSI-X table */
pci.h:    return d->cap_present & QEMU_PCI_CAP_EXPRESS;
pci.h:    return offset + len - 1;
pci_host.c: * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
pci_host.c: * bit 16 - 24: bus number
pci_host.c: * bit  8 - 15: devfun number
pci_host.c: * bit  0 -  7: offset in configuration space of a given pci device
pci_host.c:    uint32_t config_addr = addr & (PCI_CONFIG_SPACE_SIZE - 1);
pci_host.c:                __func__, pci_dev->name, config_addr, val, len);
pci_host.c:    pci_dev->config_write(pci_dev, config_addr, val, len);
pci_host.c:    uint32_t config_addr = addr & (PCI_CONFIG_SPACE_SIZE - 1);
pci_host.c:    val = pci_dev->config_read(pci_dev, config_addr, len);
pci_host.c:                __func__, pci_dev->name, config_addr, val, len);
pci_host.c:    s->config_reg = val;
pci_host.c:    uint32_t val = s->config_reg;
pci_host.c:    s->config_reg = val;
pci_host.c:    uint32_t val = s->config_reg;
pci_host.c:    s->config_reg = val;
pci_host.c:    uint32_t val = s->config_reg;
pci_host_template.h:    if (s->config_reg & (1u << 31))
pci_host_template.h:        pci_data_write(s->bus, s->config_reg | (addr & 3), val, 1);
pci_host_template.h:    if (s->config_reg & (1u << 31))
pci_host_template.h:        pci_data_write(s->bus, s->config_reg | (addr & 3), val, 2);
pci_host_template.h:    if (s->config_reg & (1u << 31))
pci_host_template.h:        pci_data_write(s->bus, s->config_reg, val, 4);
pci_host_template.h:    if (!(s->config_reg & (1 << 31)))
pci_host_template.h:    val = pci_data_read(s->bus, s->config_reg | (addr & 3), 1);
pci_host_template.h:    if (!(s->config_reg & (1 << 31)))
pci_host_template.h:    val = pci_data_read(s->bus, s->config_reg | (addr & 3), 2);
pci_host_template.h:    if (!(s->config_reg & (1 << 31)))
pci_host_template.h:    val = pci_data_read(s->bus, s->config_reg | (addr & 3), 4);
pci-hotplug.c:#include "virtio-blk.h"
pci-hotplug.c:#include "qemu-config.h"
pci-hotplug.c:#include "qemu-objects.h"
pci-hotplug.c:#include "device-assignment.h"
pci-hotplug.c:    if (!((BusState*)bus)->allow_hotplug) {
pci-hotplug.c:    scsibus = DO_UPCAST(SCSIBus, qbus, QLIST_FIRST(&adapter->child_bus));
pci-hotplug.c:    if (!scsibus || strcmp(scsibus->qbus.info->name, "SCSI") != 0) {
pci-hotplug.c:        return -1;
pci-hotplug.c:     * drive_init() tries to find a default for dinfo->unit.  Doesn't
pci-hotplug.c:    dinfo->unit = qemu_opt_get_number(dinfo->opts, "unit", -1);
pci-hotplug.c:    scsidev = scsi_bus_legacy_add_drive(scsibus, dinfo, dinfo->unit);
pci-hotplug.c:    dinfo->unit = scsidev->id;
pci-hotplug.c:        qemu_error("OK bus %d, unit %d\n", scsibus->busnr, scsidev->id);
pci-hotplug.c:    if (dinfo->devaddr) {
pci-hotplug.c:    type = dinfo->type;
pci-hotplug.c:        if (scsi_hot_add(&dev->qdev, dinfo, 1) != 0) {
pci-hotplug.c:        monitor_printf(mon, "Can't hot-add drive to type %d\n", type);
pci-hotplug.c:    int type = -1;
pci-hotplug.c:        if (dinfo->devaddr) {
pci-hotplug.c:    if (!((BusState*)bus)->allow_hotplug) {
pci-hotplug.c:        if (qdev_init(&dev->qdev) < 0)
pci-hotplug.c:            if (scsi_hot_add(&dev->qdev, dinfo, 0) != 0) {
pci-hotplug.c:                qdev_unplug(&dev->qdev);
pci-hotplug.c:        dev = pci_create(bus, devfn, "virtio-blk-pci");
pci-hotplug.c:        qdev_prop_set_drive(&dev->qdev, "drive", dinfo);
pci-hotplug.c:        if (qdev_init(&dev->qdev) < 0)
pci-hotplug.c: * - "domain": domain number
pci-hotplug.c: * - "bus": bus number
pci-hotplug.c: * - "slot": slot number
pci-hotplug.c: * - "function": function number
pci-hotplug.c:                           "'function': %d }", pci_bus_num(dev->bus),
pci-hotplug.c:                           PCI_SLOT(dev->devfn), PCI_FUNC(dev->devfn));
pci-hotplug.c:    qdev_unplug(&d->qdev);
pci_ids.h: *      QEMU-specific definitions belong in pci.h
pckbd.c:    s->status &= ~(KBD_STAT_OBF | KBD_STAT_MOUSE_OBF);
pckbd.c:    if (s->pending) {
pckbd.c:        s->status |= KBD_STAT_OBF;
pckbd.c:        if (s->pending == KBD_PENDING_AUX) {
pckbd.c:            s->status |= KBD_STAT_MOUSE_OBF;
pckbd.c:            if (s->mode & KBD_MODE_MOUSE_INT)
pckbd.c:            if ((s->mode & KBD_MODE_KBD_INT) &&
pckbd.c:                !(s->mode & KBD_MODE_DISABLE_KBD))
pckbd.c:    qemu_set_irq(s->irq_kbd, irq_kbd_level);
pckbd.c:    qemu_set_irq(s->irq_mouse, irq_mouse_level);
pckbd.c:        s->pending |= KBD_PENDING_KBD;
pckbd.c:        s->pending &= ~KBD_PENDING_KBD;
pckbd.c:        s->pending |= KBD_PENDING_AUX;
pckbd.c:        s->pending &= ~KBD_PENDING_AUX;
pckbd.c:    val = s->status;
pckbd.c:        ps2_queue(s->mouse, b);
pckbd.c:        ps2_queue(s->kbd, b);
pckbd.c:        kbd_queue(s, s->mode, 0);
pckbd.c:        s->write_cmd = val;
pckbd.c:        s->mode |= KBD_MODE_DISABLE_MOUSE;
pckbd.c:        s->mode &= ~KBD_MODE_DISABLE_MOUSE;
pckbd.c:        s->status |= KBD_STAT_SELFTEST;
pckbd.c:        s->mode |= KBD_MODE_DISABLE_KBD;
pckbd.c:        s->mode &= ~KBD_MODE_DISABLE_KBD;
pckbd.c:        if (s->status & KBD_STAT_OBF)
pckbd.c:        if (s->status & KBD_STAT_MOUSE_OBF)
pckbd.c:        /* ignore that - I don't know what is its use */
pckbd.c:    if (s->pending == KBD_PENDING_AUX)
pckbd.c:        val = ps2_read_data(s->mouse);
pckbd.c:        val = ps2_read_data(s->kbd);
pckbd.c:    switch(s->write_cmd) {
pckbd.c:        ps2_write_keyboard(s->kbd, val);
pckbd.c:        s->mode = val;
pckbd.c:        ps2_keyboard_set_translation(s->kbd, (s->mode & KBD_MODE_KCC) != 0);
pckbd.c:        ps2_write_mouse(s->mouse, val);
pckbd.c:    s->write_cmd = 0;
pckbd.c:    s->mode = KBD_MODE_KBD_INT | KBD_MODE_MOUSE_INT;
pckbd.c:    s->status = KBD_STAT_CMD | KBD_STAT_UNLOCKED;
pckbd.c:    if (addr & s->mask)
pckbd.c:    if (addr & s->mask)
pckbd.c:    s->irq_kbd = kbd_irq;
pckbd.c:    s->irq_mouse = mouse_irq;
pckbd.c:    s->mask = mask;
pckbd.c:    s->kbd = ps2_kbd_init(kbd_update_kbd_irq, s);
pckbd.c:    s->mouse = ps2_mouse_init(kbd_update_aux_irq, s);
pckbd.c:    vmmouse_init(s->mouse);
pckbd.c:    KBDState *s = &(DO_UPCAST(ISAKBDState, dev, dev)->kbd);
pckbd.c:    isa_init_irq(dev, &s->irq_kbd, 1);
pckbd.c:    isa_init_irq(dev, &s->irq_mouse, 12);
pckbd.c:    s->kbd = ps2_kbd_init(kbd_update_kbd_irq, s);
pckbd.c:    s->mouse = ps2_mouse_init(kbd_update_aux_irq, s);
pckbd.c:    vmmouse_init(s->mouse);
pcmcia.h:#include "qemu-common.h"
pcmcia.h:#define CISTPL_CFTABLE_ENTRY	0x1b	/* 16-bit PCCard Configuration */
pcnet.c: * QEMU AMD PC-Net II (Am79C970A) emulation
pcnet.c: * AMD Am79C970A PCnet-PCI II Ethernet Controller Data-Sheet
pcnet.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C100.txt
pcnet.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR92C990.txt
pcnet.c:#include "qemu-timer.h"
pcnet.c:#define BCR_DWIO(S)      !!((S)->bcr[BCR_BSBC] & 0x0080)
pcnet.c:#define BCR_SSIZE32(S)   !!((S)->bcr[BCR_SWS ] & 0x0100)
pcnet.c:#define BCR_SWSTYLE(S)     ((S)->bcr[BCR_SWS ] & 0x00FF)
pcnet.c:#define CSR_INIT(S)      !!(((S)->csr[0])&0x0001)
pcnet.c:#define CSR_STRT(S)      !!(((S)->csr[0])&0x0002)
pcnet.c:#define CSR_STOP(S)      !!(((S)->csr[0])&0x0004)
pcnet.c:#define CSR_TDMD(S)      !!(((S)->csr[0])&0x0008)
pcnet.c:#define CSR_TXON(S)      !!(((S)->csr[0])&0x0010)
pcnet.c:#define CSR_RXON(S)      !!(((S)->csr[0])&0x0020)
pcnet.c:#define CSR_INEA(S)      !!(((S)->csr[0])&0x0040)
pcnet.c:#define CSR_BSWP(S)      !!(((S)->csr[3])&0x0004)
pcnet.c:#define CSR_LAPPEN(S)    !!(((S)->csr[3])&0x0020)
pcnet.c:#define CSR_DXSUFLO(S)   !!(((S)->csr[3])&0x0040)
pcnet.c:#define CSR_ASTRP_RCV(S) !!(((S)->csr[4])&0x0800)
pcnet.c:#define CSR_DPOLL(S)     !!(((S)->csr[4])&0x1000)
pcnet.c:#define CSR_SPND(S)      !!(((S)->csr[5])&0x0001)
pcnet.c:#define CSR_LTINTEN(S)   !!(((S)->csr[5])&0x4000)
pcnet.c:#define CSR_TOKINTD(S)   !!(((S)->csr[5])&0x8000)
pcnet.c:#define CSR_DRX(S)       !!(((S)->csr[15])&0x0001)
pcnet.c:#define CSR_DTX(S)       !!(((S)->csr[15])&0x0002)
pcnet.c:#define CSR_LOOP(S)      !!(((S)->csr[15])&0x0004)
pcnet.c:#define CSR_DXMTFCS(S)   !!(((S)->csr[15])&0x0008)
pcnet.c:#define CSR_DRCVPA(S)    !!(((S)->csr[15])&0x2000)
pcnet.c:#define CSR_DRCVBC(S)    !!(((S)->csr[15])&0x4000)
pcnet.c:#define CSR_PROM(S)      !!(((S)->csr[15])&0x8000)
pcnet.c:#define CSR_CRBC(S)      ((S)->csr[40])
pcnet.c:#define CSR_CRST(S)      ((S)->csr[41])
pcnet.c:#define CSR_CXBC(S)      ((S)->csr[42])
pcnet.c:#define CSR_CXST(S)      ((S)->csr[43])
pcnet.c:#define CSR_NRBC(S)      ((S)->csr[44])
pcnet.c:#define CSR_NRST(S)      ((S)->csr[45])
pcnet.c:#define CSR_POLL(S)      ((S)->csr[46])
pcnet.c:#define CSR_PINT(S)      ((S)->csr[47])
pcnet.c:#define CSR_RCVRC(S)     ((S)->csr[72])
pcnet.c:#define CSR_XMTRC(S)     ((S)->csr[74])
pcnet.c:#define CSR_RCVRL(S)     ((S)->csr[76])
pcnet.c:#define CSR_XMTRL(S)     ((S)->csr[78])
pcnet.c:#define CSR_MISSC(S)     ((S)->csr[112])
pcnet.c:#define CSR_IADR(S)      ((S)->csr[ 1] | ((S)->csr[ 2] << 16))
pcnet.c:#define CSR_CRBA(S)      ((S)->csr[18] | ((S)->csr[19] << 16))
pcnet.c:#define CSR_CXBA(S)      ((S)->csr[20] | ((S)->csr[21] << 16))
pcnet.c:#define CSR_NRBA(S)      ((S)->csr[22] | ((S)->csr[23] << 16))
pcnet.c:#define CSR_BADR(S)      ((S)->csr[24] | ((S)->csr[25] << 16))
pcnet.c:#define CSR_NRDA(S)      ((S)->csr[26] | ((S)->csr[27] << 16))
pcnet.c:#define CSR_CRDA(S)      ((S)->csr[28] | ((S)->csr[29] << 16))
pcnet.c:#define CSR_BADX(S)      ((S)->csr[30] | ((S)->csr[31] << 16))
pcnet.c:#define CSR_NXDA(S)      ((S)->csr[32] | ((S)->csr[33] << 16))
pcnet.c:#define CSR_CXDA(S)      ((S)->csr[34] | ((S)->csr[35] << 16))
pcnet.c:#define CSR_NNRD(S)      ((S)->csr[36] | ((S)->csr[37] << 16))
pcnet.c:#define CSR_NNXD(S)      ((S)->csr[38] | ((S)->csr[39] << 16))
pcnet.c:#define CSR_PXDA(S)      ((S)->csr[60] | ((S)->csr[61] << 16))
pcnet.c:#define CSR_NXBA(S)      ((S)->csr[64] | ((S)->csr[65] << 16))
pcnet.c:  (BCR_SSIZE32(S) ? (A) : (A) | ((0xff00 & (uint32_t)(s)->csr[2])<<16))
pcnet.c:        (T)->tbadr,                                     \
pcnet.c:        GET_FIELD((T)->status, TMDS, OWN),              \
pcnet.c:        GET_FIELD((T)->status, TMDS, ERR),              \
pcnet.c:        GET_FIELD((T)->status, TMDS, NOFCS),            \
pcnet.c:        GET_FIELD((T)->status, TMDS, LTINT),            \
pcnet.c:        GET_FIELD((T)->status, TMDS, ONE),              \
pcnet.c:        GET_FIELD((T)->status, TMDS, DEF),              \
pcnet.c:        GET_FIELD((T)->status, TMDS, STP),              \
pcnet.c:        GET_FIELD((T)->status, TMDS, ENP),              \
pcnet.c:        GET_FIELD((T)->status, TMDS, BPE),              \
pcnet.c:        4096-GET_FIELD((T)->length, TMDL, BCNT),        \
pcnet.c:        GET_FIELD((T)->misc, TMDM, BUFF),               \
pcnet.c:        GET_FIELD((T)->misc, TMDM, UFLO),               \
pcnet.c:        GET_FIELD((T)->misc, TMDM, EXDEF),              \
pcnet.c:        GET_FIELD((T)->misc, TMDM, LCOL),               \
pcnet.c:        GET_FIELD((T)->misc, TMDM, LCAR),               \
pcnet.c:        GET_FIELD((T)->misc, TMDM, RTRY),               \
pcnet.c:        GET_FIELD((T)->misc, TMDM, TDR),                \
pcnet.c:        GET_FIELD((T)->misc, TMDM, TRC))
pcnet.c:        (R)->rbadr,                                     \
pcnet.c:        GET_FIELD((R)->status, RMDS, OWN),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, ERR),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, FRAM),             \
pcnet.c:        GET_FIELD((R)->status, RMDS, OFLO),             \
pcnet.c:        GET_FIELD((R)->status, RMDS, CRC),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, BUFF),             \
pcnet.c:        GET_FIELD((R)->status, RMDS, STP),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, ENP),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, BPE),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, PAM),              \
pcnet.c:        GET_FIELD((R)->status, RMDS, LFAM),             \
pcnet.c:        GET_FIELD((R)->status, RMDS, BAM),              \
pcnet.c:        GET_FIELD((R)->buf_length, RMDL, ONES),         \
pcnet.c:        4096-GET_FIELD((R)->buf_length, RMDL, BCNT),    \
pcnet.c:        GET_FIELD((R)->msg_length, RMDM, RCC),          \
pcnet.c:        GET_FIELD((R)->msg_length, RMDM, RPC),          \
pcnet.c:        GET_FIELD((R)->msg_length, RMDM, MCNT),         \
pcnet.c:        GET_FIELD((R)->msg_length, RMDM, ZEROS))
pcnet.c:        s->phys_mem_read(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);
pcnet.c:        tmd->tbadr = le32_to_cpu(xda.tbadr) & 0xffffff;
pcnet.c:        tmd->length = le16_to_cpu(xda.length);
pcnet.c:        tmd->status = (le32_to_cpu(xda.tbadr) >> 16) & 0xff00;
pcnet.c:        tmd->misc = le16_to_cpu(xda.status) << 16;
pcnet.c:        tmd->res = 0;
pcnet.c:        s->phys_mem_read(s->dma_opaque, addr, (void *)tmd, sizeof(*tmd), 0);
pcnet.c:        le32_to_cpus(&tmd->tbadr);
pcnet.c:        le16_to_cpus((uint16_t *)&tmd->length);
pcnet.c:        le16_to_cpus((uint16_t *)&tmd->status);
pcnet.c:        le32_to_cpus(&tmd->misc);
pcnet.c:        le32_to_cpus(&tmd->res);
pcnet.c:            uint32_t tmp = tmd->tbadr;
pcnet.c:            tmd->tbadr = tmd->misc;
pcnet.c:            tmd->misc = tmp;
pcnet.c:        xda.tbadr = cpu_to_le32((tmd->tbadr & 0xffffff) |
pcnet.c:                                ((tmd->status & 0xff00) << 16));
pcnet.c:        xda.length = cpu_to_le16(tmd->length);
pcnet.c:        xda.status = cpu_to_le16(tmd->misc >> 16);
pcnet.c:        s->phys_mem_write(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);
pcnet.c:        xda.tbadr = cpu_to_le32(tmd->tbadr);
pcnet.c:        xda.length = cpu_to_le16(tmd->length);
pcnet.c:        xda.status = cpu_to_le16(tmd->status);
pcnet.c:        xda.misc = cpu_to_le32(tmd->misc);
pcnet.c:        xda.res = cpu_to_le32(tmd->res);
pcnet.c:        s->phys_mem_write(s->dma_opaque, addr, (void *)&xda, sizeof(xda), 0);
pcnet.c:        s->phys_mem_read(s->dma_opaque, addr, (void *)&rda, sizeof(rda), 0);
pcnet.c:        rmd->rbadr = le32_to_cpu(rda.rbadr) & 0xffffff;
pcnet.c:        rmd->buf_length = le16_to_cpu(rda.buf_length);
pcnet.c:        rmd->status = (le32_to_cpu(rda.rbadr) >> 16) & 0xff00;
pcnet.c:        rmd->msg_length = le16_to_cpu(rda.msg_length);
pcnet.c:        rmd->res = 0;
pcnet.c:        s->phys_mem_read(s->dma_opaque, addr, (void *)rmd, sizeof(*rmd), 0);
pcnet.c:        le32_to_cpus(&rmd->rbadr);
pcnet.c:        le16_to_cpus((uint16_t *)&rmd->buf_length);
pcnet.c:        le16_to_cpus((uint16_t *)&rmd->status);
pcnet.c:        le32_to_cpus(&rmd->msg_length);
pcnet.c:        le32_to_cpus(&rmd->res);
pcnet.c:            uint32_t tmp = rmd->rbadr;
pcnet.c:            rmd->rbadr = rmd->msg_length;
pcnet.c:            rmd->msg_length = tmp;
pcnet.c:        rda.rbadr = cpu_to_le32((rmd->rbadr & 0xffffff) |
pcnet.c:                                ((rmd->status & 0xff00) << 16));
pcnet.c:        rda.buf_length = cpu_to_le16(rmd->buf_length);
pcnet.c:        rda.msg_length = cpu_to_le16(rmd->msg_length);
pcnet.c:        s->phys_mem_write(s->dma_opaque, addr, (void *)&rda, sizeof(rda), 0);
pcnet.c:        rda.rbadr = cpu_to_le32(rmd->rbadr);
pcnet.c:        rda.buf_length = cpu_to_le16(rmd->buf_length);
pcnet.c:        rda.status = cpu_to_le16(rmd->status);
pcnet.c:        rda.msg_length = cpu_to_le32(rmd->msg_length);
pcnet.c:        rda.res = cpu_to_le32(rmd->res);
pcnet.c:        s->phys_mem_write(s->dma_opaque, addr, (void *)&rda, sizeof(rda), 0);
pcnet.c:            s->phys_mem_read(s->dma_opaque, (ADDR), \
pcnet.c:            s->phys_mem_read(s->dma_opaque, (ADDR), \
pcnet.c:            s->phys_mem_read(s->dma_opaque, (ADDR), \
pcnet.c:            s->phys_mem_read(s->dma_opaque, (ADDR), \
pcnet.c:            s->phys_mem_read(s->dma_opaque, (ADDR), \
pcnet.c:           hdr->ether_dhost[0],hdr->ether_dhost[1],hdr->ether_dhost[2], \
pcnet.c:           hdr->ether_dhost[3],hdr->ether_dhost[4],hdr->ether_dhost[5], \
pcnet.c:           hdr->ether_shost[0],hdr->ether_shost[1],hdr->ether_shost[2], \
pcnet.c:           hdr->ether_shost[3],hdr->ether_shost[4],hdr->ether_shost[5], \
pcnet.c:           be16_to_cpu(hdr->ether_type));       \
pcnet.c:        s->csr[12] & 0xff, s->csr[12] >> 8,
pcnet.c:        s->csr[13] & 0xff, s->csr[13] >> 8,
pcnet.c:        s->csr[14] & 0xff, s->csr[14] >> 8
pcnet.c:    int result = (!CSR_DRCVPA(s)) && !memcmp(hdr->ether_dhost, padr, 6);
pcnet.c:           hdr->ether_dhost[0],hdr->ether_dhost[1],hdr->ether_dhost[2],
pcnet.c:           hdr->ether_dhost[3],hdr->ether_dhost[4],hdr->ether_dhost[5],
pcnet.c:    int result = !CSR_DRCVBC(s) && !memcmp(hdr->ether_dhost, BCAST, 6);
pcnet.c:    if ((*(hdr->ether_dhost)&0x01) &&
pcnet.c:        ((uint64_t *)&s->csr[8])[0] != 0LL) {
pcnet.c:            s->csr[8] & 0xff, s->csr[8] >> 8,
pcnet.c:            s->csr[9] & 0xff, s->csr[9] >> 8,
pcnet.c:            s->csr[10] & 0xff, s->csr[10] >> 8,
pcnet.c:            s->csr[11] & 0xff, s->csr[11] >> 8
pcnet.c:        int index = lnc_mchash(hdr->ether_dhost) >> 26;
pcnet.c:    return s->rdra + ((CSR_RCVRL(s) - idx) * (BCR_SWSTYLE(s) ? 16 : 8));
pcnet.c:        muldiv64(65536 - (CSR_SPND(s) ? 0 : CSR_POLL(s)),
pcnet.c:    s->lnkst = 0x40;
pcnet.c:    s->rdra = 0;
pcnet.c:    s->tdra = 0;
pcnet.c:    s->rap = 0;
pcnet.c:    s->bcr[BCR_BSBC] &= ~0x0080;
pcnet.c:    s->csr[0]   = 0x0004;
pcnet.c:    s->csr[3]   = 0x0000;
pcnet.c:    s->csr[4]   = 0x0115;
pcnet.c:    s->csr[5]   = 0x0000;
pcnet.c:    s->csr[6]   = 0x0000;
pcnet.c:    s->csr[8]   = 0;
pcnet.c:    s->csr[9]   = 0;
pcnet.c:    s->csr[10]  = 0;
pcnet.c:    s->csr[11]  = 0;
pcnet.c:    s->csr[12]  = le16_to_cpu(((uint16_t *)&s->prom[0])[0]);
pcnet.c:    s->csr[13]  = le16_to_cpu(((uint16_t *)&s->prom[0])[1]);
pcnet.c:    s->csr[14]  = le16_to_cpu(((uint16_t *)&s->prom[0])[2]);
pcnet.c:    s->csr[15] &= 0x21c4;
pcnet.c:    s->csr[72]  = 1;
pcnet.c:    s->csr[74]  = 1;
pcnet.c:    s->csr[76]  = 1;
pcnet.c:    s->csr[78]  = 1;
pcnet.c:    s->csr[80]  = 0x1410;
pcnet.c:    s->csr[88]  = 0x1003;
pcnet.c:    s->csr[89]  = 0x0262;
pcnet.c:    s->csr[94]  = 0x0000;
pcnet.c:    s->csr[100] = 0x0200;
pcnet.c:    s->csr[103] = 0x0105;
pcnet.c:    s->csr[103] = 0x0105;
pcnet.c:    s->csr[112] = 0x0000;
pcnet.c:    s->csr[114] = 0x0000;
pcnet.c:    s->csr[122] = 0x0000;
pcnet.c:    s->csr[124] = 0x0000;
pcnet.c:    s->tx_busy = 0;
pcnet.c:    s->csr[0] &= ~0x0080;
pcnet.c:    if (((s->csr[0] & ~s->csr[3]) & 0x5f00) ||
pcnet.c:        (((s->csr[4]>>1) & ~s->csr[4]) & 0x0115) ||
pcnet.c:        (((s->csr[5]>>1) & s->csr[5]) & 0x0048))
pcnet.c:    if ((!(s->csr[3] & 0x4000) && !!(s->csr[0] & 0x4000)) /* BABL */ ||
pcnet.c:        (!(s->csr[3] & 0x1000) && !!(s->csr[0] & 0x1000)) /* MISS */ ||
pcnet.c:        (!(s->csr[3] & 0x0100) && !!(s->csr[0] & 0x0100)) /* IDON */ ||
pcnet.c:        (!(s->csr[3] & 0x0200) && !!(s->csr[0] & 0x0200)) /* TINT */ ||
pcnet.c:        (!(s->csr[3] & 0x0400) && !!(s->csr[0] & 0x0400)) /* RINT */ ||
pcnet.c:        (!(s->csr[3] & 0x0800) && !!(s->csr[0] & 0x0800)) /* MERR */ ||
pcnet.c:        (!(s->csr[4] & 0x0001) && !!(s->csr[4] & 0x0002)) /* JAB */ ||
pcnet.c:        (!(s->csr[4] & 0x0004) && !!(s->csr[4] & 0x0008)) /* TXSTRT */ ||
pcnet.c:        (!(s->csr[4] & 0x0010) && !!(s->csr[4] & 0x0020)) /* RCVO */ ||
pcnet.c:        (!(s->csr[4] & 0x0100) && !!(s->csr[4] & 0x0200)) /* MFCO */ ||
pcnet.c:        (!!(s->csr[5] & 0x0040) && !!(s->csr[5] & 0x0080)) /* EXDINT */ ||
pcnet.c:        (!!(s->csr[5] & 0x0008) && !!(s->csr[5] & 0x0010)) /* MPINT */)
pcnet.c:        s->csr[0] |= 0x0080;
pcnet.c:    if (!!(s->csr[4] & 0x0080) && CSR_INEA(s)) { /* UINT */
pcnet.c:        s->csr[4] &= ~0x0080;
pcnet.c:        s->csr[4] |= 0x0040;
pcnet.c:        s->csr[0] |= 0x0080;
pcnet.c:    if (((s->csr[5]>>1) & s->csr[5]) & 0x0500)
pcnet.c:    if ((!!(s->csr[5] & 0x0400) && !!(s->csr[5] & 0x0800)) /* SINT */ ||
pcnet.c:        (!!(s->csr[5] & 0x0100) && !!(s->csr[5] & 0x0200)) /* SLPINT */ )
pcnet.c:        s->csr[0] |= 0x0080;
pcnet.c:    if (isr != s->isr) {
pcnet.c:    qemu_set_irq(s->irq, isr);
pcnet.c:    s->isr = isr;
pcnet.c:        s->phys_mem_read(s->dma_opaque, PHYSADDR(s,CSR_IADR(s)),
pcnet.c:        s->phys_mem_read(s->dma_opaque, PHYSADDR(s,CSR_IADR(s)),
pcnet.c:    s->csr[ 6] = (tlen << 12) | (rlen << 8);
pcnet.c:    s->csr[15] = mode;
pcnet.c:    s->csr[ 8] = ladrf[0];
pcnet.c:    s->csr[ 9] = ladrf[1];
pcnet.c:    s->csr[10] = ladrf[2];
pcnet.c:    s->csr[11] = ladrf[3];
pcnet.c:    s->csr[12] = padr[0];
pcnet.c:    s->csr[13] = padr[1];
pcnet.c:    s->csr[14] = padr[2];
pcnet.c:    s->rdra = PHYSADDR(s, rdra);
pcnet.c:    s->tdra = PHYSADDR(s, tdra);
pcnet.c:        s->rdra, CSR_RCVRL(s), s->tdra, CSR_XMTRL(s));
pcnet.c:    s->csr[0] |= 0x0101;
pcnet.c:    s->csr[0] &= ~0x0004;       /* clear STOP bit */
pcnet.c:        s->csr[0] |= 0x0010;    /* set TXON */
pcnet.c:        s->csr[0] |= 0x0020;    /* set RXON */
pcnet.c:    s->csr[0] &= ~0x0004;       /* clear STOP bit */
pcnet.c:    s->csr[0] |= 0x0002;
pcnet.c:    s->csr[0] &= ~0x7feb;
pcnet.c:    s->csr[0] |= 0x0014;
pcnet.c:    s->csr[4] &= ~0x02c2;
pcnet.c:    s->csr[5] &= ~0x0011;
pcnet.c:    s->csr[28] = s->csr[29] = 0;
pcnet.c:    if (s->rdra) {
pcnet.c:        target_phys_addr_t nrda = pcnet_rdra_addr(s, -1 + CSR_RCVRC(s));
pcnet.c:        target_phys_addr_t nnrd = pcnet_rdra_addr(s, -2 + CSR_RCVRC(s));
pcnet.c:        target_phys_addr_t crda = s->rdra +
pcnet.c:            (CSR_RCVRL(s) - CSR_RCVRC(s)) *
pcnet.c:        int nrdc = CSR_RCVRC(s)<=1 ? CSR_RCVRL(s) : CSR_RCVRC(s)-1;
pcnet.c:        target_phys_addr_t nrda = s->rdra +
pcnet.c:            (CSR_RCVRL(s) - nrdc) *
pcnet.c:        int nnrc = nrdc<=1 ? CSR_RCVRL(s) : nrdc-1;
pcnet.c:        target_phys_addr_t nnrd = s->rdra +
pcnet.c:            (CSR_RCVRL(s) - nnrc) *
pcnet.c:            s->csr[28] = crda & 0xffff;
pcnet.c:            s->csr[29] = crda >> 16;
pcnet.c:            s->csr[26] = nrda & 0xffff;
pcnet.c:            s->csr[27] = nrda >> 16;
pcnet.c:            s->csr[36] = nnrd & 0xffff;
pcnet.c:            s->csr[37] = nnrd >> 16;
pcnet.c:    s->csr[34] = s->csr[35] = 0;
pcnet.c:    if (s->tdra) {
pcnet.c:        target_phys_addr_t cxda = s->tdra +
pcnet.c:            (CSR_XMTRL(s) - CSR_XMTRC(s)) *
pcnet.c:                s->csr[60] = s->csr[34];
pcnet.c:                s->csr[61] = s->csr[35];
pcnet.c:                s->csr[62] = CSR_CXBC(s);
pcnet.c:                s->csr[63] = CSR_CXST(s);
pcnet.c:            s->csr[34] = cxda & 0xffff;
pcnet.c:            s->csr[35] = cxda >> 16;
pcnet.c:    PCNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
pcnet.c:    return sizeof(s->buffer)-16;
pcnet.c:    PCNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
pcnet.c:        return -1;
pcnet.c:        memset(buf1 + size, 0, MIN_BUF_SIZE - size);
pcnet.c:        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {
pcnet.c:            int rcvrc = CSR_RCVRC(s)-1,i;
pcnet.c:            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {
pcnet.c:                nrda = s->rdra +
pcnet.c:                    (CSR_RCVRL(s) - rcvrc) *
pcnet.c:                    printf("pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\n",
pcnet.c:            printf("pcnet - no buffer: RCVRC=%d\n", CSR_RCVRC(s));
pcnet.c:            s->csr[0] |= 0x1000; /* Set MISS flag */
pcnet.c:            uint8_t *src = s->buffer;
pcnet.c:            if (!s->looptest) {
pcnet.c:            } else if (s->looptest == PCNET_LOOPTEST_CRC ||
pcnet.c:                while (p != &src[size-4])
pcnet.c:    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \
pcnet.c:    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \
pcnet.c:    src += count; remaining -= count;                           \
pcnet.c:            s->csr[0] |= 0x0400;
pcnet.c:            while (pktcount--) {
pcnet.c:                    CSR_RCVRC(s)--;
pcnet.c:    int count = CSR_XMTRL(s)-1;
pcnet.c:    s->xmit_pos = -1;
pcnet.c:        s->csr[0] &= ~0x0008;
pcnet.c:    s->tx_busy = 1;
pcnet.c:            s->xmit_pos = 0;
pcnet.c:            int bcnt = 4096 - GET_FIELD(tmd.length, TMDL, BCNT);
pcnet.c:            s->phys_mem_read(s->dma_opaque, PHYSADDR(s, tmd.tbadr),
pcnet.c:                             s->buffer + s->xmit_pos, bcnt, CSR_BSWP(s));
pcnet.c:            s->xmit_pos += bcnt;
pcnet.c:        } else if (s->xmit_pos >= 0) {
pcnet.c:            int bcnt = 4096 - GET_FIELD(tmd.length, TMDL, BCNT);
pcnet.c:            s->phys_mem_read(s->dma_opaque, PHYSADDR(s, tmd.tbadr),
pcnet.c:                             s->buffer + s->xmit_pos, bcnt, CSR_BSWP(s));
pcnet.c:            s->xmit_pos += bcnt;
pcnet.c:            printf("pcnet_transmit size=%d\n", s->xmit_pos);
pcnet.c:                s->looptest = add_crc ? PCNET_LOOPTEST_CRC : PCNET_LOOPTEST_NOCRC;
pcnet.c:                pcnet_receive(&s->nic->nc, s->buffer, s->xmit_pos);
pcnet.c:                s->looptest = 0;
pcnet.c:                if (s->nic)
pcnet.c:                    qemu_send_packet(&s->nic->nc, s->buffer, s->xmit_pos);
pcnet.c:            s->csr[0] &= ~0x0008;   /* clear TDMD */
pcnet.c:            s->csr[4] |= 0x0004;    /* set TXSTRT */
pcnet.c:            s->xmit_pos = -1;
pcnet.c:            s->csr[0] |= 0x0200;    /* set TINT */
pcnet.c:            CSR_XMTRC(s)--;
pcnet.c:        if (count--)
pcnet.c:    if (s->xmit_pos >= 0) {
pcnet.c:        s->csr[0] |= 0x0200;    /* set TINT */
pcnet.c:            s->csr[0] &= ~0x0010;
pcnet.c:        if (count--)
pcnet.c:    s->tx_busy = 0;
pcnet.c:        if (s->tx_busy)
pcnet.c:    qemu_del_timer(s->poll_timer);
pcnet.c:        if (!s->timer || !now)
pcnet.c:            s->timer = now;
pcnet.c:            uint64_t t = now - s->timer + CSR_POLL(s);
pcnet.c:        qemu_mod_timer(s->poll_timer,
pcnet.c:        s->csr[0] &= ~(val & 0x7f00); /* Clear any interrupt flags */
pcnet.c:        s->csr[0] = (s->csr[0] & ~0x0040) | (val & 0x0048);
pcnet.c:        val = (val & 0x007f) | (s->csr[0] & 0x7f00);
pcnet.c:        s->csr[4] &= ~(val & 0x026a);
pcnet.c:        val &= ~0x026a; val |= s->csr[4] & 0x026a;
pcnet.c:        s->csr[5] &= ~(val & 0x0a90);
pcnet.c:        val &= ~0x0a90; val |= s->csr[5] & 0x0a90;
pcnet.c:    s->csr[rap] = val;
pcnet.c:        val = s->csr[0];
pcnet.c:        val = s->csr[89];
pcnet.c:        val |= s->csr[88];
pcnet.c:        val = s->csr[rap];
pcnet.c:        s->bcr[rap] = val;
pcnet.c:        val = s->bcr[rap] & ~0x8000;
pcnet.c:        val |= (val & 0x017f & s->lnkst) ? 0x8000 : 0;
pcnet.c:        val = rap < 32 ? s->bcr[rap] : 0;
pcnet.c:    memcpy(s->prom, s->conf.macaddr.a, 6);
pcnet.c:    s->prom[12] = s->prom[13] = 0x00;
pcnet.c:    s->prom[14] = s->prom[15] = 0x57;
pcnet.c:        checksum += s->prom[i];
pcnet.c:    *(uint16_t *)&s->prom[12] = cpu_to_le16(checksum);
pcnet.c:    s->bcr[BCR_MSRDA] = 0x0005;
pcnet.c:    s->bcr[BCR_MSWRA] = 0x0005;
pcnet.c:    s->bcr[BCR_MC   ] = 0x0002;
pcnet.c:    s->bcr[BCR_LNKST] = 0x00c0;
pcnet.c:    s->bcr[BCR_LED1 ] = 0x0084;
pcnet.c:    s->bcr[BCR_LED2 ] = 0x0088;
pcnet.c:    s->bcr[BCR_LED3 ] = 0x0090;
pcnet.c:    s->bcr[BCR_FDC  ] = 0x0000;
pcnet.c:    s->bcr[BCR_BSBC ] = 0x9001;
pcnet.c:    s->bcr[BCR_EECAS] = 0x0002;
pcnet.c:    s->bcr[BCR_SWS  ] = 0x0200;
pcnet.c:    s->bcr[BCR_PLAT ] = 0xff06;
pcnet.c:        s->prom[addr & 15] = val;
pcnet.c:    uint32_t val = s->prom[addr &= 15];
pcnet.c:            pcnet_csr_writew(s, s->rap, val);
pcnet.c:            s->rap = val & 0x7f;
pcnet.c:            pcnet_bcr_writew(s, s->rap, val);
pcnet.c:    uint32_t val = -1;
pcnet.c:            val = pcnet_csr_readw(s, s->rap);
pcnet.c:            val = s->rap;
pcnet.c:            val = pcnet_bcr_readw(s, s->rap);
pcnet.c:            pcnet_csr_writew(s, s->rap, val & 0xffff);
pcnet.c:            s->rap = val & 0x7f;
pcnet.c:            pcnet_bcr_writew(s, s->rap, val & 0xffff);
pcnet.c:    uint32_t val = -1;
pcnet.c:            val = pcnet_csr_readw(s, s->rap);
pcnet.c:            val = s->rap;
pcnet.c:            val = pcnet_bcr_readw(s, s->rap);
pcnet.c:    PCNetState *d = &DO_UPCAST(PCIPCNetState, pci_dev, pci_dev)->state;
pcnet.c:    uint32_t val = -1;
pcnet.c:    uint32_t val = -1;
pcnet.c:    d->nic = NULL;
pcnet.c:    s->poll_timer = qemu_new_timer(vm_clock, pcnet_poll_timer, s);
pcnet.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
pcnet.c:    s->nic = qemu_new_nic(info, &s->conf, dev->info->name, dev->id, s);
pcnet.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
pcnet.c:    cpu_register_physical_memory(addr, PCNET_PNPMMIO_SIZE, d->state.mmio_index);
pcnet.c:    PCNetState *d = DO_UPCAST(NICState, nc, nc)->opaque;
pcnet.c:    cpu_unregister_io_memory(d->state.mmio_index);
pcnet.c:    qemu_del_timer(d->state.poll_timer);
pcnet.c:    qemu_free_timer(d->state.poll_timer);
pcnet.c:    qemu_del_vlan_client(&d->state.nic->nc);
pcnet.c:    PCNetState *s = &d->state;
pcnet.c:    pci_conf = pci_dev->config;
pcnet.c:    /* Handler for memory-mapped I/O */
pcnet.c:    s->mmio_index =
pcnet.c:      cpu_register_io_memory(pcnet_mmio_read, pcnet_mmio_write, &d->state);
pcnet.c:    s->irq = pci_dev->irq[0];
pcnet.c:    s->phys_mem_read = pci_physical_memory_read;
pcnet.c:    s->phys_mem_write = pci_physical_memory_write;
pcnet.c:    if (!pci_dev->qdev.hotplugged) {
pcnet.c:            rom_add_option("pxe-pcnet.bin");
pcnet.c:    return pcnet_common_init(&pci_dev->qdev, s, &net_pci_pcnet_info);
pcnet.c:    pcnet_h_reset(&d->state);
pcspk.c:#include "qemu-timer.h"
pcspk.c:#include "qemu-kvm.h"
pcspk.c:#define PCSPK_MIN_COUNT ((PIT_FREQ + PCSPK_MAX_FREQ - 1) / PCSPK_MAX_FREQ)
pcspk.c:        pit->channels[2].mode = pit_state.channels[2].mode;
pcspk.c:        pit->channels[2].count = pit_state.channels[2].count;
pcspk.c:        pit->channels[2].count_load_time = pit_state.channels[2].count_load_time;
pcspk.c:        pit->channels[2].gate = pit_state.channels[2].gate;
pcspk.c:        inkernel_state->channels[2].mode = pit->channels[2].mode;
pcspk.c:        inkernel_state->channels[2].count = pit->channels[2].count;
pcspk.c:        inkernel_state->channels[2].count_load_time =
pcspk.c:            pit->channels[2].count_load_time;
pcspk.c:        inkernel_state->channels[2].gate = pit->channels[2].gate;
pcspk.c:    if (s->pit_count) {
pcspk.c:        const uint32_t m = PCSPK_SAMPLE_RATE * s->pit_count;
pcspk.c:        s->samples = (PCSPK_BUF_LEN * PIT_FREQ / m * m / (PIT_FREQ >> 1) + 1) >> 1;
pcspk.c:        for (i = 0; i < s->samples; ++i)
pcspk.c:            s->sample_buf[i] = (64 & (n * i >> 25)) - 32;
pcspk.c:        s->samples = PCSPK_BUF_LEN;
pcspk.c:            s->sample_buf[i] = 128; /* silence */
pcspk.c:    kvm_get_pit_ch2(s->pit, NULL);
pcspk.c:    if (pit_get_mode(s->pit, 2) != 3)
pcspk.c:    n = pit_get_initial_count(s->pit, 2);
pcspk.c:    if (s->pit_count != n) {
pcspk.c:        s->pit_count = n;
pcspk.c:        s->play_pos = 0;
pcspk.c:        n = audio_MIN(s->samples - s->play_pos, (unsigned int)free);
pcspk.c:        n = AUD_write(s->voice, &s->sample_buf[s->play_pos], n);
pcspk.c:        s->play_pos = (s->play_pos + n) % s->samples;
pcspk.c:        free -= n;
pcspk.c:    AUD_register_card(s_spk, &s->card);
pcspk.c:    s->voice = AUD_open_out(&s->card, s->voice, s_spk, s, pcspk_callback, &as);
pcspk.c:    if (!s->voice) {
pcspk.c:        return -1;
pcspk.c:    kvm_get_pit_ch2(s->pit, NULL);
pcspk.c:    s->dummy_refresh_clock ^= (1 << 4);
pcspk.c:    out = pit_get_out(s->pit, 2, qemu_get_clock(vm_clock)) << 5;
pcspk.c:    return pit_get_gate(s->pit, 2) | (s->data_on << 1) | s->dummy_refresh_clock | out;
pcspk.c:    kvm_get_pit_ch2(s->pit, &inkernel_state);
pcspk.c:    s->data_on = (val >> 1) & 1;
pcspk.c:    pit_set_gate(s->pit, 2, gate);
pcspk.c:    if (s->voice) {
pcspk.c:            s->play_pos = 0;
pcspk.c:        AUD_set_active_out(s->voice, gate & s->data_on);
pcspk.c:    kvm_set_pit_ch2(s->pit, &inkernel_state);
pcspk.c:    s->pit = pit;
petalogix_s3adsp1800_mmu.c: * Model of Petalogix linux reference design targeting Xilinx Spartan 3ADSP-1800
petalogix_s3adsp1800_mmu.c:    env->sregs[SR_PC] = bootstrap_pc;
petalogix_s3adsp1800_mmu.c:#define BINARY_DEVICE_TREE_FILE "petalogix-s3adsp1800.dtb"
petalogix_s3adsp1800_mmu.c:    env->pvr.regs[10] = 0x0c000000; /* spartan 3a dsp family.  */
petalogix_s3adsp1800_mmu.c:                          dinfo ? dinfo->bdrv : NULL, (64 * 1024),
petalogix_s3adsp1800_mmu.c:            kernel_size = load_elf(kernel_filename, -0x30000000LL,
petalogix_s3adsp1800_mmu.c:        env->regs[5] = ddr_base + kernel_size + 8192;
petalogix_s3adsp1800_mmu.c:            pstrcpy_targphys("cmdline", env->regs[5], 256, kernel_cmdline);
petalogix_s3adsp1800_mmu.c:        env->regs[6] = 0;
petalogix_s3adsp1800_mmu.c:        /* Provide a device-tree.  */
petalogix_s3adsp1800_mmu.c:        env->regs[7] = ddr_base + kernel_size + 256;
petalogix_s3adsp1800_mmu.c:        petalogix_load_device_tree(env->regs[7], ram_size,
petalogix_s3adsp1800_mmu.c:                                   env->regs[6], 0,
petalogix_s3adsp1800_mmu.c:    env->sregs[SR_PC] = bootstrap_pc;
petalogix_s3adsp1800_mmu.c:    .name = "petalogix-s3adsp1800",
pflash_cfi01.c: * - flash read
pflash_cfi01.c: * - flash write
pflash_cfi01.c: * - flash ID read
pflash_cfi01.c: * - sector erase
pflash_cfi01.c: * - CFI queries
pflash_cfi01.c:#include "qemu-timer.h"
pflash_cfi01.c:    printf("PFLASH: Possible BUG - " fmt, ## __VA_ARGS__); \
pflash_cfi01.c:    DPRINTF("%s: command %02x done\n", __func__, pfl->cmd);
pflash_cfi01.c:    pfl->status ^= 0x80;
pflash_cfi01.c:    if (pfl->bypass) {
pflash_cfi01.c:        pfl->wcycle = 2;
pflash_cfi01.c:        cpu_register_physical_memory(pfl->base, pfl->total_len,
pflash_cfi01.c:                        pfl->off | IO_MEM_ROMD | pfl->fl_mem);
pflash_cfi01.c:        pfl->wcycle = 0;
pflash_cfi01.c:    pfl->cmd = 0;
pflash_cfi01.c:    ret = -1;
pflash_cfi01.c:    if (pfl->width == 2)
pflash_cfi01.c:    else if (pfl->width == 4)
pflash_cfi01.c:            __func__, offset, pfl->cmd, width);
pflash_cfi01.c:    switch (pfl->cmd) {
pflash_cfi01.c:        p = pfl->storage;
pflash_cfi01.c:        ret = pfl->status;
pflash_cfi01.c:        if (boff > pfl->cfi_len)
pflash_cfi01.c:            ret = pfl->cfi_table[boff];
pflash_cfi01.c:        DPRINTF("%s: unknown command state: %x\n", __func__, pfl->cmd);
pflash_cfi01.c:        pfl->wcycle = 0;
pflash_cfi01.c:        pfl->cmd = 0;
pflash_cfi01.c:    if (pfl->bs) {
pflash_cfi01.c:        bdrv_write(pfl->bs, offset, pfl->storage + (offset << 9),
pflash_cfi01.c:                   offset_end - offset);
pflash_cfi01.c:    uint8_t *p = pfl->storage;
pflash_cfi01.c:            __func__, offset, value, pfl->counter);
pflash_cfi01.c:            __func__, offset, value, width, pfl->wcycle);
pflash_cfi01.c:    cpu_register_physical_memory(pfl->base, pfl->total_len, pfl->fl_mem);
pflash_cfi01.c:    boff = offset & (pfl->sector_len - 1);
pflash_cfi01.c:    if (pfl->width == 2)
pflash_cfi01.c:    else if (pfl->width == 4)
pflash_cfi01.c:    switch (pfl->wcycle) {
pflash_cfi01.c:            p = pfl->storage;
pflash_cfi01.c:            offset &= ~(pfl->sector_len - 1);
pflash_cfi01.c:                    __func__, offset, pfl->sector_len);
pflash_cfi01.c:            memset(p + offset, 0xff, pfl->sector_len);
pflash_cfi01.c:            pflash_update(pfl, offset, pfl->sector_len);
pflash_cfi01.c:            pfl->status |= 0x80; /* Ready! */
pflash_cfi01.c:            pfl->status = 0x0;
pflash_cfi01.c:            pfl->cmd = cmd;
pflash_cfi01.c:            pfl->status |= 0x80; /* Ready! */
pflash_cfi01.c:        pfl->wcycle++;
pflash_cfi01.c:        pfl->cmd = cmd;
pflash_cfi01.c:        switch (pfl->cmd) {
pflash_cfi01.c:            pfl->status |= 0x80; /* Ready! */
pflash_cfi01.c:            pfl->wcycle = 0;
pflash_cfi01.c:                pfl->wcycle = 0;
pflash_cfi01.c:                pfl->status |= 0x80;
pflash_cfi01.c:            pfl->counter = value;
pflash_cfi01.c:            pfl->wcycle++;
pflash_cfi01.c:                pfl->wcycle = 0;
pflash_cfi01.c:                pfl->status |= 0x80;
pflash_cfi01.c:                pfl->wcycle = 0;
pflash_cfi01.c:                pfl->status |= 0x80;
pflash_cfi01.c:        switch (pfl->cmd) {
pflash_cfi01.c:            pfl->status |= 0x80;
pflash_cfi01.c:            if (!pfl->counter) {
pflash_cfi01.c:                pfl->wcycle++;
pflash_cfi01.c:            pfl->counter--;
pflash_cfi01.c:        switch (pfl->cmd) {
pflash_cfi01.c:                pfl->wcycle = 0;
pflash_cfi01.c:                pfl->status |= 0x80;
pflash_cfi01.c:           __func__, offset, pfl->wcycle, pfl->cmd, value);
pflash_cfi01.c:    cpu_register_physical_memory(pfl->base, pfl->total_len,
pflash_cfi01.c:                    pfl->off | IO_MEM_ROMD | pfl->fl_mem);
pflash_cfi01.c:    pfl->bypass = 0;
pflash_cfi01.c:    pfl->wcycle = 0;
pflash_cfi01.c:    pfl->cmd = 0;
pflash_cfi01.c:    pfl->storage = qemu_get_ram_ptr(off);
pflash_cfi01.c:    pfl->fl_mem = cpu_register_io_memory(
pflash_cfi01.c:    pfl->off = off;
pflash_cfi01.c:                    off | pfl->fl_mem | IO_MEM_ROMD);
pflash_cfi01.c:    pfl->bs = bs;
pflash_cfi01.c:    if (pfl->bs) {
pflash_cfi01.c:        ret = bdrv_read(pfl->bs, 0, pfl->storage, total_len >> 9);
pflash_cfi01.c:            cpu_unregister_io_memory(pfl->fl_mem);
pflash_cfi01.c:#if 0 /* XXX: there should be a bit to set up read-only,
pflash_cfi01.c:    pfl->ro = 1;
pflash_cfi01.c:    pfl->ro = 0;
pflash_cfi01.c:    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);
pflash_cfi01.c:    pfl->base = base;
pflash_cfi01.c:    pfl->sector_len = sector_len;
pflash_cfi01.c:    pfl->total_len = total_len;
pflash_cfi01.c:    pfl->width = width;
pflash_cfi01.c:    pfl->wcycle = 0;
pflash_cfi01.c:    pfl->cmd = 0;
pflash_cfi01.c:    pfl->status = 0;
pflash_cfi01.c:    pfl->ident[0] = id0;
pflash_cfi01.c:    pfl->ident[1] = id1;
pflash_cfi01.c:    pfl->ident[2] = id2;
pflash_cfi01.c:    pfl->ident[3] = id3;
pflash_cfi01.c:    pfl->cfi_len = 0x52;
pflash_cfi01.c:    pfl->cfi_table[0x10] = 'Q';
pflash_cfi01.c:    pfl->cfi_table[0x11] = 'R';
pflash_cfi01.c:    pfl->cfi_table[0x12] = 'Y';
pflash_cfi01.c:    pfl->cfi_table[0x13] = 0x01;
pflash_cfi01.c:    pfl->cfi_table[0x14] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x15] = 0x31;
pflash_cfi01.c:    pfl->cfi_table[0x16] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x17] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x18] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x19] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x1A] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x1B] = 0x45;
pflash_cfi01.c:    pfl->cfi_table[0x1C] = 0x55;
pflash_cfi01.c:    pfl->cfi_table[0x1D] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x1E] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x1F] = 0x07;
pflash_cfi01.c:    pfl->cfi_table[0x20] = 0x07;
pflash_cfi01.c:    pfl->cfi_table[0x21] = 0x0a;
pflash_cfi01.c:    pfl->cfi_table[0x22] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x23] = 0x04;
pflash_cfi01.c:    pfl->cfi_table[0x24] = 0x04;
pflash_cfi01.c:    pfl->cfi_table[0x25] = 0x04;
pflash_cfi01.c:    pfl->cfi_table[0x26] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x27] = ctz32(total_len); // + 1;
pflash_cfi01.c:    pfl->cfi_table[0x28] = 0x02;
pflash_cfi01.c:    pfl->cfi_table[0x29] = 0x00;
pflash_cfi01.c:    /* Max number of bytes in multi-bytes write */
pflash_cfi01.c:    pfl->cfi_table[0x2A] = 0x0B;
pflash_cfi01.c:    pfl->cfi_table[0x2B] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x2C] = 0x01;
pflash_cfi01.c:    pfl->cfi_table[0x2D] = nb_blocs - 1;
pflash_cfi01.c:    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;
pflash_cfi01.c:    pfl->cfi_table[0x2F] = sector_len >> 8;
pflash_cfi01.c:    pfl->cfi_table[0x30] = sector_len >> 16;
pflash_cfi01.c:    pfl->cfi_table[0x31] = 'P';
pflash_cfi01.c:    pfl->cfi_table[0x32] = 'R';
pflash_cfi01.c:    pfl->cfi_table[0x33] = 'I';
pflash_cfi01.c:    pfl->cfi_table[0x34] = '1';
pflash_cfi01.c:    pfl->cfi_table[0x35] = '1';
pflash_cfi01.c:    pfl->cfi_table[0x36] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x37] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x38] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x39] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x3a] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x3b] = 0x00;
pflash_cfi01.c:    pfl->cfi_table[0x3c] = 0x00;
pflash_cfi02.c: * - flash read
pflash_cfi02.c: * - flash write
pflash_cfi02.c: * - flash ID read
pflash_cfi02.c: * - sector erase
pflash_cfi02.c: * - chip erase
pflash_cfi02.c: * - unlock bypass command
pflash_cfi02.c: * - CFI queries
pflash_cfi02.c:#include "qemu-timer.h"
pflash_cfi02.c:    unsigned long phys_offset = pfl->fl_mem;
pflash_cfi02.c:        phys_offset |= pfl->off | IO_MEM_ROMD;
pflash_cfi02.c:    pfl->rom_mode = rom_mode;
pflash_cfi02.c:    for (i = 0; i < pfl->mappings; i++)
pflash_cfi02.c:        cpu_register_physical_memory(pfl->base + i * pfl->chip_len,
pflash_cfi02.c:                                     pfl->chip_len, phys_offset);
pflash_cfi02.c:    DPRINTF("%s: command %02x done\n", __func__, pfl->cmd);
pflash_cfi02.c:    pfl->status ^= 0x80;
pflash_cfi02.c:    if (pfl->bypass) {
pflash_cfi02.c:        pfl->wcycle = 2;
pflash_cfi02.c:        pfl->wcycle = 0;
pflash_cfi02.c:    pfl->cmd = 0;
pflash_cfi02.c:    ret = -1;
pflash_cfi02.c:    if (pfl->rom_mode) {
pflash_cfi02.c:        if (pfl->wcycle == 0)
pflash_cfi02.c:    offset &= pfl->chip_len - 1;
pflash_cfi02.c:    if (pfl->width == 2)
pflash_cfi02.c:    else if (pfl->width == 4)
pflash_cfi02.c:    switch (pfl->cmd) {
pflash_cfi02.c:        DPRINTF("%s: unknown command state: %x\n", __func__, pfl->cmd);
pflash_cfi02.c:        pfl->wcycle = 0;
pflash_cfi02.c:        pfl->cmd = 0;
pflash_cfi02.c:        p = pfl->storage;
pflash_cfi02.c:            ret = pfl->ident[boff & 0x01];
pflash_cfi02.c:            if (pfl->ident[2 + (boff & 0x01)] == (uint8_t)-1)
pflash_cfi02.c:            ret = pfl->ident[2 + (boff & 0x01)];
pflash_cfi02.c:        ret = pfl->status;
pflash_cfi02.c:        pfl->status ^= 0x40;
pflash_cfi02.c:        if (boff > pfl->cfi_len)
pflash_cfi02.c:            ret = pfl->cfi_table[boff];
pflash_cfi02.c:    if (pfl->bs) {
pflash_cfi02.c:        bdrv_write(pfl->bs, offset, pfl->storage + (offset << 9),
pflash_cfi02.c:                   offset_end - offset);
pflash_cfi02.c:    if (pfl->cmd != 0xA0 && cmd == 0xF0) {
pflash_cfi02.c:                __func__, pfl->cmd, cmd);
pflash_cfi02.c:            offset, value, width, pfl->wcycle);
pflash_cfi02.c:    offset &= pfl->chip_len - 1;
pflash_cfi02.c:    boff = offset & (pfl->sector_len - 1);
pflash_cfi02.c:    if (pfl->width == 2)
pflash_cfi02.c:    else if (pfl->width == 4)
pflash_cfi02.c:    switch (pfl->wcycle) {
pflash_cfi02.c:        if (pfl->rom_mode)
pflash_cfi02.c:            pfl->wcycle = 7;
pflash_cfi02.c:            pfl->cmd = 0x98;
pflash_cfi02.c:        if (boff != pfl->unlock_addr[0] || cmd != 0xAA) {
pflash_cfi02.c:                    __func__, boff, cmd, pfl->unlock_addr[0]);
pflash_cfi02.c:        if (boff != pfl->unlock_addr[1] || cmd != 0x55) {
pflash_cfi02.c:        if (!pfl->bypass && boff != pfl->unlock_addr[0]) {
pflash_cfi02.c:            pfl->bypass = 1;
pflash_cfi02.c:            pfl->cmd = cmd;
pflash_cfi02.c:        switch (pfl->cmd) {
pflash_cfi02.c:            p = pfl->storage;
pflash_cfi02.c:            pfl->status = 0x00 | ~(value & 0x80);
pflash_cfi02.c:            if (pfl->bypass)
pflash_cfi02.c:            if (pfl->bypass && cmd == 0x00) {
pflash_cfi02.c:                    __func__, pfl->cmd);
pflash_cfi02.c:        switch (pfl->cmd) {
pflash_cfi02.c:                    __func__, pfl->cmd);
pflash_cfi02.c:            if (boff != pfl->unlock_addr[0]) {
pflash_cfi02.c:            memset(pfl->storage, 0xFF, pfl->chip_len);
pflash_cfi02.c:            pfl->status = 0x00;
pflash_cfi02.c:            pflash_update(pfl, 0, pfl->chip_len);
pflash_cfi02.c:            qemu_mod_timer(pfl->timer,
pflash_cfi02.c:            p = pfl->storage;
pflash_cfi02.c:            offset &= ~(pfl->sector_len - 1);
pflash_cfi02.c:            memset(p + offset, 0xFF, pfl->sector_len);
pflash_cfi02.c:            pflash_update(pfl, offset, pfl->sector_len);
pflash_cfi02.c:            pfl->status = 0x00;
pflash_cfi02.c:            qemu_mod_timer(pfl->timer,
pflash_cfi02.c:        pfl->cmd = cmd;
pflash_cfi02.c:        switch (pfl->cmd) {
pflash_cfi02.c:                    __func__, pfl->cmd);
pflash_cfi02.c:    pfl->wcycle++;
pflash_cfi02.c:    pfl->bypass = 0;
pflash_cfi02.c:    pfl->wcycle = 0;
pflash_cfi02.c:    pfl->cmd = 0;
pflash_cfi02.c:    pfl->wcycle = 2;
pflash_cfi02.c:    pfl->cmd = 0;
pflash_cfi02.c:    pfl->storage = qemu_get_ram_ptr(off);
pflash_cfi02.c:    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,
pflash_cfi02.c:    pfl->off = off;
pflash_cfi02.c:    pfl->base = base;
pflash_cfi02.c:    pfl->chip_len = chip_len;
pflash_cfi02.c:    pfl->mappings = nb_mappings;
pflash_cfi02.c:    pfl->bs = bs;
pflash_cfi02.c:    if (pfl->bs) {
pflash_cfi02.c:        ret = bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);
pflash_cfi02.c:            cpu_unregister_io_memory(pfl->fl_mem);
pflash_cfi02.c:#if 0 /* XXX: there should be a bit to set up read-only,
pflash_cfi02.c:    pfl->ro = 1;
pflash_cfi02.c:    pfl->ro = 0;
pflash_cfi02.c:    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);
pflash_cfi02.c:    pfl->sector_len = sector_len;
pflash_cfi02.c:    pfl->width = width;
pflash_cfi02.c:    pfl->wcycle = 0;
pflash_cfi02.c:    pfl->cmd = 0;
pflash_cfi02.c:    pfl->status = 0;
pflash_cfi02.c:    pfl->ident[0] = id0;
pflash_cfi02.c:    pfl->ident[1] = id1;
pflash_cfi02.c:    pfl->ident[2] = id2;
pflash_cfi02.c:    pfl->ident[3] = id3;
pflash_cfi02.c:    pfl->unlock_addr[0] = unlock_addr0;
pflash_cfi02.c:    pfl->unlock_addr[1] = unlock_addr1;
pflash_cfi02.c:    pfl->cfi_len = 0x52;
pflash_cfi02.c:    pfl->cfi_table[0x10] = 'Q';
pflash_cfi02.c:    pfl->cfi_table[0x11] = 'R';
pflash_cfi02.c:    pfl->cfi_table[0x12] = 'Y';
pflash_cfi02.c:    pfl->cfi_table[0x13] = 0x02;
pflash_cfi02.c:    pfl->cfi_table[0x14] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x15] = 0x31;
pflash_cfi02.c:    pfl->cfi_table[0x16] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x17] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x18] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x19] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x1A] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x1B] = 0x27;
pflash_cfi02.c:    pfl->cfi_table[0x1C] = 0x36;
pflash_cfi02.c:    pfl->cfi_table[0x1D] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x1E] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x1F] = 0x07;
pflash_cfi02.c:    pfl->cfi_table[0x20] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x21] = 0x09;
pflash_cfi02.c:    pfl->cfi_table[0x22] = 0x0C;
pflash_cfi02.c:    pfl->cfi_table[0x23] = 0x01;
pflash_cfi02.c:    pfl->cfi_table[0x24] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x25] = 0x0A;
pflash_cfi02.c:    pfl->cfi_table[0x26] = 0x0D;
pflash_cfi02.c:    pfl->cfi_table[0x27] = ctz32(chip_len);
pflash_cfi02.c:    pfl->cfi_table[0x28] = 0x02;
pflash_cfi02.c:    pfl->cfi_table[0x29] = 0x00;
pflash_cfi02.c:    /* Max number of bytes in multi-bytes write */
pflash_cfi02.c:    //    pfl->cfi_table[0x2A] = 0x05;
pflash_cfi02.c:    pfl->cfi_table[0x2A] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x2B] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x2C] = 0x01;
pflash_cfi02.c:    pfl->cfi_table[0x2D] = nb_blocs - 1;
pflash_cfi02.c:    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;
pflash_cfi02.c:    pfl->cfi_table[0x2F] = sector_len >> 8;
pflash_cfi02.c:    pfl->cfi_table[0x30] = sector_len >> 16;
pflash_cfi02.c:    pfl->cfi_table[0x31] = 'P';
pflash_cfi02.c:    pfl->cfi_table[0x32] = 'R';
pflash_cfi02.c:    pfl->cfi_table[0x33] = 'I';
pflash_cfi02.c:    pfl->cfi_table[0x34] = '1';
pflash_cfi02.c:    pfl->cfi_table[0x35] = '0';
pflash_cfi02.c:    pfl->cfi_table[0x36] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x37] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x38] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x39] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x3a] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x3b] = 0x00;
pflash_cfi02.c:    pfl->cfi_table[0x3c] = 0x00;
piix4.c:    uint8_t *pci_conf = d->config;
piix4.c:    pci_conf[0x60] = 0x0a; // PCI A -> IRQ 10
piix4.c:    pci_conf[0x61] = 0x0a; // PCI B -> IRQ 10
piix4.c:    pci_conf[0x62] = 0x0b; // PCI C -> IRQ 11
piix4.c:    pci_conf[0x63] = 0x0b; // PCI D -> IRQ 11
piix4.c:        return -EINVAL;
piix4.c:    isa_bus_new(&d->qdev);
piix4.c:    pci_conf = d->config;
piix4.c:    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge
piix4.c:    return d->devfn;
piix_pci.c:#include "qemu-kvm.h"
piix_pci.c:    slot_addend = (pci_dev->devfn >> 3) - 1;
piix_pci.c:    //    printf("ISA mapping %08x-0x%08x: %d\n", start, end, r);
piix_pci.c:        cpu_register_physical_memory(start, end - start,
piix_pci.c:        cpu_register_physical_memory(start, end - start,
piix_pci.c:                                         d->isa_page_descs[(addr - 0xa0000) >> 12]);
piix_pci.c:    update_pam(d, 0xf0000, 0x100000, (d->dev.config[0x59] >> 4) & 3);
piix_pci.c:        r = (d->dev.config[(i >> 1) + 0x5a] >> ((i & 1) * 4)) & 3;
piix_pci.c:    smram = d->dev.config[0x72];
piix_pci.c:    if ((d->smm_enabled && (smram & 0x08)) || (smram & 0x40)) {
piix_pci.c:                                         d->isa_page_descs[(addr - 0xa0000) >> 12]);
piix_pci.c:    if (d->smm_enabled != val) {
piix_pci.c:        d->smm_enabled = val;
piix_pci.c:   the 0xa0000-0x100000 range */
piix_pci.c:        d->isa_page_descs[i] = cpu_get_physical_page_desc(0xa0000 + i * 0x1000);
piix_pci.c:    ret = pci_device_load(&d->dev, f);
piix_pci.c:    qemu_get_8s(f, &d->smm_enabled);
piix_pci.c:            d->piix3->pci_irq_levels[i] = qemu_get_be32(f);
piix_pci.c:    pci_config_set_vendor_id(d->dev.config, PCI_VENDOR_ID_INTEL);
piix_pci.c:    pci_config_set_device_id(d->dev.config, PCI_DEVICE_ID_INTEL_82441);
piix_pci.c:    d->dev.config[0x08] = 0x02; // revision
piix_pci.c:    pci_config_set_class(d->dev.config, PCI_CLASS_BRIDGE_HOST);
piix_pci.c:    d->dev.config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
piix_pci.c:    d->dev.config[0x72] = 0x02; /* SMRAM */
piix_pci.c:    dev = qdev_create(NULL, "i440FX-pcihost");
piix_pci.c:    b = pci_bus_new(&s->busdev.qdev, NULL, 0);
piix_pci.c:    s->bus = b;
piix_pci.c:                                 pci_create_simple(b, -1, "PIIX3"));
piix_pci.c:    piix3->pic = pic;
piix_pci.c:    (*pi440fx_state)->piix3 = piix3;
piix_pci.c:    *piix3_devfn = piix3->dev.devfn;
piix_pci.c:    piix3->pci_irq_levels[irq_num] = level;
piix_pci.c:    pic_irq = piix3->dev.config[0x60 + irq_num];
piix_pci.c:            if (pic_irq == piix3->dev.config[0x60 + i])
piix_pci.c:                pic_level |= piix3->pci_irq_levels[i];
piix_pci.c:        qemu_set_irq(piix3->pic[pic_irq], pic_level);
piix_pci.c:        return piix3_dev->dev.config[0x60+pin];
piix_pci.c:    uint8_t *pci_conf = d->dev.config;
piix_pci.c:    memset(d->pci_irq_levels, 0, sizeof(d->pci_irq_levels));
piix_pci.c:    isa_bus_new(&d->dev.qdev);
piix_pci.c:    pci_conf = d->dev.config;
piix_pci.c:    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_0); // 82371SB PIIX3 PCI-to-ISA bridge (Step A1)
piix_pci.c:    .qdev.name    = "i440FX-pcihost",
pl011.c:#include "qemu-char.h"
pl011.c:    flags = s->int_level & s->int_enabled;
pl011.c:    qemu_set_irq(s->irq, flags != 0);
pl011.c:        return s->id[(offset - 0xfe0) >> 2];
pl011.c:        s->flags &= ~PL011_FLAG_RXFF;
pl011.c:        c = s->read_fifo[s->read_pos];
pl011.c:        if (s->read_count > 0) {
pl011.c:            s->read_count--;
pl011.c:            if (++s->read_pos == 16)
pl011.c:                s->read_pos = 0;
pl011.c:        if (s->read_count == 0) {
pl011.c:            s->flags |= PL011_FLAG_RXFE;
pl011.c:        if (s->read_count == s->read_trigger - 1)
pl011.c:            s->int_level &= ~ PL011_INT_RX;
pl011.c:        qemu_chr_accept_input(s->chr);
pl011.c:        return s->flags;
pl011.c:        return s->ilpr;
pl011.c:        return s->ibrd;
pl011.c:        return s->fbrd;
pl011.c:        return s->lcr;
pl011.c:        return s->cr;
pl011.c:        return s->ifl;
pl011.c:        return s->int_enabled;
pl011.c:        return s->int_level;
pl011.c:        return s->int_level & s->int_enabled;
pl011.c:        return s->dmacr;
pl011.c:       interrupt.  Triggering the interrupt when the FIFO is non-empty seems
pl011.c:    if (s->lcr & 0x10)
pl011.c:        s->read_trigger = (s->ifl >> 1) & 0x1c;
pl011.c:        s->read_trigger = 1;
pl011.c:        if (s->chr)
pl011.c:            qemu_chr_write(s->chr, &ch, 1);
pl011.c:        s->int_level |= PL011_INT_TX;
pl011.c:        s->cr = value;
pl011.c:        s->ilpr = value;
pl011.c:        s->ibrd = value;
pl011.c:        s->fbrd = value;
pl011.c:        s->lcr = value;
pl011.c:        s->cr = value;
pl011.c:        s->ifl = value;
pl011.c:        s->int_enabled = value;
pl011.c:        s->int_level &= ~value;
pl011.c:        s->dmacr = value;
pl011.c:    if (s->lcr & 0x10)
pl011.c:        return s->read_count < 16;
pl011.c:        return s->read_count < 1;
pl011.c:    slot = s->read_pos + s->read_count;
pl011.c:        slot -= 16;
pl011.c:    s->read_fifo[slot] = value;
pl011.c:    s->read_count++;
pl011.c:    s->flags &= ~PL011_FLAG_RXFE;
pl011.c:    if (s->cr & 0x10 || s->read_count == 16) {
pl011.c:        s->flags |= PL011_FLAG_RXFF;
pl011.c:    if (s->read_count == s->read_trigger) {
pl011.c:        s->int_level |= PL011_INT_RX;
pl011.c:    qemu_put_be32(f, s->readbuff);
pl011.c:    qemu_put_be32(f, s->flags);
pl011.c:    qemu_put_be32(f, s->lcr);
pl011.c:    qemu_put_be32(f, s->cr);
pl011.c:    qemu_put_be32(f, s->dmacr);
pl011.c:    qemu_put_be32(f, s->int_enabled);
pl011.c:    qemu_put_be32(f, s->int_level);
pl011.c:        qemu_put_be32(f, s->read_fifo[i]);
pl011.c:    qemu_put_be32(f, s->ilpr);
pl011.c:    qemu_put_be32(f, s->ibrd);
pl011.c:    qemu_put_be32(f, s->fbrd);
pl011.c:    qemu_put_be32(f, s->ifl);
pl011.c:    qemu_put_be32(f, s->read_pos);
pl011.c:    qemu_put_be32(f, s->read_count);
pl011.c:    qemu_put_be32(f, s->read_trigger);
pl011.c:        return -EINVAL;
pl011.c:    s->readbuff = qemu_get_be32(f);
pl011.c:    s->flags = qemu_get_be32(f);
pl011.c:    s->lcr = qemu_get_be32(f);
pl011.c:    s->cr = qemu_get_be32(f);
pl011.c:    s->dmacr = qemu_get_be32(f);
pl011.c:    s->int_enabled = qemu_get_be32(f);
pl011.c:    s->int_level = qemu_get_be32(f);
pl011.c:        s->read_fifo[i] = qemu_get_be32(f);
pl011.c:    s->ilpr = qemu_get_be32(f);
pl011.c:    s->ibrd = qemu_get_be32(f);
pl011.c:    s->fbrd = qemu_get_be32(f);
pl011.c:    s->ifl = qemu_get_be32(f);
pl011.c:    s->read_pos = qemu_get_be32(f);
pl011.c:    s->read_count = qemu_get_be32(f);
pl011.c:    s->read_trigger = qemu_get_be32(f);
pl011.c:    sysbus_init_irq(dev, &s->irq);
pl011.c:    s->id = id;
pl011.c:    s->chr = qdev_init_chardev(&dev->qdev);
pl011.c:    s->read_trigger = 1;
pl011.c:    s->ifl = 0x12;
pl011.c:    s->cr = 0x300;
pl011.c:    s->flags = 0x90;
pl011.c:    if (s->chr) {
pl011.c:        qemu_chr_add_handlers(s->chr, pl011_can_receive, pl011_receive,
pl011.c:    register_savevm("pl011_uart", -1, 1, pl011_save, pl011_load, s);
pl022.c:    s->sr = 0;
pl022.c:    if (s->tx_fifo_len == 0)
pl022.c:        s->sr |= PL022_SR_TFE;
pl022.c:    if (s->tx_fifo_len != 8)
pl022.c:        s->sr |= PL022_SR_TNF;
pl022.c:    if (s->rx_fifo_len != 0)
pl022.c:        s->sr |= PL022_SR_RNE;
pl022.c:    if (s->rx_fifo_len == 8)
pl022.c:        s->sr |= PL022_SR_RFF;
pl022.c:    if (s->tx_fifo_len)
pl022.c:        s->sr |= PL022_SR_BSY;
pl022.c:    s->is = 0;
pl022.c:    if (s->rx_fifo_len >= 4)
pl022.c:        s->is |= PL022_INT_RX;
pl022.c:    if (s->tx_fifo_len <= 4)
pl022.c:        s->is |= PL022_INT_TX;
pl022.c:    qemu_set_irq(s->irq, (s->is & s->im) != 0);
pl022.c:    if ((s->cr1 & PL022_CR1_SSE) == 0) {
pl022.c:    DPRINTF("Maybe xfer %d/%d\n", s->tx_fifo_len, s->rx_fifo_len);
pl022.c:    i = (s->tx_fifo_head - s->tx_fifo_len) & 7;
pl022.c:    o = s->rx_fifo_head;
pl022.c:       cause the RX FIFO to overflow.  In practice much transmit-only code
pl022.c:    while (s->tx_fifo_len && s->rx_fifo_len < 8) {
pl022.c:        val = s->tx_fifo[i];
pl022.c:        if (s->cr1 & PL022_CR1_LBM) {
pl022.c:            val = ssi_transfer(s->ssi, val);
pl022.c:        s->rx_fifo[o] = val & s->bitmask;
pl022.c:        s->tx_fifo_len--;
pl022.c:        s->rx_fifo_len++;
pl022.c:    s->rx_fifo_head = o;
pl022.c:        return pl022_id[(offset - 0xfe0) >> 2];
pl022.c:      return s->cr0;
pl022.c:      return s->cr1;
pl022.c:        if (s->rx_fifo_len) {
pl022.c:            val = s->rx_fifo[(s->rx_fifo_head - s->rx_fifo_len) & 7];
pl022.c:            s->rx_fifo_len--;
pl022.c:        return s->sr;
pl022.c:        return s->cpsr;
pl022.c:        return s->im;
pl022.c:        return s->is;
pl022.c:        return s->im & s->is;
pl022.c:        s->cr0 = value;
pl022.c:        s->bitmask = (1 << ((value & 15) + 1)) - 1;
pl022.c:        s->cr1 = value;
pl022.c:        if ((s->cr1 & (PL022_CR1_MS | PL022_CR1_SSE))
pl022.c:        if (s->tx_fifo_len < 8) {
pl022.c:            s->tx_fifo[s->tx_fifo_head] = value & s->bitmask;
pl022.c:            s->tx_fifo_head = (s->tx_fifo_head + 1) & 7;
pl022.c:            s->tx_fifo_len++;
pl022.c:        s->cpsr = value & 0xff;
pl022.c:        s->im = value;
pl022.c:    s->rx_fifo_len = 0;
pl022.c:    s->tx_fifo_len = 0;
pl022.c:    s->im = 0;
pl022.c:    s->is = PL022_INT_TX;
pl022.c:    s->sr = PL022_SR_TFE | PL022_SR_TNF;
pl022.c:    qemu_put_be32(f, s->cr0);
pl022.c:    qemu_put_be32(f, s->cr1);
pl022.c:    qemu_put_be32(f, s->bitmask);
pl022.c:    qemu_put_be32(f, s->sr);
pl022.c:    qemu_put_be32(f, s->cpsr);
pl022.c:    qemu_put_be32(f, s->is);
pl022.c:    qemu_put_be32(f, s->im);
pl022.c:    qemu_put_be32(f, s->tx_fifo_head);
pl022.c:    qemu_put_be32(f, s->rx_fifo_head);
pl022.c:    qemu_put_be32(f, s->tx_fifo_len);
pl022.c:    qemu_put_be32(f, s->rx_fifo_len);
pl022.c:        qemu_put_be16(f, s->tx_fifo[i]);
pl022.c:        qemu_put_be16(f, s->rx_fifo[i]);
pl022.c:        return -EINVAL;
pl022.c:    s->cr0 = qemu_get_be32(f);
pl022.c:    s->cr1 = qemu_get_be32(f);
pl022.c:    s->bitmask = qemu_get_be32(f);
pl022.c:    s->sr = qemu_get_be32(f);
pl022.c:    s->cpsr = qemu_get_be32(f);
pl022.c:    s->is = qemu_get_be32(f);
pl022.c:    s->im = qemu_get_be32(f);
pl022.c:    s->tx_fifo_head = qemu_get_be32(f);
pl022.c:    s->rx_fifo_head = qemu_get_be32(f);
pl022.c:    s->tx_fifo_len = qemu_get_be32(f);
pl022.c:    s->rx_fifo_len = qemu_get_be32(f);
pl022.c:        s->tx_fifo[i] = qemu_get_be16(f);
pl022.c:        s->rx_fifo[i] = qemu_get_be16(f);
pl022.c:    sysbus_init_irq(dev, &s->irq);
pl022.c:    s->ssi = ssi_create_bus(&dev->qdev, "ssi");
pl022.c:    register_savevm("pl022_ssp", -1, 1, pl022_save, pl022_load, s);
pl031.c:#include "qemu-timer.h"
pl031.c:    qemu_set_irq(s->irq, s->is & s->im);
pl031.c:    s->im = 1;
pl031.c:    return s->tick_offset + qemu_get_clock(vm_clock) / get_ticks_per_sec();
pl031.c:    ticks = s->tick_offset + now / get_ticks_per_sec();
pl031.c:    ticks = s->mr - ticks;
pl031.c:        qemu_del_timer(s->timer);
pl031.c:        qemu_mod_timer(s->timer, now + (int64_t)ticks * get_ticks_per_sec());
pl031.c:        return pl031_id[(offset - 0xfe0) >> 2];
pl031.c:        return s->mr;
pl031.c:        return s->im;
pl031.c:        return s->is;
pl031.c:        return s->lr;
pl031.c:        return s->is & s->im;
pl031.c:        s->tick_offset += value - pl031_get_count(s);
pl031.c:        s->mr = value;
pl031.c:        s->im = value & 1;
pl031.c:        DPRINTF("Interrupt mask %d\n", s->im);
pl031.c:        s->is = 0;
pl031.c:    if (iomemtype == -1) {
pl031.c:    sysbus_init_irq(dev, &s->irq);
pl031.c:    s->tick_offset = mktimegm(&tm);
pl031.c:    s->timer = qemu_new_timer(vm_clock, pl031_interrupt, s);
pl050.c: * Copyright (c) 2006-2007 CodeSourcery.
pl050.c:    s->pending = level;
pl050.c:    raise = (s->pending && (s->cr & 0x10) != 0)
pl050.c:            || (s->cr & 0x08) != 0;
pl050.c:    qemu_set_irq(s->irq, raise);
pl050.c:        return pl050_id[(offset - 0xfe0) >> 2];
pl050.c:        return s->cr;
pl050.c:            val = s->last;
pl050.c:            if (s->pending)
pl050.c:        if (s->pending)
pl050.c:            s->last = ps2_read_data(s->dev);
pl050.c:        return s->last;
pl050.c:        return s->clk;
pl050.c:        return s->pending | 2;
pl050.c:        s->cr = value;
pl050.c:        pl050_update(s, s->pending);
pl050.c:        if (s->is_mouse) {
pl050.c:            ps2_write_mouse(s->dev, value);
pl050.c:            ps2_write_keyboard(s->dev, value);
pl050.c:        s->clk = value;
pl050.c:    sysbus_init_irq(dev, &s->irq);
pl050.c:    s->is_mouse = is_mouse;
pl050.c:    if (s->is_mouse)
pl050.c:        s->dev = ps2_mouse_init(pl050_update, s);
pl050.c:        s->dev = ps2_kbd_init(pl050_update, s);
pl061.c:    out = (s->data & s->dir) | ~s->dir;
pl061.c:    changed = s->old_data ^ out;
pl061.c:    s->old_data = out;
pl061.c:        if ((changed & mask) && s->out) {
pl061.c:            qemu_set_irq(s->out[i], (out & mask) != 0);
pl061.c:        return pl061_id[(offset - 0xfd0) >> 2];
pl061.c:        return s->data & (offset >> 2);
pl061.c:        return s->dir;
pl061.c:        return s->isense;
pl061.c:        return s->ibe;
pl061.c:        return s->iev;
pl061.c:        return s->im;
pl061.c:        return s->istate;
pl061.c:        return s->istate | s->im;
pl061.c:        return s->afsel;
pl061.c:        return s->dr2r;
pl061.c:        return s->dr4r;
pl061.c:        return s->dr8r;
pl061.c:        return s->odr;
pl061.c:    case 0x510: /* Pull-up */
pl061.c:        return s->pur;
pl061.c:    case 0x514: /* Pull-down */
pl061.c:        return s->pdr;
pl061.c:        return s->slr;
pl061.c:        return s->den;
pl061.c:        return s->locked;
pl061.c:        return s->cr;
pl061.c:        mask = (offset >> 2) & s->dir;
pl061.c:        s->data = (s->data & ~mask) | (value & mask);
pl061.c:        s->dir = value;
pl061.c:        s->isense = value;
pl061.c:        s->ibe = value;
pl061.c:        s->iev = value;
pl061.c:        s->im = value;
pl061.c:        s->istate &= ~value;
pl061.c:        mask = s->cr;
pl061.c:        s->afsel = (s->afsel & ~mask) | (value & mask);
pl061.c:        s->dr2r = value;
pl061.c:        s->dr4r = value;
pl061.c:        s->dr8r = value;
pl061.c:        s->odr = value;
pl061.c:    case 0x510: /* Pull-up */
pl061.c:        s->pur = value;
pl061.c:    case 0x514: /* Pull-down */
pl061.c:        s->pdr = value;
pl061.c:        s->slr = value;
pl061.c:        s->den = value;
pl061.c:        s->locked = (value != 0xacce551);
pl061.c:        if (!s->locked)
pl061.c:            s->cr = value;
pl061.c:  s->locked = 1;
pl061.c:  s->cr = 0xff;
pl061.c:    if ((s->dir & mask) == 0) {
pl061.c:        s->data &= ~mask;
pl061.c:            s->data |= mask;
pl061.c:    qemu_put_be32(f, s->locked);
pl061.c:    qemu_put_be32(f, s->data);
pl061.c:    qemu_put_be32(f, s->old_data);
pl061.c:    qemu_put_be32(f, s->dir);
pl061.c:    qemu_put_be32(f, s->isense);
pl061.c:    qemu_put_be32(f, s->ibe);
pl061.c:    qemu_put_be32(f, s->iev);
pl061.c:    qemu_put_be32(f, s->im);
pl061.c:    qemu_put_be32(f, s->istate);
pl061.c:    qemu_put_be32(f, s->afsel);
pl061.c:    qemu_put_be32(f, s->dr2r);
pl061.c:    qemu_put_be32(f, s->dr4r);
pl061.c:    qemu_put_be32(f, s->dr8r);
pl061.c:    qemu_put_be32(f, s->odr);
pl061.c:    qemu_put_be32(f, s->pur);
pl061.c:    qemu_put_be32(f, s->pdr);
pl061.c:    qemu_put_be32(f, s->slr);
pl061.c:    qemu_put_be32(f, s->den);
pl061.c:    qemu_put_be32(f, s->cr);
pl061.c:    qemu_put_be32(f, s->float_high);
pl061.c:        return -EINVAL;
pl061.c:    s->locked = qemu_get_be32(f);
pl061.c:    s->data = qemu_get_be32(f);
pl061.c:    s->old_data = qemu_get_be32(f);
pl061.c:    s->dir = qemu_get_be32(f);
pl061.c:    s->isense = qemu_get_be32(f);
pl061.c:    s->ibe = qemu_get_be32(f);
pl061.c:    s->iev = qemu_get_be32(f);
pl061.c:    s->im = qemu_get_be32(f);
pl061.c:    s->istate = qemu_get_be32(f);
pl061.c:    s->afsel = qemu_get_be32(f);
pl061.c:    s->dr2r = qemu_get_be32(f);
pl061.c:    s->dr4r = qemu_get_be32(f);
pl061.c:    s->dr8r = qemu_get_be32(f);
pl061.c:    s->odr = qemu_get_be32(f);
pl061.c:    s->pur = qemu_get_be32(f);
pl061.c:    s->pdr = qemu_get_be32(f);
pl061.c:    s->slr = qemu_get_be32(f);
pl061.c:    s->den = qemu_get_be32(f);
pl061.c:    s->cr = qemu_get_be32(f);
pl061.c:    s->float_high = qemu_get_be32(f);
pl061.c:    sysbus_init_irq(dev, &s->irq);
pl061.c:    qdev_init_gpio_in(&dev->qdev, pl061_set_irq, 8);
pl061.c:    qdev_init_gpio_out(&dev->qdev, s->out, 8);
pl061.c:    register_savevm("pl061_gpio", -1, 1, pl061_save, pl061_load, s);
pl080.c:    if ((s->tc_int & s->tc_mask)
pl080.c:            || (s->err_int & s->err_mask))
pl080.c:        qemu_irq_raise(s->irq);
pl080.c:        qemu_irq_lower(s->irq);
pl080.c:    s->tc_mask = 0;
pl080.c:    for (c = 0; c < s->nchannels; c++) {
pl080.c:        if (s->chan[c].conf & PL080_CCONF_ITC)
pl080.c:            s->tc_mask |= 1 << c;
pl080.c:        if (s->chan[c].conf & PL080_CCONF_IE)
pl080.c:            s->err_mask |= 1 << c;
pl080.c:    if ((s->conf & PL080_CONF_E) == 0)
pl080.c:    if (s->running) {
pl080.c:        s->running++;
pl080.c:    s->running = 1;
pl080.c:    while (s->running) {
pl080.c:        for (c = 0; c < s->nchannels; c++) {
pl080.c:            ch = &s->chan[c];
pl080.c:            if ((ch->conf & (PL080_CCONF_H | PL080_CCONF_E))
pl080.c:            flow = (ch->conf >> 11) & 7;
pl080.c:            src_id = (ch->conf >> 1) & 0x1f;
pl080.c:            dest_id = (ch->conf >> 6) & 0x1f;
pl080.c:            size = ch->ctrl & 0xfff;
pl080.c:            req = s->req_single | s->req_burst;
pl080.c:            swidth = 1 << ((ch->ctrl >> 18) & 7);
pl080.c:            dwidth = 1 << ((ch->ctrl >> 21) & 7);
pl080.c:                cpu_physical_memory_read(ch->src, buff + n, swidth);
pl080.c:                if (ch->ctrl & PL080_CCTRL_SI)
pl080.c:                    ch->src += swidth;
pl080.c:                cpu_physical_memory_write(ch->dest + n, buff + n, dwidth);
pl080.c:                if (ch->ctrl & PL080_CCTRL_DI)
pl080.c:                    ch->dest += swidth;
pl080.c:            size--;
pl080.c:            ch->ctrl = (ch->ctrl & 0xfffff000) | size;
pl080.c:                if (ch->lli) {
pl080.c:                    ch->src = ldl_phys(ch->lli);
pl080.c:                    ch->dest = ldl_phys(ch->lli + 4);
pl080.c:                    ch->ctrl = ldl_phys(ch->lli + 12);
pl080.c:                    ch->lli = ldl_phys(ch->lli + 8);
pl080.c:                    ch->conf &= ~PL080_CCONF_E;
pl080.c:                if (ch->ctrl & PL080_CCTRL_I) {
pl080.c:                    s->tc_int |= 1 << c;
pl080.c:        if (--s->running)
pl080.c:            s->running = 1;
pl080.c:        if (s->nchannels == 8) {
pl080.c:            return pl080_id[(offset - 0xfe0) >> 2];
pl080.c:            return pl081_id[(offset - 0xfe0) >> 2];
pl080.c:        if (i >= s->nchannels)
pl080.c:            return s->chan[i].src;
pl080.c:            return s->chan[i].dest;
pl080.c:            return s->chan[i].lli;
pl080.c:            return s->chan[i].ctrl;
pl080.c:            return s->chan[i].conf;
pl080.c:        return (s->tc_int & s->tc_mask) | (s->err_int & s->err_mask);
pl080.c:        return (s->tc_int & s->tc_mask);
pl080.c:        return (s->err_int & s->err_mask);
pl080.c:        return s->tc_int;
pl080.c:        return s->err_int;
pl080.c:        for (i = 0; i < s->nchannels; i++) {
pl080.c:            if (s->chan[i].conf & PL080_CCONF_E)
pl080.c:        return s->conf;
pl080.c:        return s->sync;
pl080.c:        if (i >= s->nchannels)
pl080.c:            s->chan[i].src = value;
pl080.c:            s->chan[i].dest = value;
pl080.c:            s->chan[i].lli = value;
pl080.c:            s->chan[i].ctrl = value;
pl080.c:            s->chan[i].conf = value;
pl080.c:        s->tc_int &= ~value;
pl080.c:        s->err_int &= ~value;
pl080.c:        s->conf = value;
pl080.c:        if (s->conf & (PL080_CONF_M1 | PL080_CONF_M1)) {
pl080.c:            hw_error("pl080_write: Big-endian DMA not implemented\n");
pl080.c:        s->sync = value;
pl080.c:    sysbus_init_irq(dev, &s->irq);
pl080.c:    s->nchannels = nchannels;
pl110.c: * Copyright (c) 2005-2009 CodeSourcery.
pl110.c:  return (s->cr & PL110_CR_EN) && (s->cr & PL110_CR_PWR);
pl110.c:    switch (ds_get_bits_per_pixel(s->ds)) {
pl110.c:    if (s->cr & PL110_CR_BGR)
pl110.c:    if (s->cr & PL110_CR_BEBO)
pl110.c:        fn = fntable[s->bpp + 6 + bpp_offset];
pl110.c:    else if (s->cr & PL110_CR_BEPO)
pl110.c:        fn = fntable[s->bpp + 12 + bpp_offset];
pl110.c:        fn = fntable[s->bpp + bpp_offset];
pl110.c:    src_width = s->cols;
pl110.c:    switch (s->bpp) {
pl110.c:    dest_width *= s->cols;
pl110.c:    framebuffer_update_display(s->ds,
pl110.c:                               s->upbase, s->cols, s->rows,
pl110.c:                               s->invalidate,
pl110.c:                               fn, s->pallette,
pl110.c:        dpy_update(s->ds, 0, first, s->cols, last - first + 1);
pl110.c:    s->invalidate = 0;
pl110.c:    s->invalidate = 1;
pl110.c:        qemu_console_resize(s->ds, s->cols, s->rows);
pl110.c:    raw = s->raw_pallette[n];
pl110.c:        switch (ds_get_bits_per_pixel(s->ds)) {
pl110.c:            s->pallette[n] = rgb_to_pixel8(r, g, b);
pl110.c:            s->pallette[n] = rgb_to_pixel15(r, g, b);
pl110.c:            s->pallette[n] = rgb_to_pixel16(r, g, b);
pl110.c:            s->pallette[n] = rgb_to_pixel32(r, g, b);
pl110.c:    if (width != s->cols || height != s->rows) {
pl110.c:            qemu_console_resize(s->ds, width, height);
pl110.c:    s->cols = width;
pl110.c:    s->rows = height;
pl110.c:        if (s->versatile)
pl110.c:            return pl110_versatile_id[(offset - 0xfe0) >> 2];
pl110.c:            return pl110_id[(offset - 0xfe0) >> 2];
pl110.c:        return s->raw_pallette[(offset - 0x200) >> 2];
pl110.c:        return s->timing[0];
pl110.c:        return s->timing[1];
pl110.c:        return s->timing[2];
pl110.c:        return s->timing[3];
pl110.c:        return s->upbase;
pl110.c:        return s->lpbase;
pl110.c:	if (s->versatile)
pl110.c:	  return s->cr;
pl110.c:        return s->int_mask;
pl110.c:	if (s->versatile)
pl110.c:	  return s->int_mask;
pl110.c:        return s->cr;
pl110.c:        return s->int_status;
pl110.c:        return s->int_status & s->int_mask;
pl110.c:        return s->upbase;
pl110.c:        return s->lpbase;
pl110.c:    s->invalidate = 1;
pl110.c:        n = (offset - 0x200) >> 2;
pl110.c:        s->raw_pallette[(offset - 0x200) >> 2] = val;
pl110.c:        s->timing[0] = val;
pl110.c:        pl110_resize(s, n, s->rows);
pl110.c:        s->timing[1] = val;
pl110.c:        pl110_resize(s, s->cols, n);
pl110.c:        s->timing[2] = val;
pl110.c:        s->timing[3] = val;
pl110.c:        s->upbase = val;
pl110.c:        s->lpbase = val;
pl110.c:        if (s->versatile)
pl110.c:        s->int_mask = val;
pl110.c:        if (s->versatile)
pl110.c:        s->cr = val;
pl110.c:        s->bpp = (val >> 1) & 7;
pl110.c:            qemu_console_resize(s->ds, s->cols, s->rows);
pl110.c:        s->int_status &= ~val;
pl110.c:    sysbus_init_irq(dev, &s->irq);
pl110.c:    s->ds = graphic_console_init(pl110_update_display,
pl110.c:    s->versatile = 1;
pl110_template.h:#define FN(x, y) COPY_PIXEL(d, pallette[(data >> (y + 7 - (x))) & 1]);
pl110_template.h:        width -= 32;
pl110_template.h:#define FN(x, y) COPY_PIXEL(d, pallette[(data >> (y + 6 - (x)*2)) & 3]);
pl110_template.h:        width -= 16;
pl110_template.h:#define FN(x, y) COPY_PIXEL(d, pallette[(data >> (y + 4 - (x)*4)) & 0xf]);
pl110_template.h:        width -= 8;
pl110_template.h:        width -= 4;
pl110_template.h:        width -= 2;
pl110_template.h:        width--;
pl181.c:        qemu_set_irq(s->irq[i], (s->status & s->mask[i]) != 0);
pl181.c:    if (s->fifo_len == PL181_FIFO_LEN) {
pl181.c:    n = (s->fifo_pos + s->fifo_len) & (PL181_FIFO_LEN - 1);
pl181.c:    s->fifo_len++;
pl181.c:    s->fifo[n] = value;
pl181.c:    if (s->fifo_len == 0) {
pl181.c:    value = s->fifo[s->fifo_pos];
pl181.c:    s->fifo_len--;
pl181.c:    s->fifo_pos = (s->fifo_pos + 1) & (PL181_FIFO_LEN - 1);
pl181.c:    request.cmd = s->cmd & PL181_CMD_INDEX;
pl181.c:    request.arg = s->cmdarg;
pl181.c:    rlen = sd_do_command(s->card, &request, response);
pl181.c:    if (s->cmd & PL181_CMD_RESPONSE) {
pl181.c:        if (rlen == 0 || (rlen == 4 && (s->cmd & PL181_CMD_LONGRESP)))
pl181.c:        s->response[0] = RWORD(0);
pl181.c:            s->response[1] = s->response[2] = s->response[3] = 0;
pl181.c:            s->response[1] = RWORD(4);
pl181.c:            s->response[2] = RWORD(8);
pl181.c:            s->response[3] = RWORD(12) & ~1;
pl181.c:        s->status |= PL181_STATUS_CMDRESPEND;
pl181.c:        s->status |= PL181_STATUS_CMDSENT;
pl181.c:    s->status |= PL181_STATUS_CMDTIMEOUT;
pl181.c:   the FIFO holding 32-bit words and the card taking data in single byte
pl181.c:   chunks.  FIFO bytes are transferred in little-endian order.  */
pl181.c:    is_read = (s->datactrl & PL181_DATA_DIRECTION) != 0;
pl181.c:    if (s->datacnt != 0 && (!is_read || sd_data_ready(s->card))
pl181.c:            && !s->linux_hack) {
pl181.c:        while (s->datacnt && s->fifo_len != limit) {
pl181.c:                value |= (uint32_t)sd_read_data(s->card) << (n * 8);
pl181.c:                sd_write_data(s->card, value & 0xff);
pl181.c:                n--;
pl181.c:            s->datacnt--;
pl181.c:    s->status &= ~(PL181_STATUS_RX_FIFO | PL181_STATUS_TX_FIFO);
pl181.c:    if (s->datacnt == 0) {
pl181.c:        s->status |= PL181_STATUS_DATAEND;
pl181.c:        s->status |= PL181_STATUS_DATABLOCKEND;
pl181.c:    if (s->datacnt == 0 && s->fifo_len == 0) {
pl181.c:        s->datactrl &= ~PL181_DATA_ENABLE;
pl181.c:        if (s->fifo_len == 0) {
pl181.c:        if (s->fifo_len == 16) {
pl181.c:        if (s->fifo_len <= 8) {
pl181.c:        if (s->fifo_len >= 8) {
pl181.c:        if (s->datactrl & PL181_DATA_DIRECTION) {
pl181.c:        s->status |= bits;
pl181.c:        return pl181_id[(offset - 0xfe0) >> 2];
pl181.c:        return s->power;
pl181.c:        return s->clock;
pl181.c:        return s->cmdarg;
pl181.c:        return s->cmd;
pl181.c:        return s->respcmd;
pl181.c:        return s->response[0];
pl181.c:        return s->response[1];
pl181.c:        return s->response[2];
pl181.c:        return s->response[3];
pl181.c:        return s->datatimer;
pl181.c:        return s->datalength;
pl181.c:        return s->datactrl;
pl181.c:        return s->datacnt;
pl181.c:        tmp = s->status;
pl181.c:        if (s->linux_hack) {
pl181.c:            s->linux_hack = 0;
pl181.c:        return s->mask[0];
pl181.c:        return s->mask[1];
pl181.c:        tmp = (s->datacnt + 3) >> 2;
pl181.c:        if (s->linux_hack) {
pl181.c:            s->linux_hack = 0;
pl181.c:        if (s->fifo_len == 0) {
pl181.c:            s->linux_hack = 1;
pl181.c:        s->power = value & 0xff;
pl181.c:        s->clock = value & 0xff;
pl181.c:        s->cmdarg = value;
pl181.c:        s->cmd = value;
pl181.c:        if (s->cmd & PL181_CMD_ENABLE) {
pl181.c:            if (s->cmd & PL181_CMD_INTERRUPT) {
pl181.c:            } if (s->cmd & PL181_CMD_PENDING) {
pl181.c:            s->cmd &= ~PL181_CMD_ENABLE;
pl181.c:        s->datatimer = value;
pl181.c:        s->datalength = value & 0xffff;
pl181.c:        s->datactrl = value & 0xff;
pl181.c:            s->datacnt = s->datalength;
pl181.c:        s->status &= ~(value & 0x7ff);
pl181.c:        s->mask[0] = value;
pl181.c:        s->mask[1] = value;
pl181.c:        if (s->datacnt == 0) {
pl181.c:    s->power = 0;
pl181.c:    s->cmdarg = 0;
pl181.c:    s->cmd = 0;
pl181.c:    s->datatimer = 0;
pl181.c:    s->datalength = 0;
pl181.c:    s->respcmd = 0;
pl181.c:    s->response[0] = 0;
pl181.c:    s->response[1] = 0;
pl181.c:    s->response[2] = 0;
pl181.c:    s->response[3] = 0;
pl181.c:    s->datatimer = 0;
pl181.c:    s->datalength = 0;
pl181.c:    s->datactrl = 0;
pl181.c:    s->datacnt = 0;
pl181.c:    s->status = 0;
pl181.c:    s->linux_hack = 0;
pl181.c:    s->mask[0] = 0;
pl181.c:    s->mask[1] = 0;
pl181.c:    sysbus_init_irq(dev, &s->irq[0]);
pl181.c:    sysbus_init_irq(dev, &s->irq[1]);
pl181.c:    bd = qdev_init_bdrv(&dev->qdev, IF_SD);
pl181.c:    s->card = sd_init(bd, 0);
pl190.c:    return (s->level | s->soft_level) & s->irq_enable & ~s->fiq_select;
pl190.c:    set = (level & s->prio_mask[s->priority]) != 0;
pl190.c:    qemu_set_irq(s->irq, set);
pl190.c:    set = ((s->level | s->soft_level) & s->fiq_select) != 0;
pl190.c:    qemu_set_irq(s->fiq, set);
pl190.c:        s->level |= 1u << irq;
pl190.c:        s->level &= ~(1u << irq);
pl190.c:        s->prio_mask[i] = mask;
pl190.c:        if (s->vect_control[i] & 0x20)
pl190.c:            n = s->vect_control[i] & 0x1f;
pl190.c:    s->prio_mask[16] = mask;
pl190.c:        return pl190_id[(offset - 0xfe0) >> 2];
pl190.c:        return s->vect_addr[(offset - 0x100) >> 2];
pl190.c:        return s->vect_control[(offset - 0x200) >> 2];
pl190.c:        return (s->level | s->soft_level) & s->fiq_select;
pl190.c:        return s->level | s->soft_level;
pl190.c:        return s->fiq_select;
pl190.c:        return s->irq_enable;
pl190.c:        return s->soft_level;
pl190.c:        return s->protected;
pl190.c:        for (i = 0; i < s->priority; i++)
pl190.c:            if ((s->level | s->soft_level) & s->prio_mask[i])
pl190.c:          return s->vect_addr[16];
pl190.c:        if (i < s->priority)
pl190.c:            s->prev_prio[i] = s->priority;
pl190.c:            s->priority = i;
pl190.c:        return s->vect_addr[s->priority];
pl190.c:        return s->vect_addr[16];
pl190.c:        s->vect_addr[(offset - 0x100) >> 2] = val;
pl190.c:        s->vect_control[(offset - 0x200) >> 2] = val;
pl190.c:        s->fiq_select = val;
pl190.c:        s->irq_enable |= val;
pl190.c:        s->irq_enable &= ~val;
pl190.c:        s->soft_level |= val;
pl190.c:        s->soft_level &= ~val;
pl190.c:        s->protected = val & 1;
pl190.c:        if (s->priority < PL190_NUM_PRIO)
pl190.c:            s->priority = s->prev_prio[s->priority];
pl190.c:        s->default_addr = val;
pl190.c:      s->vect_addr[i] = 0;
pl190.c:      s->vect_control[i] = 0;
pl190.c:  s->vect_addr[16] = 0;
pl190.c:  s->prio_mask[17] = 0xffffffff;
pl190.c:  s->priority = PL190_NUM_PRIO;
pl190.c:    qdev_init_gpio_in(&dev->qdev, pl190_set_irq, 32);
pl190.c:    sysbus_init_irq(dev, &s->irq);
pl190.c:    sysbus_init_irq(dev, &s->fiq);
ppc405_boards.c:#include "qemu-log.h"
ppc405_boards.c: * - PowerPC 405EP CPU
ppc405_boards.c: * - SDRAM (0x00000000)
ppc405_boards.c: * - Flash (0xFFF80000)
ppc405_boards.c: * - SRAM  (0xFFF00000)
ppc405_boards.c: * - NVRAM (0xF0000000)
ppc405_boards.c: * - FPGA  (0xF0300000)
ppc405_boards.c:        ret = fpga->reg0;
ppc405_boards.c:        ret = fpga->reg1;
ppc405_boards.c:        fpga->reg1 = value;
ppc405_boards.c:    fpga->reg0 = 0x00;
ppc405_boards.c:    fpga->reg1 = 0x0F;
ppc405_boards.c:        bios_size = bdrv_getlength(dinfo->bdrv);
ppc405_boards.c:               fl_idx, bios_size, bios_offset, -bios_size,
ppc405_boards.c:               bdrv_get_device_name(dinfo->bdrv), fl_sectors);
ppc405_boards.c:        pflash_cfi02_register((uint32_t)(-bios_size), bios_offset,
ppc405_boards.c:                              dinfo->bdrv, 65536, fl_sectors, 1,
ppc405_boards.c:            bios_size = -1;
ppc405_boards.c:        cpu_register_physical_memory((uint32_t)(-bios_size),
ppc405_boards.c:        bd.bi_flashstart = -bios_size;
ppc405_boards.c:        bd.bi_flashsize = -bios_size;
ppc405_boards.c:        env->gpr[3] = bdloc;
ppc405_boards.c:                                          ram_size - kernel_base);
ppc405_boards.c:                                              ram_size - initrd_base);
ppc405_boards.c:        env->gpr[4] = initrd_base;
ppc405_boards.c:        env->gpr[5] = initrd_size;
ppc405_boards.c:            bdloc -= ((len + 255) & ~255);
ppc405_boards.c:            env->gpr[6] = bdloc;
ppc405_boards.c:            env->gpr[7] = bdloc + len;
ppc405_boards.c:            env->gpr[6] = 0;
ppc405_boards.c:            env->gpr[7] = 0;
ppc405_boards.c:        env->nip = KERNEL_LOAD_ADDR;
ppc405_boards.c:/* - PowerPC 405EP processor
ppc405_boards.c: * - SDRAM               128 MB at 0x00000000
ppc405_boards.c: * - Boot flash          2 MB   at 0xFFE00000
ppc405_boards.c: * - Application flash   32 MB  at 0xFC000000
ppc405_boards.c: * - 2 serial ports
ppc405_boards.c: * - 2 ethernet PHY
ppc405_boards.c: * - 1 USB 1.1 device    0x50000000
ppc405_boards.c: * - 1 LCD display       0x50100000
ppc405_boards.c: * - 1 CPLD              0x50100000
ppc405_boards.c: * - 1 I2C EEPROM
ppc405_boards.c: * - 1 I2C thermal sensor
ppc405_boards.c: * - a set of LEDs
ppc405_boards.c: * - bit-bang SPI port using GPIOs
ppc405_boards.c: * - 1 EBC interface connector 0 0x50200000
ppc405_boards.c: * - 1 cardbus controller + expansion slot.
ppc405_boards.c: * - 1 PCI expansion slot.
ppc405_boards.c:        ret = cpld->reg0;
ppc405_boards.c:        ret = cpld->reg1;
ppc405_boards.c:        cpld->reg1 = value;
ppc405_boards.c:    cpld->reg0 = 0x01;
ppc405_boards.c:    cpld->reg1 = 0x80;
ppc405_boards.c:        bios_size = bdrv_getlength(dinfo->bdrv);
ppc405_boards.c:               fl_idx, bios_size, bios_offset, -bios_size,
ppc405_boards.c:               bdrv_get_device_name(dinfo->bdrv), fl_sectors);
ppc405_boards.c:        pflash_cfi02_register((uint32_t)(-bios_size), bios_offset,
ppc405_boards.c:                              dinfo->bdrv, 65536, fl_sectors, 1,
ppc405_boards.c:            bios_size = -1;
ppc405_boards.c:        cpu_register_physical_memory((uint32_t)(-bios_size),
ppc405_boards.c:        bios_size = bdrv_getlength(dinfo->bdrv);
ppc405_boards.c:               bdrv_get_device_name(dinfo->bdrv));
ppc405_boards.c:                              dinfo->bdrv, 65536, fl_sectors, 1,
ppc405_boards.c:                                          ram_size - kernel_base);
ppc405_boards.c:                                              ram_size - initrd_base);
ppc405.h:/* Bootinfo as set-up by u-boot */
ppc405_uc.c:#include "qemu-timer.h"
ppc405_uc.c:#include "qemu-log.h"
ppc405_uc.c:    if (bd->bi_memsize >= 0x01000000UL)
ppc405_uc.c:        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);
ppc405_uc.c:        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);
ppc405_uc.c:    stl_phys(bdloc + 0x00, bd->bi_memstart);
ppc405_uc.c:    stl_phys(bdloc + 0x04, bd->bi_memsize);
ppc405_uc.c:    stl_phys(bdloc + 0x08, bd->bi_flashstart);
ppc405_uc.c:    stl_phys(bdloc + 0x0C, bd->bi_flashsize);
ppc405_uc.c:    stl_phys(bdloc + 0x10, bd->bi_flashoffset);
ppc405_uc.c:    stl_phys(bdloc + 0x14, bd->bi_sramstart);
ppc405_uc.c:    stl_phys(bdloc + 0x18, bd->bi_sramsize);
ppc405_uc.c:    stl_phys(bdloc + 0x1C, bd->bi_bootflags);
ppc405_uc.c:    stl_phys(bdloc + 0x20, bd->bi_ipaddr);
ppc405_uc.c:        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);
ppc405_uc.c:    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);
ppc405_uc.c:    stl_phys(bdloc + 0x2C, bd->bi_intfreq);
ppc405_uc.c:    stl_phys(bdloc + 0x30, bd->bi_busfreq);
ppc405_uc.c:    stl_phys(bdloc + 0x34, bd->bi_baudrate);
ppc405_uc.c:        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);
ppc405_uc.c:        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);
ppc405_uc.c:    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);
ppc405_uc.c:    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);
ppc405_uc.c:        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);
ppc405_uc.c:            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);
ppc405_uc.c:    stl_phys(bdloc + n, bd->bi_opbfreq);
ppc405_uc.c:        stl_phys(bdloc + n, bd->bi_iic_fast[i]);
ppc405_uc.c:        ret = plb->acr;
ppc405_uc.c:        ret = plb->bear;
ppc405_uc.c:        ret = plb->besr;
ppc405_uc.c:        plb->acr = val & 0xF8000000;
ppc405_uc.c:        /* Write-clear */
ppc405_uc.c:        plb->besr &= ~val;
ppc405_uc.c:    plb->acr = 0x00000000;
ppc405_uc.c:    plb->bear = 0x00000000;
ppc405_uc.c:    plb->besr = 0x00000000;
ppc405_uc.c:        ret = pob->bear;
ppc405_uc.c:        ret = pob->besr[dcrn - POB0_BESR0];
ppc405_uc.c:        /* Write-clear */
ppc405_uc.c:        pob->besr[dcrn - POB0_BESR0] &= ~val;
ppc405_uc.c:    pob->bear = 0x00000000;
ppc405_uc.c:    pob->besr[0] = 0x0000000;
ppc405_uc.c:    pob->besr[1] = 0x0000000;
ppc405_uc.c:        ret = opba->cr;
ppc405_uc.c:        ret = opba->pr;
ppc405_uc.c:        opba->cr = value & 0xF8;
ppc405_uc.c:        opba->pr = value & 0xFF;
ppc405_uc.c:    opba->cr = 0x00; /* No dynamic priorities - park disabled */
ppc405_uc.c:    opba->pr = 0x11;
ppc405_uc.c:        ret = ebc->addr;
ppc405_uc.c:        switch (ebc->addr) {
ppc405_uc.c:            ret = ebc->bcr[0];
ppc405_uc.c:            ret = ebc->bcr[1];
ppc405_uc.c:            ret = ebc->bcr[2];
ppc405_uc.c:            ret = ebc->bcr[3];
ppc405_uc.c:            ret = ebc->bcr[4];
ppc405_uc.c:            ret = ebc->bcr[5];
ppc405_uc.c:            ret = ebc->bcr[6];
ppc405_uc.c:            ret = ebc->bcr[7];
ppc405_uc.c:            ret = ebc->bap[0];
ppc405_uc.c:            ret = ebc->bap[1];
ppc405_uc.c:            ret = ebc->bap[2];
ppc405_uc.c:            ret = ebc->bap[3];
ppc405_uc.c:            ret = ebc->bap[4];
ppc405_uc.c:            ret = ebc->bap[5];
ppc405_uc.c:            ret = ebc->bap[6];
ppc405_uc.c:            ret = ebc->bap[7];
ppc405_uc.c:            ret = ebc->bear;
ppc405_uc.c:            ret = ebc->besr0;
ppc405_uc.c:            ret = ebc->besr1;
ppc405_uc.c:            ret = ebc->cfg;
ppc405_uc.c:        ebc->addr = val;
ppc405_uc.c:        switch (ebc->addr) {
ppc405_uc.c:    ebc->addr = 0x00000000;
ppc405_uc.c:    ebc->bap[0] = 0x7F8FFE80;
ppc405_uc.c:    ebc->bcr[0] = 0xFFE28000;
ppc405_uc.c:        ebc->bap[i] = 0x00000000;
ppc405_uc.c:        ebc->bcr[i] = 0x00000000;
ppc405_uc.c:    ebc->besr0 = 0x00000000;
ppc405_uc.c:    ebc->besr1 = 0x00000000;
ppc405_uc.c:    ebc->cfg = 0x80400000;
ppc405_uc.c:        dma->cr[i] = 0x00000000;
ppc405_uc.c:        dma->ct[i] = 0x00000000;
ppc405_uc.c:        dma->da[i] = 0x00000000;
ppc405_uc.c:        dma->sa[i] = 0x00000000;
ppc405_uc.c:        dma->sg[i] = 0x00000000;
ppc405_uc.c:    dma->sr = 0x00000000;
ppc405_uc.c:    dma->sgc = 0x00000000;
ppc405_uc.c:    dma->slp = 0x7C000000;
ppc405_uc.c:    dma->pol = 0x00000000;
ppc405_uc.c:    memcpy(dma->irqs, irqs, 4 * sizeof(qemu_irq));
ppc405_uc.c:           ocm->isarc, ocm->isacntl, ocm->dsarc, ocm->dsacntl);
ppc405_uc.c:    if (ocm->isarc != isarc ||
ppc405_uc.c:        (ocm->isacntl & 0x80000000) != (isacntl & 0x80000000)) {
ppc405_uc.c:        if (ocm->isacntl & 0x80000000) {
ppc405_uc.c:            printf("OCM unmap ISA %08" PRIx32 "\n", ocm->isarc);
ppc405_uc.c:            cpu_register_physical_memory(ocm->isarc, 0x04000000,
ppc405_uc.c:                                         ocm->offset | IO_MEM_RAM);
ppc405_uc.c:    if (ocm->dsarc != dsarc ||
ppc405_uc.c:        (ocm->dsacntl & 0x80000000) != (dsacntl & 0x80000000)) {
ppc405_uc.c:        if (ocm->dsacntl & 0x80000000) {
ppc405_uc.c:            if (!(isacntl & 0x80000000) || ocm->dsarc != isarc) {
ppc405_uc.c:                printf("OCM unmap DSA %08" PRIx32 "\n", ocm->dsarc);
ppc405_uc.c:                cpu_register_physical_memory(ocm->dsarc, 0x04000000,
ppc405_uc.c:                                             ocm->offset | IO_MEM_RAM);
ppc405_uc.c:        ret = ocm->isarc;
ppc405_uc.c:        ret = ocm->isacntl;
ppc405_uc.c:        ret = ocm->dsarc;
ppc405_uc.c:        ret = ocm->dsacntl;
ppc405_uc.c:    isarc = ocm->isarc;
ppc405_uc.c:    dsarc = ocm->dsarc;
ppc405_uc.c:    isacntl = ocm->isacntl;
ppc405_uc.c:    dsacntl = ocm->dsacntl;
ppc405_uc.c:    ocm->isarc = isarc;
ppc405_uc.c:    ocm->dsarc = dsarc;
ppc405_uc.c:    ocm->isacntl = isacntl;
ppc405_uc.c:    ocm->dsacntl = dsacntl;
ppc405_uc.c:    ocm->isarc = isarc;
ppc405_uc.c:    ocm->dsarc = dsarc;
ppc405_uc.c:    ocm->isacntl = isacntl;
ppc405_uc.c:    ocm->dsacntl = dsacntl;
ppc405_uc.c:    ocm->offset = qemu_ram_alloc(4096);
ppc405_uc.c:        //        i2c_readbyte(&i2c->mdata);
ppc405_uc.c:        ret = i2c->mdata;
ppc405_uc.c:        ret = i2c->sdata;
ppc405_uc.c:        ret = i2c->lmadr;
ppc405_uc.c:        ret = i2c->hmadr;
ppc405_uc.c:        ret = i2c->cntl;
ppc405_uc.c:        ret = i2c->mdcntl;
ppc405_uc.c:        ret = i2c->sts;
ppc405_uc.c:        ret = i2c->extsts;
ppc405_uc.c:        ret = i2c->lsadr;
ppc405_uc.c:        ret = i2c->hsadr;
ppc405_uc.c:        ret = i2c->clkdiv;
ppc405_uc.c:        ret = i2c->intrmsk;
ppc405_uc.c:        ret = i2c->xfrcnt;
ppc405_uc.c:        ret = i2c->xtcntlss;
ppc405_uc.c:        ret = i2c->directcntl;
ppc405_uc.c:        i2c->mdata = value;
ppc405_uc.c:        //        i2c_sendbyte(&i2c->mdata);
ppc405_uc.c:        i2c->sdata = value;
ppc405_uc.c:        i2c->lmadr = value;
ppc405_uc.c:        i2c->hmadr = value;
ppc405_uc.c:        i2c->cntl = value;
ppc405_uc.c:        i2c->mdcntl = value & 0xDF;
ppc405_uc.c:        i2c->sts &= ~(value & 0x0A);
ppc405_uc.c:        i2c->extsts &= ~(value & 0x8F);
ppc405_uc.c:        i2c->lsadr = value;
ppc405_uc.c:        i2c->hsadr = value;
ppc405_uc.c:        i2c->clkdiv = value;
ppc405_uc.c:        i2c->intrmsk = value;
ppc405_uc.c:        i2c->xfrcnt = value & 0x77;
ppc405_uc.c:        i2c->xtcntlss = value;
ppc405_uc.c:        i2c->directcntl = value & 0x7;
ppc405_uc.c:    i2c->mdata = 0x00;
ppc405_uc.c:    i2c->sdata = 0x00;
ppc405_uc.c:    i2c->cntl = 0x00;
ppc405_uc.c:    i2c->mdcntl = 0x00;
ppc405_uc.c:    i2c->sts = 0x00;
ppc405_uc.c:    i2c->extsts = 0x00;
ppc405_uc.c:    i2c->clkdiv = 0x00;
ppc405_uc.c:    i2c->xfrcnt = 0x00;
ppc405_uc.c:    i2c->directcntl = 0x0F;
ppc405_uc.c:    i2c->irq = irq;
ppc405_uc.c:    return -1;
ppc405_uc.c:    return -1;
ppc405_uc.c:        if (gpt->oe & mask) {
ppc405_uc.c:                ppc4xx_gpt_set_output(gpt, i, gpt->ol & mask);
ppc405_uc.c:                ppc4xx_gpt_set_output(gpt, i, gpt->ol & mask ? 0 : 1);
ppc405_uc.c:        if (gpt->is & gpt->im & mask)
ppc405_uc.c:            qemu_irq_raise(gpt->irqs[i]);
ppc405_uc.c:            qemu_irq_lower(gpt->irqs[i]);
ppc405_uc.c:        ret = muldiv64(qemu_get_clock(vm_clock) + gpt->tb_offset,
ppc405_uc.c:                       gpt->tb_freq, get_ticks_per_sec());
ppc405_uc.c:        ret = gpt->oe;
ppc405_uc.c:        ret = gpt->ol;
ppc405_uc.c:        ret = gpt->im;
ppc405_uc.c:        ret = gpt->is;
ppc405_uc.c:        ret = gpt->ie;
ppc405_uc.c:        idx = (addr - 0x80) >> 2;
ppc405_uc.c:        ret = gpt->comp[idx];
ppc405_uc.c:        idx = (addr - 0xC0) >> 2;
ppc405_uc.c:        ret = gpt->mask[idx];
ppc405_uc.c:        ret = -1;
ppc405_uc.c:        gpt->tb_offset = muldiv64(value, get_ticks_per_sec(), gpt->tb_freq)
ppc405_uc.c:            - qemu_get_clock(vm_clock);
ppc405_uc.c:        gpt->oe = value & 0xF8000000;
ppc405_uc.c:        gpt->ol = value & 0xF8000000;
ppc405_uc.c:        gpt->im = value & 0x0000F800;
ppc405_uc.c:        gpt->is |= value & 0x0000F800;
ppc405_uc.c:        gpt->is &= ~(value & 0x0000F800);
ppc405_uc.c:        gpt->ie = value & 0x0000F800;
ppc405_uc.c:        idx = (addr - 0x80) >> 2;
ppc405_uc.c:        gpt->comp[idx] = value & 0xF8000000;
ppc405_uc.c:        idx = (addr - 0xC0) >> 2;
ppc405_uc.c:        gpt->mask[idx] = value & 0xF8000000;
ppc405_uc.c:    qemu_del_timer(gpt->timer);
ppc405_uc.c:    gpt->oe = 0x00000000;
ppc405_uc.c:    gpt->ol = 0x00000000;
ppc405_uc.c:    gpt->im = 0x00000000;
ppc405_uc.c:    gpt->is = 0x00000000;
ppc405_uc.c:    gpt->ie = 0x00000000;
ppc405_uc.c:        gpt->comp[i] = 0x00000000;
ppc405_uc.c:        gpt->mask[i] = 0x00000000;
ppc405_uc.c:        gpt->irqs[i] = irqs[i];
ppc405_uc.c:    gpt->timer = qemu_new_timer(vm_clock, &ppc4xx_gpt_cb, gpt);
ppc405_uc.c:        ret = mal->cfg;
ppc405_uc.c:        ret = mal->esr;
ppc405_uc.c:        ret = mal->ier;
ppc405_uc.c:        ret = mal->txcasr;
ppc405_uc.c:        ret = mal->txcarr;
ppc405_uc.c:        ret = mal->txeobisr;
ppc405_uc.c:        ret = mal->txdeir;
ppc405_uc.c:        ret = mal->rxcasr;
ppc405_uc.c:        ret = mal->rxcarr;
ppc405_uc.c:        ret = mal->rxeobisr;
ppc405_uc.c:        ret = mal->rxdeir;
ppc405_uc.c:        ret = mal->txctpr[0];
ppc405_uc.c:        ret = mal->txctpr[1];
ppc405_uc.c:        ret = mal->txctpr[2];
ppc405_uc.c:        ret = mal->txctpr[3];
ppc405_uc.c:        ret = mal->rxctpr[0];
ppc405_uc.c:        ret = mal->rxctpr[1];
ppc405_uc.c:        ret = mal->rcbs[0];
ppc405_uc.c:        ret = mal->rcbs[1];
ppc405_uc.c:        mal->cfg = val & 0x00FFC087;
ppc405_uc.c:        mal->esr &= ~val;
ppc405_uc.c:        mal->ier = val & 0x0000001F;
ppc405_uc.c:        mal->txcasr = val & 0xF0000000;
ppc405_uc.c:        mal->txcarr = val & 0xF0000000;
ppc405_uc.c:        mal->txeobisr &= ~val;
ppc405_uc.c:        mal->txdeir &= ~val;
ppc405_uc.c:        mal->rxcasr = val & 0xC0000000;
ppc405_uc.c:        mal->rxcarr = val & 0xC0000000;
ppc405_uc.c:        mal->rxeobisr &= ~val;
ppc405_uc.c:        mal->rxdeir &= ~val;
ppc405_uc.c:        mal->txctpr[idx] = val;
ppc405_uc.c:        mal->rxctpr[idx] = val;
ppc405_uc.c:        mal->rcbs[idx] = val & 0x000000FF;
ppc405_uc.c:    mal->cfg = 0x0007C000;
ppc405_uc.c:    mal->esr = 0x00000000;
ppc405_uc.c:    mal->ier = 0x00000000;
ppc405_uc.c:    mal->rxcasr = 0x00000000;
ppc405_uc.c:    mal->rxdeir = 0x00000000;
ppc405_uc.c:    mal->rxeobisr = 0x00000000;
ppc405_uc.c:    mal->txcasr = 0x00000000;
ppc405_uc.c:    mal->txdeir = 0x00000000;
ppc405_uc.c:    mal->txeobisr = 0x00000000;
ppc405_uc.c:        mal->irqs[i] = irqs[i];
ppc405_uc.c:    env->interrupt_request |= CPU_INTERRUPT_EXITTB;
ppc405_uc.c:    dbsr = env->spr[SPR_40x_DBSR];
ppc405_uc.c:    env->spr[SPR_40x_DBSR] = dbsr;
ppc405_uc.c:    env->interrupt_request |= CPU_INTERRUPT_EXITTB;
ppc405_uc.c:    dbsr = env->spr[SPR_40x_DBSR];
ppc405_uc.c:    env->spr[SPR_40x_DBSR] = dbsr;
ppc405_uc.c:    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */
ppc405_uc.c:    if (cpc->pllmr & 0x80000000) {
ppc405_uc.c:        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */
ppc405_uc.c:        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */
ppc405_uc.c:        VCO_out = cpc->sysclk * M;
ppc405_uc.c:            cpc->pllmr &= ~0x80000000;
ppc405_uc.c:        PLL_out = cpc->sysclk * M;
ppc405_uc.c:    if (cpc->cr1 & 0x00800000)
ppc405_uc.c:        TMR_clk = cpc->sysclk; /* Should have a separate clock */
ppc405_uc.c:    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;
ppc405_uc.c:    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;
ppc405_uc.c:    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);
ppc405_uc.c:    /* Setup time-base clock */
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);
ppc405_uc.c:        ret = cpc->pllmr;
ppc405_uc.c:        ret = cpc->cr0;
ppc405_uc.c:        ret = cpc->cr1;
ppc405_uc.c:        ret = cpc->psr;
ppc405_uc.c:        ret = cpc->jtagid;
ppc405_uc.c:        ret = cpc->er;
ppc405_uc.c:        ret = cpc->fr;
ppc405_uc.c:        ret = ~(cpc->er | cpc->fr) & 0xFFFF0000;
ppc405_uc.c:        cpc->pllmr = val & 0xFFF77C3F;
ppc405_uc.c:        cpc->cr0 = val & 0x0FFFFFFE;
ppc405_uc.c:        cpc->cr1 = val & 0x00800000;
ppc405_uc.c:        /* Read-only */
ppc405_uc.c:        /* Read-only */
ppc405_uc.c:        cpc->er = val & 0xBFFC0000;
ppc405_uc.c:        cpc->fr = val & 0xBFFC0000;
ppc405_uc.c:        /* Read-only */
ppc405_uc.c:    cpc->pllmr = 0x80000000;
ppc405_uc.c:    switch ((cpc->psr >> 30) & 3) {
ppc405_uc.c:        cpc->pllmr &= ~0x80000000;
ppc405_uc.c:        cpc->pllmr |= 5 << 16;
ppc405_uc.c:        cpc->pllmr |= 4 << 16;
ppc405_uc.c:        cpc->pllmr |= 2 << 16;
ppc405_uc.c:    D = (cpc->psr >> 28) & 3;
ppc405_uc.c:    cpc->pllmr |= (D + 1) << 20;
ppc405_uc.c:    D = (cpc->psr >> 25) & 7;
ppc405_uc.c:        cpc->pllmr |= 0x13;
ppc405_uc.c:        cpc->pllmr |= 0x15;
ppc405_uc.c:        cpc->pllmr |= 0x16;
ppc405_uc.c:    D = (cpc->psr >> 23) & 3;
ppc405_uc.c:    cpc->pllmr |= D << 26;
ppc405_uc.c:    D = (cpc->psr >> 21) & 3;
ppc405_uc.c:    cpc->pllmr |= D << 10;
ppc405_uc.c:    D = (cpc->psr >> 17) & 3;
ppc405_uc.c:    cpc->pllmr |= D << 24;
ppc405_uc.c:    cpc->cr0 = 0x0000003C;
ppc405_uc.c:    cpc->cr1 = 0x2B0D8800;
ppc405_uc.c:    cpc->er = 0x00000000;
ppc405_uc.c:    cpc->fr = 0x00000000;
ppc405_uc.c:    cpc->psr = 0x00000000; /* 8 bits ROM */
ppc405_uc.c:    cpc->psr |= D << 30;
ppc405_uc.c:    cpc->psr |= D << 28;
ppc405_uc.c:    cpc->psr |= D << 23;
ppc405_uc.c:    cpc->psr |= D << 25;
ppc405_uc.c:    cpc->psr |= D << 21;
ppc405_uc.c:    cpc->psr |= D << 17;
ppc405_uc.c:    memcpy(cpc->clk_setup, clk_setup,
ppc405_uc.c:    cpc->sysclk = sysclk;
ppc405_uc.c:    cpc->jtagid = 0x42051049;
ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
ppc405_uc.c:    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {
ppc405_uc.c:        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */
ppc405_uc.c:        printf("FBMUL %01" PRIx32 " %d\n", (cpc->pllmr[1] >> 20) & 0xF, M);
ppc405_uc.c:        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */
ppc405_uc.c:        printf("FWDA %01" PRIx32 " %d\n", (cpc->pllmr[1] >> 16) & 0x7, D);
ppc405_uc.c:        VCO_out = cpc->sysclk * M * D;
ppc405_uc.c:            /* Error - unlock the PLL */
ppc405_uc.c:            cpc->pllmr[1] &= ~0x80000000;
ppc405_uc.c:        cpc->boot |= 0x00000001;
ppc405_uc.c:        PLL_out = cpc->sysclk;
ppc405_uc.c:        if (cpc->pllmr[1] & 0x40000000) {
ppc405_uc.c:            cpc->boot &= ~0x00000001;
ppc405_uc.c:    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */
ppc405_uc.c:    printf("CCDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 20) & 0x3, D);
ppc405_uc.c:    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */
ppc405_uc.c:    printf("CBDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 16) & 0x3, D);
ppc405_uc.c:    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */
ppc405_uc.c:    printf("OPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 12) & 0x3, D);
ppc405_uc.c:    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */
ppc405_uc.c:    printf("EPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 8) & 0x3, D);
ppc405_uc.c:    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */
ppc405_uc.c:    printf("MPDV %01" PRIx32 " %d\n", (cpc->pllmr[0] >> 4) & 0x3, D);
ppc405_uc.c:    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */
ppc405_uc.c:    printf("PPDV %01" PRIx32 " %d\n", cpc->pllmr[0] & 0x3, D);
ppc405_uc.c:    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */
ppc405_uc.c:    printf("U0DIV %01" PRIx32 " %d\n", cpc->ucr & 0x7F, D);
ppc405_uc.c:    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */
ppc405_uc.c:    printf("U1DIV %01" PRIx32 " %d\n", (cpc->ucr >> 8) & 0x7F, D);
ppc405_uc.c:    printf("Setup PPC405EP clocks - sysclk %" PRIu32 " VCO %" PRIu64
ppc405_uc.c:           " PLL out %" PRIu64 " Hz\n", cpc->sysclk, VCO_out, PLL_out);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);
ppc405_uc.c:    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);
ppc405_uc.c:        ret = cpc->boot;
ppc405_uc.c:        ret = cpc->epctl;
ppc405_uc.c:        ret = cpc->pllmr[0];
ppc405_uc.c:        ret = cpc->pllmr[1];
ppc405_uc.c:        ret = cpc->ucr;
ppc405_uc.c:        ret = cpc->srr;
ppc405_uc.c:        ret = cpc->jtagid;
ppc405_uc.c:        ret = cpc->pci;
ppc405_uc.c:        /* Read-only register */
ppc405_uc.c:        cpc->epctl = val & 0xC00000F3;
ppc405_uc.c:        cpc->pllmr[0] = val & 0x00633333;
ppc405_uc.c:        cpc->pllmr[1] = val & 0xC0F73FFF;
ppc405_uc.c:        /* UART control - don't care for now */
ppc405_uc.c:        cpc->ucr = val & 0x003F7F7F;
ppc405_uc.c:        cpc->srr = val;
ppc405_uc.c:        /* Read-only */
ppc405_uc.c:        cpc->pci = val;
ppc405_uc.c:    cpc->boot = 0x00000010;     /* Boot from PCI - IIC EEPROM disabled */
ppc405_uc.c:    cpc->epctl = 0x00000000;
ppc405_uc.c:    cpc->pllmr[0] = 0x00011010;
ppc405_uc.c:    cpc->pllmr[1] = 0x40000000;
ppc405_uc.c:    cpc->ucr = 0x00000000;
ppc405_uc.c:    cpc->srr = 0x00040000;
ppc405_uc.c:    cpc->pci = 0x00000000;
ppc405_uc.c:    cpc->er = 0x00000000;
ppc405_uc.c:    cpc->fr = 0x00000000;
ppc405_uc.c:    cpc->sr = 0x00000000;
ppc405_uc.c:    memcpy(cpc->clk_setup, clk_setup,
ppc405_uc.c:    cpc->jtagid = 0x20267049;
ppc405_uc.c:    cpc->sysclk = sysclk;
ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
ppc405_uc.c:        ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
ppc440_bamboo.c:#include "qemu-common.h"
ppc440_bamboo.c:#include "qemu-kvm.h"
ppc440_bamboo.c:    ret = qemu_devtree_setprop_cell(fdt, "/chosen", "linux,initrd-start",
ppc440_bamboo.c:        fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");
ppc440_bamboo.c:    ret = qemu_devtree_setprop_cell(fdt, "/chosen", "linux,initrd-end",
ppc440_bamboo.c:        fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");
ppc440_bamboo.c:                pci_create_simple(pcibus, -1, "virtio-console-pci");
ppc440_bamboo.c:                                          ram_size - initrd_base);
ppc440_bamboo.c:        env->gpr[1] = (16<<20) - 8;
ppc440_bamboo.c:        env->gpr[3] = dt_base;
ppc440_bamboo.c:        env->nip = entry;
ppc440.c:#include "qemu-kvm.h"
ppc440.c:    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];
ppc440.c:    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];
ppc4xx_devs.c:#include "qemu-log.h"
ppc4xx_devs.c:    cpu_clk->cb = NULL; /* We don't care about CPU clock frequency changes */
ppc4xx_devs.c:    cpu_clk->opaque = env;
ppc4xx_devs.c:    /* Set time-base frequency to sysclk */
ppc4xx_devs.c:    tb_clk->cb = ppc_emb_timers_init(env, sysclk);
ppc4xx_devs.c:    tb_clk->opaque = env;
ppc4xx_devs.c:    uint32_t level;  /* Remembers the state of level-triggered interrupts. */
ppc4xx_devs.c:    ir = uic->uicsr & uic->uicer & (~uic->uiccr);
ppc4xx_devs.c:    cr = uic->uicsr & uic->uicer & uic->uiccr;
ppc4xx_devs.c:                __func__, uic->uicsr, uic->uicer, uic->uiccr,
ppc4xx_devs.c:                uic->uicsr & uic->uicer, ir, cr);
ppc4xx_devs.c:        qemu_irq_raise(uic->irqs[PPCUIC_OUTPUT_INT]);
ppc4xx_devs.c:        qemu_irq_lower(uic->irqs[PPCUIC_OUTPUT_INT]);
ppc4xx_devs.c:        qemu_irq_raise(uic->irqs[PPCUIC_OUTPUT_CINT]);
ppc4xx_devs.c:        if (uic->use_vectors) {
ppc4xx_devs.c:            if (uic->uicvcr & 1) {
ppc4xx_devs.c:                inc = -1;
ppc4xx_devs.c:            uic->uicvr = uic->uicvcr & 0xFFFFFFFC;
ppc4xx_devs.c:                    uic->uicvr += (i - start) * 512 * inc;
ppc4xx_devs.c:        LOG_UIC("Raise UIC critical interrupt - "
ppc4xx_devs.c:                    "vector %08" PRIx32 "\n", uic->uicvr);
ppc4xx_devs.c:        qemu_irq_lower(uic->irqs[PPCUIC_OUTPUT_CINT]);
ppc4xx_devs.c:        uic->uicvr = 0x00000000;
ppc4xx_devs.c:    mask = 1 << (31-irq_num);
ppc4xx_devs.c:                uic->uicsr, mask, uic->uicsr & mask, level << irq_num);
ppc4xx_devs.c:    sr = uic->uicsr;
ppc4xx_devs.c:    if (uic->uictr & mask) {
ppc4xx_devs.c:            uic->uicsr |= mask;
ppc4xx_devs.c:            uic->uicsr |= mask;
ppc4xx_devs.c:            uic->level |= mask;
ppc4xx_devs.c:            uic->uicsr &= ~mask;
ppc4xx_devs.c:            uic->level &= ~mask;
ppc4xx_devs.c:                "%08" PRIx32 "\n", __func__, irq_num, level, uic->uicsr, sr);
ppc4xx_devs.c:    if (sr != uic->uicsr)
ppc4xx_devs.c:    dcrn -= uic->dcr_base;
ppc4xx_devs.c:        ret = uic->uicsr;
ppc4xx_devs.c:        ret = uic->uicer;
ppc4xx_devs.c:        ret = uic->uiccr;
ppc4xx_devs.c:        ret = uic->uicpr;
ppc4xx_devs.c:        ret = uic->uictr;
ppc4xx_devs.c:        ret = uic->uicsr & uic->uicer;
ppc4xx_devs.c:        if (!uic->use_vectors)
ppc4xx_devs.c:        ret = uic->uicvr;
ppc4xx_devs.c:        if (!uic->use_vectors)
ppc4xx_devs.c:        ret = uic->uicvcr;
ppc4xx_devs.c:    dcrn -= uic->dcr_base;
ppc4xx_devs.c:        uic->uicsr &= ~val;
ppc4xx_devs.c:        uic->uicsr |= uic->level;
ppc4xx_devs.c:        uic->uicsr |= val;
ppc4xx_devs.c:        uic->uicer = val;
ppc4xx_devs.c:        uic->uiccr = val;
ppc4xx_devs.c:        uic->uicpr = val;
ppc4xx_devs.c:        uic->uictr = val;
ppc4xx_devs.c:        uic->uicvcr = val & 0xFFFFFFFD;
ppc4xx_devs.c:    uic->uiccr = 0x00000000;
ppc4xx_devs.c:    uic->uicer = 0x00000000;
ppc4xx_devs.c:    uic->uicpr = 0x00000000;
ppc4xx_devs.c:    uic->uicsr = 0x00000000;
ppc4xx_devs.c:    uic->uictr = 0x00000000;
ppc4xx_devs.c:    if (uic->use_vectors) {
ppc4xx_devs.c:        uic->uicvcr = 0x00000000;
ppc4xx_devs.c:        uic->uicvr = 0x0000000;
ppc4xx_devs.c:    uic->dcr_base = dcr_base;
ppc4xx_devs.c:    uic->irqs = irqs;
ppc4xx_devs.c:        uic->use_vectors = 1;
ppc4xx_devs.c:        size = -1;
ppc4xx_devs.c:    for (i = 0; i < sdram->nbanks; i++) {
ppc4xx_devs.c:        if (sdram->ram_sizes[i] != 0) {
ppc4xx_devs.c:            sdram_set_bcr(&sdram->bcr[i],
ppc4xx_devs.c:                          sdram_bcr(sdram->ram_bases[i], sdram->ram_sizes[i]),
ppc4xx_devs.c:            sdram_set_bcr(&sdram->bcr[i], 0x00000000, 0);
ppc4xx_devs.c:    for (i = 0; i < sdram->nbanks; i++) {
ppc4xx_devs.c:               __func__, sdram_base(sdram->bcr[i]), sdram_size(sdram->bcr[i]));
ppc4xx_devs.c:        cpu_register_physical_memory(sdram_base(sdram->bcr[i]),
ppc4xx_devs.c:                                     sdram_size(sdram->bcr[i]),
ppc4xx_devs.c:        ret = sdram->addr;
ppc4xx_devs.c:        switch (sdram->addr) {
ppc4xx_devs.c:            ret = sdram->besr0;
ppc4xx_devs.c:            ret = sdram->besr1;
ppc4xx_devs.c:            ret = sdram->bear;
ppc4xx_devs.c:            ret = sdram->cfg;
ppc4xx_devs.c:            ret = sdram->status;
ppc4xx_devs.c:            ret = sdram->rtr;
ppc4xx_devs.c:            ret = sdram->pmit;
ppc4xx_devs.c:            ret = sdram->bcr[0];
ppc4xx_devs.c:            ret = sdram->bcr[1];
ppc4xx_devs.c:            ret = sdram->bcr[2];
ppc4xx_devs.c:            ret = sdram->bcr[3];
ppc4xx_devs.c:            ret = -1; /* ? */
ppc4xx_devs.c:            ret = sdram->ecccfg;
ppc4xx_devs.c:            ret = sdram->eccesr;
ppc4xx_devs.c:            ret = -1;
ppc4xx_devs.c:        sdram->addr = val;
ppc4xx_devs.c:        switch (sdram->addr) {
ppc4xx_devs.c:            sdram->besr0 &= ~val;
ppc4xx_devs.c:            sdram->besr1 &= ~val;
ppc4xx_devs.c:            sdram->bear = val;
ppc4xx_devs.c:            if (!(sdram->cfg & 0x80000000) && (val & 0x80000000)) {
ppc4xx_devs.c:                sdram->status &= ~0x80000000;
ppc4xx_devs.c:            } else if ((sdram->cfg & 0x80000000) && !(val & 0x80000000)) {
ppc4xx_devs.c:                sdram->status |= 0x80000000;
ppc4xx_devs.c:            if (!(sdram->cfg & 0x40000000) && (val & 0x40000000))
ppc4xx_devs.c:                sdram->status |= 0x40000000;
ppc4xx_devs.c:            else if ((sdram->cfg & 0x40000000) && !(val & 0x40000000))
ppc4xx_devs.c:                sdram->status &= ~0x40000000;
ppc4xx_devs.c:            sdram->cfg = val;
ppc4xx_devs.c:            /* Read-only register */
ppc4xx_devs.c:            sdram->rtr = val & 0x3FF80000;
ppc4xx_devs.c:            sdram->pmit = (val & 0xF8000000) | 0x07C00000;
ppc4xx_devs.c:            sdram_set_bcr(&sdram->bcr[0], val, sdram->cfg & 0x80000000);
ppc4xx_devs.c:            sdram_set_bcr(&sdram->bcr[1], val, sdram->cfg & 0x80000000);
ppc4xx_devs.c:            sdram_set_bcr(&sdram->bcr[2], val, sdram->cfg & 0x80000000);
ppc4xx_devs.c:            sdram_set_bcr(&sdram->bcr[3], val, sdram->cfg & 0x80000000);
ppc4xx_devs.c:            sdram->tr = val & 0x018FC01F;
ppc4xx_devs.c:            sdram->ecccfg = val & 0x00F00000;
ppc4xx_devs.c:            if (sdram->eccesr == 0 && val != 0)
ppc4xx_devs.c:                qemu_irq_raise(sdram->irq);
ppc4xx_devs.c:            else if (sdram->eccesr != 0 && val == 0)
ppc4xx_devs.c:                qemu_irq_lower(sdram->irq);
ppc4xx_devs.c:            sdram->eccesr = val;
ppc4xx_devs.c:    sdram->addr = 0x00000000;
ppc4xx_devs.c:    sdram->bear = 0x00000000;
ppc4xx_devs.c:    sdram->besr0 = 0x00000000; /* No error */
ppc4xx_devs.c:    sdram->besr1 = 0x00000000; /* No error */
ppc4xx_devs.c:    sdram->cfg = 0x00000000;
ppc4xx_devs.c:    sdram->ecccfg = 0x00000000; /* No ECC */
ppc4xx_devs.c:    sdram->eccesr = 0x00000000; /* No error */
ppc4xx_devs.c:    sdram->pmit = 0x07C00000;
ppc4xx_devs.c:    sdram->rtr = 0x05F00000;
ppc4xx_devs.c:    sdram->tr = 0x00854009;
ppc4xx_devs.c:    /* We pre-initialize RAM banks */
ppc4xx_devs.c:    sdram->status = 0x00000000;
ppc4xx_devs.c:    sdram->cfg = 0x00800000;
ppc4xx_devs.c:    sdram->irq = irq;
ppc4xx_devs.c:    sdram->nbanks = nbanks;
ppc4xx_devs.c:    memset(sdram->ram_bases, 0, 4 * sizeof(target_phys_addr_t));
ppc4xx_devs.c:    memcpy(sdram->ram_bases, ram_bases,
ppc4xx_devs.c:    memset(sdram->ram_sizes, 0, 4 * sizeof(target_phys_addr_t));
ppc4xx_devs.c:    memcpy(sdram->ram_sizes, ram_sizes,
ppc4xx_devs.c: * sdram_bank_sizes[] must be 0-terminated.
ppc4xx_devs.c:                size_left -= bank_size;
ppc4xx_devs.c:    ram_size -= size_left;
ppc4xx_pci.c:/* This file implements emulation of the 32-bit PCI controller found in some
ppc4xx_pci.c:    return ppc4xx_pci->pci_state.config_reg;
ppc4xx_pci.c:    ppc4xx_pci->pci_state.config_reg = value & ~0x3;
ppc4xx_pci.c:        pci->pmm[0].la = value;
ppc4xx_pci.c:        pci->pmm[0].ma = value;
ppc4xx_pci.c:        pci->pmm[0].pciha = value;
ppc4xx_pci.c:        pci->pmm[0].pcila = value;
ppc4xx_pci.c:        pci->pmm[1].la = value;
ppc4xx_pci.c:        pci->pmm[1].ma = value;
ppc4xx_pci.c:        pci->pmm[1].pciha = value;
ppc4xx_pci.c:        pci->pmm[1].pcila = value;
ppc4xx_pci.c:        pci->pmm[2].la = value;
ppc4xx_pci.c:        pci->pmm[2].ma = value;
ppc4xx_pci.c:        pci->pmm[2].pciha = value;
ppc4xx_pci.c:        pci->pmm[2].pcila = value;
ppc4xx_pci.c:        pci->ptm[0].ms = value;
ppc4xx_pci.c:        pci->ptm[0].la = value;
ppc4xx_pci.c:        pci->ptm[1].ms = value;
ppc4xx_pci.c:        pci->ptm[1].la = value;
ppc4xx_pci.c:        value = pci->pmm[0].la;
ppc4xx_pci.c:        value = pci->pmm[0].ma;
ppc4xx_pci.c:        value = pci->pmm[0].pciha;
ppc4xx_pci.c:        value = pci->pmm[0].pcila;
ppc4xx_pci.c:        value = pci->pmm[1].la;
ppc4xx_pci.c:        value = pci->pmm[1].ma;
ppc4xx_pci.c:        value = pci->pmm[1].pciha;
ppc4xx_pci.c:        value = pci->pmm[1].pcila;
ppc4xx_pci.c:        value = pci->pmm[2].la;
ppc4xx_pci.c:        value = pci->pmm[2].ma;
ppc4xx_pci.c:        value = pci->pmm[2].pciha;
ppc4xx_pci.c:        value = pci->pmm[2].pcila;
ppc4xx_pci.c:        value = pci->ptm[0].ms;
ppc4xx_pci.c:        value = pci->ptm[0].la;
ppc4xx_pci.c:        value = pci->ptm[1].ms;
ppc4xx_pci.c:        value = pci->ptm[1].la;
ppc4xx_pci.c:    memset(pci->pmm, 0, sizeof(pci->pmm));
ppc4xx_pci.c:    memset(pci->ptm, 0, sizeof(pci->ptm));
ppc4xx_pci.c:    int slot = pci_dev->devfn >> 3;
ppc4xx_pci.c:    DPRINTF("%s: devfn %x irq %d -> %d\n", __func__,
ppc4xx_pci.c:            pci_dev->devfn, irq_num, slot);
ppc4xx_pci.c:    return slot - 1;
ppc4xx_pci.c:    pci_device_save(controller->pci_dev, f);
ppc4xx_pci.c:        qemu_put_be32s(f, &controller->pmm[i].la);
ppc4xx_pci.c:        qemu_put_be32s(f, &controller->pmm[i].ma);
ppc4xx_pci.c:        qemu_put_be32s(f, &controller->pmm[i].pcila);
ppc4xx_pci.c:        qemu_put_be32s(f, &controller->pmm[i].pciha);
ppc4xx_pci.c:        qemu_put_be32s(f, &controller->ptm[i].ms);
ppc4xx_pci.c:        qemu_put_be32s(f, &controller->ptm[i].la);
ppc4xx_pci.c:        return -EINVAL;
ppc4xx_pci.c:    pci_device_load(controller->pci_dev, f);
ppc4xx_pci.c:        qemu_get_be32s(f, &controller->pmm[i].la);
ppc4xx_pci.c:        qemu_get_be32s(f, &controller->pmm[i].ma);
ppc4xx_pci.c:        qemu_get_be32s(f, &controller->pmm[i].pcila);
ppc4xx_pci.c:        qemu_get_be32s(f, &controller->pmm[i].pciha);
ppc4xx_pci.c:        qemu_get_be32s(f, &controller->ptm[i].ms);
ppc4xx_pci.c:        qemu_get_be32s(f, &controller->ptm[i].la);
ppc4xx_pci.c:    controller->pci_state.bus = pci_register_bus(NULL, "pci",
ppc4xx_pci.c:    controller->pci_dev = pci_register_device(controller->pci_state.bus,
ppc4xx_pci.c:    pci_conf = controller->pci_dev->config;
ppc4xx_pci.c:    index = pci_host_data_register_mmio(&controller->pci_state);
ppc4xx_pci.c:    return controller->pci_state.bus;
ppc.c: * Copyright (c) 2003-2007 Jocelyn Mayer
ppc.c:#include "qemu-timer.h"
ppc.c:#include "qemu-log.h"
ppc.c:        env->pending_interrupts |= 1 << n_IRQ;
ppc.c:        env->pending_interrupts &= ~(1 << n_IRQ);
ppc.c:        if (env->pending_interrupts == 0)
ppc.c:                env->pending_interrupts, env->interrupt_request);
ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active low */
ppc.c:                env->halted = 1;
ppc.c:            /* Level sensitive - active low */
ppc.c:                env->interrupt_request |= CPU_INTERRUPT_EXITTB;
ppc.c:            /* Unknown pin - do nothing */
ppc.c:            env->irq_input_state |= 1 << pin;
ppc.c:            env->irq_input_state &= ~(1 << pin);
ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc6xx_set_irq, env,
ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active low */
ppc.c:                env->halted = 1;
ppc.c:                env->halted = 0;
ppc.c:            /* Level sensitive - active low */
ppc.c:            /* Unknown pin - do nothing */
ppc.c:            env->irq_input_state |= 1 << pin;
ppc.c:            env->irq_input_state &= ~(1 << pin);
ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env,
ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active low */
ppc.c:                env->halted = 1;
ppc.c:                env->halted = 0;
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Unknown pin - do nothing */
ppc.c:            env->irq_input_state |= 1 << pin;
ppc.c:            env->irq_input_state &= ~(1 << pin);
ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc40x_set_irq,
ppc.c:    cur_level = (env->irq_input_state >> pin) & 1;
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Level sensitive - active high */
ppc.c:            /* Unknown pin - do nothing */
ppc.c:            env->irq_input_state |= 1 << pin;
ppc.c:            env->irq_input_state &= ~(1 << pin);
ppc.c:    env->irq_inputs = (void **)qemu_allocate_irqs(&ppce500_set_irq,
ppc.c:    return muldiv64(vmclk, tb_env->tb_freq, get_ticks_per_sec()) + tb_offset;
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->tb_offset);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->tb_offset);
ppc.c:    *tb_offsetp = value - muldiv64(vmclk, tb_env->tb_freq, get_ticks_per_sec());
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->tb_offset);
ppc.c:                     &tb_env->tb_offset, tb | (uint64_t)value);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->tb_offset);
ppc.c:                     &tb_env->tb_offset, ((uint64_t)value << 32) | tb);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->atb_offset);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->atb_offset);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->atb_offset);
ppc.c:                     &tb_env->atb_offset, tb | (uint64_t)value);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb = cpu_ppc_get_tb(tb_env, qemu_get_clock(vm_clock), tb_env->atb_offset);
ppc.c:                     &tb_env->atb_offset, ((uint64_t)value << 32) | tb);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    if (tb_env->tb_freq != 0) {
ppc.c:        tb = cpu_ppc_get_tb(tb_env, vmclk, tb_env->tb_offset);
ppc.c:        atb = cpu_ppc_get_tb(tb_env, vmclk, tb_env->atb_offset);
ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->tb_offset, tb);
ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->atb_offset, atb);
ppc.c:        tb_env->tb_freq = 0;
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    if (tb_env->tb_freq == 0) {
ppc.c:        tb = tb_env->tb_offset;
ppc.c:        atb = tb_env->atb_offset;
ppc.c:        tb_env->tb_freq = tb_env->decr_freq;
ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->tb_offset, tb);
ppc.c:        cpu_ppc_store_tb(tb_env, vmclk, &tb_env->atb_offset, atb);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    diff = next - qemu_get_clock(vm_clock);
ppc.c:        decr = muldiv64(diff, tb_env->decr_freq, get_ticks_per_sec());
ppc.c:        decr = -muldiv64(-diff, tb_env->decr_freq, get_ticks_per_sec());
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    return _cpu_ppc_load_decr(env, tb_env->decr_next);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    return _cpu_ppc_load_decr(env, tb_env->hdecr_next);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    diff = qemu_get_clock(vm_clock) - tb_env->purr_start;
ppc.c:    return tb_env->purr_load + muldiv64(diff, tb_env->tb_freq, get_ticks_per_sec());
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    next = now + muldiv64(value, get_ticks_per_sec(), tb_env->decr_freq);
ppc.c:        next += *nextp - now;
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    __cpu_ppc_store_decr(env, &tb_env->decr_next, tb_env->decr_timer,
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    if (tb_env->hdecr_timer != NULL) {
ppc.c:        __cpu_ppc_store_decr(env, &tb_env->hdecr_next, tb_env->hdecr_timer,
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb_env->purr_load = value;
ppc.c:    tb_env->purr_start = qemu_get_clock(vm_clock);
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb_env->tb_freq = freq;
ppc.c:    tb_env->decr_freq = freq;
ppc.c:    env->tb_env = tb_env;
ppc.c:    tb_env->decr_timer = qemu_new_timer(vm_clock, &cpu_ppc_decr_cb, env);
ppc.c:        tb_env->hdecr_timer = qemu_new_timer(vm_clock, &cpu_ppc_hdecr_cb, env);
ppc.c:        tb_env->hdecr_timer = NULL;
ppc.c:    uint64_t pit_reload;  /* PIT auto-reload value        */
ppc.c:    tb_env = env->tb_env;
ppc.c:    ppcemb_timer = tb_env->opaque;
ppc.c:    switch ((env->spr[SPR_40x_TCR] >> 24) & 0x3) {
ppc.c:    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->tb_freq);
ppc.c:    qemu_mod_timer(ppcemb_timer->fit_timer, next);
ppc.c:    env->spr[SPR_40x_TSR] |= 1 << 26;
ppc.c:    if ((env->spr[SPR_40x_TCR] >> 23) & 0x1)
ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 23) & 0x1),
ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);
ppc.c:    ppcemb_timer = tb_env->opaque;
ppc.c:    if (ppcemb_timer->pit_reload <= 1 ||
ppc.c:        !((env->spr[SPR_40x_TCR] >> 26) & 0x1) ||
ppc.c:        (is_excp && !((env->spr[SPR_40x_TCR] >> 22) & 0x1))) {
ppc.c:        qemu_del_timer(tb_env->decr_timer);
ppc.c:                    __func__, ppcemb_timer->pit_reload);
ppc.c:        next = now + muldiv64(ppcemb_timer->pit_reload,
ppc.c:                              get_ticks_per_sec(), tb_env->decr_freq);
ppc.c:            next += tb_env->decr_next - now;
ppc.c:        qemu_mod_timer(tb_env->decr_timer, next);
ppc.c:        tb_env->decr_next = next;
ppc.c:    tb_env = env->tb_env;
ppc.c:    ppcemb_timer = tb_env->opaque;
ppc.c:    env->spr[SPR_40x_TSR] |= 1 << 27;
ppc.c:    if ((env->spr[SPR_40x_TCR] >> 26) & 0x1)
ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 22) & 0x1),
ppc.c:           (int)((env->spr[SPR_40x_TCR] >> 26) & 0x1),
ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR],
ppc.c:           ppcemb_timer->pit_reload);
ppc.c:    tb_env = env->tb_env;
ppc.c:    ppcemb_timer = tb_env->opaque;
ppc.c:    switch ((env->spr[SPR_40x_TCR] >> 30) & 0x3) {
ppc.c:    next = now + muldiv64(next, get_ticks_per_sec(), tb_env->decr_freq);
ppc.c:           env->spr[SPR_40x_TCR], env->spr[SPR_40x_TSR]);
ppc.c:    switch ((env->spr[SPR_40x_TSR] >> 30) & 0x3) {
ppc.c:        qemu_mod_timer(ppcemb_timer->wdt_timer, next);
ppc.c:        ppcemb_timer->wdt_next = next;
ppc.c:        env->spr[SPR_40x_TSR] |= 1 << 31;
ppc.c:        qemu_mod_timer(ppcemb_timer->wdt_timer, next);
ppc.c:        ppcemb_timer->wdt_next = next;
ppc.c:        env->spr[SPR_40x_TSR] |= 1 << 30;
ppc.c:        if ((env->spr[SPR_40x_TCR] >> 27) & 0x1)
ppc.c:        env->spr[SPR_40x_TSR] &= ~0x30000000;
ppc.c:        env->spr[SPR_40x_TSR] |= env->spr[SPR_40x_TCR] & 0x30000000;
ppc.c:        switch ((env->spr[SPR_40x_TCR] >> 28) & 0x3) {
ppc.c:    tb_env = env->tb_env;
ppc.c:    ppcemb_timer = tb_env->opaque;
ppc.c:    ppcemb_timer->pit_reload = val;
ppc.c:    env->spr[SPR_40x_TSR] &= ~(val & 0xFC000000);
ppc.c:    tb_env = env->tb_env;
ppc.c:    env->spr[SPR_40x_TCR] = val & 0xFFC00000;
ppc.c:    ppc_tb_t *tb_env = env->tb_env;
ppc.c:    tb_env->tb_freq = freq;
ppc.c:    tb_env->decr_freq = freq;
ppc.c:    env->tb_env = tb_env;
ppc.c:    tb_env->tb_freq = freq;
ppc.c:    tb_env->decr_freq = freq;
ppc.c:    tb_env->opaque = ppcemb_timer;
ppc.c:        tb_env->decr_timer = qemu_new_timer(vm_clock, &cpu_4xx_pit_cb, env);
ppc.c:        ppcemb_timer->fit_timer =
ppc.c:        ppcemb_timer->wdt_timer =
ppc.c:    dcr = &dcr_env->dcrn[dcrn];
ppc.c:    if (dcr->dcr_read == NULL)
ppc.c:    *valp = (*dcr->dcr_read)(dcr->opaque, dcrn);
ppc.c:    if (dcr_env->read_error != NULL)
ppc.c:        return (*dcr_env->read_error)(dcrn);
ppc.c:    return -1;
ppc.c:    dcr = &dcr_env->dcrn[dcrn];
ppc.c:    if (dcr->dcr_write == NULL)
ppc.c:    (*dcr->dcr_write)(dcr->opaque, dcrn, val);
ppc.c:    if (dcr_env->write_error != NULL)
ppc.c:        return (*dcr_env->write_error)(dcrn);
ppc.c:    return -1;
ppc.c:    dcr_env = env->dcr_env;
ppc.c:        return -1;
ppc.c:        return -1;
ppc.c:    dcr = &dcr_env->dcrn[dcrn];
ppc.c:    if (dcr->opaque != NULL ||
ppc.c:        dcr->dcr_read != NULL ||
ppc.c:        dcr->dcr_write != NULL)
ppc.c:        return -1;
ppc.c:    dcr->opaque = opaque;
ppc.c:    dcr->dcr_read = dcr_read;
ppc.c:    dcr->dcr_write = dcr_write;
ppc.c:    dcr_env->read_error = read_error;
ppc.c:    dcr_env->write_error = write_error;
ppc.c:    env->dcr_env = dcr_env;
ppc.c:    return (*nvram->read_fn)(nvram->opaque, addr);;
ppc.c:    (*nvram->write_fn)(nvram->opaque, addr, val);
ppc.c:    nvram_write(nvram, addr + max - 1, '\0');
ppc.c:        pstrcpy_targphys("cmdline", CMDLINE_ADDR, RAM_size - CMDLINE_ADDR, cmdline);
ppce500_mpc8544ds.c:#include "qemu-common.h"
ppce500_mpc8544ds.c:#include "qemu-kvm.h"
ppce500_mpc8544ds.c:    ret = qemu_devtree_setprop_cell(fdt, "/chosen", "linux,initrd-start",
ppce500_mpc8544ds.c:        fprintf(stderr, "couldn't set /chosen/linux,initrd-start\n");
ppce500_mpc8544ds.c:    ret = qemu_devtree_setprop_cell(fdt, "/chosen", "linux,initrd-end",
ppce500_mpc8544ds.c:        fprintf(stderr, "couldn't set /chosen/linux,initrd-end\n");
ppce500_mpc8544ds.c:        if ((dp = opendir("/proc/device-tree/cpus/")) == NULL) {
ppce500_mpc8544ds.c:            printf("Can't open directory /proc/device-tree/cpus/\n");
ppce500_mpc8544ds.c:            if (strncmp(dirp->d_name, "PowerPC", 7) == 0) {
ppce500_mpc8544ds.c:                snprintf(buf, 128, "/cpus/%s", dirp->d_name);
ppce500_mpc8544ds.c:        mpc8544_copy_soc_cell(fdt, buf, "clock-frequency");
ppce500_mpc8544ds.c:        mpc8544_copy_soc_cell(fdt, buf, "timebase-frequency");
ppce500_mpc8544ds.c:    ram_size &= ~(RAM_SIZES_ALIGN - 1);
ppce500_mpc8544ds.c:    irqs[OPENPIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPCE500_INPUT_INT];
ppce500_mpc8544ds.c:    irqs[OPENPIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPCE500_INPUT_CINT];
ppce500_mpc8544ds.c:                                          ram_size - initrd_base);
ppce500_mpc8544ds.c:        env->gpr[1] = (16<<20) - 8;
ppce500_mpc8544ds.c:        env->gpr[3] = dt_base;
ppce500_mpc8544ds.c:        env->nip = entry;
ppce500_pci.c:#include "qemu-log.h"
ppce500_pci.c:#define PCIE500_REG_SIZE      (0x1000 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_OW1                 (0xC20 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_OW2                 (0xC40 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_OW3                 (0xC60 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_OW4                 (0xC80 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_IW3                 (0xDA0 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_IW2                 (0xDC0 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_IW1                 (0xDE0 - PCIE500_REG_BASE)
ppce500_pci.c:#define PPCE500_PCI_GASKET_TIMR         (0xE20 - PCIE500_REG_BASE)
ppce500_pci.c:        case PCI_POTAR: value = pci->pob[(addr >> 5) & 0x7].potar; break;
ppce500_pci.c:        case PCI_POTEAR: value = pci->pob[(addr >> 5) & 0x7].potear; break;
ppce500_pci.c:        case PCI_POWBAR: value = pci->pob[(addr >> 5) & 0x7].powbar; break;
ppce500_pci.c:        case PCI_POWAR: value = pci->pob[(addr >> 5) & 0x7].powar; break;
ppce500_pci.c:        case PCI_PITAR: value = pci->pib[(addr >> 5) & 0x3].pitar; break;
ppce500_pci.c:        case PCI_PIWBAR: value = pci->pib[(addr >> 5) & 0x3].piwbar; break;
ppce500_pci.c:        case PCI_PIWBEAR: value = pci->pib[(addr >> 5) & 0x3].piwbear; break;
ppce500_pci.c:        case PCI_PIWAR: value = pci->pib[(addr >> 5) & 0x3].piwar; break;
ppce500_pci.c:        value = pci->gasket_time;
ppce500_pci.c:    pci_debug("%s: win:%lx(addr:" TARGET_FMT_plx ") -> value:%x\n", __func__,
ppce500_pci.c:    pci_debug("%s: value:%x -> win:%lx(addr:" TARGET_FMT_plx ")\n",
ppce500_pci.c:        case PCI_POTAR: pci->pob[(addr >> 5) & 0x7].potar = value; break;
ppce500_pci.c:        case PCI_POTEAR: pci->pob[(addr >> 5) & 0x7].potear = value; break;
ppce500_pci.c:        case PCI_POWBAR: pci->pob[(addr >> 5) & 0x7].powbar = value; break;
ppce500_pci.c:        case PCI_POWAR: pci->pob[(addr >> 5) & 0x7].powar = value; break;
ppce500_pci.c:        case PCI_PITAR: pci->pib[(addr >> 5) & 0x3].pitar = value; break;
ppce500_pci.c:        case PCI_PIWBAR: pci->pib[(addr >> 5) & 0x3].piwbar = value; break;
ppce500_pci.c:        case PCI_PIWBEAR: pci->pib[(addr >> 5) & 0x3].piwbear = value; break;
ppce500_pci.c:        case PCI_PIWAR: pci->pib[(addr >> 5) & 0x3].piwar = value; break;
ppce500_pci.c:        pci->gasket_time = value;
ppce500_pci.c:    int devno = pci_dev->devfn >> 3, ret = 0;
ppce500_pci.c:            ret = (irq_num + devno - 0x10) % 4;
ppce500_pci.c:    pci_debug("%s: devfn %x irq %d -> %d  devno:%x\n", __func__,
ppce500_pci.c:           pci_dev->devfn, irq_num, ret, devno);
ppce500_pci.c:    pci_device_save(controller->pci_dev, f);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pob[i].potar);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pob[i].potear);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pob[i].powbar);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pob[i].powar);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pib[i].pitar);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pib[i].piwbar);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pib[i].piwbear);
ppce500_pci.c:        qemu_put_be32s(f, &controller->pib[i].piwar);
ppce500_pci.c:    qemu_put_be32s(f, &controller->gasket_time);
ppce500_pci.c:        return -EINVAL;
ppce500_pci.c:    pci_device_load(controller->pci_dev, f);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pob[i].potar);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pob[i].potear);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pob[i].powbar);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pob[i].powar);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pib[i].pitar);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pib[i].piwbar);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pib[i].piwbear);
ppce500_pci.c:        qemu_get_be32s(f, &controller->pib[i].piwar);
ppce500_pci.c:    qemu_get_be32s(f, &controller->gasket_time);
ppce500_pci.c:    controller->pci_state.bus = pci_register_bus(NULL, "pci",
ppce500_pci.c:    d = pci_register_device(controller->pci_state.bus,
ppce500_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_FREESCALE);
ppce500_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MPC8533E);
ppce500_pci.c:    pci_config_set_class(d->config, PCI_CLASS_PROCESSOR_POWERPC);
ppce500_pci.c:    controller->pci_dev = d;
ppce500_pci.c:    index = pci_host_conf_register_mmio_noswap(&controller->pci_state);
ppce500_pci.c:    index = pci_host_data_register_mmio(&controller->pci_state);
ppce500_pci.c:    return controller->pci_state.bus;
ppc.h:    if (clk->cb != NULL)
ppc.h:        (*clk->cb)(clk->opaque, freq);
ppc_mac.h: * Copyright (c) 2004-2007 Fabrice Bellard
ppc_mac.h:#define PROM_FILENAME    "openbios-ppc"
ppc_newworld.c: * Copyright (c) 2004-2007 Fabrice Bellard
ppc_newworld.c:#include "usb-ohci.h"
ppc_newworld.c:        /* Set time-base frequency to 100 Mhz */
ppc_newworld.c:        env->osi_call = vga_osi_call;
ppc_newworld.c:        bios_size = -1;
ppc_newworld.c:        vga_bios_size = -1;
ppc_newworld.c:        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &
ppc_newworld.c:            kernel_size = load_elf(kernel_filename, (2 * kernel_base) - lowaddr,
ppc_newworld.c:                                    ram_size - kernel_base, bswap_needed,
ppc_newworld.c:                                              ram_size - kernel_base);
ppc_newworld.c:                                              ram_size - initrd_base);
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];
ppc_newworld.c:                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];
ppc_newworld.c:        usb_ohci_init_pci(pci_bus, -1);
ppc_oldworld.c: * Copyright (c) 2004-2007 Fabrice Bellard
ppc_oldworld.c:#include "usb-ohci.h"
ppc_oldworld.c:    switch(env->gpr[5]) {
ppc_oldworld.c:        if (env->gpr[6] != 1 || env->gpr[7] != 0)
ppc_oldworld.c:            env->gpr[3] = 1;
ppc_oldworld.c:            env->gpr[3] = 0;
ppc_oldworld.c:        if (env->gpr[6] != 0) {
ppc_oldworld.c:            if (env->gpr[6] != 1 || env->gpr[7] != 0) {
ppc_oldworld.c:                env->gpr[3] = 1;
ppc_oldworld.c:        env->gpr[3] = 0;
ppc_oldworld.c:        env->gpr[4] = (1 << 16) | 1; /* num_vmodes, cur_vmode */
ppc_oldworld.c:        env->gpr[5] = (1 << 16) | 0; /* num_depths, cur_depth_mode */
ppc_oldworld.c:        env->gpr[6] = (graphic_width << 16) | graphic_height; /* w, h */
ppc_oldworld.c:        env->gpr[7] = 85 << 16; /* refresh rate */
ppc_oldworld.c:        env->gpr[8] = (graphic_depth + 7) & ~7; /* depth (round to byte) */
ppc_oldworld.c:        env->gpr[9] = (linesize << 16) | 0; /* row_bytes, offset */
ppc_oldworld.c:        env->gpr[3] = 0;
ppc_oldworld.c:        if (env->gpr[6] == 0 || env->gpr[6] == 1)
ppc_oldworld.c:            vga_vbl_enabled = env->gpr[6];
ppc_oldworld.c:        env->gpr[3] = 0;
ppc_oldworld.c:        env->gpr[3] = 0;
ppc_oldworld.c:        env->gpr[3] = 0;
ppc_oldworld.c:        /* Set time-base frequency to 16.6 Mhz */
ppc_oldworld.c:        env->osi_call = vga_osi_call;
ppc_oldworld.c:        bios_size = -1;
ppc_oldworld.c:        vga_bios_size = -1;
ppc_oldworld.c:        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &
ppc_oldworld.c:            kernel_size = load_elf(kernel_filename, (2 * kernel_base) - lowaddr,
ppc_oldworld.c:                                    ram_size - kernel_base, bswap_needed,
ppc_oldworld.c:                                              ram_size - kernel_base);
ppc_oldworld.c:                                              ram_size - initrd_base);
ppc_oldworld.c:                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];
ppc_oldworld.c:    ide_mem_index[0] = -1;
ppc_oldworld.c:        usb_ohci_init_pci(pci_bus, -1);
ppc_prep.c: * Copyright (c) 2003-2007 Jocelyn Mayer
ppc_prep.c:#include "usb-ohci.h"
ppc_prep.c:#include "qemu-log.h"
ppc_prep.c:/* Read-only register (?) */
ppc_prep.c:/* Fake super-io ports for PREP platform (Intel 82378ZB) */
ppc_prep.c:    PPC_IO_DPRINTF("0x%08" PRIx32 " => 0x%02" PRIx32 "\n", addr - PPC_IO_BASE,
ppc_prep.c:    sysctrl->fake_io[addr - 0x0398] = val;
ppc_prep.c:    PPC_IO_DPRINTF("0x%08" PRIx32 " <= 0x%02" PRIx32 "\n", addr - PPC_IO_BASE,
ppc_prep.c:                   sysctrl->fake_io[addr - 0x0398]);
ppc_prep.c:    return sysctrl->fake_io[addr - 0x0398];
ppc_prep.c:                   addr - PPC_IO_BASE, val);
ppc_prep.c:            qemu_irq_raise(sysctrl->reset_irq);
ppc_prep.c:            qemu_irq_lower(sysctrl->reset_irq);
ppc_prep.c:            sysctrl->endian = 1;
ppc_prep.c:            sysctrl->endian = 0;
ppc_prep.c:        /* Motorola CPU configuration register : read-only */
ppc_prep.c:        /* Motorola base module feature register : read-only */
ppc_prep.c:        /* Motorola base module status register : read-only */
ppc_prep.c:            sysctrl->state |= STATE_HARDFILE;
ppc_prep.c:            sysctrl->state &= ~STATE_HARDFILE;
ppc_prep.c:        if (sysctrl->nvram != NULL)
ppc_prep.c:            m48t59_toggle_lock(sysctrl->nvram, 1);
ppc_prep.c:        if (sysctrl->nvram != NULL)
ppc_prep.c:            m48t59_toggle_lock(sysctrl->nvram, 2);
ppc_prep.c:        sysctrl->syscontrol = val & 0x0F;
ppc_prep.c:        sysctrl->contiguous_map = val & 0x01;
ppc_prep.c:         * 7 - 6 / 1 - 0: L2 cache enable
ppc_prep.c:        retval = sysctrl->syscontrol;
ppc_prep.c:        retval = sysctrl->contiguous_map;
ppc_prep.c:                   addr - PPC_IO_BASE, retval);
ppc_prep.c:    if (sysctrl->contiguous_map == 0) {
ppc_prep.c:        /* 8 MB non-contiguous space for IOs */
ppc_prep.c:        if (env->flags & POWERPC_FLAG_RTC_CLK) {
ppc_prep.c:            /* Set time-base frequency to 100 Mhz */
ppc_prep.c:        bios_size = -1;
ppc_prep.c:        bios_addr = (uint32_t)(-bios_size);
ppc_prep.c:    if (env->nip < 0xFFF80000 && bios_size < 0x00100000) {
ppc_prep.c:                                          ram_size - kernel_base);
ppc_prep.c:                                              ram_size - initrd_base);
ppc_prep.c:    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);
ppc_prep.c:    /* Hmm, prep has no pci-isa bridge ??? */
ppc_prep.c:    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */
ppc_prep.c:    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];
ppc_prep.c:        usb_ohci_init_pci(pci_bus, -1);
ppc_prep.c:    sysctrl->nvram = m48t59;
ppc_prep.c:    /* Special port to get debug messages from Open-Firmware */
prep_pci.c:    pci_data_write(s->bus, PPC_PCIIO_config(addr), val, 1);
prep_pci.c:    pci_data_write(s->bus, PPC_PCIIO_config(addr), val, 2);
prep_pci.c:    pci_data_write(s->bus, PPC_PCIIO_config(addr), val, 4);
prep_pci.c:    val = pci_data_read(s->bus, PPC_PCIIO_config(addr), 1);
prep_pci.c:    val = pci_data_read(s->bus, PPC_PCIIO_config(addr), 2);
prep_pci.c:    val = pci_data_read(s->bus, PPC_PCIIO_config(addr), 4);
prep_pci.c:    return (irq_num + (pci_dev->devfn >> 3)) & 1;
prep_pci.c:    s->bus = pci_register_bus(NULL, "pci",
prep_pci.c:    d = pci_register_device(s->bus, "PREP Host Bridge - Motorola Raven",
prep_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_MOTOROLA);
prep_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_MOTOROLA_RAVEN);
prep_pci.c:    d->config[0x08] = 0x00; // revision
prep_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
prep_pci.c:    d->config[0x0C] = 0x08; // cache_line_size
prep_pci.c:    d->config[0x0D] = 0x10; // latency_timer
prep_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
prep_pci.c:    d->config[0x34] = 0x00; // capabilities_pointer
prep_pci.c:    return s->bus;
prep_pci.h:#include "qemu-common.h"
ps2.c:    PS2Queue *q = &s->queue;
ps2.c:    if (q->count >= PS2_QUEUE_SIZE)
ps2.c:    q->data[q->wptr] = b;
ps2.c:    if (++q->wptr == PS2_QUEUE_SIZE)
ps2.c:        q->wptr = 0;
ps2.c:    q->count++;
ps2.c:    s->update_irq(s->update_arg, 1);
ps2.c:   bit 7    - 0 key pressed, 1 = key released
ps2.c:   bits 6-0 - translated scancode set 2
ps2.c:    if (!s->translate && keycode < 0xe0 && s->scancode_set == 2)
ps2.c:            ps2_queue(&s->common, 0xf0);
ps2.c:    ps2_queue(&s->common, keycode);
ps2.c:    q = &s->queue;
ps2.c:    if (q->count == 0) {
ps2.c:        index = q->rptr - 1;
ps2.c:            index = PS2_QUEUE_SIZE - 1;
ps2.c:        val = q->data[index];
ps2.c:        val = q->data[q->rptr];
ps2.c:        if (++q->rptr == PS2_QUEUE_SIZE)
ps2.c:            q->rptr = 0;
ps2.c:        q->count--;
ps2.c:        s->update_irq(s->update_arg, 0);
ps2.c:        s->update_irq(s->update_arg, q->count != 0);
ps2.c:    s->scan_enabled = 1;
ps2.c:    s->scancode_set = 2;
ps2.c:    switch(s->common.write_cmd) {
ps2.c:    case -1:
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            ps2_queue(&s->common, KBD_REPLY_RESEND);
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ID);
ps2.c:            if (s->translate)
ps2.c:                ps2_queue(&s->common, 0x41);
ps2.c:                ps2_queue(&s->common, 0x83);
ps2.c:            ps2_queue(&s->common, KBD_CMD_ECHO);
ps2.c:            s->scan_enabled = 1;
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            s->common.write_cmd = val;
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            s->scan_enabled = 0;
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            s->scan_enabled = 1;
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            ps2_queue(&s->common, KBD_REPLY_POR);
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:            if (s->scancode_set == 1)
ps2.c:            else if (s->scancode_set == 2)
ps2.c:            else if (s->scancode_set == 3)
ps2.c:                s->scancode_set = val;
ps2.c:            ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:        s->common.write_cmd = -1;
ps2.c:        ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:        s->common.write_cmd = -1;
ps2.c:        ps2_queue(&s->common, KBD_REPLY_ACK);
ps2.c:        s->common.write_cmd = -1;
ps2.c:    s->translate = mode;
ps2.c:    dx1 = s->mouse_dx;
ps2.c:    dy1 = s->mouse_dy;
ps2.c:    dz1 = s->mouse_dz;
ps2.c:    else if (dx1 < -127)
ps2.c:        dx1 = -127;
ps2.c:    else if (dy1 < -127)
ps2.c:        dy1 = -127;
ps2.c:    b = 0x08 | ((dx1 < 0) << 4) | ((dy1 < 0) << 5) | (s->mouse_buttons & 0x07);
ps2.c:    ps2_queue(&s->common, b);
ps2.c:    ps2_queue(&s->common, dx1 & 0xff);
ps2.c:    ps2_queue(&s->common, dy1 & 0xff);
ps2.c:    switch(s->mouse_type) {
ps2.c:        else if (dz1 < -127)
ps2.c:                dz1 = -127;
ps2.c:        ps2_queue(&s->common, dz1 & 0xff);
ps2.c:        else if (dz1 < -7)
ps2.c:            dz1 = -7;
ps2.c:        b = (dz1 & 0x0f) | ((s->mouse_buttons & 0x18) << 1);
ps2.c:        ps2_queue(&s->common, b);
ps2.c:    s->mouse_dx -= dx1;
ps2.c:    s->mouse_dy -= dy1;
ps2.c:    s->mouse_dz -= dz1;
ps2.c:    if (!(s->mouse_status & MOUSE_STATUS_ENABLED))
ps2.c:    s->mouse_dx += dx;
ps2.c:    s->mouse_dy -= dy;
ps2.c:    s->mouse_dz += dz;
ps2.c:    if (s->mouse_dx == 0 && s->mouse_dy == 0 && s->mouse_dz == 0 &&
ps2.c:        s->mouse_buttons == buttons_state)
ps2.c:    s->mouse_buttons = buttons_state;
ps2.c:    if (!(s->mouse_status & MOUSE_STATUS_REMOTE) &&
ps2.c:        (s->common.queue.count < (PS2_QUEUE_SIZE - 16))) {
ps2.c:            if (s->mouse_dx == 0 && s->mouse_dy == 0 && s->mouse_dz == 0)
ps2.c:    switch(s->common.write_cmd) {
ps2.c:    case -1:
ps2.c:        if (s->mouse_wrap) {
ps2.c:                s->mouse_wrap = 0;
ps2.c:                ps2_queue(&s->common, AUX_ACK);
ps2.c:                ps2_queue(&s->common, val);
ps2.c:            s->mouse_status &= ~MOUSE_STATUS_SCALE21;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_status |= MOUSE_STATUS_SCALE21;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_status &= ~MOUSE_STATUS_REMOTE;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_wrap = 1;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_status |= MOUSE_STATUS_REMOTE;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            ps2_queue(&s->common, s->mouse_type);
ps2.c:            s->common.write_cmd = val;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            ps2_queue(&s->common, s->mouse_status);
ps2.c:            ps2_queue(&s->common, s->mouse_resolution);
ps2.c:            ps2_queue(&s->common, s->mouse_sample_rate);
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_status |= MOUSE_STATUS_ENABLED;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_status &= ~MOUSE_STATUS_ENABLED;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_sample_rate = 100;
ps2.c:            s->mouse_resolution = 2;
ps2.c:            s->mouse_status = 0;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            s->mouse_sample_rate = 100;
ps2.c:            s->mouse_resolution = 2;
ps2.c:            s->mouse_status = 0;
ps2.c:            s->mouse_type = 0;
ps2.c:            ps2_queue(&s->common, AUX_ACK);
ps2.c:            ps2_queue(&s->common, 0xaa);
ps2.c:            ps2_queue(&s->common, s->mouse_type);
ps2.c:        s->mouse_sample_rate = val;
ps2.c:        switch(s->mouse_detect_state) {
ps2.c:                s->mouse_detect_state = 1;
ps2.c:                s->mouse_detect_state = 2;
ps2.c:                s->mouse_detect_state = 3;
ps2.c:                s->mouse_detect_state = 0;
ps2.c:                s->mouse_type = 3; /* IMPS/2 */
ps2.c:            s->mouse_detect_state = 0;
ps2.c:                s->mouse_type = 4; /* IMEX */
ps2.c:            s->mouse_detect_state = 0;
ps2.c:        ps2_queue(&s->common, AUX_ACK);
ps2.c:        s->common.write_cmd = -1;
ps2.c:        s->mouse_resolution = val;
ps2.c:        ps2_queue(&s->common, AUX_ACK);
ps2.c:        s->common.write_cmd = -1;
ps2.c:    s->write_cmd = -1;
ps2.c:    q = &s->queue;
ps2.c:    q->rptr = 0;
ps2.c:    q->wptr = 0;
ps2.c:    q->count = 0;
ps2.c:    s->update_irq(s->update_arg, 0);
ps2.c:    ps2_common_reset(&s->common);
ps2.c:    s->scan_enabled = 0;
ps2.c:    s->translate = 0;
ps2.c:    s->scancode_set = 0;
ps2.c:    ps2_common_reset(&s->common);
ps2.c:    s->mouse_status = 0;
ps2.c:    s->mouse_resolution = 0;
ps2.c:    s->mouse_sample_rate = 0;
ps2.c:    s->mouse_wrap = 0;
ps2.c:    s->mouse_type = 0;
ps2.c:    s->mouse_detect_state = 0;
ps2.c:    s->mouse_dx = 0;
ps2.c:    s->mouse_dy = 0;
ps2.c:    s->mouse_dz = 0;
ps2.c:    s->mouse_buttons = 0;
ps2.c:        s->scancode_set=2;
ps2.c:    s->common.update_irq = update_irq;
ps2.c:    s->common.update_arg = update_arg;
ps2.c:    s->scancode_set = 2;
ps2.c:    s->common.update_irq = update_irq;
ps2.c:    s->common.update_arg = update_arg;
ptimer.c:#include "qemu-timer.h"
ptimer.c:#include "host-utils.h"
ptimer.c:/* Use a bottom-half routine to avoid reentrancy issues.  */
ptimer.c:    if (s->bh) {
ptimer.c:        qemu_bh_schedule(s->bh);
ptimer.c:    if (s->delta == 0) {
ptimer.c:        s->delta = s->limit;
ptimer.c:    if (s->delta == 0 || s->period == 0) {
ptimer.c:        s->enabled = 0;
ptimer.c:    s->last_event = s->next_event;
ptimer.c:    s->next_event = s->last_event + s->delta * s->period;
ptimer.c:    if (s->period_frac) {
ptimer.c:        s->next_event += ((int64_t)s->period_frac * s->delta) >> 32;
ptimer.c:    qemu_mod_timer(s->timer, s->next_event);
ptimer.c:    s->delta = 0;
ptimer.c:    if (s->enabled == 2) {
ptimer.c:        s->enabled = 0;
ptimer.c:    if (s->enabled) {
ptimer.c:        if (now - s->next_event > 0
ptimer.c:            || s->period == 0) {
ptimer.c:               rem (64-bit integer) and period is stored in period/period_frac
ptimer.c:               do a 64-bit division.  The result should be rounded down,
ptimer.c:            rem = s->next_event - now;
ptimer.c:            div = s->period;
ptimer.c:                div |= ((uint64_t)s->period_frac << (shift - 32));
ptimer.c:                    div |= (s->period_frac >> (32 - shift));
ptimer.c:                if ((uint32_t)(s->period_frac << shift))
ptimer.c:        counter = s->delta;
ptimer.c:    s->delta = count;
ptimer.c:    if (s->enabled) {
ptimer.c:        s->next_event = qemu_get_clock(vm_clock);
ptimer.c:    if (s->enabled) {
ptimer.c:    if (s->period == 0) {
ptimer.c:    s->enabled = oneshot ? 2 : 1;
ptimer.c:    s->next_event = qemu_get_clock(vm_clock);
ptimer.c:    if (!s->enabled)
ptimer.c:    s->delta = ptimer_get_count(s);
ptimer.c:    qemu_del_timer(s->timer);
ptimer.c:    s->enabled = 0;
ptimer.c:    s->period = period;
ptimer.c:    s->period_frac = 0;
ptimer.c:    if (s->enabled) {
ptimer.c:        s->next_event = qemu_get_clock(vm_clock);
ptimer.c:    s->period = 1000000000ll / freq;
ptimer.c:    s->period_frac = (1000000000ll << 32) / freq;
ptimer.c:    if (s->enabled) {
ptimer.c:        s->next_event = qemu_get_clock(vm_clock);
ptimer.c:    s->limit = limit;
ptimer.c:        s->delta = limit;
ptimer.c:    if (s->enabled && reload) {
ptimer.c:        s->next_event = qemu_get_clock(vm_clock);
ptimer.c:    qemu_put_byte(f, s->enabled);
ptimer.c:    qemu_put_be64s(f, &s->limit);
ptimer.c:    qemu_put_be64s(f, &s->delta);
ptimer.c:    qemu_put_be32s(f, &s->period_frac);
ptimer.c:    qemu_put_sbe64s(f, &s->period);
ptimer.c:    qemu_put_sbe64s(f, &s->last_event);
ptimer.c:    qemu_put_sbe64s(f, &s->next_event);
ptimer.c:    qemu_put_timer(f, s->timer);
ptimer.c:    s->enabled = qemu_get_byte(f);
ptimer.c:    qemu_get_be64s(f, &s->limit);
ptimer.c:    qemu_get_be64s(f, &s->delta);
ptimer.c:    qemu_get_be32s(f, &s->period_frac);
ptimer.c:    qemu_get_sbe64s(f, &s->period);
ptimer.c:    qemu_get_sbe64s(f, &s->last_event);
ptimer.c:    qemu_get_sbe64s(f, &s->next_event);
ptimer.c:    qemu_get_timer(f, s->timer);
ptimer.c:    s->bh = bh;
ptimer.c:    s->timer = qemu_new_timer(vm_clock, ptimer_tick, s);
pxa2xx.c:#include "qemu-timer.h"
pxa2xx.c:#include "qemu-char.h"
pxa2xx.c:#define PSPR	0x08	/* Power Manager Scratch-Pad register */
pxa2xx.c:#define PWER	0x0c	/* Power Manager Wake-Up Enable register */
pxa2xx.c:#define PRER	0x10	/* Power Manager Rising-Edge Detect Enable register */
pxa2xx.c:#define PFER	0x14	/* Power Manager Falling-Edge Detect Enable register */
pxa2xx.c:#define PEDR	0x18	/* Power Manager Edge-Detect Status register */
pxa2xx.c:#define PGSR0	0x20	/* Power Manager GPIO Sleep-State register 0 */
pxa2xx.c:#define PGSR1	0x24	/* Power Manager GPIO Sleep-State register 1 */
pxa2xx.c:#define PGSR2	0x28	/* Power Manager GPIO Sleep-State register 2 */
pxa2xx.c:#define PGSR3	0x2c	/* Power Manager GPIO Sleep-State register 3 */
pxa2xx.c:#define PKWR	0x50	/* Power Manager Keyboard Wake-Up Enable register */
pxa2xx.c:#define PKSR	0x54	/* Power Manager Keyboard Level-Detect Status */
pxa2xx.c:        return s->pm_regs[addr >> 2];
pxa2xx.c:        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);
pxa2xx.c:        s->pm_regs[addr >> 2] |= value & 0x15;
pxa2xx.c:    case PSSR:	/* Read-clean registers */
pxa2xx.c:        s->pm_regs[addr >> 2] &= ~value;
pxa2xx.c:    default:	/* Read-write registers */
pxa2xx.c:            s->pm_regs[addr >> 2] = value;
pxa2xx.c:        qemu_put_be32s(f, &s->pm_regs[i]);
pxa2xx.c:        qemu_get_be32s(f, &s->pm_regs[i]);
pxa2xx.c:        return s->cm_regs[addr >> 2];
pxa2xx.c:        return s->cm_regs[CCCR >> 2] | (3 << 28);
pxa2xx.c:        s->cm_regs[addr >> 2] = value;
pxa2xx.c:        s->cm_regs[addr >> 2] &= ~0x6c;
pxa2xx.c:        s->cm_regs[addr >> 2] |= value & 0x6e;
pxa2xx.c:            s->cm_regs[addr >> 2] |= 1 << 0;	/* Oscillator is now stable */
pxa2xx.c:        qemu_put_be32s(f, &s->cm_regs[i]);
pxa2xx.c:    qemu_put_be32s(f, &s->clkcfg);
pxa2xx.c:    qemu_put_be32s(f, &s->pmnc);
pxa2xx.c:        qemu_get_be32s(f, &s->cm_regs[i]);
pxa2xx.c:    qemu_get_be32s(f, &s->clkcfg);
pxa2xx.c:    qemu_get_be32s(f, &s->pmnc);
pxa2xx.c:        return s->clkcfg;
pxa2xx.c:        "Normal", "Idle", "Deep-idle", "Standby",
pxa2xx.c:        "Sleep", "reserved (!)", "reserved (!)", "Deep-sleep",
pxa2xx.c:        s->clkcfg = value & 0xf;
pxa2xx.c:            if (!(s->cm_regs[CCCR >> 2] & (1 << 31))) {	/* CPDIS */
pxa2xx.c:                cpu_interrupt(s->env, CPU_INTERRUPT_HALT);
pxa2xx.c:            /* Deep-Idle */
pxa2xx.c:            cpu_interrupt(s->env, CPU_INTERRUPT_HALT);
pxa2xx.c:            s->pm_regs[RCSR >> 2] |= 0x8;	/* Set GPR */
pxa2xx.c:            s->env->uncached_cpsr =
pxa2xx.c:            s->env->cp15.c1_sys = 0;
pxa2xx.c:            s->env->cp15.c1_coproc = 0;
pxa2xx.c:            s->env->cp15.c2_base0 = 0;
pxa2xx.c:            s->env->cp15.c3 = 0;
pxa2xx.c:            s->pm_regs[PSSR >> 2] |= 0x8;	/* Set STS */
pxa2xx.c:            s->pm_regs[RCSR >> 2] |= 0x8;	/* Set GPR */
pxa2xx.c:             * The scratch-pad register is almost universally used
pxa2xx.c:            memset(s->env->regs, 0, 4 * 15);
pxa2xx.c:            s->env->regs[15] = s->pm_regs[PSPR >> 2];
pxa2xx.c:            buffer = s->pm_regs[PSPR >> 2];
pxa2xx.c:        return s->pmnc;
pxa2xx.c:        if (s->pmnc & 1)
pxa2xx.c:        s->pmnc = value;
pxa2xx.c:#define BOOT_DEF	0x44	/* Boot-time Default Configuration register */
pxa2xx.c:#define SA1110		0x64	/* SA-1110 Memory Compatibility register */
pxa2xx.c:            return s->mm_regs[addr >> 2];
pxa2xx.c:            s->mm_regs[addr >> 2] = value;
pxa2xx.c:        qemu_put_be32s(f, &s->mm_regs[i]);
pxa2xx.c:        qemu_get_be32s(f, &s->mm_regs[i]);
pxa2xx.c:#define SSTO	0x28	/* SSP Time-Out register */
pxa2xx.c:    level |= s->ssitr & SSITR_INT;
pxa2xx.c:    level |= (s->sssr & SSSR_BCE)  &&  (s->sscr[1] & SSCR1_EBCEI);
pxa2xx.c:    level |= (s->sssr & SSSR_TUR)  && !(s->sscr[0] & SSCR0_TIM);
pxa2xx.c:    level |= (s->sssr & SSSR_EOC)  &&  (s->sssr & (SSSR_TINT | SSSR_PINT));
pxa2xx.c:    level |= (s->sssr & SSSR_TINT) &&  (s->sscr[1] & SSCR1_TINTE);
pxa2xx.c:    level |= (s->sssr & SSSR_PINT) &&  (s->sscr[1] & SSCR1_PINTE);
pxa2xx.c:    level |= (s->sssr & SSSR_ROR)  && !(s->sscr[0] & SSCR0_RIM);
pxa2xx.c:    level |= (s->sssr & SSSR_RFS)  &&  (s->sscr[1] & SSCR1_RIE);
pxa2xx.c:    level |= (s->sssr & SSSR_TFS)  &&  (s->sscr[1] & SSCR1_TIE);
pxa2xx.c:    qemu_set_irq(s->irq, !!level);
pxa2xx.c:    s->sssr &= ~(0xf << 12);	/* Clear RFL */
pxa2xx.c:    s->sssr &= ~(0xf << 8);	/* Clear TFL */
pxa2xx.c:    s->sssr &= ~SSSR_TNF;
pxa2xx.c:    if (s->enable) {
pxa2xx.c:        s->sssr |= ((s->rx_level - 1) & 0xf) << 12;
pxa2xx.c:        if (s->rx_level >= SSCR1_RFT(s->sscr[1]))
pxa2xx.c:            s->sssr |= SSSR_RFS;
pxa2xx.c:            s->sssr &= ~SSSR_RFS;
pxa2xx.c:        if (0 <= SSCR1_TFT(s->sscr[1]))
pxa2xx.c:            s->sssr |= SSSR_TFS;
pxa2xx.c:            s->sssr &= ~SSSR_TFS;
pxa2xx.c:        if (s->rx_level)
pxa2xx.c:            s->sssr |= SSSR_RNE;
pxa2xx.c:            s->sssr &= ~SSSR_RNE;
pxa2xx.c:        s->sssr |= SSSR_TNF;
pxa2xx.c:        return s->sscr[0];
pxa2xx.c:        return s->sscr[1];
pxa2xx.c:        return s->sspsp;
pxa2xx.c:        return s->ssto;
pxa2xx.c:        return s->ssitr;
pxa2xx.c:        return s->sssr | s->ssitr;
pxa2xx.c:        if (!s->enable)
pxa2xx.c:        if (s->rx_level < 1) {
pxa2xx.c:        s->rx_level --;
pxa2xx.c:        retval = s->rx_fifo[s->rx_start ++];
pxa2xx.c:        s->rx_start &= 0xf;
pxa2xx.c:        return s->sstsa;
pxa2xx.c:        return s->ssrsa;
pxa2xx.c:        return s->ssacd;
pxa2xx.c:        s->sscr[0] = value & 0xc7ffffff;
pxa2xx.c:        s->enable = value & SSCR0_SSE;
pxa2xx.c:        if (s->enable && SSCR0_DSS(value) < 4)
pxa2xx.c:            s->sssr = 0;
pxa2xx.c:            s->ssitr = 0;
pxa2xx.c:            s->rx_level = 0;
pxa2xx.c:        s->sscr[1] = value;
pxa2xx.c:        s->sspsp = value;
pxa2xx.c:        s->ssto = value;
pxa2xx.c:        s->ssitr = value & SSITR_INT;
pxa2xx.c:        s->sssr &= ~(value & SSSR_RW);
pxa2xx.c:        if (SSCR0_UWIRE(s->sscr[0])) {
pxa2xx.c:            if (s->sscr[1] & SSCR1_MWDS)
pxa2xx.c:            value &= (1 << SSCR0_DSS(s->sscr[0])) - 1;
pxa2xx.c:        if (s->enable) {
pxa2xx.c:            readval = ssi_transfer(s->bus, value);
pxa2xx.c:            if (s->rx_level < 0x10) {
pxa2xx.c:                s->rx_fifo[(s->rx_start + s->rx_level ++) & 0xf] = readval;
pxa2xx.c:                s->sssr |= SSSR_ROR;
pxa2xx.c:        s->sstsa = value;
pxa2xx.c:        s->ssrsa = value;
pxa2xx.c:        s->ssacd = value;
pxa2xx.c:    qemu_put_be32(f, s->enable);
pxa2xx.c:    qemu_put_be32s(f, &s->sscr[0]);
pxa2xx.c:    qemu_put_be32s(f, &s->sscr[1]);
pxa2xx.c:    qemu_put_be32s(f, &s->sspsp);
pxa2xx.c:    qemu_put_be32s(f, &s->ssto);
pxa2xx.c:    qemu_put_be32s(f, &s->ssitr);
pxa2xx.c:    qemu_put_be32s(f, &s->sssr);
pxa2xx.c:    qemu_put_8s(f, &s->sstsa);
pxa2xx.c:    qemu_put_8s(f, &s->ssrsa);
pxa2xx.c:    qemu_put_8s(f, &s->ssacd);
pxa2xx.c:    qemu_put_byte(f, s->rx_level);
pxa2xx.c:    for (i = 0; i < s->rx_level; i ++)
pxa2xx.c:        qemu_put_byte(f, s->rx_fifo[(s->rx_start + i) & 0xf]);
pxa2xx.c:    s->enable = qemu_get_be32(f);
pxa2xx.c:    qemu_get_be32s(f, &s->sscr[0]);
pxa2xx.c:    qemu_get_be32s(f, &s->sscr[1]);
pxa2xx.c:    qemu_get_be32s(f, &s->sspsp);
pxa2xx.c:    qemu_get_be32s(f, &s->ssto);
pxa2xx.c:    qemu_get_be32s(f, &s->ssitr);
pxa2xx.c:    qemu_get_be32s(f, &s->sssr);
pxa2xx.c:    qemu_get_8s(f, &s->sstsa);
pxa2xx.c:    qemu_get_8s(f, &s->ssrsa);
pxa2xx.c:    qemu_get_8s(f, &s->ssacd);
pxa2xx.c:    s->rx_level = qemu_get_byte(f);
pxa2xx.c:    s->rx_start = 0;
pxa2xx.c:    for (i = 0; i < s->rx_level; i ++)
pxa2xx.c:        s->rx_fifo[i] = qemu_get_byte(f);
pxa2xx.c:    sysbus_init_irq(dev, &s->irq);
pxa2xx.c:    register_savevm("pxa2xx_ssp", -1, 0,
pxa2xx.c:    s->bus = ssi_create_bus(&dev->qdev, "ssi");
pxa2xx.c:/* Real-Time Clock */
pxa2xx.c:    qemu_set_irq(s->pic[PXA2XX_PIC_RTCALARM], !!(s->rtsr & 0x2553));
pxa2xx.c:    s->last_rcnr += ((rt - s->last_hz) << 15) /
pxa2xx.c:            (1000 * ((s->rttr & 0xffff) + 1));
pxa2xx.c:    s->last_rdcr += ((rt - s->last_hz) << 15) /
pxa2xx.c:            (1000 * ((s->rttr & 0xffff) + 1));
pxa2xx.c:    s->last_hz = rt;
pxa2xx.c:    if (s->rtsr & (1 << 12))
pxa2xx.c:        s->last_swcr += (rt - s->last_sw) / 10;
pxa2xx.c:    s->last_sw = rt;
pxa2xx.c:    if (s->rtsr & (1 << 15))
pxa2xx.c:        s->last_swcr += rt - s->last_pi;
pxa2xx.c:    s->last_pi = rt;
pxa2xx.c:        qemu_mod_timer(s->rtc_hz, s->last_hz +
pxa2xx.c:                (((s->rtar - s->last_rcnr) * 1000 *
pxa2xx.c:                  ((s->rttr & 0xffff) + 1)) >> 15));
pxa2xx.c:        qemu_del_timer(s->rtc_hz);
pxa2xx.c:        qemu_mod_timer(s->rtc_rdal1, s->last_hz +
pxa2xx.c:                (((s->rdar1 - s->last_rdcr) * 1000 *
pxa2xx.c:                  ((s->rttr & 0xffff) + 1)) >> 15)); /* TODO: fixup */
pxa2xx.c:        qemu_del_timer(s->rtc_rdal1);
pxa2xx.c:        qemu_mod_timer(s->rtc_rdal2, s->last_hz +
pxa2xx.c:                (((s->rdar2 - s->last_rdcr) * 1000 *
pxa2xx.c:                  ((s->rttr & 0xffff) + 1)) >> 15)); /* TODO: fixup */
pxa2xx.c:        qemu_del_timer(s->rtc_rdal2);
pxa2xx.c:        qemu_mod_timer(s->rtc_swal1, s->last_sw +
pxa2xx.c:                        (s->swar1 - s->last_swcr) * 10); /* TODO: fixup */
pxa2xx.c:        qemu_del_timer(s->rtc_swal1);
pxa2xx.c:        qemu_mod_timer(s->rtc_swal2, s->last_sw +
pxa2xx.c:                        (s->swar2 - s->last_swcr) * 10); /* TODO: fixup */
pxa2xx.c:        qemu_del_timer(s->rtc_swal2);
pxa2xx.c:        qemu_mod_timer(s->rtc_pi, s->last_pi +
pxa2xx.c:                        (s->piar & 0xffff) - s->last_rtcpicr);
pxa2xx.c:        qemu_del_timer(s->rtc_pi);
pxa2xx.c:    s->rtsr |= (1 << 0);
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    s->rtsr |= (1 << 4);
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    s->rtsr |= (1 << 6);
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    s->rtsr |= (1 << 8);
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    s->rtsr |= (1 << 10);
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    s->rtsr |= (1 << 13);
pxa2xx.c:    s->last_rtcpicr = 0;
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        return s->rttr;
pxa2xx.c:        return s->rtsr;
pxa2xx.c:        return s->rtar;
pxa2xx.c:        return s->rdar1;
pxa2xx.c:        return s->rdar2;
pxa2xx.c:        return s->ryar1;
pxa2xx.c:        return s->ryar2;
pxa2xx.c:        return s->swar1;
pxa2xx.c:        return s->swar2;
pxa2xx.c:        return s->piar;
pxa2xx.c:        return s->last_rcnr + ((qemu_get_clock(rt_clock) - s->last_hz) << 15) /
pxa2xx.c:                (1000 * ((s->rttr & 0xffff) + 1));
pxa2xx.c:        return s->last_rdcr + ((qemu_get_clock(rt_clock) - s->last_hz) << 15) /
pxa2xx.c:                (1000 * ((s->rttr & 0xffff) + 1));
pxa2xx.c:        return s->last_rycr;
pxa2xx.c:        if (s->rtsr & (1 << 12))
pxa2xx.c:            return s->last_swcr + (qemu_get_clock(rt_clock) - s->last_sw) / 10;
pxa2xx.c:            return s->last_swcr;
pxa2xx.c:        if (!(s->rttr & (1 << 31))) {
pxa2xx.c:            s->rttr = value;
pxa2xx.c:            pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        if ((s->rtsr ^ value) & (1 << 15))
pxa2xx.c:        if ((s->rtsr ^ value) & (1 << 12))
pxa2xx.c:        if (((s->rtsr ^ value) & 0x4aac) | (value & ~0xdaac))
pxa2xx.c:        s->rtsr = (value & 0xdaac) | (s->rtsr & ~(value & ~0xdaac));
pxa2xx.c:        s->rtar = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->rdar1 = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->rdar2 = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->ryar1 = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->ryar2 = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->swar1 = value;
pxa2xx.c:        s->last_swcr = 0;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->swar2 = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->piar = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->last_rcnr = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->last_rdcr = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->last_rycr = value;
pxa2xx.c:        s->last_swcr = value;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:        s->last_rtcpicr = value & 0xffff;
pxa2xx.c:        pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    s->rttr = 0x7fff;
pxa2xx.c:    s->rtsr = 0;
pxa2xx.c:    wom = ((tm.tm_mday - 1) / 7) + 1;
pxa2xx.c:    s->last_rcnr = (uint32_t) mktimegm(&tm);
pxa2xx.c:    s->last_rdcr = (wom << 20) | ((tm.tm_wday + 1) << 17) |
pxa2xx.c:    s->last_rycr = ((tm.tm_year + 1900) << 9) |
pxa2xx.c:    s->last_swcr = (tm.tm_hour << 19) |
pxa2xx.c:    s->last_rtcpicr = 0;
pxa2xx.c:    s->last_hz = s->last_sw = s->last_pi = qemu_get_clock(rt_clock);
pxa2xx.c:    s->rtc_hz    = qemu_new_timer(rt_clock, pxa2xx_rtc_hz_tick,    s);
pxa2xx.c:    s->rtc_rdal1 = qemu_new_timer(rt_clock, pxa2xx_rtc_rdal1_tick, s);
pxa2xx.c:    s->rtc_rdal2 = qemu_new_timer(rt_clock, pxa2xx_rtc_rdal2_tick, s);
pxa2xx.c:    s->rtc_swal1 = qemu_new_timer(rt_clock, pxa2xx_rtc_swal1_tick, s);
pxa2xx.c:    s->rtc_swal2 = qemu_new_timer(rt_clock, pxa2xx_rtc_swal2_tick, s);
pxa2xx.c:    s->rtc_pi    = qemu_new_timer(rt_clock, pxa2xx_rtc_pi_tick,    s);
pxa2xx.c:    qemu_put_be32s(f, &s->rttr);
pxa2xx.c:    qemu_put_be32s(f, &s->rtsr);
pxa2xx.c:    qemu_put_be32s(f, &s->rtar);
pxa2xx.c:    qemu_put_be32s(f, &s->rdar1);
pxa2xx.c:    qemu_put_be32s(f, &s->rdar2);
pxa2xx.c:    qemu_put_be32s(f, &s->ryar1);
pxa2xx.c:    qemu_put_be32s(f, &s->ryar2);
pxa2xx.c:    qemu_put_be32s(f, &s->swar1);
pxa2xx.c:    qemu_put_be32s(f, &s->swar2);
pxa2xx.c:    qemu_put_be32s(f, &s->piar);
pxa2xx.c:    qemu_put_be32s(f, &s->last_rcnr);
pxa2xx.c:    qemu_put_be32s(f, &s->last_rdcr);
pxa2xx.c:    qemu_put_be32s(f, &s->last_rycr);
pxa2xx.c:    qemu_put_be32s(f, &s->last_swcr);
pxa2xx.c:    qemu_put_be32s(f, &s->last_rtcpicr);
pxa2xx.c:    qemu_put_sbe64s(f, &s->last_hz);
pxa2xx.c:    qemu_put_sbe64s(f, &s->last_sw);
pxa2xx.c:    qemu_put_sbe64s(f, &s->last_pi);
pxa2xx.c:    qemu_get_be32s(f, &s->rttr);
pxa2xx.c:    qemu_get_be32s(f, &s->rtsr);
pxa2xx.c:    qemu_get_be32s(f, &s->rtar);
pxa2xx.c:    qemu_get_be32s(f, &s->rdar1);
pxa2xx.c:    qemu_get_be32s(f, &s->rdar2);
pxa2xx.c:    qemu_get_be32s(f, &s->ryar1);
pxa2xx.c:    qemu_get_be32s(f, &s->ryar2);
pxa2xx.c:    qemu_get_be32s(f, &s->swar1);
pxa2xx.c:    qemu_get_be32s(f, &s->swar2);
pxa2xx.c:    qemu_get_be32s(f, &s->piar);
pxa2xx.c:    qemu_get_be32s(f, &s->last_rcnr);
pxa2xx.c:    qemu_get_be32s(f, &s->last_rdcr);
pxa2xx.c:    qemu_get_be32s(f, &s->last_rycr);
pxa2xx.c:    qemu_get_be32s(f, &s->last_swcr);
pxa2xx.c:    qemu_get_be32s(f, &s->last_rtcpicr);
pxa2xx.c:    qemu_get_sbe64s(f, &s->last_hz);
pxa2xx.c:    qemu_get_sbe64s(f, &s->last_sw);
pxa2xx.c:    qemu_get_sbe64s(f, &s->last_pi);
pxa2xx.c:    pxa2xx_rtc_alarm_update(s, s->rtsr);
pxa2xx.c:    level |= s->status & s->control & (1 << 10);		/* BED */
pxa2xx.c:    level |= (s->status & (1 << 7)) && (s->control & (1 << 9));	/* IRF */
pxa2xx.c:    level |= (s->status & (1 << 6)) && (s->control & (1 << 8));	/* ITE */
pxa2xx.c:    level |= s->status & (1 << 9);				/* SAD */
pxa2xx.c:    qemu_set_irq(s->irq, !!level);
pxa2xx.c:    PXA2xxI2CState *s = slave->host;
pxa2xx.c:        s->status |= (1 << 9);				/* set SAD */
pxa2xx.c:        s->status &= ~(1 << 0);				/* clear RWM */
pxa2xx.c:        s->status |= (1 << 9);				/* set SAD */
pxa2xx.c:        s->status |= 1 << 0;				/* set RWM */
pxa2xx.c:        s->status |= (1 << 4);				/* set SSD */
pxa2xx.c:        s->status |= 1 << 1;				/* set ACKNAK */
pxa2xx.c:    PXA2xxI2CState *s = slave->host;
pxa2xx.c:    if ((s->control & (1 << 14)) || !(s->control & (1 << 6)))
pxa2xx.c:    if (s->status & (1 << 0)) {			/* RWM */
pxa2xx.c:        s->status |= 1 << 6;			/* set ITE */
pxa2xx.c:    return s->data;
pxa2xx.c:    PXA2xxI2CState *s = slave->host;
pxa2xx.c:    if ((s->control & (1 << 14)) || !(s->control & (1 << 6)))
pxa2xx.c:    if (!(s->status & (1 << 0))) {		/* RWM */
pxa2xx.c:        s->status |= 1 << 7;			/* set IRF */
pxa2xx.c:        s->data = data;
pxa2xx.c:    addr -= s->offset;
pxa2xx.c:        return s->control;
pxa2xx.c:        return s->status | (i2c_bus_busy(s->bus) << 2);
pxa2xx.c:        return s->slave->i2c.address;
pxa2xx.c:        return s->data;
pxa2xx.c:        if (s->status & (1 << 2))
pxa2xx.c:            s->ibmr ^= 3;	/* Fake SCL and SDA pin changes */
pxa2xx.c:            s->ibmr = 0;
pxa2xx.c:        return s->ibmr;
pxa2xx.c:    addr -= s->offset;
pxa2xx.c:        s->control = value & 0xfff7;
pxa2xx.c:                if (s->data & 1)
pxa2xx.c:                    s->status |= 1 << 0;		/* set RWM */
pxa2xx.c:                    s->status &= ~(1 << 0);		/* clear RWM */
pxa2xx.c:                ack = !i2c_start_transfer(s->bus, s->data >> 1, s->data & 1);
pxa2xx.c:                if (s->status & (1 << 0)) {		/* RWM */
pxa2xx.c:                    s->data = i2c_recv(s->bus);
pxa2xx.c:                        i2c_nack(s->bus);
pxa2xx.c:                    ack = !i2c_send(s->bus, s->data);
pxa2xx.c:                i2c_end_transfer(s->bus);
pxa2xx.c:                    s->status |= 1 << 6;		/* set ITE */
pxa2xx.c:                    if (s->status & (1 << 0))		/* RWM */
pxa2xx.c:                        s->status |= 1 << 7;		/* set IRF */
pxa2xx.c:                        s->status |= 1 << 6;		/* set ITE */
pxa2xx.c:                s->status &= ~(1 << 1);			/* clear ACKNAK */
pxa2xx.c:                s->status |= 1 << 6;			/* set ITE */
pxa2xx.c:                s->status |= 1 << 10;			/* set BED */
pxa2xx.c:                s->status |= 1 << 1;			/* set ACKNAK */
pxa2xx.c:                i2c_end_transfer(s->bus);
pxa2xx.c:        s->status &= ~(value & 0x07f0);
pxa2xx.c:        i2c_set_slave_address(&s->slave->i2c, value & 0x7f);
pxa2xx.c:        s->data = value & 0xff;
pxa2xx.c:    .qdev.name = "pxa2xx-i2c-slave",
pxa2xx.c:    dev = i2c_create_slave(i2c_init_bus(NULL, "dummy"), "pxa2xx-i2c-slave", 0);
pxa2xx.c:    s->slave = FROM_I2C_SLAVE(PXA2xxI2CSlaveState, I2C_SLAVE_FROM_QDEV(dev));
pxa2xx.c:    s->slave->host = s;
pxa2xx.c:    s->irq = irq;
pxa2xx.c:    s->bus = i2c_init_bus(NULL, "i2c");
pxa2xx.c:    s->offset = base - (base & (~region_size) & TARGET_PAGE_MASK);
pxa2xx.c:    return s->bus;
pxa2xx.c:/* PXA Inter-IC Sound Controller */
pxa2xx.c:    i2s->rx_len = 0;
pxa2xx.c:    i2s->tx_len = 0;
pxa2xx.c:    i2s->fifo_len = 0;
pxa2xx.c:    i2s->clk = 0x1a;
pxa2xx.c:    i2s->control[0] = 0x00;
pxa2xx.c:    i2s->control[1] = 0x00;
pxa2xx.c:    i2s->status = 0x00;
pxa2xx.c:    i2s->mask = 0x00;
pxa2xx.c:    rfs = SACR_RFTH(i2s->control[0]) < i2s->rx_len &&
pxa2xx.c:            !SACR_DREC(i2s->control[1]);
pxa2xx.c:    tfs = (i2s->tx_len || i2s->fifo_len < SACR_TFTH(i2s->control[0])) &&
pxa2xx.c:            i2s->enable && !SACR_DPRL(i2s->control[1]);
pxa2xx.c:    pxa2xx_dma_request(i2s->dma, PXA2XX_RX_RQ_I2S, rfs);
pxa2xx.c:    pxa2xx_dma_request(i2s->dma, PXA2XX_TX_RQ_I2S, tfs);
pxa2xx.c:    i2s->status &= 0xe0;
pxa2xx.c:    if (i2s->fifo_len < 16 || !i2s->enable)
pxa2xx.c:        i2s->status |= 1 << 0;			/* TNF */
pxa2xx.c:    if (i2s->rx_len)
pxa2xx.c:        i2s->status |= 1 << 1;			/* RNE */
pxa2xx.c:    if (i2s->enable)
pxa2xx.c:        i2s->status |= 1 << 2;			/* BSY */
pxa2xx.c:        i2s->status |= 1 << 3;			/* TFS */
pxa2xx.c:        i2s->status |= 1 << 4;			/* RFS */
pxa2xx.c:    if (!(i2s->tx_len && i2s->enable))
pxa2xx.c:        i2s->status |= i2s->fifo_len << 8;	/* TFL */
pxa2xx.c:    i2s->status |= MAX(i2s->rx_len, 0xf) << 12;	/* RFL */
pxa2xx.c:    qemu_set_irq(i2s->irq, i2s->status & i2s->mask);
pxa2xx.c:#define SACR1	0x04	/* Serial Audio I2S/MSB-Justified Control register */
pxa2xx.c:        return s->control[0];
pxa2xx.c:        return s->control[1];
pxa2xx.c:        return s->status;
pxa2xx.c:        return s->mask;
pxa2xx.c:        return s->clk;
pxa2xx.c:        if (s->rx_len > 0) {
pxa2xx.c:            s->rx_len --;
pxa2xx.c:            return s->codec_in(s->opaque);
pxa2xx.c:        s->control[0] = value & 0xff3d;
pxa2xx.c:        if (!s->enable && (value & 1) && s->tx_len) {	/* ENB */
pxa2xx.c:            for (sample = s->fifo; s->fifo_len > 0; s->fifo_len --, sample ++)
pxa2xx.c:                s->codec_out(s->opaque, *sample);
pxa2xx.c:            s->status &= ~(1 << 7);			/* I2SOFF */
pxa2xx.c:        s->enable = ((value ^ 4) & 5) == 5;		/* ENB && !RST*/
pxa2xx.c:        s->control[1] = value & 0x0039;
pxa2xx.c:            s->fifo_len = 0;
pxa2xx.c:        s->mask = value & 0x0078;
pxa2xx.c:        s->status &= ~(value & (3 << 5));
pxa2xx.c:        s->clk = value & 0x007f;
pxa2xx.c:        if (s->tx_len && s->enable) {
pxa2xx.c:            s->tx_len --;
pxa2xx.c:            s->codec_out(s->opaque, value);
pxa2xx.c:        } else if (s->fifo_len < 16) {
pxa2xx.c:            s->fifo[s->fifo_len ++] = value;
pxa2xx.c:    qemu_put_be32s(f, &s->control[0]);
pxa2xx.c:    qemu_put_be32s(f, &s->control[1]);
pxa2xx.c:    qemu_put_be32s(f, &s->status);
pxa2xx.c:    qemu_put_be32s(f, &s->mask);
pxa2xx.c:    qemu_put_be32s(f, &s->clk);
pxa2xx.c:    qemu_put_be32(f, s->enable);
pxa2xx.c:    qemu_put_be32(f, s->rx_len);
pxa2xx.c:    qemu_put_be32(f, s->tx_len);
pxa2xx.c:    qemu_put_be32(f, s->fifo_len);
pxa2xx.c:    qemu_get_be32s(f, &s->control[0]);
pxa2xx.c:    qemu_get_be32s(f, &s->control[1]);
pxa2xx.c:    qemu_get_be32s(f, &s->status);
pxa2xx.c:    qemu_get_be32s(f, &s->mask);
pxa2xx.c:    qemu_get_be32s(f, &s->clk);
pxa2xx.c:    s->enable = qemu_get_be32(f);
pxa2xx.c:    s->rx_len = qemu_get_be32(f);
pxa2xx.c:    s->tx_len = qemu_get_be32(f);
pxa2xx.c:    s->fifo_len = qemu_get_be32(f);
pxa2xx.c:    if (s->enable && s->tx_len)
pxa2xx.c:        s->status |= 1 << 5;		/* TUR */
pxa2xx.c:    if (s->enable && s->rx_len)
pxa2xx.c:        s->status |= 1 << 6;		/* ROR */
pxa2xx.c:    /* Should be tx - MIN(tx, s->fifo_len) but we don't really need to
pxa2xx.c:    s->tx_len = tx - s->fifo_len;
pxa2xx.c:    s->rx_len = rx;
pxa2xx.c:    /* Note that is s->codec_out wasn't set, we wouldn't get called.  */
pxa2xx.c:    if (s->enable)
pxa2xx.c:        for (sample = s->fifo; s->fifo_len; s->fifo_len --, sample ++)
pxa2xx.c:            s->codec_out(s->opaque, *sample);
pxa2xx.c:    s->irq = irq;
pxa2xx.c:    s->dma = dma;
pxa2xx.c:    s->data_req = pxa2xx_i2s_data_req;
pxa2xx.c:/* PXA Fast Infra-red Communications Port */
pxa2xx.c:    s->control[0] = 0x00;
pxa2xx.c:    s->control[1] = 0x00;
pxa2xx.c:    s->control[2] = 0x00;
pxa2xx.c:    s->status[0] = 0x00;
pxa2xx.c:    s->status[1] = 0x00;
pxa2xx.c:    s->enable = 0;
pxa2xx.c:    if ((s->control[0] & (1 << 4)) &&			/* RXE */
pxa2xx.c:                    s->rx_len >= tresh[s->control[2] & 3])	/* TRIG */
pxa2xx.c:        s->status[0] |= 1 << 4;				/* RFS */
pxa2xx.c:        s->status[0] &= ~(1 << 4);			/* RFS */
pxa2xx.c:    if (s->control[0] & (1 << 3))			/* TXE */
pxa2xx.c:        s->status[0] |= 1 << 3;				/* TFS */
pxa2xx.c:        s->status[0] &= ~(1 << 3);			/* TFS */
pxa2xx.c:    if (s->rx_len)
pxa2xx.c:        s->status[1] |= 1 << 2;				/* RNE */
pxa2xx.c:        s->status[1] &= ~(1 << 2);			/* RNE */
pxa2xx.c:    if (s->control[0] & (1 << 4))			/* RXE */
pxa2xx.c:        s->status[1] |= 1 << 0;				/* RSY */
pxa2xx.c:        s->status[1] &= ~(1 << 0);			/* RSY */
pxa2xx.c:    intr |= (s->control[0] & (1 << 5)) &&		/* RIE */
pxa2xx.c:            (s->status[0] & (1 << 4));			/* RFS */
pxa2xx.c:    intr |= (s->control[0] & (1 << 6)) &&		/* TIE */
pxa2xx.c:            (s->status[0] & (1 << 3));			/* TFS */
pxa2xx.c:    intr |= (s->control[2] & (1 << 4)) &&		/* TRAIL */
pxa2xx.c:            (s->status[0] & (1 << 6));			/* EOC */
pxa2xx.c:    intr |= (s->control[0] & (1 << 2)) &&		/* TUS */
pxa2xx.c:            (s->status[0] & (1 << 1));			/* TUR */
pxa2xx.c:    intr |= s->status[0] & 0x25;			/* FRE, RAB, EIF */
pxa2xx.c:    pxa2xx_dma_request(s->dma, PXA2XX_RX_RQ_ICP, (s->status[0] >> 4) & 1);
pxa2xx.c:    pxa2xx_dma_request(s->dma, PXA2XX_TX_RQ_ICP, (s->status[0] >> 3) & 1);
pxa2xx.c:    qemu_set_irq(s->irq, intr && s->enable);
pxa2xx.c:        return s->control[0];
pxa2xx.c:        return s->control[1];
pxa2xx.c:        return s->control[2];
pxa2xx.c:        s->status[0] &= ~0x01;
pxa2xx.c:        s->status[1] &= ~0x72;
pxa2xx.c:        if (s->rx_len) {
pxa2xx.c:            s->rx_len --;
pxa2xx.c:            ret = s->rx_fifo[s->rx_start ++];
pxa2xx.c:            s->rx_start &= 63;
pxa2xx.c:        return s->status[0];
pxa2xx.c:        return s->status[1] | (1 << 3);			/* TNF */
pxa2xx.c:        return s->rx_len;
pxa2xx.c:        s->control[0] = value;
pxa2xx.c:            s->rx_len = s->rx_start = 0;
pxa2xx.c:        s->enable = value & 1;				/* ITR */
pxa2xx.c:        if (!s->enable)
pxa2xx.c:            s->status[0] = 0;
pxa2xx.c:        s->control[1] = value;
pxa2xx.c:        s->control[2] = value & 0x3f;
pxa2xx.c:        if (s->control[2] & (1 << 2))			/* TXP */
pxa2xx.c:        if (s->chr && s->enable && (s->control[0] & (1 << 3)))	/* TXE */
pxa2xx.c:            qemu_chr_write(s->chr, &ch, 1);
pxa2xx.c:        s->status[0] &= ~(value & 0x66);
pxa2xx.c:    return (s->rx_len < 64);
pxa2xx.c:    if (!(s->control[0] & (1 << 4)))			/* RXE */
pxa2xx.c:    while (size --) {
pxa2xx.c:        s->status[1] |= 1 << 4;				/* EOF */
pxa2xx.c:        if (s->rx_len >= 64) {
pxa2xx.c:            s->status[1] |= 1 << 6;			/* ROR */
pxa2xx.c:        if (s->control[2] & (1 << 3))			/* RXP */
pxa2xx.c:            s->rx_fifo[(s->rx_start + s->rx_len ++) & 63] = *(buf ++);
pxa2xx.c:            s->rx_fifo[(s->rx_start + s->rx_len ++) & 63] = ~*(buf ++);
pxa2xx.c:    qemu_put_be32(f, s->enable);
pxa2xx.c:    qemu_put_8s(f, &s->control[0]);
pxa2xx.c:    qemu_put_8s(f, &s->control[1]);
pxa2xx.c:    qemu_put_8s(f, &s->control[2]);
pxa2xx.c:    qemu_put_8s(f, &s->status[0]);
pxa2xx.c:    qemu_put_8s(f, &s->status[1]);
pxa2xx.c:    qemu_put_byte(f, s->rx_len);
pxa2xx.c:    for (i = 0; i < s->rx_len; i ++)
pxa2xx.c:        qemu_put_byte(f, s->rx_fifo[(s->rx_start + i) & 63]);
pxa2xx.c:    s->enable = qemu_get_be32(f);
pxa2xx.c:    qemu_get_8s(f, &s->control[0]);
pxa2xx.c:    qemu_get_8s(f, &s->control[1]);
pxa2xx.c:    qemu_get_8s(f, &s->control[2]);
pxa2xx.c:    qemu_get_8s(f, &s->status[0]);
pxa2xx.c:    qemu_get_8s(f, &s->status[1]);
pxa2xx.c:    s->rx_len = qemu_get_byte(f);
pxa2xx.c:    s->rx_start = 0;
pxa2xx.c:    for (i = 0; i < s->rx_len; i ++)
pxa2xx.c:        s->rx_fifo[i] = qemu_get_byte(f);
pxa2xx.c:    s->irq = irq;
pxa2xx.c:    s->dma = dma;
pxa2xx.c:    s->chr = chr;
pxa2xx.c:    if (level && (s->pm_regs[PCFR >> 2] & 0x10)) {	/* GPR_EN */
pxa2xx.c:        cpu_reset(s->env);
pxa2xx.c:    s->env = cpu_init(revision);
pxa2xx.c:    if (!s->env) {
pxa2xx.c:    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];
pxa2xx.c:    s->pic = pxa2xx_pic_init(0x40d00000, s->env);
pxa2xx.c:    s->dma = pxa27x_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);
pxa2xx.c:    pxa27x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0],
pxa2xx.c:                    s->pic[PXA27X_PIC_OST_4_11]);
pxa2xx.c:    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 121);
pxa2xx.c:    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,
pxa2xx.c:                              s->pic[PXA2XX_PIC_MMC], s->dma);
pxa2xx.c:                           s->pic[pxa270_serial[i].irqn], 14857000/16,
pxa2xx.c:        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],
pxa2xx.c:                        s->dma, serial_hds[i]);
pxa2xx.c:    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);
pxa2xx.c:    s->cm_base = 0x41300000;
pxa2xx.c:    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */
pxa2xx.c:    s->clkcfg = 0x00000009;		/* Turbo mode active */
pxa2xx.c:    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);
pxa2xx.c:    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);
pxa2xx.c:    s->mm_base = 0x48000000;
pxa2xx.c:    s->mm_regs[MDMRS >> 2] = 0x00020002;
pxa2xx.c:    s->mm_regs[MDREFR >> 2] = 0x03ca4000;
pxa2xx.c:    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */
pxa2xx.c:    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);
pxa2xx.c:    s->pm_base = 0x40f00000;
pxa2xx.c:    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);
pxa2xx.c:    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);
pxa2xx.c:        dev = sysbus_create_simple("pxa2xx-ssp", pxa27x_ssp[i].io_base,
pxa2xx.c:                                   s->pic[pxa27x_ssp[i].irqn]);
pxa2xx.c:        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi");
pxa2xx.c:        usb_ohci_init_pxa(0x4c000000, 3, -1, s->pic[PXA2XX_PIC_USBH1]);
pxa2xx.c:    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);
pxa2xx.c:    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);
pxa2xx.c:    s->rtc_base = 0x40900000;
pxa2xx.c:    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);
pxa2xx.c:    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);
pxa2xx.c:    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);
pxa2xx.c:    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);
pxa2xx.c:    s->kp = pxa27x_keypad_init(0x41500000, s->pic[PXA2XX_PIC_KEYPAD]);
pxa2xx.c:    /* The handler can be overridden by board-specific code */
pxa2xx.c:    pxa2xx_gpio_out_set(s->gpio, 1, s->reset);
pxa2xx.c:    s->env = cpu_init("pxa255");
pxa2xx.c:    if (!s->env) {
pxa2xx.c:    s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0];
pxa2xx.c:    s->pic = pxa2xx_pic_init(0x40d00000, s->env);
pxa2xx.c:    s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]);
pxa2xx.c:    pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]);
pxa2xx.c:    s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85);
pxa2xx.c:    s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv,
pxa2xx.c:                              s->pic[PXA2XX_PIC_MMC], s->dma);
pxa2xx.c:                           s->pic[pxa255_serial[i].irqn], 14745600/16,
pxa2xx.c:        s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP],
pxa2xx.c:                        s->dma, serial_hds[i]);
pxa2xx.c:    s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]);
pxa2xx.c:    s->cm_base = 0x41300000;
pxa2xx.c:    s->cm_regs[CCCR >> 2] = 0x02000210;	/* 416.0 MHz */
pxa2xx.c:    s->clkcfg = 0x00000009;		/* Turbo mode active */
pxa2xx.c:    cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype);
pxa2xx.c:    cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s);
pxa2xx.c:    s->mm_base = 0x48000000;
pxa2xx.c:    s->mm_regs[MDMRS >> 2] = 0x00020002;
pxa2xx.c:    s->mm_regs[MDREFR >> 2] = 0x03ca4000;
pxa2xx.c:    s->mm_regs[MECR >> 2] = 0x00000001;	/* Two PC Card sockets */
pxa2xx.c:    cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype);
pxa2xx.c:    s->pm_base = 0x40f00000;
pxa2xx.c:    cpu_register_physical_memory(s->pm_base, 0x100, iomemtype);
pxa2xx.c:    s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i);
pxa2xx.c:        dev = sysbus_create_simple("pxa2xx-ssp", pxa255_ssp[i].io_base,
pxa2xx.c:                                   s->pic[pxa255_ssp[i].irqn]);
pxa2xx.c:        s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi");
pxa2xx.c:        usb_ohci_init_pxa(0x4c000000, 3, -1, s->pic[PXA2XX_PIC_USBH1]);
pxa2xx.c:    s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000);
pxa2xx.c:    s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000);
pxa2xx.c:    s->rtc_base = 0x40900000;
pxa2xx.c:    cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype);
pxa2xx.c:    s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff);
pxa2xx.c:    s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff);
pxa2xx.c:    s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma);
pxa2xx.c:    /* The handler can be overridden by board-specific code */
pxa2xx.c:    pxa2xx_gpio_out_set(s->gpio, 1, s->reset);
pxa2xx.c:    sysbus_register_dev("pxa2xx-ssp", sizeof(PXA2xxSSPState), pxa2xx_ssp_init);
pxa2xx_dma.c:/* Per-channel register */
pxa2xx_dma.c:/* Bit-field masks */
pxa2xx_dma.c:#define DCMD_WIDTH(x)		(1 << ((((x) >> 14) & 3) - 1))
pxa2xx_dma.c:        if ((s->chan[ch].state & DCSR_STOPIRQEN) &&
pxa2xx_dma.c:                (s->chan[ch].state & DCSR_STOPINTR))
pxa2xx_dma.c:            s->stopintr |= 1 << ch;
pxa2xx_dma.c:            s->stopintr &= ~(1 << ch);
pxa2xx_dma.c:        if ((s->chan[ch].state & DCSR_EORIRQEN) &&
pxa2xx_dma.c:                (s->chan[ch].state & DCSR_EORINT))
pxa2xx_dma.c:            s->eorintr |= 1 << ch;
pxa2xx_dma.c:            s->eorintr &= ~(1 << ch);
pxa2xx_dma.c:        if ((s->chan[ch].state & DCSR_RASIRQEN) &&
pxa2xx_dma.c:                (s->chan[ch].state & DCSR_RASINTR))
pxa2xx_dma.c:            s->rasintr |= 1 << ch;
pxa2xx_dma.c:            s->rasintr &= ~(1 << ch);
pxa2xx_dma.c:        if (s->chan[ch].state & DCSR_STARTINTR)
pxa2xx_dma.c:            s->startintr |= 1 << ch;
pxa2xx_dma.c:            s->startintr &= ~(1 << ch);
pxa2xx_dma.c:        if (s->chan[ch].state & DCSR_ENDINTR)
pxa2xx_dma.c:            s->endintr |= 1 << ch;
pxa2xx_dma.c:            s->endintr &= ~(1 << ch);
pxa2xx_dma.c:    if (s->stopintr | s->eorintr | s->rasintr | s->startintr | s->endintr)
pxa2xx_dma.c:        qemu_irq_raise(s->irq);
pxa2xx_dma.c:        qemu_irq_lower(s->irq);
pxa2xx_dma.c:    target_phys_addr_t daddr = s->chan[ch].descr & ~0xf;
pxa2xx_dma.c:    if ((s->chan[ch].descr & DDADR_BREN) && (s->chan[ch].state & DCSR_CMPST))
pxa2xx_dma.c:    s->chan[ch].descr = desc[DDADR];
pxa2xx_dma.c:    s->chan[ch].src = desc[DSADR];
pxa2xx_dma.c:    s->chan[ch].dest = desc[DTADR];
pxa2xx_dma.c:    s->chan[ch].cmd = desc[DCMD];
pxa2xx_dma.c:    if (s->chan[ch].cmd & DCMD_FLOWSRC)
pxa2xx_dma.c:        s->chan[ch].src &= ~3;
pxa2xx_dma.c:    if (s->chan[ch].cmd & DCMD_FLOWTRG)
pxa2xx_dma.c:        s->chan[ch].dest &= ~3;
pxa2xx_dma.c:    if (s->chan[ch].cmd & (DCMD_CMPEN | DCMD_FLYBYS | DCMD_FLYBYT))
pxa2xx_dma.c:    if (s->chan[ch].cmd & DCMD_STARTIRQEN)
pxa2xx_dma.c:        s->chan[ch].state |= DCSR_STARTINTR;
pxa2xx_dma.c:    if (s->running ++)
pxa2xx_dma.c:    while (s->running) {
pxa2xx_dma.c:        s->running = 1;
pxa2xx_dma.c:        for (c = 0; c < s->channels; c ++) {
pxa2xx_dma.c:            ch = &s->chan[c];
pxa2xx_dma.c:            while ((ch->state & DCSR_RUN) && !(ch->state & DCSR_STOPINTR)) {
pxa2xx_dma.c:                if ((ch->cmd & (DCMD_FLOWSRC | DCMD_FLOWTRG)) && !ch->request)
pxa2xx_dma.c:                length = ch->cmd & DCMD_LEN;
pxa2xx_dma.c:                size = DCMD_SIZE(ch->cmd);
pxa2xx_dma.c:                width = DCMD_WIDTH(ch->cmd);
pxa2xx_dma.c:                srcinc = (ch->cmd & DCMD_INCSRCADDR) ? width : 0;
pxa2xx_dma.c:                destinc = (ch->cmd & DCMD_INCTRGADDR) ? width : 0;
pxa2xx_dma.c:                        cpu_physical_memory_read(ch->src, buffer + n, width);
pxa2xx_dma.c:                        ch->src += srcinc;
pxa2xx_dma.c:                        cpu_physical_memory_write(ch->dest, buffer + n, width);
pxa2xx_dma.c:                        ch->dest += destinc;
pxa2xx_dma.c:                    length -= size;
pxa2xx_dma.c:                    if ((ch->cmd & (DCMD_FLOWSRC | DCMD_FLOWTRG)) &&
pxa2xx_dma.c:                            !ch->request) {
pxa2xx_dma.c:                        ch->state |= DCSR_EORINT;
pxa2xx_dma.c:                        if (ch->state & DCSR_EORSTOPEN)
pxa2xx_dma.c:                            ch->state |= DCSR_STOPINTR;
pxa2xx_dma.c:                        if ((ch->state & DCSR_EORJMPEN) &&
pxa2xx_dma.c:                                        !(ch->state & DCSR_NODESCFETCH))
pxa2xx_dma.c:                ch->cmd = (ch->cmd & ~DCMD_LEN) | length;
pxa2xx_dma.c:                    if (ch->cmd & DCMD_ENDIRQEN)
pxa2xx_dma.c:                        ch->state |= DCSR_ENDINTR;
pxa2xx_dma.c:                    if ((ch->state & DCSR_NODESCFETCH) ||
pxa2xx_dma.c:                                (ch->descr & DDADR_STOP) ||
pxa2xx_dma.c:                                (ch->state & DCSR_EORSTOPEN)) {
pxa2xx_dma.c:                        ch->state |= DCSR_STOPINTR;
pxa2xx_dma.c:                        ch->state &= ~DCSR_RUN;
pxa2xx_dma.c:                    ch->state |= DCSR_STOPINTR;
pxa2xx_dma.c:        s->running --;
pxa2xx_dma.c:        offset -= DRCMR64 - DRCMR0 - (64 << 2);
pxa2xx_dma.c:        channel = (offset - DRCMR0) >> 2;
pxa2xx_dma.c:        return s->req[channel];
pxa2xx_dma.c:	if (s->chan[channel].request)
pxa2xx_dma.c:            return s->chan[channel].state | DCSR_REQPEND;
pxa2xx_dma.c:        return s->chan[channel].state;
pxa2xx_dma.c:        return s->stopintr | s->eorintr | s->rasintr |
pxa2xx_dma.c:                s->startintr | s->endintr;
pxa2xx_dma.c:        return s->align;
pxa2xx_dma.c:        return s->pio;
pxa2xx_dma.c:    if (offset >= D_CH0 && offset < D_CH0 + (s->channels << 4)) {
pxa2xx_dma.c:        channel = (offset - D_CH0) >> 4;
pxa2xx_dma.c:            return s->chan[channel].descr;
pxa2xx_dma.c:            return s->chan[channel].src;
pxa2xx_dma.c:            return s->chan[channel].dest;
pxa2xx_dma.c:            return s->chan[channel].cmd;
pxa2xx_dma.c:        offset -= DRCMR64 - DRCMR0 - (64 << 2);
pxa2xx_dma.c:        channel = (offset - DRCMR0) >> 2;
pxa2xx_dma.c:            if ((value & DRCMR_CHLNUM) > s->channels)
pxa2xx_dma.c:        s->req[channel] = value;
pxa2xx_dma.c:        s->chan[channel].state &= 0x0000071f & ~(value &
pxa2xx_dma.c:        s->chan[channel].state |= value & 0xfc800000;
pxa2xx_dma.c:        if (s->chan[channel].state & DCSR_STOPIRQEN)
pxa2xx_dma.c:            s->chan[channel].state &= ~DCSR_STOPINTR;
pxa2xx_dma.c:            /* No-descriptor-fetch mode */
pxa2xx_dma.c:                s->chan[channel].state &= ~DCSR_STOPINTR;
pxa2xx_dma.c:            /* Descriptor-fetch mode */
pxa2xx_dma.c:                s->chan[channel].state &= ~DCSR_STOPINTR;
pxa2xx_dma.c:            s->chan[channel].state |= DCSR_STOPINTR;
pxa2xx_dma.c:            s->chan[channel].state &= ~DCSR_CMPST;
pxa2xx_dma.c:            s->chan[channel].state |= DCSR_CMPST;
pxa2xx_dma.c:        s->align = value;
pxa2xx_dma.c:        s->pio = value & 0x80000001;
pxa2xx_dma.c:        if (offset >= D_CH0 && offset < D_CH0 + (s->channels << 4)) {
pxa2xx_dma.c:            channel = (offset - D_CH0) >> 4;
pxa2xx_dma.c:                s->chan[channel].descr = value;
pxa2xx_dma.c:                s->chan[channel].src = value;
pxa2xx_dma.c:                s->chan[channel].dest = value;
pxa2xx_dma.c:                s->chan[channel].cmd = value;
pxa2xx_dma.c:    qemu_put_be32(f, s->channels);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->stopintr);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->eorintr);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->rasintr);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->startintr);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->endintr);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->align);
pxa2xx_dma.c:    qemu_put_be32s(f, &s->pio);
pxa2xx_dma.c:    qemu_put_buffer(f, s->req, PXA2XX_DMA_NUM_REQUESTS);
pxa2xx_dma.c:    for (i = 0; i < s->channels; i ++) {
pxa2xx_dma.c:        qemu_put_betl(f, s->chan[i].descr);
pxa2xx_dma.c:        qemu_put_betl(f, s->chan[i].src);
pxa2xx_dma.c:        qemu_put_betl(f, s->chan[i].dest);
pxa2xx_dma.c:        qemu_put_be32s(f, &s->chan[i].cmd);
pxa2xx_dma.c:        qemu_put_be32s(f, &s->chan[i].state);
pxa2xx_dma.c:        qemu_put_be32(f, s->chan[i].request);
pxa2xx_dma.c:    if (qemu_get_be32(f) != s->channels)
pxa2xx_dma.c:        return -EINVAL;
pxa2xx_dma.c:    qemu_get_be32s(f, &s->stopintr);
pxa2xx_dma.c:    qemu_get_be32s(f, &s->eorintr);
pxa2xx_dma.c:    qemu_get_be32s(f, &s->rasintr);
pxa2xx_dma.c:    qemu_get_be32s(f, &s->startintr);
pxa2xx_dma.c:    qemu_get_be32s(f, &s->endintr);
pxa2xx_dma.c:    qemu_get_be32s(f, &s->align);
pxa2xx_dma.c:    qemu_get_be32s(f, &s->pio);
pxa2xx_dma.c:    qemu_get_buffer(f, s->req, PXA2XX_DMA_NUM_REQUESTS);
pxa2xx_dma.c:    for (i = 0; i < s->channels; i ++) {
pxa2xx_dma.c:        s->chan[i].descr = qemu_get_betl(f);
pxa2xx_dma.c:        s->chan[i].src = qemu_get_betl(f);
pxa2xx_dma.c:        s->chan[i].dest = qemu_get_betl(f);
pxa2xx_dma.c:        qemu_get_be32s(f, &s->chan[i].cmd);
pxa2xx_dma.c:        qemu_get_be32s(f, &s->chan[i].state);
pxa2xx_dma.c:        s->chan[i].request = qemu_get_be32(f);
pxa2xx_dma.c:    s->channels = channels;
pxa2xx_dma.c:    s->chan = qemu_mallocz(sizeof(PXA2xxDMAChannel) * s->channels);
pxa2xx_dma.c:    s->irq = irq;
pxa2xx_dma.c:    s->handler = (pxa2xx_dma_handler_t) pxa2xx_dma_request;
pxa2xx_dma.c:    s->req = qemu_mallocz(sizeof(uint8_t) * PXA2XX_DMA_NUM_REQUESTS);
pxa2xx_dma.c:    memset(s->chan, 0, sizeof(PXA2xxDMAChannel) * s->channels);
pxa2xx_dma.c:    for (i = 0; i < s->channels; i ++)
pxa2xx_dma.c:        s->chan[i].state = DCSR_STOPINTR;
pxa2xx_dma.c:    memset(s->req, 0, sizeof(uint8_t) * PXA2XX_DMA_NUM_REQUESTS);
pxa2xx_dma.c:    if (!(s->req[req_num] & DRCMR_MAPVLD))
pxa2xx_dma.c:    ch = s->req[req_num] & DRCMR_CHLNUM;
pxa2xx_dma.c:    if (!s->chan[ch].request && on)
pxa2xx_dma.c:        s->chan[ch].state |= DCSR_RASINTR;
pxa2xx_dma.c:        s->chan[ch].state &= ~DCSR_RASINTR;
pxa2xx_dma.c:    if (s->chan[ch].request && !on)
pxa2xx_dma.c:        s->chan[ch].state |= DCSR_EORINT;
pxa2xx_dma.c:    s->chan[ch].request = on;
pxa2xx_gpio.c:    if (s->status[0] & (1 << 0))
pxa2xx_gpio.c:        qemu_irq_raise(s->pic[PXA2XX_PIC_GPIO_0]);
pxa2xx_gpio.c:        qemu_irq_lower(s->pic[PXA2XX_PIC_GPIO_0]);
pxa2xx_gpio.c:    if (s->status[0] & (1 << 1))
pxa2xx_gpio.c:        qemu_irq_raise(s->pic[PXA2XX_PIC_GPIO_1]);
pxa2xx_gpio.c:        qemu_irq_lower(s->pic[PXA2XX_PIC_GPIO_1]);
pxa2xx_gpio.c:    if ((s->status[0] & ~3) | s->status[1] | s->status[2] | s->status[3])
pxa2xx_gpio.c:        qemu_irq_raise(s->pic[PXA2XX_PIC_GPIO_X]);
pxa2xx_gpio.c:        qemu_irq_lower(s->pic[PXA2XX_PIC_GPIO_X]);
pxa2xx_gpio.c:/* Bitmap of pins used as standby and sleep wake-up sources.  */
pxa2xx_gpio.c:    if (line >= s->lines) {
pxa2xx_gpio.c:        s->status[bank] |= s->rising[bank] & mask &
pxa2xx_gpio.c:                ~s->ilevel[bank] & ~s->dir[bank];
pxa2xx_gpio.c:        s->ilevel[bank] |= mask;
pxa2xx_gpio.c:        s->status[bank] |= s->falling[bank] & mask &
pxa2xx_gpio.c:                s->ilevel[bank] & ~s->dir[bank];
pxa2xx_gpio.c:        s->ilevel[bank] &= ~mask;
pxa2xx_gpio.c:    if (s->status[bank] & mask)
pxa2xx_gpio.c:    /* Wake-up GPIOs */
pxa2xx_gpio.c:    if (s->cpu_env->halted && (mask & ~s->dir[bank] & pxa2xx_gpio_wake[bank]))
pxa2xx_gpio.c:        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_EXITTB);
pxa2xx_gpio.c:        level = s->olevel[i] & s->dir[i];
pxa2xx_gpio.c:        for (diff = s->prev_level[i] ^ level; diff; diff ^= 1 << bit) {
pxa2xx_gpio.c:            bit = ffs(diff) - 1;
pxa2xx_gpio.c:            qemu_set_irq(s->handler[line], (level >> bit) & 1);
pxa2xx_gpio.c:        s->prev_level[i] = level;
pxa2xx_gpio.c:    case GPDR:		/* GPIO Pin-Direction registers */
pxa2xx_gpio.c:        return s->dir[bank];
pxa2xx_gpio.c:    case GPSR:		/* GPIO Pin-Output Set registers */
pxa2xx_gpio.c:        printf("%s: Read from a write-only register " REG_FMT "\n",
pxa2xx_gpio.c:        return s->gpsr[bank];	/* Return last written value.  */
pxa2xx_gpio.c:    case GPCR:		/* GPIO Pin-Output Clear registers */
pxa2xx_gpio.c:        printf("%s: Read from a write-only register " REG_FMT "\n",
pxa2xx_gpio.c:    case GRER:		/* GPIO Rising-Edge Detect Enable registers */
pxa2xx_gpio.c:        return s->rising[bank];
pxa2xx_gpio.c:    case GFER:		/* GPIO Falling-Edge Detect Enable registers */
pxa2xx_gpio.c:        return s->falling[bank];
pxa2xx_gpio.c:        return s->gafr[bank * 2];
pxa2xx_gpio.c:        return s->gafr[bank * 2 + 1];
pxa2xx_gpio.c:    case GPLR:		/* GPIO Pin-Level registers */
pxa2xx_gpio.c:        ret = (s->olevel[bank] & s->dir[bank]) |
pxa2xx_gpio.c:                (s->ilevel[bank] & ~s->dir[bank]);
pxa2xx_gpio.c:        qemu_irq_raise(s->read_notify);
pxa2xx_gpio.c:        return s->status[bank];
pxa2xx_gpio.c:    case GPDR:		/* GPIO Pin-Direction registers */
pxa2xx_gpio.c:        s->dir[bank] = value;
pxa2xx_gpio.c:    case GPSR:		/* GPIO Pin-Output Set registers */
pxa2xx_gpio.c:        s->olevel[bank] |= value;
pxa2xx_gpio.c:        s->gpsr[bank] = value;
pxa2xx_gpio.c:    case GPCR:		/* GPIO Pin-Output Clear registers */
pxa2xx_gpio.c:        s->olevel[bank] &= ~value;
pxa2xx_gpio.c:    case GRER:		/* GPIO Rising-Edge Detect Enable registers */
pxa2xx_gpio.c:        s->rising[bank] = value;
pxa2xx_gpio.c:    case GFER:		/* GPIO Falling-Edge Detect Enable registers */
pxa2xx_gpio.c:        s->falling[bank] = value;
pxa2xx_gpio.c:        s->gafr[bank * 2] = value;
pxa2xx_gpio.c:        s->gafr[bank * 2 + 1] = value;
pxa2xx_gpio.c:        s->status[bank] &= ~value;
pxa2xx_gpio.c:    qemu_put_be32(f, s->lines);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->ilevel[i]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->olevel[i]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->dir[i]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->rising[i]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->falling[i]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->status[i]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->gafr[i * 2 + 0]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->gafr[i * 2 + 1]);
pxa2xx_gpio.c:        qemu_put_be32s(f, &s->prev_level[i]);
pxa2xx_gpio.c:    if (qemu_get_be32(f) != s->lines)
pxa2xx_gpio.c:        return -EINVAL;
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->ilevel[i]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->olevel[i]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->dir[i]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->rising[i]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->falling[i]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->status[i]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->gafr[i * 2 + 0]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->gafr[i * 2 + 1]);
pxa2xx_gpio.c:        qemu_get_be32s(f, &s->prev_level[i]);
pxa2xx_gpio.c:    s->pic = pic;
pxa2xx_gpio.c:    s->lines = lines;
pxa2xx_gpio.c:    s->cpu_env = env;
pxa2xx_gpio.c:    s->in = qemu_allocate_irqs(pxa2xx_gpio_set, s, lines);
pxa2xx_gpio.c:    return s->in;
pxa2xx_gpio.c:    if (line >= s->lines) {
pxa2xx_gpio.c:    s->handler[line] = handler;
pxa2xx_gpio.c:    s->read_notify = handler;
pxa2xx_keypad.c: * Written by Armin Kuster <akuster@kama-aina.net>
pxa2xx_keypad.c:    if(!(kp->kpc & KPC_ME)) /* skip if not enabled */
pxa2xx_keypad.c:    if(kp->kpc & KPC_AS || kp->kpc & KPC_ASACT) {
pxa2xx_keypad.c:        if(kp->kpc & KPC_AS)
pxa2xx_keypad.c:            kp->kpc &= ~(KPC_AS);
pxa2xx_keypad.c:        row = kp->map[keycode].row;
pxa2xx_keypad.c:        col = kp->map[keycode].column;
pxa2xx_keypad.c:        if(row == -1 || col == -1)
pxa2xx_keypad.c:                kp->kpasmkp0 = ~(0xffffffff);
pxa2xx_keypad.c:                kp->kpasmkp0 |= KPASMKPx_MKC(row,col);
pxa2xx_keypad.c:                kp->kpasmkp1 = ~(0xffffffff);
pxa2xx_keypad.c:                kp->kpasmkp1 |= KPASMKPx_MKC(row,col);
pxa2xx_keypad.c:                kp->kpasmkp2 = ~(0xffffffff);
pxa2xx_keypad.c:                kp->kpasmkp2 |= KPASMKPx_MKC(row,col);
pxa2xx_keypad.c:                kp->kpasmkp3 = ~(0xffffffff);
pxa2xx_keypad.c:                kp->kpasmkp3 |= KPASMKPx_MKC(row,col);
pxa2xx_keypad.c:    if(kp->kpc & KPC_MIE) {
pxa2xx_keypad.c:        kp->kpc |= KPC_MI;
pxa2xx_keypad.c:        qemu_irq_raise(kp->irq);
pxa2xx_keypad.c:        tmp = s->kpc;
pxa2xx_keypad.c:            s->kpc &= ~(KPC_MI);
pxa2xx_keypad.c:            s->kpc &= ~(KPC_DI);
pxa2xx_keypad.c:        qemu_irq_lower(s->irq);
pxa2xx_keypad.c:        return s->kpdk;
pxa2xx_keypad.c:        tmp = s->kprec;
pxa2xx_keypad.c:            s->kprec &= ~(KPREC_OF1);
pxa2xx_keypad.c:            s->kprec &= ~(KPREC_UF1);
pxa2xx_keypad.c:            s->kprec &= ~(KPREC_OF0);
pxa2xx_keypad.c:            s->kprec &= ~(KPREC_UF0);
pxa2xx_keypad.c:        tmp = s->kpmk;
pxa2xx_keypad.c:            s->kpmk &= ~(KPMK_MKP);
pxa2xx_keypad.c:        return s->kpas;
pxa2xx_keypad.c:        return s->kpasmkp0;
pxa2xx_keypad.c:        return s->kpasmkp1;
pxa2xx_keypad.c:        return s->kpasmkp2;
pxa2xx_keypad.c:        return s->kpasmkp3;
pxa2xx_keypad.c:        return s->kpkdi;
pxa2xx_keypad.c:        s->kpc = value;
pxa2xx_keypad.c:        s->kpdk = value;
pxa2xx_keypad.c:        s->kprec = value;
pxa2xx_keypad.c:        s->kpmk = value;
pxa2xx_keypad.c:        s->kpas = value;
pxa2xx_keypad.c:        s->kpasmkp0 = value;
pxa2xx_keypad.c:        s->kpasmkp1 = value;
pxa2xx_keypad.c:        s->kpasmkp2 = value;
pxa2xx_keypad.c:        s->kpasmkp3 = value;
pxa2xx_keypad.c:        s->kpkdi = value;
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpc);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpdk);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kprec);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpmk);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpas);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpasmkp0);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpasmkp1);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpasmkp2);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpasmkp3);
pxa2xx_keypad.c:    qemu_put_be32s(f, &s->kpkdi);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpc);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpdk);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kprec);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpmk);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpas);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpasmkp0);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpasmkp1);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpasmkp2);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpasmkp3);
pxa2xx_keypad.c:    qemu_get_be32s(f, &s->kpkdi);
pxa2xx_keypad.c:    s->irq = irq;
pxa2xx_keypad.c:        fprintf(stderr, "%s - No PXA keypad map defined\n", __FUNCTION__);
pxa2xx_keypad.c:        exit(-1);
pxa2xx_keypad.c:    kp->map = map;
pxa2xx_lcd.c:#define LCCR5_SOFM(ch)	(1 << (ch - 1))
pxa2xx_lcd.c:#define LCSR1_SOF(ch)	(1 << (ch - 1))
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_LDD)    && !(s->control[0] & LCCR0_LDM);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_SOF0)   && !(s->control[0] & LCCR0_SOFM0);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_IU0)    && !(s->control[0] & LCCR0_IUM);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_IU1)    && !(s->control[5] & LCCR5_IUM(1));
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_OU)     && !(s->control[0] & LCCR0_OUM);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_QD)     && !(s->control[0] & LCCR0_QDM);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_EOF0)   && !(s->control[0] & LCCR0_EOFM0);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_BS0)    && !(s->control[0] & LCCR0_BSM0);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_RDST)   && !(s->control[0] & LCCR0_RDSTM);
pxa2xx_lcd.c:    level |= (s->status[0] & LCSR0_CMDINT) && !(s->control[0] & LCCR0_CMDIM);
pxa2xx_lcd.c:    level |= (s->status[1] & ~s->control[5]);
pxa2xx_lcd.c:    qemu_set_irq(s->irq, !!level);
pxa2xx_lcd.c:    s->irqlevel = level;
pxa2xx_lcd.c:        s->status[0] |= LCSR0_BS0;
pxa2xx_lcd.c:        unmasked = !(s->control[0] & LCCR0_BSM0);
pxa2xx_lcd.c:        s->status[1] |= LCSR1_BS(ch);
pxa2xx_lcd.c:        unmasked = !(s->control[5] & LCCR5_BSM(ch));
pxa2xx_lcd.c:        if (s->irqlevel)
pxa2xx_lcd.c:            s->status[0] |= LCSR0_SINT;
pxa2xx_lcd.c:            s->liidr = s->dma_ch[ch].id;
pxa2xx_lcd.c:    if (!(s->dma_ch[ch].command & LDCMD_SOFINT))
pxa2xx_lcd.c:        s->status[0] |= LCSR0_SOF0;
pxa2xx_lcd.c:        unmasked = !(s->control[0] & LCCR0_SOFM0);
pxa2xx_lcd.c:        s->status[1] |= LCSR1_SOF(ch);
pxa2xx_lcd.c:        unmasked = !(s->control[5] & LCCR5_SOFM(ch));
pxa2xx_lcd.c:        if (s->irqlevel)
pxa2xx_lcd.c:            s->status[0] |= LCSR0_SINT;
pxa2xx_lcd.c:            s->liidr = s->dma_ch[ch].id;
pxa2xx_lcd.c:    if (!(s->dma_ch[ch].command & LDCMD_EOFINT))
pxa2xx_lcd.c:        s->status[0] |= LCSR0_EOF0;
pxa2xx_lcd.c:        unmasked = !(s->control[0] & LCCR0_EOFM0);
pxa2xx_lcd.c:        s->status[1] |= LCSR1_EOF(ch);
pxa2xx_lcd.c:        unmasked = !(s->control[5] & LCCR5_EOFM(ch));
pxa2xx_lcd.c:        if (s->irqlevel)
pxa2xx_lcd.c:            s->status[0] |= LCSR0_SINT;
pxa2xx_lcd.c:            s->liidr = s->dma_ch[ch].id;
pxa2xx_lcd.c:    s->status[0] |= LCSR0_BERCH(ch) | LCSR0_BER;
pxa2xx_lcd.c:    if (s->irqlevel)
pxa2xx_lcd.c:        s->status[0] |= LCSR0_SINT;
pxa2xx_lcd.c:        s->liidr = s->dma_ch[ch].id;
pxa2xx_lcd.c:    s->status[0] |= LCSR0_RDST;
pxa2xx_lcd.c:    if (s->irqlevel && !(s->control[0] & LCCR0_RDSTM))
pxa2xx_lcd.c:        s->status[0] |= LCSR0_SINT;
pxa2xx_lcd.c:        s->dma_ch[i].source = 0;
pxa2xx_lcd.c:        if (!s->dma_ch[i].up)
pxa2xx_lcd.c:        if (s->dma_ch[i].branch & FBR_BRA) {
pxa2xx_lcd.c:            descptr = s->dma_ch[i].branch & FBR_SRCADDR;
pxa2xx_lcd.c:            if (s->dma_ch[i].branch & FBR_BINT)
pxa2xx_lcd.c:            s->dma_ch[i].branch &= ~FBR_BRA;
pxa2xx_lcd.c:            descptr = s->dma_ch[i].descriptor;
pxa2xx_lcd.c:        s->dma_ch[i].descriptor = tswap32(desc.fdaddr);
pxa2xx_lcd.c:        s->dma_ch[i].source = tswap32(desc.fsaddr);
pxa2xx_lcd.c:        s->dma_ch[i].id = tswap32(desc.fidr);
pxa2xx_lcd.c:        s->dma_ch[i].command = tswap32(desc.ldcmd);
pxa2xx_lcd.c:        return s->control[0];
pxa2xx_lcd.c:        return s->control[1];
pxa2xx_lcd.c:        return s->control[2];
pxa2xx_lcd.c:        return s->control[3];
pxa2xx_lcd.c:        return s->control[4];
pxa2xx_lcd.c:        return s->control[5];
pxa2xx_lcd.c:        return s->ovl1c[0];
pxa2xx_lcd.c:        return s->ovl1c[1];
pxa2xx_lcd.c:        return s->ovl2c[0];
pxa2xx_lcd.c:        return s->ovl2c[1];
pxa2xx_lcd.c:        return s->ccr;
pxa2xx_lcd.c:        return s->cmdcr;
pxa2xx_lcd.c:        return s->trgbr;
pxa2xx_lcd.c:        return s->tcr;
pxa2xx_lcd.c:    case 0x200 ... 0x1000:	/* DMA per-channel registers */
pxa2xx_lcd.c:        ch = (offset - 0x200) >> 4;
pxa2xx_lcd.c:            return s->dma_ch[ch].descriptor;
pxa2xx_lcd.c:            return s->dma_ch[ch].source;
pxa2xx_lcd.c:            return s->dma_ch[ch].id;
pxa2xx_lcd.c:            return s->dma_ch[ch].command;
pxa2xx_lcd.c:        return s->dma_ch[0].branch;
pxa2xx_lcd.c:        return s->dma_ch[1].branch;
pxa2xx_lcd.c:        return s->dma_ch[2].branch;
pxa2xx_lcd.c:        return s->dma_ch[3].branch;
pxa2xx_lcd.c:        return s->dma_ch[4].branch;
pxa2xx_lcd.c:        return s->dma_ch[5].branch;
pxa2xx_lcd.c:        return s->dma_ch[6].branch;
pxa2xx_lcd.c:        return s->bscntr;
pxa2xx_lcd.c:        return s->status[0];
pxa2xx_lcd.c:        return s->status[1];
pxa2xx_lcd.c:        return s->liidr;
pxa2xx_lcd.c:        if ((s->control[0] & LCCR0_ENB) && !(value & LCCR0_ENB))
pxa2xx_lcd.c:            s->status[0] |= LCSR0_QD;
pxa2xx_lcd.c:        if (!(s->control[0] & LCCR0_LCDT) && (value & LCCR0_LCDT))
pxa2xx_lcd.c:        if ((s->control[3] & LCCR3_API) &&
pxa2xx_lcd.c:            s->status[0] |= LCSR0_ABC;
pxa2xx_lcd.c:        s->control[0] = value & 0x07ffffff;
pxa2xx_lcd.c:        s->dma_ch[0].up = !!(value & LCCR0_ENB);
pxa2xx_lcd.c:        s->dma_ch[1].up = (s->ovl1c[0] & OVLC1_EN) || (value & LCCR0_SDS);
pxa2xx_lcd.c:        s->control[1] = value;
pxa2xx_lcd.c:        s->control[2] = value;
pxa2xx_lcd.c:        s->control[3] = value & 0xefffffff;
pxa2xx_lcd.c:        s->bpp = LCCR3_BPP(value);
pxa2xx_lcd.c:        s->control[4] = value & 0x83ff81ff;
pxa2xx_lcd.c:        s->control[5] = value & 0x3f3f3f3f;
pxa2xx_lcd.c:        if (!(s->ovl1c[0] & OVLC1_EN) && (value & OVLC1_EN))
pxa2xx_lcd.c:        s->ovl1c[0] = value & 0x80ffffff;
pxa2xx_lcd.c:        s->dma_ch[1].up = (value & OVLC1_EN) || (s->control[0] & LCCR0_SDS);
pxa2xx_lcd.c:        s->ovl1c[1] = value & 0x000fffff;
pxa2xx_lcd.c:        if (!(s->ovl2c[0] & OVLC1_EN) && (value & OVLC1_EN))
pxa2xx_lcd.c:        s->ovl2c[0] = value & 0x80ffffff;
pxa2xx_lcd.c:        s->dma_ch[2].up = !!(value & OVLC1_EN);
pxa2xx_lcd.c:        s->dma_ch[3].up = !!(value & OVLC1_EN);
pxa2xx_lcd.c:        s->dma_ch[4].up = !!(value & OVLC1_EN);
pxa2xx_lcd.c:        s->ovl2c[1] = value & 0x007fffff;
pxa2xx_lcd.c:        if (!(s->ccr & CCR_CEN) && (value & CCR_CEN))
pxa2xx_lcd.c:        s->ccr = value & 0x81ffffe7;
pxa2xx_lcd.c:        s->dma_ch[5].up = !!(value & CCR_CEN);
pxa2xx_lcd.c:        s->cmdcr = value & 0xff;
pxa2xx_lcd.c:        s->trgbr = value & 0x00ffffff;
pxa2xx_lcd.c:        s->tcr = value & 0x7fff;
pxa2xx_lcd.c:    case 0x200 ... 0x1000:	/* DMA per-channel registers */
pxa2xx_lcd.c:        ch = (offset - 0x200) >> 4;
pxa2xx_lcd.c:            s->dma_ch[ch].descriptor = value & 0xfffffff0;
pxa2xx_lcd.c:        s->dma_ch[0].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->dma_ch[1].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->dma_ch[2].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->dma_ch[3].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->dma_ch[4].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->dma_ch[5].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->dma_ch[6].branch = value & 0xfffffff3;
pxa2xx_lcd.c:        s->bscntr = value & 0xf;
pxa2xx_lcd.c:        s->status[0] &= ~(value & 0xfff);
pxa2xx_lcd.c:            s->status[0] &= ~LCSR0_BERCH(7);
pxa2xx_lcd.c:        s->status[1] &= ~(value & 0x3e3f3f);
pxa2xx_lcd.c:    s->pal_for = LCCR4_PALFOR(s->control[4]);
pxa2xx_lcd.c:    format = s->pal_for;
pxa2xx_lcd.c:    src = (uint32_t *) s->dma_ch[ch].pbuffer;
pxa2xx_lcd.c:    dest = (uint32_t *) s->dma_ch[ch].palette;
pxa2xx_lcd.c:            if (s->control[0] & LCCR0_CMS)
pxa2xx_lcd.c:            if (s->control[0] & LCCR0_CMS)
pxa2xx_lcd.c:            if (s->control[0] & LCCR0_CMS)
pxa2xx_lcd.c:            if (s->control[0] & LCCR0_CMS)
pxa2xx_lcd.c:        switch (ds_get_bits_per_pixel(s->ds)) {
pxa2xx_lcd.c:    if (s->dest_width)
pxa2xx_lcd.c:        fn = s->line_fn[s->transp][s->bpp];
pxa2xx_lcd.c:    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */
pxa2xx_lcd.c:    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)
pxa2xx_lcd.c:    else if (s->bpp > pxa_lcdc_16bpp)
pxa2xx_lcd.c:    else if (s->bpp > pxa_lcdc_8bpp)
pxa2xx_lcd.c:    dest_width = s->xres * s->dest_width;
pxa2xx_lcd.c:    framebuffer_update_display(s->ds,
pxa2xx_lcd.c:                               addr, s->xres, s->yres,
pxa2xx_lcd.c:                               src_width, dest_width, s->dest_width,
pxa2xx_lcd.c:                               s->invalidated,
pxa2xx_lcd.c:                               fn, s->dma_ch[0].palette, miny, maxy);
pxa2xx_lcd.c:    if (s->dest_width)
pxa2xx_lcd.c:        fn = s->line_fn[s->transp][s->bpp];
pxa2xx_lcd.c:    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */
pxa2xx_lcd.c:    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)
pxa2xx_lcd.c:    else if (s->bpp > pxa_lcdc_16bpp)
pxa2xx_lcd.c:    else if (s->bpp > pxa_lcdc_8bpp)
pxa2xx_lcd.c:    dest_width = s->yres * s->dest_width;
pxa2xx_lcd.c:    framebuffer_update_display(s->ds,
pxa2xx_lcd.c:                               addr, s->xres, s->yres,
pxa2xx_lcd.c:                               src_width, s->dest_width, -dest_width,
pxa2xx_lcd.c:                               s->invalidated,
pxa2xx_lcd.c:                               fn, s->dma_ch[0].palette,
pxa2xx_lcd.c:    if (!(s->control[0] & LCCR0_ENB))
pxa2xx_lcd.c:    width = LCCR1_PPL(s->control[1]) + 1;
pxa2xx_lcd.c:    height = LCCR2_LPP(s->control[2]) + 1;
pxa2xx_lcd.c:    if (width != s->xres || height != s->yres) {
pxa2xx_lcd.c:        if (s->orientation)
pxa2xx_lcd.c:            qemu_console_resize(s->ds, height, width);
pxa2xx_lcd.c:            qemu_console_resize(s->ds, width, height);
pxa2xx_lcd.c:        s->invalidated = 1;
pxa2xx_lcd.c:        s->xres = width;
pxa2xx_lcd.c:        s->yres = height;
pxa2xx_lcd.c:    if (!(s->control[0] & LCCR0_ENB))
pxa2xx_lcd.c:    miny = s->yres;
pxa2xx_lcd.c:    s->transp = s->dma_ch[2].up || s->dma_ch[3].up;
pxa2xx_lcd.c:        if (s->dma_ch[ch].up) {
pxa2xx_lcd.c:            if (!s->dma_ch[ch].source) {
pxa2xx_lcd.c:            fbptr = s->dma_ch[ch].source;
pxa2xx_lcd.c:            if (s->dma_ch[ch].command & LDCMD_PAL) {
pxa2xx_lcd.c:                cpu_physical_memory_read(fbptr, s->dma_ch[ch].pbuffer,
pxa2xx_lcd.c:                    MAX(LDCMD_LENGTH(s->dma_ch[ch].command),
pxa2xx_lcd.c:                        sizeof(s->dma_ch[ch].pbuffer)));
pxa2xx_lcd.c:                pxa2xx_palette_parse(s, ch, s->bpp);
pxa2xx_lcd.c:                if (LCCR4_PALFOR(s->control[4]) != s->pal_for)
pxa2xx_lcd.c:                    pxa2xx_palette_parse(s, ch, s->bpp);
pxa2xx_lcd.c:                s->dma_ch[ch].redraw(s, fbptr, &miny, &maxy);
pxa2xx_lcd.c:                s->invalidated = 0;
pxa2xx_lcd.c:    if (s->control[0] & LCCR0_DIS) {
pxa2xx_lcd.c:        s->control[0] &= ~LCCR0_ENB;
pxa2xx_lcd.c:        s->status[0] |= LCSR0_LDD;
pxa2xx_lcd.c:        if (s->orientation)
pxa2xx_lcd.c:            dpy_update(s->ds, miny, 0, maxy, s->xres);
pxa2xx_lcd.c:            dpy_update(s->ds, 0, miny, s->xres, maxy);
pxa2xx_lcd.c:    qemu_irq_raise(s->vsync_cb);
pxa2xx_lcd.c:    s->invalidated = 1;
pxa2xx_lcd.c:        s->dma_ch[0].redraw = pxa2xx_lcdc_dma0_redraw_vert;
pxa2xx_lcd.c:        s->dma_ch[0].redraw = pxa2xx_lcdc_dma0_redraw_horiz;
pxa2xx_lcd.c:    s->orientation = angle;
pxa2xx_lcd.c:    s->xres = s->yres = -1;
pxa2xx_lcd.c:    qemu_put_be32(f, s->irqlevel);
pxa2xx_lcd.c:    qemu_put_be32(f, s->transp);
pxa2xx_lcd.c:        qemu_put_be32s(f, &s->control[i]);
pxa2xx_lcd.c:        qemu_put_be32s(f, &s->status[i]);
pxa2xx_lcd.c:        qemu_put_be32s(f, &s->ovl1c[i]);
pxa2xx_lcd.c:        qemu_put_be32s(f, &s->ovl2c[i]);
pxa2xx_lcd.c:    qemu_put_be32s(f, &s->ccr);
pxa2xx_lcd.c:    qemu_put_be32s(f, &s->cmdcr);
pxa2xx_lcd.c:    qemu_put_be32s(f, &s->trgbr);
pxa2xx_lcd.c:    qemu_put_be32s(f, &s->tcr);
pxa2xx_lcd.c:    qemu_put_be32s(f, &s->liidr);
pxa2xx_lcd.c:    qemu_put_8s(f, &s->bscntr);
pxa2xx_lcd.c:        qemu_put_betl(f, s->dma_ch[i].branch);
pxa2xx_lcd.c:        qemu_put_byte(f, s->dma_ch[i].up);
pxa2xx_lcd.c:        qemu_put_buffer(f, s->dma_ch[i].pbuffer, sizeof(s->dma_ch[i].pbuffer));
pxa2xx_lcd.c:        qemu_put_betl(f, s->dma_ch[i].descriptor);
pxa2xx_lcd.c:        qemu_put_betl(f, s->dma_ch[i].source);
pxa2xx_lcd.c:        qemu_put_be32s(f, &s->dma_ch[i].id);
pxa2xx_lcd.c:        qemu_put_be32s(f, &s->dma_ch[i].command);
pxa2xx_lcd.c:    s->irqlevel = qemu_get_be32(f);
pxa2xx_lcd.c:    s->transp = qemu_get_be32(f);
pxa2xx_lcd.c:        qemu_get_be32s(f, &s->control[i]);
pxa2xx_lcd.c:        qemu_get_be32s(f, &s->status[i]);
pxa2xx_lcd.c:        qemu_get_be32s(f, &s->ovl1c[i]);
pxa2xx_lcd.c:        qemu_get_be32s(f, &s->ovl2c[i]);
pxa2xx_lcd.c:    qemu_get_be32s(f, &s->ccr);
pxa2xx_lcd.c:    qemu_get_be32s(f, &s->cmdcr);
pxa2xx_lcd.c:    qemu_get_be32s(f, &s->trgbr);
pxa2xx_lcd.c:    qemu_get_be32s(f, &s->tcr);
pxa2xx_lcd.c:    qemu_get_be32s(f, &s->liidr);
pxa2xx_lcd.c:    qemu_get_8s(f, &s->bscntr);
pxa2xx_lcd.c:        s->dma_ch[i].branch = qemu_get_betl(f);
pxa2xx_lcd.c:        s->dma_ch[i].up = qemu_get_byte(f);
pxa2xx_lcd.c:        qemu_get_buffer(f, s->dma_ch[i].pbuffer, sizeof(s->dma_ch[i].pbuffer));
pxa2xx_lcd.c:        s->dma_ch[i].descriptor = qemu_get_betl(f);
pxa2xx_lcd.c:        s->dma_ch[i].source = qemu_get_betl(f);
pxa2xx_lcd.c:        qemu_get_be32s(f, &s->dma_ch[i].id);
pxa2xx_lcd.c:        qemu_get_be32s(f, &s->dma_ch[i].command);
pxa2xx_lcd.c:    s->bpp = LCCR3_BPP(s->control[3]);
pxa2xx_lcd.c:    s->xres = s->yres = s->pal_for = -1;
pxa2xx_lcd.c:    s->invalidated = 1;
pxa2xx_lcd.c:    s->irq = irq;
pxa2xx_lcd.c:    s->ds = graphic_console_init(pxa2xx_update_display,
pxa2xx_lcd.c:    switch (ds_get_bits_per_pixel(s->ds)) {
pxa2xx_lcd.c:        s->dest_width = 0;
pxa2xx_lcd.c:        s->line_fn[0] = pxa2xx_draw_fn_8;
pxa2xx_lcd.c:        s->line_fn[1] = pxa2xx_draw_fn_8t;
pxa2xx_lcd.c:        s->dest_width = 1;
pxa2xx_lcd.c:        s->line_fn[0] = pxa2xx_draw_fn_15;
pxa2xx_lcd.c:        s->line_fn[1] = pxa2xx_draw_fn_15t;
pxa2xx_lcd.c:        s->dest_width = 2;
pxa2xx_lcd.c:        s->line_fn[0] = pxa2xx_draw_fn_16;
pxa2xx_lcd.c:        s->line_fn[1] = pxa2xx_draw_fn_16t;
pxa2xx_lcd.c:        s->dest_width = 2;
pxa2xx_lcd.c:        s->line_fn[0] = pxa2xx_draw_fn_24;
pxa2xx_lcd.c:        s->line_fn[1] = pxa2xx_draw_fn_24t;
pxa2xx_lcd.c:        s->dest_width = 3;
pxa2xx_lcd.c:        s->line_fn[0] = pxa2xx_draw_fn_32;
pxa2xx_lcd.c:        s->line_fn[1] = pxa2xx_draw_fn_32t;
pxa2xx_lcd.c:        s->dest_width = 4;
pxa2xx_lcd.c:    s->vsync_cb = handler;
pxa2xx_mmci.c:#define MMC_RESTO	0x14	/* MMC Response Time-Out register */
pxa2xx_mmci.c:#define MMC_RDTO	0x18	/* MMC Read Time-Out register */
pxa2xx_mmci.c:    uint32_t mask = s->intmask;
pxa2xx_mmci.c:    if (s->cmdat & CMDAT_DMA_EN) {
pxa2xx_mmci.c:        pxa2xx_dma_request(s->dma,
pxa2xx_mmci.c:                        PXA2XX_RX_RQ_MMCI, !!(s->intreq & INT_RXFIFO_REQ));
pxa2xx_mmci.c:        pxa2xx_dma_request(s->dma,
pxa2xx_mmci.c:                        PXA2XX_TX_RQ_MMCI, !!(s->intreq & INT_TXFIFO_REQ));
pxa2xx_mmci.c:    qemu_set_irq(s->irq, !!(s->intreq & ~mask));
pxa2xx_mmci.c:    if (!s->active)
pxa2xx_mmci.c:    if (s->cmdat & CMDAT_WR_RD) {
pxa2xx_mmci.c:        while (s->bytesleft && s->tx_len) {
pxa2xx_mmci.c:            sd_write_data(s->card, s->tx_fifo[s->tx_start ++]);
pxa2xx_mmci.c:            s->tx_start &= 0x1f;
pxa2xx_mmci.c:            s->tx_len --;
pxa2xx_mmci.c:            s->bytesleft --;
pxa2xx_mmci.c:        if (s->bytesleft)
pxa2xx_mmci.c:            s->intreq |= INT_TXFIFO_REQ;
pxa2xx_mmci.c:        while (s->bytesleft && s->rx_len < 32) {
pxa2xx_mmci.c:            s->rx_fifo[(s->rx_start + (s->rx_len ++)) & 0x1f] =
pxa2xx_mmci.c:                sd_read_data(s->card);
pxa2xx_mmci.c:            s->bytesleft --;
pxa2xx_mmci.c:            s->intreq |= INT_RXFIFO_REQ;
pxa2xx_mmci.c:    if (!s->bytesleft) {
pxa2xx_mmci.c:        s->active = 0;
pxa2xx_mmci.c:        s->intreq |= INT_DATA_DONE;
pxa2xx_mmci.c:        s->status |= STAT_DATA_DONE;
pxa2xx_mmci.c:        if (s->cmdat & CMDAT_WR_RD) {
pxa2xx_mmci.c:            s->intreq |= INT_PRG_DONE;
pxa2xx_mmci.c:            s->status |= STAT_PRG_DONE;
pxa2xx_mmci.c:    s->active = 1;
pxa2xx_mmci.c:    s->rx_len = 0;
pxa2xx_mmci.c:    s->tx_len = 0;
pxa2xx_mmci.c:    s->cmdreq = 0;
pxa2xx_mmci.c:    request.cmd = s->cmd;
pxa2xx_mmci.c:    request.arg = s->arg;
pxa2xx_mmci.c:    rsplen = sd_do_command(s->card, &request, response);
pxa2xx_mmci.c:    s->intreq |= INT_END_CMD;
pxa2xx_mmci.c:    memset(s->resp_fifo, 0, sizeof(s->resp_fifo));
pxa2xx_mmci.c:    switch (s->cmdat & CMDAT_RES_TYPE) {
pxa2xx_mmci.c:        s->resp_fifo[(wd) + 0] |= (value0);	\
pxa2xx_mmci.c:        s->resp_fifo[(wd) + 1] |= (value1) << 8;
pxa2xx_mmci.c:        for (i = 0; rsplen > 0; i ++, rsplen -= 2) {
pxa2xx_mmci.c:        s->status |= STAT_END_CMDRES;
pxa2xx_mmci.c:        if (!(s->cmdat & CMDAT_DATA_EN))
pxa2xx_mmci.c:            s->active = 0;
pxa2xx_mmci.c:            s->bytesleft = s->numblk * s->blklen;
pxa2xx_mmci.c:        s->resp_len = 0;
pxa2xx_mmci.c:        s->active = 0;
pxa2xx_mmci.c:        s->status |= STAT_TOUT_RES;
pxa2xx_mmci.c:        return s->status;
pxa2xx_mmci.c:        return s->clkrt;
pxa2xx_mmci.c:        return s->spi;
pxa2xx_mmci.c:        return s->cmdat;
pxa2xx_mmci.c:        return s->resp_tout;
pxa2xx_mmci.c:        return s->read_tout;
pxa2xx_mmci.c:        return s->blklen;
pxa2xx_mmci.c:        return s->numblk;
pxa2xx_mmci.c:        return s->intmask;
pxa2xx_mmci.c:        return s->intreq;
pxa2xx_mmci.c:        return s->cmd | 0x40;
pxa2xx_mmci.c:        return s->arg >> 16;
pxa2xx_mmci.c:        return s->arg & 0xffff;
pxa2xx_mmci.c:        if (s->resp_len < 9)
pxa2xx_mmci.c:            return s->resp_fifo[s->resp_len ++];
pxa2xx_mmci.c:        while (s->ac_width -- && s->rx_len) {
pxa2xx_mmci.c:            ret |= s->rx_fifo[s->rx_start ++] << (s->ac_width << 3);
pxa2xx_mmci.c:            s->rx_start &= 0x1f;
pxa2xx_mmci.c:            s->rx_len --;
pxa2xx_mmci.c:        s->intreq &= ~INT_RXFIFO_REQ;
pxa2xx_mmci.c:        return s->numblk;
pxa2xx_mmci.c:            s->status |= STAT_CLK_EN;
pxa2xx_mmci.c:            s->intreq &= ~INT_CLK_OFF;
pxa2xx_mmci.c:            if (s->cmdreq && !(s->cmdat & CMDAT_STOP_TRAN)) {
pxa2xx_mmci.c:                s->status &= STAT_CLK_EN;
pxa2xx_mmci.c:            s->status &= ~STAT_CLK_EN;
pxa2xx_mmci.c:            s->intreq |= INT_CLK_OFF;
pxa2xx_mmci.c:            s->active = 0;
pxa2xx_mmci.c:        s->clkrt = value & 7;
pxa2xx_mmci.c:        s->spi = value & 0xf;
pxa2xx_mmci.c:        s->cmdat = value & 0x3dff;
pxa2xx_mmci.c:        s->active = 0;
pxa2xx_mmci.c:        s->cmdreq = 1;
pxa2xx_mmci.c:            s->status &= STAT_CLK_EN;
pxa2xx_mmci.c:            if (s->status & STAT_CLK_EN)
pxa2xx_mmci.c:        s->resp_tout = value & 0x7f;
pxa2xx_mmci.c:        s->read_tout = value & 0xffff;
pxa2xx_mmci.c:        s->blklen = value & 0xfff;
pxa2xx_mmci.c:        s->numblk = value & 0xffff;
pxa2xx_mmci.c:            s->tx_start ^= 32;
pxa2xx_mmci.c:            s->tx_len = 0;
pxa2xx_mmci.c:        s->intmask = value & 0x1fff;
pxa2xx_mmci.c:        s->cmd = value & 0x3f;
pxa2xx_mmci.c:        s->arg &= 0x0000ffff;
pxa2xx_mmci.c:        s->arg |= value << 16;
pxa2xx_mmci.c:        s->arg &= 0xffff0000;
pxa2xx_mmci.c:        s->arg |= value & 0x0000ffff;
pxa2xx_mmci.c:        while (s->ac_width -- && s->tx_len < 0x20)
pxa2xx_mmci.c:            s->tx_fifo[(s->tx_start + (s->tx_len ++)) & 0x1f] =
pxa2xx_mmci.c:                    (value >> (s->ac_width << 3)) & 0xff;
pxa2xx_mmci.c:        s->intreq &= ~INT_TXFIFO_REQ;
pxa2xx_mmci.c:    s->ac_width = 1;
pxa2xx_mmci.c:    s->ac_width = 2;
pxa2xx_mmci.c:    s->ac_width = 4;
pxa2xx_mmci.c:    s->ac_width = 1;
pxa2xx_mmci.c:    s->ac_width = 2;
pxa2xx_mmci.c:    s->ac_width = 4;
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->status);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->clkrt);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->spi);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->cmdat);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->resp_tout);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->read_tout);
pxa2xx_mmci.c:    qemu_put_be32(f, s->blklen);
pxa2xx_mmci.c:    qemu_put_be32(f, s->numblk);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->intmask);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->intreq);
pxa2xx_mmci.c:    qemu_put_be32(f, s->cmd);
pxa2xx_mmci.c:    qemu_put_be32s(f, &s->arg);
pxa2xx_mmci.c:    qemu_put_be32(f, s->cmdreq);
pxa2xx_mmci.c:    qemu_put_be32(f, s->active);
pxa2xx_mmci.c:    qemu_put_be32(f, s->bytesleft);
pxa2xx_mmci.c:    qemu_put_byte(f, s->tx_len);
pxa2xx_mmci.c:    for (i = 0; i < s->tx_len; i ++)
pxa2xx_mmci.c:        qemu_put_byte(f, s->tx_fifo[(s->tx_start + i) & 63]);
pxa2xx_mmci.c:    qemu_put_byte(f, s->rx_len);
pxa2xx_mmci.c:    for (i = 0; i < s->rx_len; i ++)
pxa2xx_mmci.c:        qemu_put_byte(f, s->rx_fifo[(s->rx_start + i) & 31]);
pxa2xx_mmci.c:    qemu_put_byte(f, s->resp_len);
pxa2xx_mmci.c:    for (i = s->resp_len; i < 9; i ++)
pxa2xx_mmci.c:        qemu_put_be16s(f, &s->resp_fifo[i]);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->status);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->clkrt);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->spi);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->cmdat);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->resp_tout);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->read_tout);
pxa2xx_mmci.c:    s->blklen = qemu_get_be32(f);
pxa2xx_mmci.c:    s->numblk = qemu_get_be32(f);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->intmask);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->intreq);
pxa2xx_mmci.c:    s->cmd = qemu_get_be32(f);
pxa2xx_mmci.c:    qemu_get_be32s(f, &s->arg);
pxa2xx_mmci.c:    s->cmdreq = qemu_get_be32(f);
pxa2xx_mmci.c:    s->active = qemu_get_be32(f);
pxa2xx_mmci.c:    s->bytesleft = qemu_get_be32(f);
pxa2xx_mmci.c:    s->tx_len = qemu_get_byte(f);
pxa2xx_mmci.c:    s->tx_start = 0;
pxa2xx_mmci.c:    if (s->tx_len >= sizeof(s->tx_fifo) || s->tx_len < 0)
pxa2xx_mmci.c:        return -EINVAL;
pxa2xx_mmci.c:    for (i = 0; i < s->tx_len; i ++)
pxa2xx_mmci.c:        s->tx_fifo[i] = qemu_get_byte(f);
pxa2xx_mmci.c:    s->rx_len = qemu_get_byte(f);
pxa2xx_mmci.c:    s->rx_start = 0;
pxa2xx_mmci.c:    if (s->rx_len >= sizeof(s->rx_fifo) || s->rx_len < 0)
pxa2xx_mmci.c:        return -EINVAL;
pxa2xx_mmci.c:    for (i = 0; i < s->rx_len; i ++)
pxa2xx_mmci.c:        s->rx_fifo[i] = qemu_get_byte(f);
pxa2xx_mmci.c:    s->resp_len = qemu_get_byte(f);
pxa2xx_mmci.c:    if (s->resp_len > 9 || s->resp_len < 0)
pxa2xx_mmci.c:        return -EINVAL;
pxa2xx_mmci.c:    for (i = s->resp_len; i < 9; i ++)
pxa2xx_mmci.c:         qemu_get_be16s(f, &s->resp_fifo[i]);
pxa2xx_mmci.c:    s->irq = irq;
pxa2xx_mmci.c:    s->dma = dma;
pxa2xx_mmci.c:    s->card = sd_init(bd, 0);
pxa2xx_mmci.c:    sd_set_cb(s->card, readonly, coverswitch);
pxa2xx_pcmcia.c:    if (s->slot.attached) {
pxa2xx_pcmcia.c:        return s->card->common_read(s->card->state, offset);
pxa2xx_pcmcia.c:    if (s->slot.attached) {
pxa2xx_pcmcia.c:        s->card->common_write(s->card->state, offset, value);
pxa2xx_pcmcia.c:    if (s->slot.attached) {
pxa2xx_pcmcia.c:        return s->card->attr_read(s->card->state, offset);
pxa2xx_pcmcia.c:    if (s->slot.attached) {
pxa2xx_pcmcia.c:        s->card->attr_write(s->card->state, offset, value);
pxa2xx_pcmcia.c:    if (s->slot.attached) {
pxa2xx_pcmcia.c:        return s->card->io_read(s->card->state, offset);
pxa2xx_pcmcia.c:    if (s->slot.attached) {
pxa2xx_pcmcia.c:        s->card->io_write(s->card->state, offset, value);
pxa2xx_pcmcia.c:    if (!s->irq)
pxa2xx_pcmcia.c:    qemu_set_irq(s->irq, level);
pxa2xx_pcmcia.c:        s->slot.slot_string = "PXA PC Card Socket 1";
pxa2xx_pcmcia.c:        s->slot.slot_string = "PXA PC Card Socket 0";
pxa2xx_pcmcia.c:    s->slot.irq = qemu_allocate_irqs(pxa2xx_pcmcia_set_irq, s, 1)[0];
pxa2xx_pcmcia.c:    pcmcia_socket_register(&s->slot);
pxa2xx_pcmcia.c:    if (s->slot.attached)
pxa2xx_pcmcia.c:        return -EEXIST;
pxa2xx_pcmcia.c:    if (s->cd_irq) {
pxa2xx_pcmcia.c:        qemu_irq_raise(s->cd_irq);
pxa2xx_pcmcia.c:    s->card = card;
pxa2xx_pcmcia.c:    s->slot.attached = 1;
pxa2xx_pcmcia.c:    s->card->slot = &s->slot;
pxa2xx_pcmcia.c:    s->card->attach(s->card->state);
pxa2xx_pcmcia.c:    if (!s->slot.attached)
pxa2xx_pcmcia.c:        return -ENOENT;
pxa2xx_pcmcia.c:    s->card->detach(s->card->state);
pxa2xx_pcmcia.c:    s->card->slot = NULL;
pxa2xx_pcmcia.c:    s->card = NULL;
pxa2xx_pcmcia.c:    s->slot.attached = 0;
pxa2xx_pcmcia.c:    if (s->irq)
pxa2xx_pcmcia.c:        qemu_irq_lower(s->irq);
pxa2xx_pcmcia.c:    if (s->cd_irq)
pxa2xx_pcmcia.c:        qemu_irq_lower(s->cd_irq);
pxa2xx_pcmcia.c:    s->irq = irq;
pxa2xx_pcmcia.c:    s->cd_irq = cd_irq;
pxa2xx_pic.c:    if (s->cpu_env->halted) {
pxa2xx_pic.c:        mask[0] = s->int_pending[0] & (s->int_enabled[0] | s->int_idle);
pxa2xx_pic.c:        mask[1] = s->int_pending[1] & (s->int_enabled[1] | s->int_idle);
pxa2xx_pic.c:            cpu_interrupt(s->cpu_env, CPU_INTERRUPT_EXITTB);
pxa2xx_pic.c:    mask[0] = s->int_pending[0] & s->int_enabled[0];
pxa2xx_pic.c:    mask[1] = s->int_pending[1] & s->int_enabled[1];
pxa2xx_pic.c:    if ((mask[0] & s->is_fiq[0]) || (mask[1] & s->is_fiq[1]))
pxa2xx_pic.c:        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_FIQ);
pxa2xx_pic.c:        cpu_reset_interrupt(s->cpu_env, CPU_INTERRUPT_FIQ);
pxa2xx_pic.c:    if ((mask[0] & ~s->is_fiq[0]) || (mask[1] & ~s->is_fiq[1]))
pxa2xx_pic.c:        cpu_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
pxa2xx_pic.c:        cpu_reset_interrupt(s->cpu_env, CPU_INTERRUPT_HARD);
pxa2xx_pic.c:        s->int_pending[int_set] |= 1 << irq;
pxa2xx_pic.c:        s->int_pending[int_set] &= ~(1 << irq);
pxa2xx_pic.c:    mask[0] = s->int_pending[0] & s->int_enabled[0];
pxa2xx_pic.c:    mask[1] = s->int_pending[1] & s->int_enabled[1];
pxa2xx_pic.c:    for (i = PXA2XX_PIC_SRCS - 1; i >= 0; i --) {
pxa2xx_pic.c:        irq = s->priority[i] & 0x3f;
pxa2xx_pic.c:        if ((s->priority[i] & (1 << 31)) && irq < PXA2XX_PIC_SRCS) {
pxa2xx_pic.c:            if (mask[int_set] & bit & s->is_fiq[int_set]) {
pxa2xx_pic.c:            if (mask[int_set] & bit & ~s->is_fiq[int_set]) {
pxa2xx_pic.c:        return s->int_pending[0] & ~s->is_fiq[0] & s->int_enabled[0];
pxa2xx_pic.c:        return s->int_pending[1] & ~s->is_fiq[1] & s->int_enabled[1];
pxa2xx_pic.c:        return s->int_enabled[0];
pxa2xx_pic.c:        return s->int_enabled[1];
pxa2xx_pic.c:        return s->is_fiq[0];
pxa2xx_pic.c:        return s->is_fiq[1];
pxa2xx_pic.c:        return (s->int_idle == 0);
pxa2xx_pic.c:        return s->int_pending[0] & s->is_fiq[0] & s->int_enabled[0];
pxa2xx_pic.c:        return s->int_pending[1] & s->is_fiq[1] & s->int_enabled[1];
pxa2xx_pic.c:        return s->int_pending[0];
pxa2xx_pic.c:        return s->int_pending[1];
pxa2xx_pic.c:        return s->priority[0  + ((offset - IPR0 ) >> 2)];
pxa2xx_pic.c:        return s->priority[32 + ((offset - IPR32) >> 2)];
pxa2xx_pic.c:        s->int_enabled[0] = value;
pxa2xx_pic.c:        s->int_enabled[1] = value;
pxa2xx_pic.c:        s->is_fiq[0] = value;
pxa2xx_pic.c:        s->is_fiq[1] = value;
pxa2xx_pic.c:        s->int_idle = (value & 1) ? 0 : ~0;
pxa2xx_pic.c:        s->priority[0  + ((offset - IPR0 ) >> 2)] = value & 0x8000003f;
pxa2xx_pic.c:        s->priority[32 + ((offset - IPR32) >> 2)] = value & 0x8000003f;
pxa2xx_pic.c:    [0x0 ... 0xf] = -1,
pxa2xx_pic.c:    if (pxa2xx_cp_reg_map[reg] == -1) {
pxa2xx_pic.c:    if (pxa2xx_cp_reg_map[reg] == -1) {
pxa2xx_pic.c:        qemu_put_be32s(f, &s->int_enabled[i]);
pxa2xx_pic.c:        qemu_put_be32s(f, &s->int_pending[i]);
pxa2xx_pic.c:        qemu_put_be32s(f, &s->is_fiq[i]);
pxa2xx_pic.c:    qemu_put_be32s(f, &s->int_idle);
pxa2xx_pic.c:        qemu_put_be32s(f, &s->priority[i]);
pxa2xx_pic.c:        qemu_get_be32s(f, &s->int_enabled[i]);
pxa2xx_pic.c:        qemu_get_be32s(f, &s->int_pending[i]);
pxa2xx_pic.c:        qemu_get_be32s(f, &s->is_fiq[i]);
pxa2xx_pic.c:    qemu_get_be32s(f, &s->int_idle);
pxa2xx_pic.c:        qemu_get_be32s(f, &s->priority[i]);
pxa2xx_pic.c:    s->cpu_env = env;
pxa2xx_pic.c:    s->int_pending[0] = 0;
pxa2xx_pic.c:    s->int_pending[1] = 0;
pxa2xx_pic.c:    s->int_enabled[0] = 0;
pxa2xx_pic.c:    s->int_enabled[1] = 0;
pxa2xx_pic.c:    s->is_fiq[0] = 0;
pxa2xx_pic.c:    s->is_fiq[1] = 0;
pxa2xx_pic.c:    /* Enable IC memory-mapped registers access.  */
pxa2xx_template.h:        width -= 16;
pxa2xx_template.h:        width -= 8;
pxa2xx_template.h:        width -= 4;
pxa2xx_template.h:        width -= 2;
pxa2xx_template.h:        width -= 2;
pxa2xx_template.h:        width -= 1;
pxa2xx_template.h:        width -= 4;
pxa2xx_template.h:        width -= 1;
pxa2xx_template.h:        width -= 4;
pxa2xx_template.h:        width -= 1;
pxa2xx_template.h:        width -= 1;
pxa2xx_template.h:        width -= 1;
pxa2xx_timer.c:#include "qemu-timer.h"
pxa2xx_timer.c:#define OIER	0x1c	/* Interrupt enable register  3-0 to E3-E0 */
pxa2xx_timer.c:    now_vm = s->clock +
pxa2xx_timer.c:            muldiv64(now_qemu - s->lastload, s->freq, get_ticks_per_sec());
pxa2xx_timer.c:        new_qemu = now_qemu + muldiv64((uint32_t) (s->timer[i].value - now_vm),
pxa2xx_timer.c:                        get_ticks_per_sec(), s->freq);
pxa2xx_timer.c:        qemu_mod_timer(s->timer[i].qtimer, new_qemu);
pxa2xx_timer.c:    if (s->tm4[n].control & (1 << 7))
pxa2xx_timer.c:    if (!s->tm4[counter].freq) {
pxa2xx_timer.c:        qemu_del_timer(s->tm4[n].tm.qtimer);
pxa2xx_timer.c:    now_vm = s->tm4[counter].clock + muldiv64(now_qemu -
pxa2xx_timer.c:                    s->tm4[counter].lastload,
pxa2xx_timer.c:                    s->tm4[counter].freq, get_ticks_per_sec());
pxa2xx_timer.c:    new_qemu = now_qemu + muldiv64((uint32_t) (s->tm4[n].tm.value - now_vm),
pxa2xx_timer.c:                    get_ticks_per_sec(), s->tm4[counter].freq);
pxa2xx_timer.c:    qemu_mod_timer(s->tm4[n].tm.qtimer, new_qemu);
pxa2xx_timer.c:        return s->timer[tm].value;
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        return s->tm4[tm].tm.value;
pxa2xx_timer.c:        return s->clock + muldiv64(qemu_get_clock(vm_clock) -
pxa2xx_timer.c:                        s->lastload, s->freq, get_ticks_per_sec());
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        if ((tm == 9 - 4 || tm == 11 - 4) && (s->tm4[tm].control & (1 << 9))) {
pxa2xx_timer.c:            if (s->tm4[tm - 1].freq)
pxa2xx_timer.c:                s->snapshot = s->tm4[tm - 1].clock + muldiv64(
pxa2xx_timer.c:                                qemu_get_clock(vm_clock) -
pxa2xx_timer.c:                                s->tm4[tm - 1].lastload,
pxa2xx_timer.c:                                s->tm4[tm - 1].freq, get_ticks_per_sec());
pxa2xx_timer.c:                s->snapshot = s->tm4[tm - 1].clock;
pxa2xx_timer.c:        if (!s->tm4[tm].freq)
pxa2xx_timer.c:            return s->tm4[tm].clock;
pxa2xx_timer.c:        return s->tm4[tm].clock + muldiv64(qemu_get_clock(vm_clock) -
pxa2xx_timer.c:                        s->tm4[tm].lastload, s->tm4[tm].freq, get_ticks_per_sec());
pxa2xx_timer.c:        return s->irq_enabled;
pxa2xx_timer.c:        return s->events;
pxa2xx_timer.c:        return s->reset3;
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        return s->tm4[tm].control;
pxa2xx_timer.c:        return s->snapshot;
pxa2xx_timer.c:        s->timer[tm].value = value;
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        s->tm4[tm].tm.value = value;
pxa2xx_timer.c:        s->oldclock = s->clock;
pxa2xx_timer.c:        s->lastload = qemu_get_clock(vm_clock);
pxa2xx_timer.c:        s->clock = value;
pxa2xx_timer.c:        pxa2xx_timer_update(s, s->lastload);
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        s->tm4[tm].oldclock = s->tm4[tm].clock;
pxa2xx_timer.c:        s->tm4[tm].lastload = qemu_get_clock(vm_clock);
pxa2xx_timer.c:        s->tm4[tm].clock = value;
pxa2xx_timer.c:        pxa2xx_timer_update4(s, s->tm4[tm].lastload, tm);
pxa2xx_timer.c:        s->irq_enabled = value & 0xfff;
pxa2xx_timer.c:        s->events &= ~value;
pxa2xx_timer.c:            if (s->timer[i].level && (value & 1)) {
pxa2xx_timer.c:                s->timer[i].level = 0;
pxa2xx_timer.c:                qemu_irq_lower(s->timer[i].irq);
pxa2xx_timer.c:        if (s->tm4) {
pxa2xx_timer.c:                if (s->tm4[i].tm.level && (value & 1))
pxa2xx_timer.c:                    s->tm4[i].tm.level = 0;
pxa2xx_timer.c:            if (!(s->events & 0xff0))
pxa2xx_timer.c:                qemu_irq_lower(s->tm4->tm.irq);
pxa2xx_timer.c:        s->reset3 = value;
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        s->tm4[tm].control = value & 0x0ff;
pxa2xx_timer.c:            s->tm4[tm].freq = pxa2xx_timer4_freq[value & 7];
pxa2xx_timer.c:            s->tm4[tm].freq = 0;
pxa2xx_timer.c:        if (!s->tm4)
pxa2xx_timer.c:        s->tm4[tm].control = value & 0x3ff;
pxa2xx_timer.c:            s->tm4[tm].freq =
pxa2xx_timer.c:            s->tm4[tm].freq = 0;
pxa2xx_timer.c:    pxa2xx_timer_info *i = (pxa2xx_timer_info *) t->info;
pxa2xx_timer.c:    if (i->irq_enabled & (1 << t->num)) {
pxa2xx_timer.c:        t->level = 1;
pxa2xx_timer.c:        i->events |= 1 << t->num;
pxa2xx_timer.c:        qemu_irq_raise(t->irq);
pxa2xx_timer.c:    if (t->num == 3)
pxa2xx_timer.c:        if (i->reset3 & 1) {
pxa2xx_timer.c:            i->reset3 = 0;
pxa2xx_timer.c:    pxa2xx_timer_info *i = (pxa2xx_timer_info *) t->tm.info;
pxa2xx_timer.c:    pxa2xx_timer_tick(&t->tm);
pxa2xx_timer.c:    if (t->control & (1 << 3))
pxa2xx_timer.c:        t->clock = 0;
pxa2xx_timer.c:    if (t->control & (1 << 6))
pxa2xx_timer.c:        pxa2xx_timer_update4(i, qemu_get_clock(vm_clock), t->tm.num - 4);
pxa2xx_timer.c:    qemu_put_be32s(f, (uint32_t *) &s->clock);
pxa2xx_timer.c:    qemu_put_be32s(f, (uint32_t *) &s->oldclock);
pxa2xx_timer.c:    qemu_put_be64s(f, &s->lastload);
pxa2xx_timer.c:        qemu_put_be32s(f, &s->timer[i].value);
pxa2xx_timer.c:        qemu_put_be32(f, s->timer[i].level);
pxa2xx_timer.c:    if (s->tm4)
pxa2xx_timer.c:            qemu_put_be32s(f, &s->tm4[i].tm.value);
pxa2xx_timer.c:            qemu_put_be32(f, s->tm4[i].tm.level);
pxa2xx_timer.c:            qemu_put_sbe32s(f, &s->tm4[i].oldclock);
pxa2xx_timer.c:            qemu_put_sbe32s(f, &s->tm4[i].clock);
pxa2xx_timer.c:            qemu_put_be64s(f, &s->tm4[i].lastload);
pxa2xx_timer.c:            qemu_put_be32s(f, &s->tm4[i].freq);
pxa2xx_timer.c:            qemu_put_be32s(f, &s->tm4[i].control);
pxa2xx_timer.c:    qemu_put_be32s(f, &s->events);
pxa2xx_timer.c:    qemu_put_be32s(f, &s->irq_enabled);
pxa2xx_timer.c:    qemu_put_be32s(f, &s->reset3);
pxa2xx_timer.c:    qemu_put_be32s(f, &s->snapshot);
pxa2xx_timer.c:    qemu_get_be32s(f, (uint32_t *) &s->clock);
pxa2xx_timer.c:    qemu_get_be32s(f, (uint32_t *) &s->oldclock);
pxa2xx_timer.c:    qemu_get_be64s(f, &s->lastload);
pxa2xx_timer.c:        qemu_get_be32s(f, &s->timer[i].value);
pxa2xx_timer.c:        s->timer[i].level = qemu_get_be32(f);
pxa2xx_timer.c:    if (s->tm4)
pxa2xx_timer.c:            qemu_get_be32s(f, &s->tm4[i].tm.value);
pxa2xx_timer.c:            s->tm4[i].tm.level = qemu_get_be32(f);
pxa2xx_timer.c:            qemu_get_sbe32s(f, &s->tm4[i].oldclock);
pxa2xx_timer.c:            qemu_get_sbe32s(f, &s->tm4[i].clock);
pxa2xx_timer.c:            qemu_get_be64s(f, &s->tm4[i].lastload);
pxa2xx_timer.c:            qemu_get_be32s(f, &s->tm4[i].freq);
pxa2xx_timer.c:            qemu_get_be32s(f, &s->tm4[i].control);
pxa2xx_timer.c:    qemu_get_be32s(f, &s->events);
pxa2xx_timer.c:    qemu_get_be32s(f, &s->irq_enabled);
pxa2xx_timer.c:    qemu_get_be32s(f, &s->reset3);
pxa2xx_timer.c:    qemu_get_be32s(f, &s->snapshot);
pxa2xx_timer.c:    s->irq_enabled = 0;
pxa2xx_timer.c:    s->oldclock = 0;
pxa2xx_timer.c:    s->clock = 0;
pxa2xx_timer.c:    s->lastload = qemu_get_clock(vm_clock);
pxa2xx_timer.c:    s->reset3 = 0;
pxa2xx_timer.c:        s->timer[i].value = 0;
pxa2xx_timer.c:        s->timer[i].irq = irqs[i];
pxa2xx_timer.c:        s->timer[i].info = s;
pxa2xx_timer.c:        s->timer[i].num = i;
pxa2xx_timer.c:        s->timer[i].level = 0;
pxa2xx_timer.c:        s->timer[i].qtimer = qemu_new_timer(vm_clock,
pxa2xx_timer.c:                        pxa2xx_timer_tick, &s->timer[i]);
pxa2xx_timer.c:    s->freq = PXA25X_FREQ;
pxa2xx_timer.c:    s->tm4 = NULL;
pxa2xx_timer.c:    s->freq = PXA27X_FREQ;
pxa2xx_timer.c:    s->tm4 = (PXA2xxTimer4 *) qemu_mallocz(8 *
pxa2xx_timer.c:        s->tm4[i].tm.value = 0;
pxa2xx_timer.c:        s->tm4[i].tm.irq = irq4;
pxa2xx_timer.c:        s->tm4[i].tm.info = s;
pxa2xx_timer.c:        s->tm4[i].tm.num = i + 4;
pxa2xx_timer.c:        s->tm4[i].tm.level = 0;
pxa2xx_timer.c:        s->tm4[i].freq = 0;
pxa2xx_timer.c:        s->tm4[i].control = 0x0;
pxa2xx_timer.c:        s->tm4[i].tm.qtimer = qemu_new_timer(vm_clock,
pxa2xx_timer.c:                        pxa2xx_timer_tick4, &s->tm4[i]);
pxa.h:    /* Real-Time clock */
pxa.h:/* usb-ohci.c */
qdev-addr.c:#include "qdev-addr.h"
qdev-addr.c:/* --- target physical address --- */
qdev.c:    assert(info->size >= sizeof(DeviceState));
qdev.c:    assert(!info->next);
qdev.c:    info->next = device_info_list;
qdev.c:    for (info = device_info_list; info != NULL; info = info->next) {
qdev.c:        if (bus_info && info->bus_info != bus_info)
qdev.c:        if (strcmp(info->name, name) != 0)
qdev.c:    for (info = device_info_list; info != NULL; info = info->next) {
qdev.c:        if (bus_info && info->bus_info != bus_info)
qdev.c:        if (!info->alias)
qdev.c:        if (strcmp(info->alias, name) != 0)
qdev.c:            main_system_bus = qbus_create(&system_bus_info, NULL, "main-system-bus");
qdev.c:    info = qdev_find_info(bus->info, name);
qdev.c:        hw_error("Unknown device '%s' for bus '%s'\n", name, bus->info->name);
qdev.c:    dev = qemu_mallocz(info->size);
qdev.c:    dev->info = info;
qdev.c:    dev->parent_bus = bus;
qdev.c:    qdev_prop_set_defaults(dev, dev->info->props);
qdev.c:    qdev_prop_set_defaults(dev, dev->parent_bus->info->props);
qdev.c:    QLIST_INSERT_HEAD(&bus->children, dev, sibling);
qdev.c:        assert(bus->allow_hotplug);
qdev.c:        dev->hotplugged = 1;
qdev.c:    dev->state = DEV_STATE_CREATED;
qdev.c:    ret = snprintf(dest+pos, len-pos, "name \"%s\", bus %s",
qdev.c:                   info->name, info->bus_info->name);
qdev.c:    pos += MIN(len-pos,ret);
qdev.c:    if (info->alias) {
qdev.c:        ret = snprintf(dest+pos, len-pos, ", alias \"%s\"", info->alias);
qdev.c:        pos += MIN(len-pos,ret);
qdev.c:    if (info->desc) {
qdev.c:        ret = snprintf(dest+pos, len-pos, ", desc \"%s\"", info->desc);
qdev.c:        pos += MIN(len-pos,ret);
qdev.c:    if (info->no_user) {
qdev.c:        ret = snprintf(dest+pos, len-pos, ", no-user");
qdev.c:        pos += MIN(len-pos,ret);
qdev.c:    if (qdev_prop_parse(dev, name, value) == -1) {
qdev.c:                   name, value, dev->info->name);
qdev.c:        return -1;
qdev.c:        qemu_error("-device: no driver specified\n");
qdev.c:        for (info = device_info_list; info != NULL; info = info->next) {
qdev.c:    if (info->no_user) {
qdev.c:                   info->name);
qdev.c:        bus = qbus_find_recursive(main_system_bus, NULL, info->bus_info);
qdev.c:                   path ? path : info->bus_info->name, info->name);
qdev.c:    if (qdev_hotplug && !bus->allow_hotplug) {
qdev.c:                   bus->name);
qdev.c:        qdev->id = id;
qdev.c:    qdev->opts = opts;
qdev.c:    if (dev->info->reset)
qdev.c:        dev->info->reset(dev);
qdev.c:    assert(dev->state == DEV_STATE_CREATED);
qdev.c:    rc = dev->info->init(dev, dev->info);
qdev.c:    if (dev->info->vmsd)
qdev.c:        vmstate_register(-1, dev->info->vmsd, dev);
qdev.c:    dev->state = DEV_STATE_INITIALIZED;
qdev.c:    if (!dev->parent_bus->allow_hotplug) {
qdev.c:                   dev->parent_bus->name);
qdev.c:        return -1;
qdev.c:    assert(dev->info->unplug != NULL);
qdev.c:    return dev->info->unplug(dev);
qdev.c:/* can be used as ->unplug() callback for the simple cases */
qdev.c:    DeviceInfo *info = dev->info;
qdev.c:        hw_error("Initialization of device %s failed\n", info->name);
qdev.c:    if (dev->state == DEV_STATE_INITIALIZED) {
qdev.c:        while (dev->num_child_bus) {
qdev.c:            bus = QLIST_FIRST(&dev->child_bus);
qdev.c:        if (dev->info->vmsd)
qdev.c:            vmstate_unregister(dev->info->vmsd, dev);
qdev.c:        if (dev->info->exit)
qdev.c:            dev->info->exit(dev);
qdev.c:        if (dev->opts)
qdev.c:            qemu_opts_del(dev->opts);
qdev.c:    if (strncmp(dev->info->name, "virtio", 6) == 0) {
qdev.c:    return dev->parent_bus;
qdev.c:    assert(dev->num_gpio_in == 0);
qdev.c:    dev->num_gpio_in = n;
qdev.c:    dev->gpio_in = qemu_allocate_irqs(handler, dev, n);
qdev.c:    assert(dev->num_gpio_out == 0);
qdev.c:    dev->num_gpio_out = n;
qdev.c:    dev->gpio_out = pins;
qdev.c:    assert(n >= 0 && n < dev->num_gpio_in);
qdev.c:    return dev->gpio_in[n];
qdev.c:    assert(n >= 0 && n < dev->num_gpio_out);
qdev.c:    dev->gpio_out[n] = pin;
qdev.c:    qdev_prop_set_macaddr(dev, "mac", nd->macaddr);
qdev.c:    if (nd->vlan)
qdev.c:        qdev_prop_set_vlan(dev, "vlan", nd->vlan);
qdev.c:    if (nd->netdev)
qdev.c:        qdev_prop_set_netdev(dev, "netdev", nd->netdev);
qdev.c:    if (nd->nvectors != NIC_NVECTORS_UNSPECIFIED &&
qdev.c:        qdev_prop_set_uint32(dev, "vectors", nd->nvectors);
qdev.c:/* Get a block device.  This should only be used for single-drive devices
qdev.c:   (e.g. SD/Floppy/MTD).  Multi-disk devices (scsi/ide) should use the
qdev.c:    return dinfo ? dinfo->bdrv : NULL;
qdev.c:    QLIST_FOREACH(bus, &dev->child_bus, sibling) {
qdev.c:        if (strcmp(name, bus->name) == 0) {
qdev.c:    if (name && (strcmp(bus->name, name) != 0)) {
qdev.c:    if (info && (bus->info != info)) {
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:        QLIST_FOREACH(child, &dev->child_bus, sibling) {
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:        if (dev->id && strcmp(dev->id, id) == 0)
qdev.c:        QLIST_FOREACH(child, &dev->child_bus, sibling) {
qdev.c:    pos += snprintf(dest+pos, len-pos,"child busses at \"%s\":",
qdev.c:                    dev->id ? dev->id : dev->info->name);
qdev.c:    QLIST_FOREACH(child, &dev->child_bus, sibling) {
qdev.c:        pos += snprintf(dest+pos, len-pos, "%s\"%s\"", sep, child->name);
qdev.c:    pos += snprintf(dest+pos, len-pos, "devices at \"%s\":",
qdev.c:                    bus->name);
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:        pos += snprintf(dest+pos, len-pos, "%s\"%s\"",
qdev.c:                        sep, dev->info->name);
qdev.c:        if (dev->id)
qdev.c:            pos += snprintf(dest+pos, len-pos, "/\"%s\"", dev->id);
qdev.c:    QLIST_FOREACH(child, &dev->child_bus, sibling) {
qdev.c:        if (strcmp(child->name, elem) == 0) {
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:        if (dev->id  &&  strcmp(dev->id, elem) == 0) {
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:        if (strcmp(dev->info->name, elem) == 0) {
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:        if (dev->info->alias && strcmp(dev->info->alias, elem) == 0) {
qdev.c:            switch (dev->num_child_bus) {
qdev.c:                return QLIST_FIRST(&dev->child_bus);
qdev.c:    bus->info = info;
qdev.c:    bus->parent = parent;
qdev.c:        bus->name = qemu_strdup(name);
qdev.c:    } else if (parent && parent->id) {
qdev.c:        /* parent device has id -> use it for bus name */
qdev.c:        len = strlen(parent->id) + 16;
qdev.c:        snprintf(buf, len, "%s.%d", parent->id, parent->num_child_bus);
qdev.c:        bus->name = buf;
qdev.c:        /* no id -> use lowercase bus type for bus name */
qdev.c:        len = strlen(info->name) + 16;
qdev.c:        len = snprintf(buf, len, "%s.%d", info->name,
qdev.c:                       parent ? parent->num_child_bus : 0);
qdev.c:        bus->name = buf;
qdev.c:    QLIST_INIT(&bus->children);
qdev.c:        QLIST_INSERT_HEAD(&parent->child_bus, bus, sibling);
qdev.c:        parent->num_child_bus++;
qdev.c:    bus = qemu_mallocz(info->size);
qdev.c:    bus->qdev_allocated = 1;
qdev.c:    while ((dev = QLIST_FIRST(&bus->children)) != NULL) {
qdev.c:    if (bus->parent) {
qdev.c:        bus->parent->num_child_bus--;
qdev.c:    if (bus->qdev_allocated) {
qdev.c:    while (props->name) {
qdev.c:        if (props->info->print) {
qdev.c:            props->info->print(dev, props, buf, sizeof(buf));
qdev.c:            qdev_printf("%s-prop: %s = %s\n", prefix, props->name, buf);
qdev.c:    qdev_printf("dev: %s, id \"%s\"\n", dev->info->name,
qdev.c:                dev->id ? dev->id : "");
qdev.c:    if (dev->num_gpio_in) {
qdev.c:        qdev_printf("gpio-in %d\n", dev->num_gpio_in);
qdev.c:    if (dev->num_gpio_out) {
qdev.c:        qdev_printf("gpio-out %d\n", dev->num_gpio_out);
qdev.c:    qdev_print_props(mon, dev, dev->info->props, "dev", indent);
qdev.c:    qdev_print_props(mon, dev, dev->parent_bus->info->props, "bus", indent);
qdev.c:    if (dev->parent_bus->info->print_dev)
qdev.c:        dev->parent_bus->info->print_dev(mon, dev, indent);
qdev.c:    QLIST_FOREACH(child, &dev->child_bus, sibling) {
qdev.c:    qdev_printf("bus: %s\n", bus->name);
qdev.c:    qdev_printf("type %s\n", bus->info->name);
qdev.c:    QLIST_FOREACH(dev, &bus->children, sibling) {
qdev.c:    for (info = device_info_list; info != NULL; info = info->next) {
qdev.h:#include "qemu-queue.h"
qdev.h:#include "qemu-char.h"
qdev.h:#include "qemu-option.h"
qdev.h:/*** qdev-properties.c ***/
qdev-properties.c:    ptr += prop->offset;
qdev-properties.c:/* --- 8bit integer --- */
qdev-properties.c:        return -1;
qdev-properties.c:/* --- 16bit integer --- */
qdev-properties.c:        return -1;
qdev-properties.c:/* --- 32bit integer --- */
qdev-properties.c:        return -1;
qdev-properties.c:        return -1;
qdev-properties.c:/* --- 32bit hex value --- */
qdev-properties.c:        return -1;
qdev-properties.c:/* --- 64bit integer --- */
qdev-properties.c:        return -1;
qdev-properties.c:/* --- 64bit hex value --- */
qdev-properties.c:        return -1;
qdev-properties.c:/* --- string --- */
qdev-properties.c:/* --- drive --- */
qdev-properties.c:        return -1;
qdev-properties.c:    return snprintf(dest, len, "%s", (*ptr) ? (*ptr)->id : "<null>");
qdev-properties.c:/* --- character device --- */
qdev-properties.c:        return -1;
qdev-properties.c:    if (*ptr && (*ptr)->label) {
qdev-properties.c:        return snprintf(dest, len, "%s", (*ptr)->label);
qdev-properties.c:/* --- netdev device --- */
qdev-properties.c:        return -1;
qdev-properties.c:    if (*ptr && (*ptr)->name) {
qdev-properties.c:        return snprintf(dest, len, "%s", (*ptr)->name);
qdev-properties.c:/* --- vlan --- */
qdev-properties.c:        return -1;
qdev-properties.c:        return -1;
qdev-properties.c:        return snprintf(dest, len, "%d", (*ptr)->id);
qdev-properties.c:/* --- pointer --- */
qdev-properties.c:/* --- mac address --- */
qdev-properties.c: *   01-02-03-04-05-06
qdev-properties.c:            return -1;
qdev-properties.c:            return -1;
qdev-properties.c:                return -1;
qdev-properties.c:            if (str[pos+2] != ':' && str[pos+2] != '-')
qdev-properties.c:                return -1;
qdev-properties.c:        mac->a[i] = strtol(str+pos, &p, 16);
qdev-properties.c:                    mac->a[0], mac->a[1], mac->a[2],
qdev-properties.c:                    mac->a[3], mac->a[4], mac->a[5]);
qdev-properties.c:/* --- pci address --- */
qdev-properties.c: * bus-local address, i.e. "$slot" or "$slot.$fn"
qdev-properties.c:            return -1;
qdev-properties.c:        return -1;
qdev-properties.c:        return -1;
qdev-properties.c:    if (*ptr == -1) {
qdev-properties.c:    .name  = "pci-devfn",
qdev-properties.c:/* --- public helpers --- */
qdev-properties.c:    while (props->name) {
qdev-properties.c:        if (strcmp(props->name, name) == 0)
qdev-properties.c:    prop = qdev_prop_walk(dev->info->props, name);
qdev-properties.c:    prop = qdev_prop_walk(dev->parent_bus->info->props, name);
qdev-properties.c:                dev->info->name, name);
qdev-properties.c:        return -1;
qdev-properties.c:    if (!prop->info->parse) {
qdev-properties.c:                dev->info->name, name);
qdev-properties.c:        return -1;
qdev-properties.c:    if (prop->info->parse(dev, prop, value) != 0) {
qdev-properties.c:                dev->info->name, name, value);
qdev-properties.c:        return -1;
qdev-properties.c:                __FUNCTION__, dev->info->name, name);
qdev-properties.c:    if (prop->info->type != type) {
qdev-properties.c:                __FUNCTION__, dev->info->name, name);
qdev-properties.c:    memcpy(dst, src, prop->info->size);
qdev-properties.c:    while (props->name) {
qdev-properties.c:        if (props->defval) {
qdev-properties.c:            memcpy(dst, props->defval, props->info->size);
qdev-properties.c:        if (strcmp(dev->info->name, prop->driver) != 0 &&
qdev-properties.c:            strcmp(dev->info->bus_info->name, prop->driver) != 0) {
qdev-properties.c:        if (qdev_prop_parse(dev, prop->property, prop->value) != 0) {
r2d.c: * Renesas SH7751R R2D-PLUS emulation
r2d.c:        if (fpga->irlmon & fpga->irlmsk & irqtab[i].msk)
r2d.c:    qemu_set_irq(fpga->irl, irl ^ 15);
r2d.c:        fpga->irlmon |= irqtab[n].msk;
r2d.c:        fpga->irlmon &= ~irqtab[n].msk;
r2d.c:        return s->irlmsk;
r2d.c:	return s->outport;
r2d.c:	return s->powoff;
r2d.c:        s->irlmsk = value;
r2d.c:	s->outport = value;
r2d.c:	s->powoff = value;
r2d.c:    s->irl = irl;
r2d.c:    return intx[d->devfn >> 3];
r2d.c:    /* NIC: rtl8139 on-board, and 2 slots. */
r2d.c:				   SDRAM_SIZE - LINUX_LOAD_OFFSET);
r2d.c:          env->pc = (SDRAM_BASE + LINUX_LOAD_OFFSET) | 0xa0000000;
r2d.c:          env->pc = SDRAM_BASE | 0xa0000000; /* Start from P2 area */
r2d.c:    .desc = "r2d-plus board",
rc4030.c: * Copyright (c) 2007-2009 Herve Poussineau
rc4030.c:#include "qemu-timer.h"
rc4030.c:    qemu_irq_lower(s->timer_irq);
rc4030.c:    tm_hz = 1000 / (s->itr + 1);
rc4030.c:    qemu_mod_timer(s->periodic_timer, qemu_get_clock(vm_clock) +
rc4030.c:        val = s->config;
rc4030.c:        val = s->revision;
rc4030.c:        val = s->invalid_address_register;
rc4030.c:        val = s->dma_tl_base;
rc4030.c:        val = s->dma_tl_limit;
rc4030.c:        val = s->remote_failed_address;
rc4030.c:        val = s->memory_failed_address;
rc4030.c:        val = s->cache_bmask;
rc4030.c:        if (s->cache_bmask == (uint32_t)-1)
rc4030.c:            s->cache_bmask = 0;
rc4030.c:        val = s->rem_speed[(addr - 0x0070) >> 3];
rc4030.c:            int entry = (addr - 0x0100) >> 5;
rc4030.c:            val = s->dma_regs[entry][idx];
rc4030.c:        val = s->nmi_interrupt;
rc4030.c:        val = s->offset210;
rc4030.c:        val = s->nvram_protect;
rc4030.c:        qemu_irq_lower(s->timer_irq);
rc4030.c:        s->config = val;
rc4030.c:        s->dma_tl_base = val;
rc4030.c:        s->dma_tl_limit = val;
rc4030.c:        s->cache_maint = val;
rc4030.c:        s->cache_ptag = val;
rc4030.c:        s->cache_ltag = val;
rc4030.c:        s->cache_bmask |= val; /* HACK */
rc4030.c:        if (s->cache_ltag == 0x80000001 && s->cache_bmask == 0xf0f0f0f) {
rc4030.c:            target_phys_addr_t dest = s->cache_ptag & ~0x1;
rc4030.c:            dest += (s->cache_maint & 0x3) << 3;
rc4030.c:        s->rem_speed[(addr - 0x0070) >> 3] = val;
rc4030.c:            int entry = (addr - 0x0100) >> 5;
rc4030.c:            s->dma_regs[entry][idx] = val;
rc4030.c:        s->offset210 = val;
rc4030.c:        s->itr = val;
rc4030.c:        qemu_irq_lower(s->timer_irq);
rc4030.c:    pending = s->isr_jazz & s->imr_jazz;
rc4030.c:    if (s->isr_jazz != 0) {
rc4030.c:            if (s->isr_jazz & (1 << irq)) {
rc4030.c:                if (!(s->imr_jazz & (1 << irq))) {
rc4030.c:        qemu_irq_raise(s->jazz_bus_irq);
rc4030.c:        qemu_irq_lower(s->jazz_bus_irq);
rc4030.c:        s->isr_jazz |= 1 << irq;
rc4030.c:        s->isr_jazz &= ~(1 << irq);
rc4030.c:    qemu_irq_raise(s->timer_irq);
rc4030.c:        uint32_t pending = s->isr_jazz & s->imr_jazz;
rc4030.c:        val = s->imr_jazz;
rc4030.c:        s->imr_jazz = val;
rc4030.c:    s->config = 0x410; /* some boards seem to accept 0x104 too */
rc4030.c:    s->revision = 1;
rc4030.c:    s->invalid_address_register = 0;
rc4030.c:    memset(s->dma_regs, 0, sizeof(s->dma_regs));
rc4030.c:    s->dma_tl_base = s->dma_tl_limit = 0;
rc4030.c:    s->remote_failed_address = s->memory_failed_address = 0;
rc4030.c:    s->cache_maint = 0;
rc4030.c:    s->cache_ptag = s->cache_ltag = 0;
rc4030.c:    s->cache_bmask = 0;
rc4030.c:    s->offset210 = 0x18186;
rc4030.c:    s->nvram_protect = 7;
rc4030.c:        s->rem_speed[i] = 7;
rc4030.c:    s->imr_jazz = 0x10; /* XXX: required by firmware, but why? */
rc4030.c:    s->isr_jazz = 0;
rc4030.c:    s->itr = 0;
rc4030.c:    qemu_irq_lower(s->timer_irq);
rc4030.c:    qemu_irq_lower(s->jazz_bus_irq);
rc4030.c:        return -EINVAL;
rc4030.c:    s->config = qemu_get_be32(f);
rc4030.c:    s->invalid_address_register = qemu_get_be32(f);
rc4030.c:            s->dma_regs[i][j] = qemu_get_be32(f);
rc4030.c:    s->dma_tl_base = qemu_get_be32(f);
rc4030.c:    s->dma_tl_limit = qemu_get_be32(f);
rc4030.c:    s->cache_maint = qemu_get_be32(f);
rc4030.c:    s->remote_failed_address = qemu_get_be32(f);
rc4030.c:    s->memory_failed_address = qemu_get_be32(f);
rc4030.c:    s->cache_ptag = qemu_get_be32(f);
rc4030.c:    s->cache_ltag = qemu_get_be32(f);
rc4030.c:    s->cache_bmask = qemu_get_be32(f);
rc4030.c:    s->offset210 = qemu_get_be32(f);
rc4030.c:    s->nvram_protect = qemu_get_be32(f);
rc4030.c:        s->rem_speed[i] = qemu_get_be32(f);
rc4030.c:    s->imr_jazz = qemu_get_be32(f);
rc4030.c:    s->isr_jazz = qemu_get_be32(f);
rc4030.c:    s->itr = qemu_get_be32(f);
rc4030.c:    qemu_put_be32(f, s->config);
rc4030.c:    qemu_put_be32(f, s->invalid_address_register);
rc4030.c:            qemu_put_be32(f, s->dma_regs[i][j]);
rc4030.c:    qemu_put_be32(f, s->dma_tl_base);
rc4030.c:    qemu_put_be32(f, s->dma_tl_limit);
rc4030.c:    qemu_put_be32(f, s->cache_maint);
rc4030.c:    qemu_put_be32(f, s->remote_failed_address);
rc4030.c:    qemu_put_be32(f, s->memory_failed_address);
rc4030.c:    qemu_put_be32(f, s->cache_ptag);
rc4030.c:    qemu_put_be32(f, s->cache_ltag);
rc4030.c:    qemu_put_be32(f, s->cache_bmask);
rc4030.c:    qemu_put_be32(f, s->offset210);
rc4030.c:    qemu_put_be32(f, s->nvram_protect);
rc4030.c:        qemu_put_be32(f, s->rem_speed[i]);
rc4030.c:    qemu_put_be32(f, s->imr_jazz);
rc4030.c:    qemu_put_be32(f, s->isr_jazz);
rc4030.c:    qemu_put_be32(f, s->itr);
rc4030.c:        ncpy = DMA_PAGESIZE - (addr & (DMA_PAGESIZE - 1));
rc4030.c:        if (ncpy > len - i)
rc4030.c:            ncpy = len - i;
rc4030.c:        if (index >= s->dma_tl_limit / sizeof(dma_pagetable_entry)) {
rc4030.c:        entry_addr = s->dma_tl_base + index * sizeof(dma_pagetable_entry);
rc4030.c:        phys_addr = entry.frame + (addr & (DMA_PAGESIZE - 1));
rc4030.c:    s->dma_regs[n][DMA_REG_ENABLE] &= ~(DMA_FLAG_TC_INTR | DMA_FLAG_MEM_INTR | DMA_FLAG_ADDR_INTR);
rc4030.c:    dev_to_mem = (s->dma_regs[n][DMA_REG_ENABLE] & DMA_FLAG_MEM_TO_DEV) ? 0 : 1;
rc4030.c:    if (!(s->dma_regs[n][DMA_REG_ENABLE] & DMA_FLAG_ENABLE) ||
rc4030.c:        s->dma_regs[n][DMA_REG_ENABLE] |= DMA_FLAG_MEM_INTR;
rc4030.c:        s->nmi_interrupt |= 1 << n;
rc4030.c:    if (len > s->dma_regs[n][DMA_REG_COUNT])
rc4030.c:        len = s->dma_regs[n][DMA_REG_COUNT];
rc4030.c:    dma_addr = s->dma_regs[n][DMA_REG_ADDRESS];
rc4030.c:    s->dma_regs[n][DMA_REG_ENABLE] |= DMA_FLAG_TC_INTR;
rc4030.c:    s->dma_regs[n][DMA_REG_COUNT] -= len;
rc4030.c:            int n = min(16, len - i);
rc4030.c:    rc4030_do_dma(s->opaque, s->n, buf, len, 0);
rc4030.c:    rc4030_do_dma(s->opaque, s->n, buf, len, 1);
rc4030.c:        p->opaque = opaque;
rc4030.c:        p->n = i;
rc4030.c:    s->periodic_timer = qemu_new_timer(vm_clock, rc4030_periodic_timer, s);
rc4030.c:    s->timer_irq = timer;
rc4030.c:    s->jazz_bus_irq = jazz_bus;
realview.c: * Copyright (c) 2006-2007 CodeSourcery.
realview.c:#include "arm-misc.h"
realview.c:#include "usb-ohci.h"
realview.c:        return (s->out & 1) | (s->in << 1);
realview.c:        return -1;
realview.c:        s->out |= value & 3;
realview.c:        s->out &= ~value;
realview.c:    bitbang_i2c_set(s->bitbang, BITBANG_I2C_SCL, (s->out & 1) != 0);
realview.c:    s->in = bitbang_i2c_set(s->bitbang, BITBANG_I2C_SDA, (s->out & 2) != 0);
realview.c:    bus = i2c_init_bus(&dev->qdev, "i2c");
realview.c:    s->bitbang = bitbang_i2c_init(bus);
realview.c:  env->regs[15] = SMP_BOOT_ADDR;
realview.c:        qdev_prop_set_uint32(dev, "num-cpu", smp_cpus);
realview.c:            usb_ohci_init_pci(pci_bus, -1);
realview.c:            pci_create_simple(pci_bus, -1, "lsi53c895a");
realview.c:            n--;
realview.c:        if ((!nd->model && !done_nic)
realview.c:            || strcmp(nd->model, is_pb ? "lan9118" : "smc91c111") == 0) {
realview.c:    /* 0x10002000 Two-Wire Serial Bus.  */
realview.c:    /*  0x10002000 Two-Wire Serial Bus - DVI. (PB) */
realview.c:        cpu_model = "cortex-a8";
realview.c:        cpu_model = "cortex-a9";
realview.c:    .name = "realview-eb",
realview.c:    .desc = "ARM RealView Emulation Baseboard (ARM926EJ-S)",
realview.c:    .name = "realview-eb-mpcore",
realview.c:    .name = "realview-pb-a8",
realview.c:    .desc = "ARM RealView Platform Baseboard for Cortex-A8",
realview.c:    .name = "realview-pbx-a9",
realview.c:    .desc = "ARM RealView Platform Baseboard Explore for Cortex-A9",
realview_gic.c: * Copyright (c) 2006-2007 CodeSourcery.
realview_gic.c:    cpu_register_physical_memory(base, 0x1000, s->iomemtype);
realview_gic.c:    cpu_register_physical_memory(base + 0x1000, 0x1000, s->gic.iomemtype);
realview_gic.c:    gic_init(&s->gic);
realview_gic.c:    s->iomemtype = cpu_register_io_memory(realview_gic_cpu_readfn,
rtl8139.c: *  2006-Jan-28  Mark Malakanov :   TSAD and CSCR implementation (for Windows driver)
rtl8139.c: *  2006-Apr-28  Juergen Lock   :   EEPROM emulation changes for FreeBSD driver
rtl8139.c: *  2006-Jul-01  Igor Kovalenko :   Implemented loopback mode for FreeBSD driver
rtl8139.c: *  2006-Jul-04  Igor Kovalenko :   Implemented TCP segmentation offloading
rtl8139.c: *  2006-Jul-09  Igor Kovalenko :   Fixed TCP header length calculation while processing
rtl8139.c:#include "qemu-timer.h"
rtl8139.c:/* Uncomment to enable on-board timer interrupts */
rtl8139.c:    ( ( input ) & ( size - 1 )  )
rtl8139.c:    Timer = 0x48,        /* A general-purpose counter. */
rtl8139.c:    Config4 = 0x5A,        /* absent on RTL-8139A */
rtl8139.c:    Config5 = 0xD8,        /* absent on RTL-8139A */
rtl8139.c:    RxRingAddrLO    = 0xE4, /* 64-bit start addr of Rx ring */
rtl8139.c:    RxRingAddrHI    = 0xE8, /* 64-bit start addr of Rx ring */
rtl8139.c:    TxDMAShift = 8,        /* DMA burst value (0-7) is shifted this many bits */
rtl8139.c:    TxRetryShift = 4,    /* TXRR value (0-15) is shifted this many bits */
rtl8139.c:    TxVersionMask = 0x7C800000, /* mask out version bits 30-26, 23 */
rtl8139.c:    CSCR_Testfun = 1<<15, /* 1 = Auto-neg speeds up internal timer, WO, def 0 */
rtl8139.c:#define EEPROM_9346_ADDR_MASK (EEPROM_9346_SIZE - 1)
rtl8139.c:    /* Non-persistent data */
rtl8139.c:            eeprom->address = command & EEPROM_9346_ADDR_MASK;
rtl8139.c:            eeprom->output = eeprom->contents[eeprom->address];
rtl8139.c:            eeprom->eedo = 0;
rtl8139.c:            eeprom->tick = 0;
rtl8139.c:            eeprom->mode = Chip9346_data_read;
rtl8139.c:                   eeprom->address, eeprom->output));
rtl8139.c:            eeprom->address = command & EEPROM_9346_ADDR_MASK;
rtl8139.c:            eeprom->input = 0;
rtl8139.c:            eeprom->tick = 0;
rtl8139.c:            eeprom->mode = Chip9346_none; /* Chip9346_data_write */
rtl8139.c:                   eeprom->address));
rtl8139.c:            eeprom->mode = Chip9346_none;
rtl8139.c:    int bit = eeprom->eedi?1:0;
rtl8139.c:    ++ eeprom->tick;
rtl8139.c:    DEBUG_PRINT(("eeprom: tick %d eedi=%d eedo=%d\n", eeprom->tick, eeprom->eedi, eeprom->eedo));
rtl8139.c:    switch (eeprom->mode)
rtl8139.c:                eeprom->mode = Chip9346_read_command;
rtl8139.c:                eeprom->tick = 0;
rtl8139.c:                eeprom->input = 0;
rtl8139.c:            eeprom->input = (eeprom->input << 1) | (bit & 1);
rtl8139.c:            if (eeprom->tick == 8)
rtl8139.c:                prom9346_decode_command(eeprom, eeprom->input & 0xff);
rtl8139.c:            eeprom->eedo = (eeprom->output & 0x8000)?1:0;
rtl8139.c:            eeprom->output <<= 1;
rtl8139.c:            if (eeprom->tick == 16)
rtl8139.c:        // so we need to enter wait-for-command state here
rtl8139.c:                eeprom->mode = Chip9346_enter_command_mode;
rtl8139.c:                eeprom->input = 0;
rtl8139.c:                eeprom->tick = 0;
rtl8139.c:                ++eeprom->address;
rtl8139.c:                eeprom->address &= EEPROM_9346_ADDR_MASK;
rtl8139.c:                eeprom->output = eeprom->contents[eeprom->address];
rtl8139.c:                eeprom->tick = 0;
rtl8139.c:                       eeprom->address, eeprom->output));
rtl8139.c:            eeprom->input = (eeprom->input << 1) | (bit & 1);
rtl8139.c:            if (eeprom->tick == 16)
rtl8139.c:                       eeprom->address, eeprom->input));
rtl8139.c:                eeprom->contents[eeprom->address] = eeprom->input;
rtl8139.c:                eeprom->mode = Chip9346_none; /* waiting for next command after CS cycle */
rtl8139.c:                eeprom->tick = 0;
rtl8139.c:                eeprom->input = 0;
rtl8139.c:            eeprom->input = (eeprom->input << 1) | (bit & 1);
rtl8139.c:            if (eeprom->tick == 16)
rtl8139.c:                    eeprom->contents[i] = eeprom->input;
rtl8139.c:                       eeprom->input));
rtl8139.c:                eeprom->mode = Chip9346_enter_command_mode;
rtl8139.c:                eeprom->tick = 0;
rtl8139.c:                eeprom->input = 0;
rtl8139.c:    EEprom9346 *eeprom = &s->eeprom;
rtl8139.c:    if (!eeprom->eecs)
rtl8139.c:    return eeprom->eedo;
rtl8139.c:    EEprom9346 *eeprom = &s->eeprom;
rtl8139.c:    uint8_t old_eecs = eeprom->eecs;
rtl8139.c:    uint8_t old_eesk = eeprom->eesk;
rtl8139.c:    eeprom->eecs = eecs;
rtl8139.c:    eeprom->eesk = eesk;
rtl8139.c:    eeprom->eedi = eedi;
rtl8139.c:                 eeprom->eecs, eeprom->eesk, eeprom->eedi, eeprom->eedo));
rtl8139.c:        eeprom->tick = 0;
rtl8139.c:        eeprom->input = 0;
rtl8139.c:        eeprom->output = 0;
rtl8139.c:        eeprom->mode = Chip9346_enter_command_mode;
rtl8139.c:    isr = (s->IntrStatus & s->IntrMask) & 0xffff;
rtl8139.c:       isr ? 1 : 0, s->IntrStatus, s->IntrMask));
rtl8139.c:    qemu_set_irq(s->dev.irq[0], (isr != 0));
rtl8139.c:    return (s->RxConfig & (1 << 7));
rtl8139.c:    return s->bChipCmdState & CmdRxEnb;
rtl8139.c:    return s->bChipCmdState & CmdTxEnb;
rtl8139.c:    return s->CpCmd & CPlusRxEnb;
rtl8139.c:    return s->CpCmd & CPlusTxEnb;
rtl8139.c:    if (s->RxBufAddr + size > s->RxBufferSize)
rtl8139.c:        int wrapped = MOD2(s->RxBufAddr + size, s->RxBufferSize);
rtl8139.c:        if (wrapped && !(s->RxBufferSize < 65536 && rtl8139_RxWrap(s)))
rtl8139.c:            DEBUG_PRINT((">>> RTL8139: rx packet wrapped in buffer at %d\n", size-wrapped));
rtl8139.c:                cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,
rtl8139.c:                                           buf, size-wrapped );
rtl8139.c:            s->RxBufAddr = 0;
rtl8139.c:            cpu_physical_memory_write( s->RxBuf + s->RxBufAddr,
rtl8139.c:                                       buf + (size-wrapped), wrapped );
rtl8139.c:            s->RxBufAddr = wrapped;
rtl8139.c:    /* non-wrapping path or overwrapping enabled */
rtl8139.c:    cpu_physical_memory_write( s->RxBuf + s->RxBufAddr, buf, size );
rtl8139.c:    s->RxBufAddr += size;
rtl8139.c:    RTL8139State *s = DO_UPCAST(NICState, nc, nc)->opaque;
rtl8139.c:    if (!s->clock_enabled)
rtl8139.c:        avail = MOD2(s->RxBufferSize + s->RxBufPtr - s->RxBufAddr,
rtl8139.c:                     s->RxBufferSize);
rtl8139.c:    RTL8139State *s = DO_UPCAST(NICState, nc, nc)->opaque;
rtl8139.c:    if (!s->clock_enabled)
rtl8139.c:        return -1;
rtl8139.c:        return -1;
rtl8139.c:    if (s->RxConfig & AcceptAllPhys) {
rtl8139.c:            if (!(s->RxConfig & AcceptBroadcast))
rtl8139.c:                ++s->tally_counters.RxERR;
rtl8139.c:            ++s->tally_counters.RxOkBrd;
rtl8139.c:            if (!(s->RxConfig & AcceptMulticast))
rtl8139.c:                ++s->tally_counters.RxERR;
rtl8139.c:            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))
rtl8139.c:                ++s->tally_counters.RxERR;
rtl8139.c:            ++s->tally_counters.RxOkMul;
rtl8139.c:        } else if (s->phys[0] == buf[0] &&
rtl8139.c:                   s->phys[1] == buf[1] &&
rtl8139.c:                   s->phys[2] == buf[2] &&
rtl8139.c:                   s->phys[3] == buf[3] &&
rtl8139.c:                   s->phys[4] == buf[4] &&
rtl8139.c:                   s->phys[5] == buf[5]) {
rtl8139.c:            if (!(s->RxConfig & AcceptMyPhys))
rtl8139.c:                ++s->tally_counters.RxERR;
rtl8139.c:            ++s->tally_counters.RxOkPhy;
rtl8139.c:            ++s->tally_counters.RxERR;
rtl8139.c:        memset(buf1 + size, 0, MIN_BUF_SIZE - size);
rtl8139.c:#define CP_RX_BUFFER_SIZE_MASK ((1<<13) - 1)
rtl8139.c:#define CP_RX_VLAN_TAG_MASK ((1<<16) - 1)
rtl8139.c:        int descriptor = s->currCPlusRxDesc;
rtl8139.c:        cplus_rx_ring_desc = rtl8139_addr64(s->RxRingAddrLO, s->RxRingAddrHI);
rtl8139.c:               descriptor, s->RxRingAddrHI, s->RxRingAddrLO, (uint64_t)cplus_rx_ring_desc));
rtl8139.c:            s->IntrStatus |= RxOverflow;
rtl8139.c:            ++s->RxMissed;
rtl8139.c:            ++s->tally_counters.RxERR;
rtl8139.c:            ++s->tally_counters.MissPkt;
rtl8139.c:            s->IntrStatus |= RxOverflow;
rtl8139.c:            ++s->RxMissed;
rtl8139.c:            ++s->tally_counters.RxERR;
rtl8139.c:            ++s->tally_counters.MissPkt;
rtl8139.c:        if (s->CpCmd & CPlusRxChkSum)
rtl8139.c:/* physical-matching packet flag */
rtl8139.c:        ++s->tally_counters.RxOk;
rtl8139.c:            s->currCPlusRxDesc = 0;
rtl8139.c:            ++s->currCPlusRxDesc;
rtl8139.c:        DEBUG_PRINT(("RTL8139: done C+ Rx mode ----------------\n"));
rtl8139.c:        int avail = MOD2(s->RxBufferSize + s->RxBufPtr - s->RxBufAddr, s->RxBufferSize);
rtl8139.c:                   s->RxBufferSize, s->RxBufAddr, s->RxBufPtr, avail, size + 8));
rtl8139.c:            s->IntrStatus |= RxOverflow;
rtl8139.c:            ++s->RxMissed;
rtl8139.c:        s->RxBufAddr = MOD2((s->RxBufAddr + 3) & ~0x3, s->RxBufferSize);
rtl8139.c:               s->RxBufferSize, s->RxBufAddr, s->RxBufPtr));
rtl8139.c:    s->IntrStatus |= RxOK;
rtl8139.c:    s->RxBufferSize = bufferSize;
rtl8139.c:    s->RxBufPtr  = 0;
rtl8139.c:    s->RxBufAddr = 0;
rtl8139.c:    memcpy(s->phys, s->conf.macaddr.a, 6);
rtl8139.c:    s->IntrStatus = 0;
rtl8139.c:    s->IntrMask = 0;
rtl8139.c:    s->eeprom.contents[0] = 0x8129;
rtl8139.c:    s->eeprom.contents[1] = PCI_VENDOR_ID_REALTEK;
rtl8139.c:    s->eeprom.contents[2] = PCI_DEVICE_ID_REALTEK_8139;
rtl8139.c:    s->eeprom.contents[7] = s->conf.macaddr.a[0] | s->conf.macaddr.a[1] << 8;
rtl8139.c:    s->eeprom.contents[8] = s->conf.macaddr.a[2] | s->conf.macaddr.a[3] << 8;
rtl8139.c:    s->eeprom.contents[9] = s->conf.macaddr.a[4] | s->conf.macaddr.a[5] << 8;
rtl8139.c:        s->TxStatus[i] = TxHostOwns;
rtl8139.c:    s->currTxDesc = 0;
rtl8139.c:    s->currCPlusRxDesc = 0;
rtl8139.c:    s->currCPlusTxDesc = 0;
rtl8139.c:    s->RxRingAddrLO = 0;
rtl8139.c:    s->RxRingAddrHI = 0;
rtl8139.c:    s->RxBuf = 0;
rtl8139.c:    s->TxConfig = 0;
rtl8139.c://    s->TxConfig |= HW_REVID(1, 0, 0, 0, 0, 0, 0); // RTL-8139  HasHltClk
rtl8139.c:    s->clock_enabled = 0;
rtl8139.c:    s->TxConfig |= HW_REVID(1, 1, 1, 0, 1, 1, 0); // RTL-8139C+ HasLWake
rtl8139.c:    s->clock_enabled = 1;
rtl8139.c:    s->bChipCmdState = CmdReset; /* RxBufEmpty bit is calculated on read from ChipCmd */;
rtl8139.c:    s->Config0 = 0x0; /* No boot ROM */
rtl8139.c:    s->Config1 = 0xC; /* IO mapped and MEM mapped registers available */
rtl8139.c:    s->Config3 = 0x1; /* fast back-to-back compatible */
rtl8139.c:    s->Config5 = 0x0;
rtl8139.c:    s->CSCR = CSCR_F_LINK_100 | CSCR_HEART_BIT | CSCR_LD;
rtl8139.c:    s->CpCmd   = 0x0; /* reset C+ mode */
rtl8139.c:    s->cplus_enabled = 0;
rtl8139.c://    s->BasicModeCtrl = 0x3100; // 100Mbps, full duplex, autonegotiation
rtl8139.c://    s->BasicModeCtrl = 0x2100; // 100Mbps, full duplex
rtl8139.c:    s->BasicModeCtrl = 0x1000; // autonegotiation
rtl8139.c:    s->BasicModeStatus  = 0x7809;
rtl8139.c:    //s->BasicModeStatus |= 0x0040; /* UTP medium */
rtl8139.c:    s->BasicModeStatus |= 0x0020; /* autonegotiation completed */
rtl8139.c:    s->BasicModeStatus |= 0x0004; /* link is up */
rtl8139.c:    s->NWayAdvert    = 0x05e1; /* all modes, full duplex */
rtl8139.c:    s->NWayLPAR      = 0x05e1; /* all modes, full duplex */
rtl8139.c:    s->NWayExpansion = 0x0001; /* autonegotiation supported */
rtl8139.c:    s->TCTR = 0;
rtl8139.c:    s->TimerInt = 0;
rtl8139.c:    s->TCTR_base = 0;
rtl8139.c:    RTL8139TallyCounters_clear(&s->tally_counters);
rtl8139.c:    counters->TxOk = 0;
rtl8139.c:    counters->RxOk = 0;
rtl8139.c:    counters->TxERR = 0;
rtl8139.c:    counters->RxERR = 0;
rtl8139.c:    counters->MissPkt = 0;
rtl8139.c:    counters->FAE = 0;
rtl8139.c:    counters->Tx1Col = 0;
rtl8139.c:    counters->TxMCol = 0;
rtl8139.c:    counters->RxOkPhy = 0;
rtl8139.c:    counters->RxOkBrd = 0;
rtl8139.c:    counters->RxOkMul = 0;
rtl8139.c:    counters->TxAbt = 0;
rtl8139.c:    counters->TxUndrn = 0;
rtl8139.c:    val64 = cpu_to_le64(tally_counters->TxOk);
rtl8139.c:    val64 = cpu_to_le64(tally_counters->RxOk);
rtl8139.c:    val64 = cpu_to_le64(tally_counters->TxERR);
rtl8139.c:    val32 = cpu_to_le32(tally_counters->RxERR);
rtl8139.c:    val16 = cpu_to_le16(tally_counters->MissPkt);
rtl8139.c:    val16 = cpu_to_le16(tally_counters->FAE);
rtl8139.c:    val32 = cpu_to_le32(tally_counters->Tx1Col);
rtl8139.c:    val32 = cpu_to_le32(tally_counters->TxMCol);
rtl8139.c:    val64 = cpu_to_le64(tally_counters->RxOkPhy);
rtl8139.c:    val64 = cpu_to_le64(tally_counters->RxOkBrd);
rtl8139.c:    val32 = cpu_to_le32(tally_counters->RxOkMul);
rtl8139.c:    val16 = cpu_to_le16(tally_counters->TxAbt);
rtl8139.c:    val16 = cpu_to_le16(tally_counters->TxUndrn);
rtl8139.c:        rtl8139_reset(&s->dev.qdev);
rtl8139.c:        s->currCPlusRxDesc = 0;
rtl8139.c:        s->currCPlusTxDesc = 0;
rtl8139.c:    val = SET_MASKED(val, 0xe3, s->bChipCmdState);
rtl8139.c:    s->bChipCmdState = val;
rtl8139.c:    int unread = MOD2(s->RxBufferSize + s->RxBufAddr - s->RxBufPtr, s->RxBufferSize);
rtl8139.c:    uint32_t ret = s->bChipCmdState;
rtl8139.c:    s->cplus_enabled = 1;
rtl8139.c:    val = SET_MASKED(val, 0xff84, s->CpCmd);
rtl8139.c:    s->CpCmd = val;
rtl8139.c:    uint32_t ret = s->CpCmd;
rtl8139.c:    if (s->Cfg9346 & Cfg9346_Unlock)
rtl8139.c:    DEBUG_PRINT(("RTL8139: Configuration registers are write-protected\n"));
rtl8139.c:        /* Speed setting and autonegotiation enable bits are read-only */
rtl8139.c:        /* Duplex mode setting is read-only */
rtl8139.c:    val = SET_MASKED(val, mask, s->BasicModeCtrl);
rtl8139.c:    s->BasicModeCtrl = val;
rtl8139.c:    uint32_t ret = s->BasicModeCtrl;
rtl8139.c:    val = SET_MASKED(val, 0xff3f, s->BasicModeStatus);
rtl8139.c:    s->BasicModeStatus = val;
rtl8139.c:    uint32_t ret = s->BasicModeStatus;
rtl8139.c:    val = SET_MASKED(val, 0x31, s->Cfg9346);
rtl8139.c:        rtl8139_reset(&s->dev.qdev);
rtl8139.c:    s->Cfg9346 = val;
rtl8139.c:    uint32_t ret = s->Cfg9346;
rtl8139.c:    val = SET_MASKED(val, 0xf8, s->Config0);
rtl8139.c:    s->Config0 = val;
rtl8139.c:    uint32_t ret = s->Config0;
rtl8139.c:    val = SET_MASKED(val, 0xC, s->Config1);
rtl8139.c:    s->Config1 = val;
rtl8139.c:    uint32_t ret = s->Config1;
rtl8139.c:    val = SET_MASKED(val, 0x8F, s->Config3);
rtl8139.c:    s->Config3 = val;
rtl8139.c:    uint32_t ret = s->Config3;
rtl8139.c:    val = SET_MASKED(val, 0x0a, s->Config4);
rtl8139.c:    s->Config4 = val;
rtl8139.c:    uint32_t ret = s->Config4;
rtl8139.c:    val = SET_MASKED(val, 0x80, s->Config5);
rtl8139.c:    s->Config5 = val;
rtl8139.c:    uint32_t ret = s->Config5;
rtl8139.c:    val = SET_MASKED(val, TxVersionMask | 0x8070f80f, s->TxConfig);
rtl8139.c:    s->TxConfig = val;
rtl8139.c:    uint32_t tc = s->TxConfig;
rtl8139.c:    uint32_t ret = s->TxConfig;
rtl8139.c:    val = SET_MASKED(val, 0xf0fc0040, s->RxConfig);
rtl8139.c:    s->RxConfig = val;
rtl8139.c:    rtl8139_reset_rxring(s, 8192 << ((s->RxConfig >> 11) & 0x3));
rtl8139.c:    DEBUG_PRINT(("RTL8139: RxConfig write reset buffer size to %d\n", s->RxBufferSize));
rtl8139.c:    uint32_t ret = s->RxConfig;
rtl8139.c:    if (TxLoopBack == (s->TxConfig & TxLoopBack))
rtl8139.c:        rtl8139_do_receive(&s->nic->nc, buf, size, do_interrupt);
rtl8139.c:        qemu_send_packet(&s->nic->nc, buf, size);
rtl8139.c:    if (s->TxStatus[descriptor] & TxHostOwns)
rtl8139.c:                     descriptor, s->TxStatus[descriptor]));
rtl8139.c:    int txsize = s->TxStatus[descriptor] & 0x1fff;
rtl8139.c:                 txsize, s->TxAddr[descriptor]));
rtl8139.c:    cpu_physical_memory_read(s->TxAddr[descriptor], txbuffer, txsize);
rtl8139.c:    s->TxStatus[descriptor] |= TxHostOwns;
rtl8139.c:    s->TxStatus[descriptor] |= TxStatOK;
rtl8139.c:    s->IntrStatus |= TxOK;
rtl8139.c:#define IP_HEADER_VERSION(ip) ((ip->ip_ver_len >> 4)&0xf)
rtl8139.c:#define IP_HEADER_LENGTH(ip) (((ip->ip_ver_len)&0xf) << 2)
rtl8139.c:#define TCP_HEADER_DATA_OFFSET(tcp) (((be16_to_cpu(tcp->th_offset_flags) >> 12)&0xf) << 2)
rtl8139.c:#define TCP_HEADER_FLAGS(tcp) TCP_FLAGS_ONLY(be16_to_cpu(tcp->th_offset_flags))
rtl8139.c:#define TCP_HEADER_CLEAR_FLAGS(tcp, off) ((tcp)->th_offset_flags &= cpu_to_be16(~TCP_FLAGS_ONLY(off)))
rtl8139.c:    for (; len > 1; data+=2, len-=2)
rtl8139.c:    int descriptor = s->currCPlusTxDesc;
rtl8139.c:        rtl8139_addr64(s->TxAddr[0], s->TxAddr[1]);
rtl8139.c:           descriptor, s->TxAddr[1], s->TxAddr[0], cplus_tx_ring_desc));
rtl8139.c:#define CP_TC_LGSEN_MSS_MASK ((1 << 12) - 1)
rtl8139.c:#define CP_TX_BUFFER_SIZE_MASK (CP_TX_BUFFER_SIZE - 1)
rtl8139.c:#define CP_TX_VLAN_TAG_MASK ((1<<16) - 1)
rtl8139.c:/* out-of-window collision flag */
rtl8139.c:        s->cplus_txbuffer_offset = 0;
rtl8139.c:    if (!s->cplus_txbuffer)
rtl8139.c:        s->cplus_txbuffer_len = CP_TX_BUFFER_SIZE;
rtl8139.c:        s->cplus_txbuffer = qemu_malloc(s->cplus_txbuffer_len);
rtl8139.c:        s->cplus_txbuffer_offset = 0;
rtl8139.c:        DEBUG_PRINT(("RTL8139: +++ C+ mode transmission buffer allocated space %d\n", s->cplus_txbuffer_len));
rtl8139.c:    while (s->cplus_txbuffer && s->cplus_txbuffer_offset + txsize >= s->cplus_txbuffer_len)
rtl8139.c:        s->cplus_txbuffer_len += CP_TX_BUFFER_SIZE;
rtl8139.c:        s->cplus_txbuffer = qemu_realloc(s->cplus_txbuffer, s->cplus_txbuffer_len);
rtl8139.c:        DEBUG_PRINT(("RTL8139: +++ C+ mode transmission buffer space changed to %d\n", s->cplus_txbuffer_len));
rtl8139.c:    if (!s->cplus_txbuffer)
rtl8139.c:        DEBUG_PRINT(("RTL8139: +++ C+ mode transmiter failed to reallocate %d bytes\n", s->cplus_txbuffer_len));
rtl8139.c:        ++s->tally_counters.TxERR;
rtl8139.c:        ++s->tally_counters.TxAbt;
rtl8139.c:                 txsize, (uint64_t)tx_addr, s->cplus_txbuffer_offset));
rtl8139.c:    cpu_physical_memory_read(tx_addr, s->cplus_txbuffer + s->cplus_txbuffer_offset, txsize);
rtl8139.c:    s->cplus_txbuffer_offset += txsize;
rtl8139.c:        s->currCPlusTxDesc = 0;
rtl8139.c:        ++s->currCPlusTxDesc;
rtl8139.c:        if (s->currCPlusTxDesc >= 64)
rtl8139.c:            s->currCPlusTxDesc = 0;
rtl8139.c:        uint8_t *saved_buffer  = s->cplus_txbuffer;
rtl8139.c:        int      saved_size    = s->cplus_txbuffer_offset;
rtl8139.c:        int      saved_buffer_len = s->cplus_txbuffer_len;
rtl8139.c:        s->cplus_txbuffer = NULL;
rtl8139.c:        s->cplus_txbuffer_offset = 0;
rtl8139.c:        s->cplus_txbuffer_len = 0;
rtl8139.c:                eth_payload_len  = saved_size   - ETH_HLEN;
rtl8139.c:                    ip_protocol = ip->ip_p;
rtl8139.c:                    ip_data_len = be16_to_cpu(ip->ip_len) - hlen;
rtl8139.c:                        ip->ip_sum = 0;
rtl8139.c:                        ip->ip_sum = ip_checksum(ip, hlen);
rtl8139.c:                        DEBUG_PRINT(("RTL8139: +++ C+ mode IP header len=%d checksum=%04x\n", hlen, ip->ip_sum));
rtl8139.c:                                 ETH_MTU, ip_data_len, saved_size - ETH_HLEN, large_send_mss));
rtl8139.c:                    uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;
rtl8139.c:                    //                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;
rtl8139.c:                    int tcp_data_len = ip_data_len - tcp_hlen;
rtl8139.c:                    int tcp_chunk_size = ETH_MTU - hlen - tcp_hlen;
rtl8139.c:                            chunk_size = tcp_data_len - tcp_send_offset;
rtl8139.c:                        DEBUG_PRINT(("RTL8139: +++ C+ mode TSO TCP seqno %08x\n", be32_to_cpu(p_tcp_hdr->th_seq)));
rtl8139.c:                        p_tcpip_hdr->zeros      = 0;
rtl8139.c:                        p_tcpip_hdr->ip_proto   = IP_PROTO_TCP;
rtl8139.c:                        p_tcpip_hdr->ip_payload = cpu_to_be16(tcp_hlen + chunk_size);
rtl8139.c:                        p_tcp_hdr->th_sum = 0;
rtl8139.c:                        p_tcp_hdr->th_sum = tcp_checksum;
rtl8139.c:                        ip->ip_len = cpu_to_be16(hlen + tcp_hlen + chunk_size);
rtl8139.c:                        ip->ip_id = cpu_to_be16(tcp_send_offset/tcp_chunk_size + be16_to_cpu(ip->ip_id));
rtl8139.c:                        ip->ip_sum = 0;
rtl8139.c:                        ip->ip_sum = ip_checksum(eth_payload_data, hlen);
rtl8139.c:                        DEBUG_PRINT(("RTL8139: +++ C+ mode TSO IP header len=%d checksum=%04x\n", hlen, ip->ip_sum));
rtl8139.c:                        p_tcp_hdr->th_seq = cpu_to_be32(chunk_size + be32_to_cpu(p_tcp_hdr->th_seq));
rtl8139.c:                    uint8_t *data_to_checksum     = eth_payload_data + hlen - 12;
rtl8139.c:                    //                    size_t   data_to_checksum_len = eth_payload_len  - hlen + 12;
rtl8139.c:                        p_tcpip_hdr->zeros      = 0;
rtl8139.c:                        p_tcpip_hdr->ip_proto   = IP_PROTO_TCP;
rtl8139.c:                        p_tcpip_hdr->ip_payload = cpu_to_be16(ip_data_len);
rtl8139.c:                        p_tcp_hdr->th_sum = 0;
rtl8139.c:                        p_tcp_hdr->th_sum = tcp_checksum;
rtl8139.c:                        p_udpip_hdr->zeros      = 0;
rtl8139.c:                        p_udpip_hdr->ip_proto   = IP_PROTO_UDP;
rtl8139.c:                        p_udpip_hdr->ip_payload = cpu_to_be16(ip_data_len);
rtl8139.c:                        p_udp_hdr->uh_sum = 0;
rtl8139.c:                        p_udp_hdr->uh_sum = udp_checksum;
rtl8139.c:        ++s->tally_counters.TxOk;
rtl8139.c:        if (!s->cplus_txbuffer)
rtl8139.c:            s->cplus_txbuffer        = saved_buffer;
rtl8139.c:            s->cplus_txbuffer_len    = saved_buffer_len;
rtl8139.c:            s->cplus_txbuffer_offset = 0;
rtl8139.c:                     s->currCPlusTxDesc));
rtl8139.c:        s->IntrStatus |= TxOK;
rtl8139.c:    int descriptor = s->currTxDesc, txcount = 0;
rtl8139.c:        ++s->currTxDesc;
rtl8139.c:        s->currTxDesc %= 4;
rtl8139.c:        DEBUG_PRINT(("RTL8139: transmitter queue stalled, current TxDesc = %d\n", s->currTxDesc));
rtl8139.c:    if (s->cplus_enabled)
rtl8139.c:        s->TxStatus[descriptor] = val;
rtl8139.c:            target_phys_addr_t tc_addr = rtl8139_addr64(s->TxStatus[0] & ~0x3f, s->TxStatus[1]);
rtl8139.c:            RTL8139TallyCounters_physical_memory_write( tc_addr, &s->tally_counters);
rtl8139.c:            s->TxStatus[0] &= ~0x8;
rtl8139.c:    val = SET_MASKED(val, 0x00c00000, s->TxStatus[descriptor]);
rtl8139.c:    s->TxStatus[descriptor] = val;
rtl8139.c:    uint32_t ret = s->TxStatus[txRegOffset/4];
rtl8139.c:    ret = ((s->TxStatus[3] & TxStatOK  )?TSAD_TOK3:0)
rtl8139.c:         |((s->TxStatus[2] & TxStatOK  )?TSAD_TOK2:0)
rtl8139.c:         |((s->TxStatus[1] & TxStatOK  )?TSAD_TOK1:0)
rtl8139.c:         |((s->TxStatus[0] & TxStatOK  )?TSAD_TOK0:0)
rtl8139.c:         |((s->TxStatus[3] & TxUnderrun)?TSAD_TUN3:0)
rtl8139.c:         |((s->TxStatus[2] & TxUnderrun)?TSAD_TUN2:0)
rtl8139.c:         |((s->TxStatus[1] & TxUnderrun)?TSAD_TUN1:0)
rtl8139.c:         |((s->TxStatus[0] & TxUnderrun)?TSAD_TUN0:0)
rtl8139.c:         |((s->TxStatus[3] & TxAborted )?TSAD_TABT3:0)
rtl8139.c:         |((s->TxStatus[2] & TxAborted )?TSAD_TABT2:0)
rtl8139.c:         |((s->TxStatus[1] & TxAborted )?TSAD_TABT1:0)
rtl8139.c:         |((s->TxStatus[0] & TxAborted )?TSAD_TABT0:0)
rtl8139.c:         |((s->TxStatus[3] & TxHostOwns )?TSAD_OWN3:0)
rtl8139.c:         |((s->TxStatus[2] & TxHostOwns )?TSAD_OWN2:0)
rtl8139.c:         |((s->TxStatus[1] & TxHostOwns )?TSAD_OWN1:0)
rtl8139.c:         |((s->TxStatus[0] & TxHostOwns )?TSAD_OWN0:0) ;
rtl8139.c:    uint16_t ret = s->CSCR;
rtl8139.c:    s->TxAddr[txAddrOffset/4] = val;
rtl8139.c:    uint32_t ret = s->TxAddr[txAddrOffset/4];
rtl8139.c:    s->RxBufPtr = MOD2(val + 0x10, s->RxBufferSize);
rtl8139.c:           s->RxBufferSize, s->RxBufAddr, s->RxBufPtr));
rtl8139.c:    uint32_t ret = s->RxBufPtr - 0x10;
rtl8139.c:    uint32_t ret = s->RxBufAddr;
rtl8139.c:    s->RxBuf = val;
rtl8139.c:    uint32_t ret = s->RxBuf;
rtl8139.c:    val = SET_MASKED(val, 0x1e00, s->IntrMask);
rtl8139.c:    s->IntrMask = val;
rtl8139.c:    uint32_t ret = s->IntrMask;
rtl8139.c:    uint16_t newStatus = s->IntrStatus & ~val;
rtl8139.c:    newStatus = SET_MASKED(newStatus, 0x1e00, s->IntrStatus);
rtl8139.c:    s->IntrStatus = 0;
rtl8139.c:    s->IntrStatus = newStatus;
rtl8139.c:    uint32_t ret = s->IntrStatus;
rtl8139.c:    s->IntrStatus = 0;
rtl8139.c:    val = SET_MASKED(val, 0xf000, s->MultiIntr);
rtl8139.c:    s->MultiIntr = val;
rtl8139.c:    uint32_t ret = s->MultiIntr;
rtl8139.c:            s->phys[addr - MAC0] = val;
rtl8139.c:            s->mult[addr - MAR0] = val;
rtl8139.c:        case TxConfig: /* windows driver sometimes writes using byte-lenth call */
rtl8139.c:                s->clock_enabled = 1;
rtl8139.c:                s->clock_enabled = 0;
rtl8139.c:            s->TxThresh = val;
rtl8139.c:            s->NWayAdvert = val;
rtl8139.c:            s->NWayExpansion = val;
rtl8139.c:            s->RxMissed = 0;
rtl8139.c:        case TxStatus0 ... TxStatus0+4*4-1:
rtl8139.c:            rtl8139_TxStatus_write(s, addr-TxStatus0, val);
rtl8139.c:        case TxAddr0 ... TxAddr0+4*4-1:
rtl8139.c:            rtl8139_TxAddr_write(s, addr-TxAddr0, val);
rtl8139.c:            s->RxRingAddrLO = val;
rtl8139.c:            s->RxRingAddrHI = val;
rtl8139.c:            s->TCTR = 0;
rtl8139.c:            s->TCTR_base = qemu_get_clock(vm_clock);
rtl8139.c:            s->TimerInt = val;
rtl8139.c:            ret = s->phys[addr - MAC0];
rtl8139.c:            ret = s->mult[addr - MAR0];
rtl8139.c:            ret = s->clock_enabled;
rtl8139.c:            ret = s->TxThresh;
rtl8139.c:            ret = s->TxConfig >> 24;
rtl8139.c:            ret = s->NWayAdvert;
rtl8139.c:            ret = s->NWayLPAR;
rtl8139.c:            ret = s->NWayExpansion;
rtl8139.c:            ret = s->RxMissed;
rtl8139.c:        case TxStatus0 ... TxStatus0+4*4-1:
rtl8139.c:            ret = rtl8139_TxStatus_read(s, addr-TxStatus0);
rtl8139.c:        case TxAddr0 ... TxAddr0+4*4-1:
rtl8139.c:            ret = rtl8139_TxAddr_read(s, addr-TxAddr0);
rtl8139.c:            ret = s->RxRingAddrLO;
rtl8139.c:            ret = s->RxRingAddrHI;
rtl8139.c:            ret = s->TCTR;
rtl8139.c:            ret = s->TimerInt;
rtl8139.c:        s->cplus_enabled = s->CpCmd != 0;
rtl8139.c:    cpu_register_physical_memory(addr + 0, 0x100, s->rtl8139_mmio_io_addr);
rtl8139.c:    if (!s->clock_enabled)
rtl8139.c:    curr_tick = muldiv64(curr_time - s->TCTR_base, PCI_FREQUENCY,
rtl8139.c:    if (s->TimerInt && curr_tick >= s->TimerInt)
rtl8139.c:        if (s->TCTR < s->TimerInt || curr_tick < s->TCTR)
rtl8139.c:    s->TCTR = curr_tick;
rtl8139.c://  DEBUG_PRINT(("RTL8139: >>> timer: tick=%08u\n", s->TCTR));
rtl8139.c:        DEBUG_PRINT(("RTL8139: >>> timer: timeout tick=%08u\n", s->TCTR));
rtl8139.c:        s->IntrStatus |= PCSTimeout;
rtl8139.c:    qemu_mod_timer(s->timer,
rtl8139.c:    RTL8139State *s = DO_UPCAST(NICState, nc, nc)->opaque;
rtl8139.c:    s->nic = NULL;
rtl8139.c:    cpu_unregister_io_memory(s->rtl8139_mmio_io_addr);
rtl8139.c:    if (s->cplus_txbuffer) {
rtl8139.c:        qemu_free(s->cplus_txbuffer);
rtl8139.c:        s->cplus_txbuffer = NULL;
rtl8139.c:    qemu_del_timer(s->timer);
rtl8139.c:    qemu_free_timer(s->timer);
rtl8139.c:    qemu_del_vlan_client(&s->nic->nc);
rtl8139.c:    pci_conf = s->dev.config;
rtl8139.c:    /* I/O handler for memory-mapped I/O */
rtl8139.c:    s->rtl8139_mmio_io_addr =
rtl8139.c:    pci_register_bar(&s->dev, 0, 0x100,
rtl8139.c:    pci_register_bar(&s->dev, 1, 0x100,
rtl8139.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
rtl8139.c:    s->nic = qemu_new_nic(&net_rtl8139_info, &s->conf,
rtl8139.c:                          dev->qdev.info->name, dev->qdev.id, s);
rtl8139.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
rtl8139.c:    s->cplus_txbuffer = NULL;
rtl8139.c:    s->cplus_txbuffer_len = 0;
rtl8139.c:    s->cplus_txbuffer_offset = 0;
rtl8139.c:    s->timer = qemu_new_timer(vm_clock, rtl8139_timer, s);
rtl8139.c:    qemu_mod_timer(s->timer,
rtl8139.c:    .romfile    = "pxe-rtl8139.bin",
s390-virtio-bus.c:#include "hw/virtio-console.h"
s390-virtio-bus.c:#include "hw/s390-virtio-bus.h"
s390-virtio-bus.c:    .name       = "s390-virtio",
s390-virtio-bus.c:    dev = qdev_create(NULL, "s390-virtio-bridge");
s390-virtio-bus.c:    _bus = qbus_create(&s390_virtio_bus_info, dev, "s390-virtio");
s390-virtio-bus.c:    bus->dev_page = *ram_size;
s390-virtio-bus.c:    bus->dev_offs = bus->dev_page;
s390-virtio-bus.c:    bus->next_ring = bus->dev_page + TARGET_PAGE_SIZE;
s390-virtio-bus.c:    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
s390-virtio-bus.c:    dev->vdev = vdev;
s390-virtio-bus.c:    dev->dev_offs = bus->dev_offs;
s390-virtio-bus.c:    dev->feat_len = sizeof(uint32_t); /* always keep 32 bits features */
s390-virtio-bus.c:    dev_len += dev->feat_len * 2;
s390-virtio-bus.c:    dev_len += vdev->config_len;
s390-virtio-bus.c:    bus->dev_offs += dev_len;
s390-virtio-bus.c:    vdev = virtio_net_init((DeviceState *)dev, &dev->nic);
s390-virtio-bus.c:        return -1;
s390-virtio-bus.c:    vdev = virtio_blk_init((DeviceState *)dev, dev->dinfo);
s390-virtio-bus.c:        return -1;
s390-virtio-bus.c:    bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
s390-virtio-bus.c:        return -1;
s390-virtio-bus.c:        bus->console = dev;
s390-virtio-bus.c:    token_off = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +
s390-virtio-bus.c:    VirtIODevice *vdev = dev->vdev;
s390-virtio-bus.c:    ram_addr_t r = bus->next_ring;
s390-virtio-bus.c:    bus->next_ring += VIRTIO_RING_LEN;
s390-virtio-bus.c:    VirtIOS390Bus *bus = DO_UPCAST(VirtIOS390Bus, bus, dev->qdev.parent_bus);
s390-virtio-bus.c:    virtio_reset(dev->vdev);
s390-virtio-bus.c:    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_TYPE, dev->vdev->device_id);
s390-virtio-bus.c:    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, s390_virtio_device_num_vq(dev));
s390-virtio-bus.c:    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_FEATURE_LEN, dev->feat_len);
s390-virtio-bus.c:    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG_LEN, dev->vdev->config_len);
s390-virtio-bus.c:    stb_phys(dev->dev_offs + VIRTIO_DEV_OFFS_NUM_VQ, num_vq);
s390-virtio-bus.c:        ram_addr_t vq = (dev->dev_offs + VIRTIO_DEV_OFFS_CONFIG) +
s390-virtio-bus.c:        virtio_queue_set_addr(dev->vdev, i, vring);
s390-virtio-bus.c:        virtio_queue_set_vector(dev->vdev, i, i);
s390-virtio-bus.c:        stw_phys(vq + VIRTIO_VQCONFIG_OFFS_NUM, virtio_queue_get_num(dev->vdev, i));
s390-virtio-bus.c:    cur_offs = dev->dev_offs;
s390-virtio-bus.c:    if (dev->vdev->get_features) {
s390-virtio-bus.c:        stl_phys(cur_offs, dev->vdev->get_features(dev->vdev));
s390-virtio-bus.c:    dev->feat_offs = cur_offs + dev->feat_len;
s390-virtio-bus.c:    cur_offs += dev->feat_len * 2;
s390-virtio-bus.c:    if (dev->vdev->get_config) {
s390-virtio-bus.c:        dev->vdev->get_config(dev->vdev, dev->vdev->config);
s390-virtio-bus.c:    cpu_physical_memory_rw(cur_offs, dev->vdev->config, dev->vdev->config_len, 1);
s390-virtio-bus.c:    cur_offs += dev->vdev->config_len;
s390-virtio-bus.c:    VirtIODevice *vdev = dev->vdev;
s390-virtio-bus.c:    vdev->status = ldub_phys(dev->dev_offs + VIRTIO_DEV_OFFS_STATUS);
s390-virtio-bus.c:    features = ldl_phys(dev->feat_offs);
s390-virtio-bus.c:    if (vdev->set_features) {
s390-virtio-bus.c:        vdev->set_features(vdev, features);
s390-virtio-bus.c:    vdev->features = features;
s390-virtio-bus.c:    return bus->console;
s390-virtio-bus.c:    QLIST_FOREACH(dev, &bus->bus.children, sibling) {
s390-virtio-bus.c:            if (!virtio_queue_get_addr(_dev->vdev, i))
s390-virtio-bus.c:            if (virtio_queue_get_addr(_dev->vdev, i) == mem) {
s390-virtio-bus.c:    QLIST_FOREACH(dev, &bus->bus.children, sibling) {
s390-virtio-bus.c:        if (_dev->dev_offs == mem) {
s390-virtio-bus.c:    .qdev.name = "virtio-net-s390",
s390-virtio-bus.c:    .qdev.name = "virtio-blk-s390",
s390-virtio-bus.c:    .qdev.name = "virtio-console-s390",
s390-virtio-bus.c:    return _info->init(_dev);
s390-virtio-bus.c:    info->qdev.init = s390_virtio_busdev_init;
s390-virtio-bus.c:    info->qdev.bus_info = &s390_virtio_bus_info;
s390-virtio-bus.c:    assert(info->qdev.size >= sizeof(VirtIOS390Device));
s390-virtio-bus.c:    qdev_register(&info->qdev);
s390-virtio-bus.c:    .qdev.name  = "s390-virtio-bridge",
s390-virtio.c:#include "hw/virtio-console.h"
s390-virtio.c:#include "hw/s390-virtio-bus.h"
s390-virtio.c:    target_ulong mem = env->regs[2];
s390-virtio.c:    dprintf("KVM hypercall: %ld\n", env->regs[1]);
s390-virtio.c:    switch (env->regs[1]) {
s390-virtio.c:                virtio_queue_notify(dev->vdev, i);
s390-virtio.c:                r = -EINVAL;
s390-virtio.c:        /* virtio_reset(dev->vdev); */
s390-virtio.c:            r = -EINVAL;
s390-virtio.c:        r = -EINVAL;
s390-virtio.c:    env->regs[2] = r;
s390-virtio.c:        tmp_env->halted = 1;
s390-virtio.c:        tmp_env->exception_index = EXCP_HLT;
s390-virtio.c:    env->halted = 0;
s390-virtio.c:    env->exception_index = 0;
s390-virtio.c:        env->psw.addr = KERN_IMAGE_START;
s390-virtio.c:        env->psw.mask = 0x0000000180000000ULL;
s390-virtio.c:            qdev_init_nofail(qdev_create((BusState *)s390_bus, "virtio-console-s390"));
s390-virtio.c:        if (!nd->model) {
s390-virtio.c:            nd->model = qemu_strdup("virtio");
s390-virtio.c:        if (strcmp(nd->model, "virtio")) {
s390-virtio.c:        dev = qdev_create((BusState *)s390_bus, "virtio-net-s390");
s390-virtio.c:        dev = qdev_create((BusState *)s390_bus, "virtio-blk-s390");
s390-virtio.c:    .name = "s390-virtio",
sb16.c: * Copyright (c) 2003-2005 Vassili Karpov (malc)
sb16.c:#include "qemu-timer.h"
sb16.c:#include "host-utils.h"
sb16.c:        return -1;
sb16.c:            dsp->fmt_stereo ? "Stereo" : "Mono",
sb16.c:            dsp->fmt_signed ? "Signed" : "Unsigned",
sb16.c:            dsp->fmt_bits,
sb16.c:            dsp->dma_auto ? "Auto" : "Single",
sb16.c:            dsp->block_size,
sb16.c:            dsp->freq,
sb16.c:            dsp->time_const,
sb16.c:            dsp->speaker);
sb16.c:    s->speaker = on;
sb16.c:    /* AUD_enable (s->voice, on); */
sb16.c:    int dma = s->use_hdma ? s->hdma : s->dma;
sb16.c:    s->dma_running = hold;
sb16.c:    ldebug ("hold %d high %d dma %d\n", hold, s->use_hdma, dma);
sb16.c:        AUD_set_active_out (s->voice, 1);
sb16.c:        AUD_set_active_out (s->voice, 0);
sb16.c:    s->can_write = 1;
sb16.c:    qemu_irq_raise (s->pic);
sb16.c:    if (s->freq > 0) {
sb16.c:        s->audio_free = 0;
sb16.c:        as.freq = s->freq;
sb16.c:        as.nchannels = 1 << s->fmt_stereo;
sb16.c:        as.fmt = s->fmt;
sb16.c:        s->voice = AUD_open_out (
sb16.c:            &s->card,
sb16.c:            s->voice,
sb16.c:    s->fmt = AUD_FMT_U8;
sb16.c:    s->use_hdma = 0;
sb16.c:    s->fmt_bits = 8;
sb16.c:    s->fmt_signed = 0;
sb16.c:    s->fmt_stereo = (s->mixer_regs[0x0e] & 2) != 0;
sb16.c:    if (-1 == s->time_const) {
sb16.c:        if (s->freq <= 0)
sb16.c:            s->freq = 11025;
sb16.c:        int tmp = (256 - s->time_const);
sb16.c:        s->freq = (1000000 + (tmp / 2)) / tmp;
sb16.c:    if (dma_len != -1) {
sb16.c:        s->block_size = dma_len << s->fmt_stereo;
sb16.c:        s->block_size &= ~s->fmt_stereo;
sb16.c:    s->freq >>= s->fmt_stereo;
sb16.c:    s->left_till_irq = s->block_size;
sb16.c:    s->bytes_per_second = (s->freq << s->fmt_stereo);
sb16.c:    /* s->highspeed = (mask & DMA8_HIGH) != 0; */
sb16.c:    s->dma_auto = (mask & DMA8_AUTO) != 0;
sb16.c:    s->align = (1 << s->fmt_stereo) - 1;
sb16.c:    if (s->block_size & s->align) {
sb16.c:               s->block_size, s->align + 1);
sb16.c:            s->freq, s->fmt_stereo, s->fmt_signed, s->fmt_bits,
sb16.c:            s->block_size, s->dma_auto, s->fifo, s->highspeed);
sb16.c:    s->use_hdma = cmd < 0xc0;
sb16.c:    s->fifo = (cmd >> 1) & 1;
sb16.c:    s->dma_auto = (cmd >> 2) & 1;
sb16.c:    s->fmt_signed = (d0 >> 4) & 1;
sb16.c:    s->fmt_stereo = (d0 >> 5) & 1;
sb16.c:        s->fmt_bits = 16;
sb16.c:        s->fmt_bits = 8;
sb16.c:    if (-1 != s->time_const) {
sb16.c:        int tmp = 256 - s->time_const;
sb16.c:        s->freq = (1000000 + (tmp / 2)) / tmp;
sb16.c:        /* s->freq = 1000000 / ((255 - s->time_const) << s->fmt_stereo); */
sb16.c:        s->freq = 1000000 / ((255 - s->time_const));
sb16.c:        s->time_const = -1;
sb16.c:    s->block_size = dma_len + 1;
sb16.c:    s->block_size <<= (s->fmt_bits == 16);
sb16.c:    if (!s->dma_auto) {
sb16.c:        /* It is clear that for DOOM and auto-init this value
sb16.c:        s->block_size <<= s->fmt_stereo;
sb16.c:            s->freq, s->fmt_stereo, s->fmt_signed, s->fmt_bits,
sb16.c:            s->block_size, s->dma_auto, s->fifo, s->highspeed);
sb16.c:    if (16 == s->fmt_bits) {
sb16.c:        if (s->fmt_signed) {
sb16.c:            s->fmt = AUD_FMT_S16;
sb16.c:            s->fmt = AUD_FMT_U16;
sb16.c:        if (s->fmt_signed) {
sb16.c:            s->fmt = AUD_FMT_S8;
sb16.c:            s->fmt = AUD_FMT_U8;
sb16.c:    s->left_till_irq = s->block_size;
sb16.c:    s->bytes_per_second = (s->freq << s->fmt_stereo) << (s->fmt_bits == 16);
sb16.c:    s->highspeed = 0;
sb16.c:    s->align = (1 << (s->fmt_stereo + (s->fmt_bits == 16))) - 1;
sb16.c:    if (s->block_size & s->align) {
sb16.c:               s->block_size, s->align + 1);
sb16.c:    if (s->freq) {
sb16.c:        s->audio_free = 0;
sb16.c:        as.freq = s->freq;
sb16.c:        as.nchannels = 1 << s->fmt_stereo;
sb16.c:        as.fmt = s->fmt;
sb16.c:        s->voice = AUD_open_out (
sb16.c:            &s->card,
sb16.c:            s->voice,
sb16.c:    if ((size_t) s->out_data_len < sizeof (s->out_data)) {
sb16.c:        s->out_data[s->out_data_len++] = val;
sb16.c:    if (s->in_index) {
sb16.c:        return s->in2_data[--s->in_index];
sb16.c:        s->needed_bytes = 3;
sb16.c:        s->needed_bytes = 0;
sb16.c:            dsp_out_data (s, 0x10); /* s->csp_param); */
sb16.c:            s->needed_bytes = 1;
sb16.c:            s->needed_bytes = 2;
sb16.c:            s->needed_bytes = 2;
sb16.c:            s->needed_bytes = 1;
sb16.c:            s->needed_bytes = 1;
sb16.c:            s->needed_bytes = 2;
sb16.c:            s->block_size = 0;
sb16.c:        case 0x1c:              /* Auto-Initialize DMA DAC, 8-bit */
sb16.c:            dma_cmd8 (s, DMA8_AUTO, -1);
sb16.c:            dolog ("0x35 - MIDI command not implemented\n");
sb16.c:            s->freq = -1;
sb16.c:            s->time_const = -1;
sb16.c:            s->needed_bytes = 1;
sb16.c:            s->freq = -1;
sb16.c:            s->time_const = -1;
sb16.c:            s->needed_bytes = 2;
sb16.c:            s->freq = -1;
sb16.c:            s->time_const = -1;
sb16.c:            s->needed_bytes = 2;
sb16.c:        case 0x47:                /* Continue Auto-Initialize DMA 16bit */
sb16.c:            s->needed_bytes = 2;
sb16.c:            s->needed_bytes = 2; /* DMA DAC, 4-bit ADPCM */
sb16.c:            dolog ("0x75 - DMA DAC, 4-bit ADPCM not implemented\n");
sb16.c:        case 0x75:              /* DMA DAC, 4-bit ADPCM Reference */
sb16.c:            s->needed_bytes = 2;
sb16.c:            dolog ("0x74 - DMA DAC, 4-bit ADPCM Reference not implemented\n");
sb16.c:        case 0x76:              /* DMA DAC, 2.6-bit ADPCM */
sb16.c:            s->needed_bytes = 2;
sb16.c:            dolog ("0x74 - DMA DAC, 2.6-bit ADPCM not implemented\n");
sb16.c:        case 0x77:              /* DMA DAC, 2.6-bit ADPCM Reference */
sb16.c:            s->needed_bytes = 2;
sb16.c:            dolog ("0x74 - DMA DAC, 2.6-bit ADPCM Reference not implemented\n");
sb16.c:            dolog ("0x7d - Autio-Initialize DMA DAC, 4-bit ADPCM Reference\n");
sb16.c:                "0x7d - Autio-Initialize DMA DAC, 2.6-bit ADPCM Reference\n"
sb16.c:            s->needed_bytes = 2;
sb16.c:            dma_cmd8 (s, ((cmd & 1) == 0) | DMA8_HIGH, -1);
sb16.c:        case 0xd9:              /* exit auto-init DMA after this block. 16bit */
sb16.c:            s->dma_auto = 0;
sb16.c:        case 0xda:              /* exit auto-init DMA after this block. 8bit */
sb16.c:            s->dma_auto = 0;
sb16.c:            s->needed_bytes = 1;
sb16.c:            dsp_out_data (s, s->ver & 0xff);
sb16.c:            dsp_out_data (s, s->ver >> 8);
sb16.c:            s->needed_bytes = 1;
sb16.c:                for (i = sizeof (e3) - 1; i >= 0; --i)
sb16.c:            s->needed_bytes = 1;
sb16.c:            dsp_out_data (s, s->test_reg);
sb16.c:            s->mixer_regs[0x82] |= (cmd == 0xf2) ? 1 : 2;
sb16.c:            qemu_irq_raise (s->pic);
sb16.c:            s->needed_bytes = 1;
sb16.c:    if (!s->needed_bytes) {
sb16.c:    if (!s->needed_bytes) {
sb16.c:        s->cmd = -1;
sb16.c:        s->cmd = cmd;
sb16.c:           cmd, s->needed_bytes);
sb16.c:            s->cmd, s->in_index, s->needed_bytes);
sb16.c:    if (s->cmd > 0xaf && s->cmd < 0xd0) {
sb16.c:        if (s->cmd & 8) {
sb16.c:                   s->cmd, d0, d1, d2);
sb16.c:                    s->cmd, d0, d1, d2);
sb16.c:            dma_cmd (s, s->cmd, d0, d1 + (d2 << 8));
sb16.c:        switch (s->cmd) {
sb16.c:            s->csp_mode = dsp_get_data (s);
sb16.c:            s->csp_reg83r = 0;
sb16.c:            s->csp_reg83w = 0;
sb16.c:            ldebug ("CSP command 0x04: mode=%#x\n", s->csp_mode);
sb16.c:            s->csp_param = dsp_get_data (s);
sb16.c:            s->csp_value = dsp_get_data (s);
sb16.c:                    s->csp_param,
sb16.c:                    s->csp_value);
sb16.c:            ldebug ("write CSP register %d <- %#x\n", d1, d0);
sb16.c:                ldebug ("0x83[%d] <- %#x\n", s->csp_reg83r, d0);
sb16.c:                s->csp_reg83[s->csp_reg83r % 4] = d0;
sb16.c:                s->csp_reg83r += 1;
sb16.c:                s->csp_regs[d1] = d0;
sb16.c:            ldebug ("read CSP register %#x -> %#x, mode=%#x\n",
sb16.c:                    d0, s->csp_regs[d0], s->csp_mode);
sb16.c:                ldebug ("0x83[%d] -> %#x\n",
sb16.c:                        s->csp_reg83w,
sb16.c:                        s->csp_reg83[s->csp_reg83w % 4]);
sb16.c:                dsp_out_data (s, s->csp_reg83[s->csp_reg83w % 4]);
sb16.c:                s->csp_reg83w += 1;
sb16.c:                dsp_out_data (s, s->csp_regs[d0]);
sb16.c:            s->time_const = dsp_get_data (s);
sb16.c:            ldebug ("set time const %d\n", s->time_const);
sb16.c:            s->freq = dsp_get_hilo (s);
sb16.c:            ldebug ("set freq %d\n", s->freq);
sb16.c:            s->block_size = dsp_get_lohi (s) + 1;
sb16.c:            ldebug ("set dma block len %d\n", s->block_size);
sb16.c:                freq = s->freq > 0 ? s->freq : 11025;
sb16.c:                bytes = samples << s->fmt_stereo << (s->fmt_bits == 16);
sb16.c:                    qemu_irq_raise (s->pic);
sb16.c:                    if (s->aux_ts) {
sb16.c:                            s->aux_ts,
sb16.c:            s->out_data_len = 0;
sb16.c:            s->test_reg = dsp_get_data (s);
sb16.c:            dolog ("complete: unrecognized command %#x\n", s->cmd);
sb16.c:    s->cmd = -1;
sb16.c:    s->freq = 11025;
sb16.c:    s->fmt_signed = 0;
sb16.c:    s->fmt_bits = 8;
sb16.c:    s->fmt_stereo = 0;
sb16.c:    as.freq = s->freq;
sb16.c:    s->voice = AUD_open_out (
sb16.c:        &s->card,
sb16.c:        s->voice,
sb16.c:    /* AUD_set_active_out (s->voice, 1); */
sb16.c:    qemu_irq_lower (s->pic);
sb16.c:    if (s->dma_auto) {
sb16.c:        qemu_irq_raise (s->pic);
sb16.c:        qemu_irq_lower (s->pic);
sb16.c:    s->mixer_regs[0x82] = 0;
sb16.c:    s->dma_auto = 0;
sb16.c:    s->in_index = 0;
sb16.c:    s->out_data_len = 0;
sb16.c:    s->left_till_irq = 0;
sb16.c:    s->needed_bytes = 0;
sb16.c:    s->block_size = -1;
sb16.c:    s->nzero = 0;
sb16.c:    s->highspeed = 0;
sb16.c:    s->v2x6 = 0;
sb16.c:    s->cmd = -1;
sb16.c:    iport = nport - s->port;
sb16.c:    ldebug ("write %#x <- %#x\n", nport, val);
sb16.c:            if (s->v2x6 == 1) {
sb16.c:            s->v2x6 = 0;
sb16.c:            s->v2x6 = 1;
sb16.c:            s->v2x6 = 0;        /* Prince of Persia, csp.sys, diagnose.exe */
sb16.c:            s->v2x6 = 0x39;
sb16.c:            s->v2x6 = val;
sb16.c:/*         if (s->highspeed) */
sb16.c:        if (0 == s->needed_bytes) {
sb16.c:            if (0 == s->needed_bytes) {
sb16.c:            if (s->in_index == sizeof (s->in2_data)) {
sb16.c:                s->in2_data[s->in_index++] = val;
sb16.c:                if (s->in_index == s->needed_bytes) {
sb16.c:                    s->needed_bytes = 0;
sb16.c:    iport = nport - s->port;
sb16.c:        if (s->out_data_len) {
sb16.c:            retval = s->out_data[--s->out_data_len];
sb16.c:            s->last_read_byte = retval;
sb16.c:            if (s->cmd != -1) {
sb16.c:                       s->cmd);
sb16.c:            retval = s->last_read_byte;
sb16.c:        retval = s->can_write ? 0 : 0x80;
sb16.c:        retval = (!s->out_data_len || s->highspeed) ? 0 : 0x80;
sb16.c:        if (s->mixer_regs[0x82] & 1) {
sb16.c:            s->mixer_regs[0x82] &= 1;
sb16.c:            qemu_irq_lower (s->pic);
sb16.c:        if (s->mixer_regs[0x82] & 2) {
sb16.c:            s->mixer_regs[0x82] &= 2;
sb16.c:            qemu_irq_lower (s->pic);
sb16.c:        ldebug ("read %#x -> %#x\n", nport, retval);
sb16.c:    memset (s->mixer_regs, 0xff, 0x7f);
sb16.c:    memset (s->mixer_regs + 0x83, 0xff, sizeof (s->mixer_regs) - 0x83);
sb16.c:    s->mixer_regs[0x02] = 4;    /* master volume 3bits */
sb16.c:    s->mixer_regs[0x06] = 4;    /* MIDI volume 3bits */
sb16.c:    s->mixer_regs[0x08] = 0;    /* CD volume 3bits */
sb16.c:    s->mixer_regs[0x0a] = 0;    /* voice volume 2bits */
sb16.c:    s->mixer_regs[0x0c] = 0;
sb16.c:    s->mixer_regs[0x0e] = 0;
sb16.c:    s->mixer_regs[0x04] = (4 << 5) | (4 << 1);
sb16.c:    s->mixer_regs[0x22] = (4 << 5) | (4 << 1);
sb16.c:    s->mixer_regs[0x26] = (4 << 5) | (4 << 1);
sb16.c:        s->mixer_regs[i] = 0x20;
sb16.c:    s->mixer_nreg = val;
sb16.c:    ldebug ("mixer_write [%#x] <- %#x\n", s->mixer_nreg, val);
sb16.c:    switch (s->mixer_nreg) {
sb16.c:                s->irq = irq;
sb16.c:            if (dma != s->dma || hdma != s->hdma) {
sb16.c:                    dma, s->dma, hdma, s->hdma, val);
sb16.c:            s->dma = dma;
sb16.c:            s->hdma = hdma;
sb16.c:        if (s->mixer_nreg >= 0x80) {
sb16.c:            ldebug ("attempt to write mixer[%#x] <- %#x\n", s->mixer_nreg, val);
sb16.c:    s->mixer_regs[s->mixer_nreg] = val;
sb16.c:    if (s->mixer_nreg != 0x82) {
sb16.c:        ldebug ("mixer_read[%#x] -> %#x\n",
sb16.c:                s->mixer_nreg, s->mixer_regs[s->mixer_nreg]);
sb16.c:    ldebug ("mixer_read[%#x] -> %#x\n",
sb16.c:            s->mixer_nreg, s->mixer_regs[s->mixer_nreg]);
sb16.c:    return s->mixer_regs[s->mixer_nreg];
sb16.c:        int left = dma_len - dma_pos;
sb16.c:        copied = AUD_write (s->voice, tmpbuf, copied);
sb16.c:        temp -= copied;
sb16.c:    if (s->block_size <= 0) {
sb16.c:               s->block_size, nchan, dma_pos, dma_len);
sb16.c:    if (s->left_till_irq < 0) {
sb16.c:        s->left_till_irq = s->block_size;
sb16.c:    if (s->voice) {
sb16.c:        free = s->audio_free & ~s->align;
sb16.c:    till = s->left_till_irq;
sb16.c:        if (0 == s->dma_auto) {
sb16.c:    s->left_till_irq -= written;
sb16.c:    if (s->left_till_irq <= 0) {
sb16.c:        s->mixer_regs[0x82] |= (nchan & 4) ? 2 : 1;
sb16.c:        qemu_irq_raise (s->pic);
sb16.c:        if (0 == s->dma_auto) {
sb16.c:            dma_pos, free, dma_len, s->left_till_irq, copy, written,
sb16.c:            s->block_size);
sb16.c:    while (s->left_till_irq <= 0) {
sb16.c:        s->left_till_irq = s->block_size + s->left_till_irq;
sb16.c:    s->audio_free = free;
sb16.c:    if (s->voice) {
sb16.c:        AUD_close_out (&s->card, s->voice);
sb16.c:        s->voice = NULL;
sb16.c:    if (s->dma_running) {
sb16.c:        if (s->freq) {
sb16.c:            s->audio_free = 0;
sb16.c:            as.freq = s->freq;
sb16.c:            as.nchannels = 1 << s->fmt_stereo;
sb16.c:            as.fmt = s->fmt;
sb16.c:            s->voice = AUD_open_out (
sb16.c:                &s->card,
sb16.c:                s->voice,
sb16.c:        speaker (s, s->speaker);
sb16.c:    s->cmd = -1;
sb16.c:    isa_init_irq (dev, &s->pic, s->irq);
sb16.c:    s->mixer_regs[0x80] = magic_of_irq (s->irq);
sb16.c:    s->mixer_regs[0x81] = (1 << s->dma) | (1 << s->hdma);
sb16.c:    s->mixer_regs[0x82] = 2 << 5;
sb16.c:    s->csp_regs[5] = 1;
sb16.c:    s->csp_regs[9] = 0xf8;
sb16.c:    s->aux_ts = qemu_new_timer (vm_clock, aux_timer, s);
sb16.c:    if (!s->aux_ts) {
sb16.c:        register_ioport_write (s->port + dsp_write_ports[i], 1, 1, dsp_write, s);
sb16.c:        register_ioport_read (s->port + dsp_read_ports[i], 1, 1, dsp_read, s);
sb16.c:    register_ioport_write (s->port + 0x4, 1, 1, mixer_write_indexb, s);
sb16.c:    register_ioport_write (s->port + 0x4, 1, 2, mixer_write_indexw, s);
sb16.c:    register_ioport_read (s->port + 0x5, 1, 1, mixer_read, s);
sb16.c:    register_ioport_write (s->port + 0x5, 1, 1, mixer_write_datab, s);
sb16.c:    DMA_register_channel (s->hdma, SB_read_DMA, s);
sb16.c:    DMA_register_channel (s->dma, SB_read_DMA, s);
sb16.c:    s->can_write = 1;
sb16.c:    AUD_register_card ("sb16", &s->card);
sbi.c: * Based on slavio_intctl, copyright (c) 2003-2005 Fabrice Bellard
sbi.c:        ret = s->regs[saddr];
sbi.c:        s->regs[saddr] = val;
sbi.c:        s->intreg_pending[i] = 0;
sbi.c:    qdev_init_gpio_in(&dev->qdev, sbi_set_irq, 32 + MAX_CPUS);
sbi.c:        sysbus_init_irq(dev, &s->cpu_irqs[i]);
scsi-bus.c:#include "scsi-defs.h"
scsi-bus.c:        DEFINE_PROP_UINT32("scsi-id", SCSIDevice, id, -1),
scsi-bus.c:    qbus_create_inplace(&bus->qbus, &scsi_bus_info, host, NULL);
scsi-bus.c:    bus->busnr = next_scsi_bus++;
scsi-bus.c:    bus->tcq = tcq;
scsi-bus.c:    bus->ndev = ndev;
scsi-bus.c:    bus->complete = complete;
scsi-bus.c:    bus->qbus.allow_hotplug = 1;
scsi-bus.c:    SCSIBus *bus = DO_UPCAST(SCSIBus, qbus, dev->qdev.parent_bus);
scsi-bus.c:    int rc = -1;
scsi-bus.c:    if (dev->id == -1) {
scsi-bus.c:        for (dev->id = 0; dev->id < bus->ndev; dev->id++) {
scsi-bus.c:            if (bus->devs[dev->id] == NULL)
scsi-bus.c:    if (dev->id >= bus->ndev) {
scsi-bus.c:        qemu_error("bad scsi device id: %d\n", dev->id);
scsi-bus.c:    if (bus->devs[dev->id]) {
scsi-bus.c:        qdev_free(&bus->devs[dev->id]->qdev);
scsi-bus.c:    bus->devs[dev->id] = dev;
scsi-bus.c:    dev->info = info;
scsi-bus.c:    QTAILQ_INIT(&dev->requests);
scsi-bus.c:    rc = dev->info->init(dev);
scsi-bus.c:        bus->devs[dev->id] = NULL;
scsi-bus.c:    SCSIBus *bus = DO_UPCAST(SCSIBus, qbus, dev->qdev.parent_bus);
scsi-bus.c:    assert(bus->devs[dev->id] != NULL);
scsi-bus.c:    if (bus->devs[dev->id]->info->destroy) {
scsi-bus.c:        bus->devs[dev->id]->info->destroy(bus->devs[dev->id]);
scsi-bus.c:    bus->devs[dev->id] = NULL;
scsi-bus.c:    info->qdev.bus_info = &scsi_bus_info;
scsi-bus.c:    info->qdev.init     = scsi_qdev_init;
scsi-bus.c:    info->qdev.unplug   = qdev_simple_unplug_cb;
scsi-bus.c:    info->qdev.exit     = scsi_qdev_exit;
scsi-bus.c:    qdev_register(&info->qdev);
scsi-bus.c:/* handle legacy '-drive if=scsi,...' cmd line args */
scsi-bus.c:    driver = bdrv_is_sg(dinfo->bdrv) ? "scsi-generic" : "scsi-disk";
scsi-bus.c:    dev = qdev_create(&bus->qbus, driver);
scsi-bus.c:    qdev_prop_set_uint32(dev, "scsi-id", unit);
scsi-bus.c:        dinfo = drive_get(IF_SCSI, bus->busnr, unit);
scsi-bus.c:    memset(&dev->sense, 0, sizeof(dev->sense));
scsi-bus.c:    dev->sense.key = key;
scsi-bus.c:    req->bus = scsi_bus_from_device(d);
scsi-bus.c:    req->dev = d;
scsi-bus.c:    req->tag = tag;
scsi-bus.c:    req->lun = lun;
scsi-bus.c:    req->status = -1;
scsi-bus.c:    QTAILQ_INSERT_TAIL(&d->requests, req, next);
scsi-bus.c:    QTAILQ_FOREACH(req, &d->requests, next) {
scsi-bus.c:        if (req->tag == tag) {
scsi-bus.c:    QTAILQ_REMOVE(&req->dev->requests, req, next);
scsi-bus.c:        req->cmd.xfer = cmd[4];
scsi-bus.c:        req->cmd.len = 6;
scsi-bus.c:        if (req->cmd.xfer == 0)
scsi-bus.c:            req->cmd.xfer = 256;
scsi-bus.c:        req->cmd.xfer = cmd[8] | (cmd[7] << 8);
scsi-bus.c:        req->cmd.len = 10;
scsi-bus.c:        req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24);
scsi-bus.c:        req->cmd.len = 16;
scsi-bus.c:        req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24);
scsi-bus.c:        req->cmd.len = 12;
scsi-bus.c:        return -1;
scsi-bus.c:        req->cmd.xfer = 0;
scsi-bus.c:        req->cmd.xfer = 1;
scsi-bus.c:        req->cmd.xfer = 8;
scsi-bus.c:        req->cmd.xfer = 6;
scsi-bus.c:        req->cmd.xfer = 20;
scsi-bus.c:        req->cmd.xfer *= 40;
scsi-bus.c:        req->cmd.xfer *= 8;
scsi-bus.c:        req->cmd.xfer *= req->dev->blocksize;
scsi-bus.c:        req->cmd.xfer *= req->dev->blocksize;
scsi-bus.c:        req->cmd.xfer = cmd[4] | (cmd[3] << 8);
scsi-bus.c:        req->cmd.len = 6;
scsi-bus.c:        req->cmd.xfer = cmd[4] | (cmd[3] << 8) | (cmd[2] << 16);
scsi-bus.c:            req->cmd.xfer *= req->dev->blocksize;
scsi-bus.c:        req->cmd.len = 6;
scsi-bus.c:        req->cmd.xfer = 0;
scsi-bus.c:    switch (req->cmd.buf[0]) {
scsi-bus.c:        req->cmd.mode = SCSI_XFER_TO_DEV;
scsi-bus.c:        if (req->cmd.xfer)
scsi-bus.c:            req->cmd.mode = SCSI_XFER_FROM_DEV;
scsi-bus.c:            req->cmd.mode = SCSI_XFER_NONE;
scsi-bus.c:    uint8_t *buf = req->cmd.buf;
scsi-bus.c:        lba = -1;
scsi-bus.c:    if (req->dev->type == TYPE_TAPE) {
scsi-bus.c:    memcpy(req->cmd.buf, buf, req->cmd.len);
scsi-bus.c:    req->cmd.lba = scsi_req_lba(req);
scsi-bus.c:            req->dev->qdev.parent_bus->name,
scsi-bus.c:            req->dev->id,
scsi-bus.c:            scsi_command_name(req->cmd.buf[0]));
scsi-bus.c:    for (i = 1; i < req->cmd.len; i++) {
scsi-bus.c:        fprintf(fp, " 0x%02x", req->cmd.buf[i]);
scsi-bus.c:    switch (req->cmd.mode) {
scsi-bus.c:        fprintf(fp, " - none\n");
scsi-bus.c:        fprintf(fp, " - from-dev len=%zd\n", req->cmd.xfer);
scsi-bus.c:        fprintf(fp, " - to-dev len=%zd\n", req->cmd.xfer);
scsi-bus.c:        fprintf(fp, " - Oops\n");
scsi-bus.c:    assert(req->status != -1);
scsi-bus.c:    req->bus->complete(req->bus, SCSI_REASON_DONE,
scsi-bus.c:                       req->tag,
scsi-bus.c:                       req->status);
scsi-defs.h:   02111-1307 USA.  */
scsi-defs.h:/* from hw/scsi-generic.c */
scsi-defs.h:#define TYPE_MOD            0x07    /* Magneto-optical disk -
scsi-defs.h:				     * - treated as TYPE_DISK */
scsi-disk.c: *  2009-Dec-12 Artyom Tarasenko : implemented stamdard inquiry for the case
scsi-disk.c: *  2009-Oct-13 Artyom Tarasenko : implemented the block descriptor in the
scsi-disk.c:#include <qemu-common.h>
scsi-disk.c:do { printf("scsi-disk: " fmt , ## __VA_ARGS__); } while (0)
scsi-disk.c:do { fprintf(stderr, "scsi-disk: " fmt , ## __VA_ARGS__); } while (0)
scsi-disk.c:#include "qemu-common.h"
scsi-disk.c:#include "scsi-defs.h"
scsi-disk.c:    r->iov.iov_base = qemu_memalign(512, SCSI_DMA_BUF_SIZE);
scsi-disk.c:    qemu_vfree(r->iov.iov_base);
scsi-disk.c:    scsi_req_free(&r->req);
scsi-disk.c:    return DO_UPCAST(SCSIDiskReq, req, scsi_req_find(&s->qdev, tag));
scsi-disk.c:    req->status = status;
scsi-disk.c:    scsi_dev_set_sense(req->dev, sense_code);
scsi-disk.c:            r->req.tag, status, sense);
scsi-disk.c:    scsi_req_set_status(&r->req, status, sense);
scsi-disk.c:    scsi_req_complete(&r->req);
scsi-disk.c:        if (r->req.aiocb)
scsi-disk.c:            bdrv_aio_cancel(r->req.aiocb);
scsi-disk.c:        r->req.aiocb = NULL;
scsi-disk.c:        r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, 0);
scsi-disk.c:    DPRINTF("Data ready tag=0x%x len=%" PRId64 "\n", r->req.tag, r->iov.iov_len);
scsi-disk.c:    r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, r->iov.iov_len);
scsi-disk.c:    if (r->sector_count == (uint32_t)-1) {
scsi-disk.c:        DPRINTF("Read buf_len=%" PRId64 "\n", r->iov.iov_len);
scsi-disk.c:        r->sector_count = 0;
scsi-disk.c:        r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, r->iov.iov_len);
scsi-disk.c:    DPRINTF("Read sector_count=%d\n", r->sector_count);
scsi-disk.c:    if (r->sector_count == 0) {
scsi-disk.c:    n = r->sector_count;
scsi-disk.c:    r->iov.iov_len = n * 512;
scsi-disk.c:    qemu_iovec_init_external(&r->qiov, &r->iov, 1);
scsi-disk.c:    r->req.aiocb = bdrv_aio_readv(s->qdev.dinfo->bdrv, r->sector, &r->qiov, n,
scsi-disk.c:    if (r->req.aiocb == NULL)
scsi-disk.c:    r->sector += n;
scsi-disk.c:    r->sector_count -= n;
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
scsi-disk.c:        drive_get_on_error(s->qdev.dinfo->bdrv, 0);
scsi-disk.c:        r->status |= SCSI_REQ_STATUS_RETRY;
scsi-disk.c:    r->req.aiocb = NULL;
scsi-disk.c:        if (scsi_handle_write_error(r, -ret))
scsi-disk.c:    n = r->iov.iov_len / 512;
scsi-disk.c:    r->sector += n;
scsi-disk.c:    r->sector_count -= n;
scsi-disk.c:    if (r->sector_count == 0) {
scsi-disk.c:        len = r->sector_count * 512;
scsi-disk.c:        r->iov.iov_len = len;
scsi-disk.c:        DPRINTF("Write complete tag=0x%x more=%d\n", r->req.tag, len);
scsi-disk.c:        r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, len);
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
scsi-disk.c:    n = r->iov.iov_len / 512;
scsi-disk.c:        qemu_iovec_init_external(&r->qiov, &r->iov, 1);
scsi-disk.c:        r->req.aiocb = bdrv_aio_writev(s->qdev.dinfo->bdrv, r->sector, &r->qiov, n,
scsi-disk.c:        if (r->req.aiocb == NULL)
scsi-disk.c:    if (r->req.aiocb)
scsi-disk.c:    qemu_bh_delete(s->bh);
scsi-disk.c:    s->bh = NULL;
scsi-disk.c:    QTAILQ_FOREACH(req, &s->qdev.requests, next) {
scsi-disk.c:        if (r->status & SCSI_REQ_STATUS_RETRY) {
scsi-disk.c:            r->status &= ~SCSI_REQ_STATUS_RETRY;
scsi-disk.c:    if (!s->bh) {
scsi-disk.c:        s->bh = qemu_bh_new(scsi_dma_restart_bh, s);
scsi-disk.c:        qemu_bh_schedule(s->bh);
scsi-disk.c:    return (uint8_t *)r->iov.iov_base;
scsi-disk.c:    BlockDriverState *bdrv = req->dev->dinfo->bdrv;
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
scsi-disk.c:    if (req->cmd.buf[1] & 0x2) {
scsi-disk.c:        /* Command support data - optional, not implemented */
scsi-disk.c:        return -1;
scsi-disk.c:    if (req->cmd.buf[1] & 0x1) {
scsi-disk.c:        uint8_t page_code = req->cmd.buf[2];
scsi-disk.c:        if (req->cmd.xfer < 4) {
scsi-disk.c:                 "less than 4\n", page_code, req->cmd.xfer);
scsi-disk.c:            return -1;
scsi-disk.c:                    "buffer size %zd\n", req->cmd.xfer);
scsi-disk.c:            const char *serial = req->dev->dinfo->serial ?
scsi-disk.c:                req->dev->dinfo->serial : "0";
scsi-disk.c:            if (l > req->cmd.xfer)
scsi-disk.c:                l = req->cmd.xfer;
scsi-disk.c:                    "buffer size %zd\n", req->cmd.xfer);
scsi-disk.c:            int max_len = 255 - 8;
scsi-disk.c:                    "buffer size %zd\n", req->cmd.xfer);
scsi-disk.c:                 "buffer size %zd\n", page_code, req->cmd.xfer);
scsi-disk.c:            return -1;
scsi-disk.c:    if (req->cmd.buf[2] != 0) {
scsi-disk.c:             "is non-zero [%02X]\n", req->cmd.buf[2]);
scsi-disk.c:        return -1;
scsi-disk.c:    if (req->cmd.xfer < 5) {
scsi-disk.c:             "is less than 5\n", req->cmd.xfer);
scsi-disk.c:        return -1;
scsi-disk.c:    buflen = req->cmd.xfer;
scsi-disk.c:    if (req->lun || req->cmd.buf[1] >> 5) {
scsi-disk.c:        memcpy(&outbuf[16], "QEMU CD-ROM     ", 16);
scsi-disk.c:    memcpy(&outbuf[32], s->version ? s->version : QEMU_VERSION, 4);
scsi-disk.c:    /* Identify device as SCSI-3 rev 1.
scsi-disk.c:        outbuf[4] = buflen - 5; /* Additional Length = (Len - 1) - 4 */
scsi-disk.c:        outbuf[4] = 36 - 5;
scsi-disk.c:    outbuf[7] = 0x10 | (req->bus->tcq ? 0x02 : 0);
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
scsi-disk.c:    BlockDriverState *bdrv = req->dev->dinfo->bdrv;
scsi-disk.c:        p[6] = s->cluster_size * 2;
scsi-disk.c:        if (bdrv_enable_write_cache(s->qdev.dinfo->bdrv)) {
scsi-disk.c:        p[2] = 3; // CD-R & CD-RW read
scsi-disk.c:        p[6] = 0x2d | (bdrv_is_locked(s->qdev.dinfo->bdrv)? 2 : 0);
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
scsi-disk.c:    BlockDriverState *bdrv = req->dev->dinfo->bdrv;
scsi-disk.c:    dbd = req->cmd.buf[1]  & 0x8;
scsi-disk.c:    page = req->cmd.buf[2] & 0x3f;
scsi-disk.c:    DPRINTF("Mode Sense (page %d, len %zd)\n", page, req->cmd.xfer);
scsi-disk.c:    memset(outbuf, 0, req->cmd.xfer);
scsi-disk.c:        nb_sectors /= s->cluster_size;
scsi-disk.c:        nb_sectors--;
scsi-disk.c:        p[5] = 0; /* bytes 5-7 are the sector size in bytes */
scsi-disk.c:        p[6] = s->cluster_size * 2;
scsi-disk.c:    buflen = p - outbuf;
scsi-disk.c:    outbuf[0] = buflen - 4;
scsi-disk.c:    if (buflen > req->cmd.xfer)
scsi-disk.c:        buflen = req->cmd.xfer;
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
scsi-disk.c:    BlockDriverState *bdrv = req->dev->dinfo->bdrv;
scsi-disk.c:    msf = req->cmd.buf[1] & 2;
scsi-disk.c:    format = req->cmd.buf[2] & 0xf;
scsi-disk.c:    start_track = req->cmd.buf[6];
scsi-disk.c:    nb_sectors /= s->cluster_size;
scsi-disk.c:        return -1;
scsi-disk.c:    if (toclen > req->cmd.xfer)
scsi-disk.c:        toclen = req->cmd.xfer;
scsi-disk.c:    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);
scsi-disk.c:    BlockDriverState *bdrv = req->dev->dinfo->bdrv;
scsi-disk.c:    switch (req->cmd.buf[0]) {
scsi-disk.c:        if (req->cmd.xfer < 4)
scsi-disk.c:        if (req->dev->sense.key == NOT_READY && req->cmd.xfer >= 18) {
scsi-disk.c:        outbuf[2] = req->dev->sense.key;
scsi-disk.c:        scsi_dev_clear_sense(req->dev);
scsi-disk.c:        if (req->cmd.buf[1] & 1)
scsi-disk.c:        if (req->cmd.buf[1] & 3)
scsi-disk.c:        if (req->cmd.buf[1] & 1)
scsi-disk.c:        if (req->cmd.buf[1] & 3)
scsi-disk.c:        if (bdrv_get_type_hint(bdrv) == BDRV_TYPE_CDROM && (req->cmd.buf[4] & 2)) {
scsi-disk.c:            bdrv_eject(bdrv, !(req->cmd.buf[4] & 1));
scsi-disk.c:        bdrv_set_locked(bdrv, req->cmd.buf[4] & 1);
scsi-disk.c:        nb_sectors /= s->cluster_size;
scsi-disk.c:        nb_sectors--;
scsi-disk.c:        s->max_lba = nb_sectors;
scsi-disk.c:        outbuf[6] = s->cluster_size * 2;
scsi-disk.c:           just return the basic header indicating the CD-ROM profile.  */
scsi-disk.c:        outbuf[7] = 8; // CD-ROM
scsi-disk.c:        if ((req->cmd.buf[1] & 31) == 0x10) {
scsi-disk.c:            memset(outbuf, 0, req->cmd.xfer);
scsi-disk.c:            nb_sectors /= s->cluster_size;
scsi-disk.c:            nb_sectors--;
scsi-disk.c:            s->max_lba = nb_sectors;
scsi-disk.c:            outbuf[10] = s->cluster_size * 2;
scsi-disk.c:            buflen = req->cmd.xfer;
scsi-disk.c:        if (req->cmd.xfer < 16)
scsi-disk.c:    outbuf = (uint8_t *)r->iov.iov_base;
scsi-disk.c:    if (scsi_req_parse(&r->req, buf) != 0) {
scsi-disk.c:    assert(r->req.cmd.len == cmdlen);
scsi-disk.c:    assert(r->req.cmd.lba == lba);
scsi-disk.c:        rc = scsi_disk_emulate_command(&r->req, outbuf);
scsi-disk.c:            r->iov.iov_len = rc;
scsi-disk.c:            scsi_req_complete(&r->req);
scsi-disk.c:        if (lba > s->max_lba)
scsi-disk.c:        r->sector = lba * s->cluster_size;
scsi-disk.c:        r->sector_count = len * s->cluster_size;
scsi-disk.c:        if (lba > s->max_lba)
scsi-disk.c:        r->sector = lba * s->cluster_size;
scsi-disk.c:        r->sector_count = len * s->cluster_size;
scsi-disk.c:    if (r->sector_count == 0 && r->iov.iov_len == 0) {
scsi-disk.c:    len = r->sector_count * 512 + r->iov.iov_len;
scsi-disk.c:        return -len;
scsi-disk.c:        if (!r->sector_count)
scsi-disk.c:            r->sector_count = -1;
scsi-disk.c:    while (!QTAILQ_EMPTY(&s->qdev.requests)) {
scsi-disk.c:        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));
scsi-disk.c:    drive_uninit(s->qdev.dinfo);
scsi-disk.c:    if (!s->qdev.dinfo || !s->qdev.dinfo->bdrv) {
scsi-disk.c:        qemu_error("scsi-disk: drive property not set\n");
scsi-disk.c:        return -1;
scsi-disk.c:    if (bdrv_get_type_hint(s->qdev.dinfo->bdrv) == BDRV_TYPE_CDROM) {
scsi-disk.c:        s->cluster_size = 4;
scsi-disk.c:        s->cluster_size = 1;
scsi-disk.c:    s->qdev.blocksize = 512 * s->cluster_size;
scsi-disk.c:    s->qdev.type = TYPE_DISK;
scsi-disk.c:    bdrv_get_geometry(s->qdev.dinfo->bdrv, &nb_sectors);
scsi-disk.c:    nb_sectors /= s->cluster_size;
scsi-disk.c:        nb_sectors--;
scsi-disk.c:    s->max_lba = nb_sectors;
scsi-disk.c:    .qdev.name    = "scsi-disk",
scsi-generic.c:#include "qemu-common.h"
scsi-generic.c:do { printf("scsi-generic: " fmt , ## __VA_ARGS__); } while (0)
scsi-generic.c:do { fprintf(stderr, "scsi-generic: " fmt , ## __VA_ARGS__); } while (0)
scsi-generic.c:#include "scsi-defs.h"
scsi-generic.c:#define MAX_UINT ((unsigned int)-1)
scsi-generic.c:    qemu_free(r->buf);
scsi-generic.c:    scsi_req_free(&r->req);
scsi-generic.c:    return DO_UPCAST(SCSIGenericReq, req, scsi_req_find(&s->qdev, tag));
scsi-generic.c:    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, r->req.dev);
scsi-generic.c:    s->driver_status = r->io_header.driver_status;
scsi-generic.c:    if (s->driver_status & SG_ERR_DRIVER_SENSE)
scsi-generic.c:        s->senselen = r->io_header.sb_len_wr;
scsi-generic.c:        r->req.status = BUSY << 1;
scsi-generic.c:        if (s->driver_status & SG_ERR_DRIVER_TIMEOUT) {
scsi-generic.c:            r->req.status = BUSY << 1;
scsi-generic.c:        } else if (r->io_header.status)
scsi-generic.c:            r->req.status = r->io_header.status;
scsi-generic.c:        else if (s->driver_status & SG_ERR_DRIVER_SENSE)
scsi-generic.c:            r->req.status = CHECK_CONDITION << 1;
scsi-generic.c:            r->req.status = GOOD << 1;
scsi-generic.c:            r, r->req.tag, r->req.status);
scsi-generic.c:    scsi_req_complete(&r->req);
scsi-generic.c:        if (r->req.aiocb)
scsi-generic.c:            bdrv_aio_cancel(r->req.aiocb);
scsi-generic.c:        r->req.aiocb = NULL;
scsi-generic.c:    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, r->req.dev);
scsi-generic.c:    r->io_header.interface_id = 'S';
scsi-generic.c:    r->io_header.dxfer_direction = direction;
scsi-generic.c:    r->io_header.dxferp = r->buf;
scsi-generic.c:    r->io_header.dxfer_len = r->buflen;
scsi-generic.c:    r->io_header.cmdp = r->req.cmd.buf;
scsi-generic.c:    r->io_header.cmd_len = r->req.cmd.len;
scsi-generic.c:    r->io_header.mx_sb_len = sizeof(s->sensebuf);
scsi-generic.c:    r->io_header.sbp = s->sensebuf;
scsi-generic.c:    r->io_header.timeout = MAX_UINT;
scsi-generic.c:    r->io_header.usr_ptr = r;
scsi-generic.c:    r->io_header.flags |= SG_FLAG_DIRECT_IO;
scsi-generic.c:    r->req.aiocb = bdrv_aio_ioctl(bdrv, SG_IO, &r->io_header, complete, r);
scsi-generic.c:    if (r->req.aiocb == NULL) {
scsi-generic.c:        return -1;
scsi-generic.c:    len = r->io_header.dxfer_len - r->io_header.resid;
scsi-generic.c:    DPRINTF("Data ready tag=0x%x len=%d\n", r->req.tag, len);
scsi-generic.c:    r->len = -1;
scsi-generic.c:    r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, len);
scsi-generic.c:        scsi_command_complete(r, -EINVAL);
scsi-generic.c:    if (r->len == -1) {
scsi-generic.c:    if (r->req.cmd.buf[0] == REQUEST_SENSE && s->driver_status & SG_ERR_DRIVER_SENSE)
scsi-generic.c:        s->senselen = MIN(r->len, s->senselen);
scsi-generic.c:        memcpy(r->buf, s->sensebuf, s->senselen);
scsi-generic.c:        r->io_header.driver_status = 0;
scsi-generic.c:        r->io_header.status = 0;
scsi-generic.c:        r->io_header.dxfer_len  = s->senselen;
scsi-generic.c:        r->len = -1;
scsi-generic.c:        DPRINTF("Data ready tag=0x%x len=%d\n", r->req.tag, s->senselen);
scsi-generic.c:                r->buf[0], r->buf[1], r->buf[2], r->buf[3],
scsi-generic.c:                r->buf[4], r->buf[5], r->buf[6], r->buf[7]);
scsi-generic.c:        r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, s->senselen);
scsi-generic.c:    ret = execute_command(s->qdev.dinfo->bdrv, r, SG_DXFER_FROM_DEV, scsi_read_complete);
scsi-generic.c:    if (ret == -1) {
scsi-generic.c:        scsi_command_complete(r, -EINVAL);
scsi-generic.c:    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, r->req.dev);
scsi-generic.c:    if (r->req.cmd.buf[0] == MODE_SELECT && r->req.cmd.buf[4] == 12 &&
scsi-generic.c:        s->qdev.type == TYPE_TAPE) {
scsi-generic.c:        s->qdev.blocksize = (r->buf[9] << 16) | (r->buf[10] << 8) | r->buf[11];
scsi-generic.c:        DPRINTF("block size %d\n", s->blocksize);
scsi-generic.c:        scsi_command_complete(r, -EINVAL);
scsi-generic.c:    if (r->len == 0) {
scsi-generic.c:        r->len = r->buflen;
scsi-generic.c:        r->req.bus->complete(r->req.bus, SCSI_REASON_DATA, r->req.tag, r->len);
scsi-generic.c:    ret = execute_command(s->qdev.dinfo->bdrv, r, SG_DXFER_TO_DEV, scsi_write_complete);
scsi-generic.c:    if (ret == -1) {
scsi-generic.c:        scsi_command_complete(r, -EINVAL);
scsi-generic.c:    return r->buf;
scsi-generic.c:    switch(req->cmd.buf[0]) {
scsi-generic.c:        req->cmd.buf[1] &= ~0x08;	/* disable FUA */
scsi-generic.c:        req->cmd.buf[1] &= ~0x08;	/* disable FUA */
scsi-generic.c:        if (req->dev->type == TYPE_TAPE) {
scsi-generic.c:            req->cmd.buf[1] = 0x01;
scsi-generic.c:        (lun != s->lun || (cmd[1] >> 5) != s->lun)) {
scsi-generic.c:        s->sensebuf[0] = 0x70;
scsi-generic.c:        s->sensebuf[1] = 0x00;
scsi-generic.c:        s->sensebuf[2] = ILLEGAL_REQUEST;
scsi-generic.c:        s->sensebuf[3] = 0x00;
scsi-generic.c:        s->sensebuf[4] = 0x00;
scsi-generic.c:        s->sensebuf[5] = 0x00;
scsi-generic.c:        s->sensebuf[6] = 0x00;
scsi-generic.c:        s->senselen = 7;
scsi-generic.c:        s->driver_status = SG_ERR_DRIVER_SENSE;
scsi-generic.c:        bus->complete(bus, SCSI_REASON_DONE, tag, CHECK_CONDITION << 1);
scsi-generic.c:    if (-1 == scsi_req_parse(&r->req, cmd)) {
scsi-generic.c:    scsi_req_fixup(&r->req);
scsi-generic.c:            cmd[0], r->req.cmd.xfer);
scsi-generic.c:    if (r->req.cmd.xfer == 0) {
scsi-generic.c:        if (r->buf != NULL)
scsi-generic.c:            qemu_free(r->buf);
scsi-generic.c:        r->buflen = 0;
scsi-generic.c:        r->buf = NULL;
scsi-generic.c:        ret = execute_command(s->qdev.dinfo->bdrv, r, SG_DXFER_NONE, scsi_command_complete);
scsi-generic.c:        if (ret == -1) {
scsi-generic.c:            scsi_command_complete(r, -EINVAL);
scsi-generic.c:    if (r->buflen != r->req.cmd.xfer) {
scsi-generic.c:        if (r->buf != NULL)
scsi-generic.c:            qemu_free(r->buf);
scsi-generic.c:        r->buf = qemu_malloc(r->req.cmd.xfer);
scsi-generic.c:        r->buflen = r->req.cmd.xfer;
scsi-generic.c:    memset(r->buf, 0, r->buflen);
scsi-generic.c:    r->len = r->req.cmd.xfer;
scsi-generic.c:    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {
scsi-generic.c:        r->len = 0;
scsi-generic.c:        return -r->req.cmd.xfer;
scsi-generic.c:    return r->req.cmd.xfer;
scsi-generic.c:        return -1;
scsi-generic.c:        return -1;
scsi-generic.c:    while (!QTAILQ_EMPTY(&s->qdev.requests)) {
scsi-generic.c:        r = DO_UPCAST(SCSIGenericReq, req, QTAILQ_FIRST(&s->qdev.requests));
scsi-generic.c:    drive_uninit(s->qdev.dinfo);
scsi-generic.c:    if (!s->qdev.dinfo || !s->qdev.dinfo->bdrv) {
scsi-generic.c:        qemu_error("scsi-generic: drive property not set\n");
scsi-generic.c:        return -1;
scsi-generic.c:    if (!bdrv_is_sg(s->qdev.dinfo->bdrv)) {
scsi-generic.c:        qemu_error("scsi-generic: not /dev/sg*\n");
scsi-generic.c:        return -1;
scsi-generic.c:    if (bdrv_ioctl(s->qdev.dinfo->bdrv, SG_GET_VERSION_NUM, &sg_version) < 0 ||
scsi-generic.c:        qemu_error("scsi-generic: scsi generic interface too old\n");
scsi-generic.c:        return -1;
scsi-generic.c:    if (bdrv_ioctl(s->qdev.dinfo->bdrv, SG_GET_SCSI_ID, &scsiid)) {
scsi-generic.c:        qemu_error("scsi-generic: SG_GET_SCSI_ID ioctl failed\n");
scsi-generic.c:        return -1;
scsi-generic.c:    s->lun = scsiid.lun;
scsi-generic.c:    DPRINTF("LUN %d\n", s->lun);
scsi-generic.c:    s->qdev.type = scsiid.scsi_type;
scsi-generic.c:    DPRINTF("device type %d\n", s->qdev.type);
scsi-generic.c:    if (s->qdev.type == TYPE_TAPE) {
scsi-generic.c:        s->qdev.blocksize = get_stream_blocksize(s->qdev.dinfo->bdrv);
scsi-generic.c:        if (s->qdev.blocksize == -1)
scsi-generic.c:            s->qdev.blocksize = 0;
scsi-generic.c:        s->qdev.blocksize = get_blocksize(s->qdev.dinfo->bdrv);
scsi-generic.c:        if (s->qdev.blocksize <= 0) {
scsi-generic.c:            if (s->qdev.type == TYPE_ROM || s->qdev.type  == TYPE_WORM)
scsi-generic.c:                s->qdev.blocksize = 2048;
scsi-generic.c:                s->qdev.blocksize = 512;
scsi-generic.c:    DPRINTF("block size %d\n", s->qdev.blocksize);
scsi-generic.c:    s->driver_status = 0;
scsi-generic.c:    memset(s->sensebuf, 0, sizeof(s->sensebuf));
scsi-generic.c:    .qdev.name    = "scsi-generic",
scsi.h:/* scsi-disk.c */
scsi.h:/* scsi-bus.c */
scsi.h:    return DO_UPCAST(SCSIBus, qbus, d->qdev.parent_bus);
sd.c:    sd_r1b = -1,
sd.c:        sd_inactive_state = -1,
sd.c:    switch (sd->state) {
sd.c:        sd->mode = sd_inactive;
sd.c:        sd->mode = sd_card_identification_mode;
sd.c:        sd->mode = sd_data_transfer_mode;
sd.c:    sd->card_status &= ~CURRENT_STATE;
sd.c:    sd->card_status |= sd->state << 9;
sd.c:        for (bit = 7; bit >= 0; bit --) {
sd.c:        for (bit = 15; bit >= 0; bit --) {
sd.c:    /* All voltages OK, card power-up OK, Standard Capacity SD Memory Card */
sd.c:    sd->ocr = 0x80ffff00;
sd.c:    sd->scr[0] = 0x00;		/* SCR Structure */
sd.c:    sd->scr[1] = 0x2f;		/* SD Security Support */
sd.c:    sd->scr[2] = 0x00;
sd.c:    sd->scr[3] = 0x00;
sd.c:    sd->scr[4] = 0x00;
sd.c:    sd->scr[5] = 0x00;
sd.c:    sd->scr[6] = 0x00;
sd.c:    sd->scr[7] = 0x00;
sd.c:    sd->cid[0] = MID;		/* Fake card manufacturer ID (MID) */
sd.c:    sd->cid[1] = OID[0];	/* OEM/Application ID (OID) */
sd.c:    sd->cid[2] = OID[1];
sd.c:    sd->cid[3] = PNM[0];	/* Fake product name (PNM) */
sd.c:    sd->cid[4] = PNM[1];
sd.c:    sd->cid[5] = PNM[2];
sd.c:    sd->cid[6] = PNM[3];
sd.c:    sd->cid[7] = PNM[4];
sd.c:    sd->cid[8] = PRV;		/* Fake product revision (PRV) */
sd.c:    sd->cid[9] = 0xde;		/* Fake serial number (PSN) */
sd.c:    sd->cid[10] = 0xad;
sd.c:    sd->cid[11] = 0xbe;
sd.c:    sd->cid[12] = 0xef;
sd.c:    sd->cid[13] = 0x00 |	/* Manufacture date (MDT) */
sd.c:        ((MDT_YR - 2000) / 10);
sd.c:    sd->cid[14] = ((MDT_YR % 10) << 4) | MDT_MON;
sd.c:    sd->cid[15] = (sd_crc7(sd->cid, 15) << 1) | 1;
sd.c:    uint32_t csize = (size >> (CMULT_SHIFT + HWBLOCK_SHIFT)) - 1;
sd.c:    uint32_t sectsize = (1 << (SECTOR_SHIFT + 1)) - 1;
sd.c:    uint32_t wpsize = (1 << (WPGROUP_SHIFT + 1)) - 1;
sd.c:        sd->csd[0] = 0x00;	/* CSD structure */
sd.c:        sd->csd[1] = 0x26;	/* Data read access-time-1 */
sd.c:        sd->csd[2] = 0x00;	/* Data read access-time-2 */
sd.c:        sd->csd[3] = 0x5a;	/* Max. data transfer rate */
sd.c:        sd->csd[4] = 0x5f;	/* Card Command Classes */
sd.c:        sd->csd[5] = 0x50 |	/* Max. read data block length */
sd.c:        sd->csd[6] = 0xe0 |	/* Partial block for read allowed */
sd.c:        sd->csd[7] = 0x00 |	/* Device size */
sd.c:        sd->csd[8] = 0x3f |	/* Max. read current */
sd.c:        sd->csd[9] = 0xfc |	/* Max. write current */
sd.c:            ((CMULT_SHIFT - 2) >> 1);
sd.c:        sd->csd[10] = 0x40 |	/* Erase sector size */
sd.c:            (((CMULT_SHIFT - 2) << 7) & 0x80) | (sectsize >> 1);
sd.c:        sd->csd[11] = 0x00 |	/* Write protect group size */
sd.c:        sd->csd[12] = 0x90 |	/* Write speed factor */
sd.c:        sd->csd[13] = 0x20 |	/* Max. write data block length */
sd.c:        sd->csd[14] = 0x00;	/* File format group */
sd.c:        sd->csd[15] = (sd_crc7(sd->csd, 15) << 1) | 1;
sd.c:        size -= 1;
sd.c:        sd->csd[0] = 0x40;
sd.c:        sd->csd[1] = 0x0e;
sd.c:        sd->csd[2] = 0x00;
sd.c:        sd->csd[3] = 0x32;
sd.c:        sd->csd[4] = 0x5b;
sd.c:        sd->csd[5] = 0x59;
sd.c:        sd->csd[6] = 0x00;
sd.c:        sd->csd[7] = (size >> 16) & 0xff;
sd.c:        sd->csd[8] = (size >> 8) & 0xff;
sd.c:        sd->csd[9] = (size & 0xff);
sd.c:        sd->csd[10] = 0x7f;
sd.c:        sd->csd[11] = 0x80;
sd.c:        sd->csd[12] = 0x0a;
sd.c:        sd->csd[13] = 0x40;
sd.c:        sd->csd[14] = 0x00;
sd.c:        sd->csd[15] = 0x00;
sd.c:        sd->ocr |= 1 << 30;	/* High Capacity SD Memort Card */
sd.c:    sd->rca += 0x4567;
sd.c:    sd->card_status = 0x00000100;
sd.c:    memset(sd->sd_status, 0, 64);
sd.c:    buffer[0] = 0x40 | req->cmd;
sd.c:    buffer[1] = (req->arg >> 24) & 0xff;
sd.c:    buffer[2] = (req->arg >> 16) & 0xff;
sd.c:    buffer[3] = (req->arg >> 8) & 0xff;
sd.c:    buffer[4] = (req->arg >> 0) & 0xff;
sd.c:    return sd_crc7(buffer, 5) != req->crc;	/* TODO */
sd.c:    status = (sd->card_status & ~mask) | (last_status & mask);
sd.c:    sd->card_status &= ~CARD_STATUS_C | APP_CMD;
sd.c:    response[0] = (sd->ocr >> 24) & 0xff;
sd.c:    response[1] = (sd->ocr >> 16) & 0xff;
sd.c:    response[2] = (sd->ocr >> 8) & 0xff;
sd.c:    response[3] = (sd->ocr >> 0) & 0xff;
sd.c:    arg = sd->rca;
sd.c:    status = ((sd->card_status >> 8) & 0xc000) |
sd.c:             ((sd->card_status >> 6) & 0x2000) |
sd.c:              (sd->card_status & 0x1fff);
sd.c:    response[0] = (sd->vhs >> 24) & 0xff;
sd.c:    response[1] = (sd->vhs >> 16) & 0xff;
sd.c:    response[2] = (sd->vhs >>  8) & 0xff;
sd.c:    response[3] = (sd->vhs >>  0) & 0xff;
sd.c:    sd->state = sd_idle_state;
sd.c:    sd->rca = 0x0000;
sd.c:    sd->bdrv = bdrv;
sd.c:    if (sd->wp_groups)
sd.c:        qemu_free(sd->wp_groups);
sd.c:    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;
sd.c:    sd->wp_groups = (int *) qemu_mallocz(sizeof(int) * sect);
sd.c:    memset(sd->function_group, 0, sizeof(int) * 6);
sd.c:    sd->erase_start = 0;
sd.c:    sd->erase_end = 0;
sd.c:    sd->size = size;
sd.c:    sd->blk_len = 0x200;
sd.c:    sd->pwd_len = 0;
sd.c:    qemu_set_irq(sd->inserted_cb, bdrv_is_inserted(sd->bdrv));
sd.c:    if (bdrv_is_inserted(sd->bdrv)) {
sd.c:        sd_reset(sd, sd->bdrv);
sd.c:        qemu_set_irq(sd->readonly_cb, sd->wp_switch);
sd.c:    sd->buf = qemu_memalign(512, 512);
sd.c:    sd->spi = is_spi;
sd.c:    sd->enable = 1;
sd.c:    if (sd->bdrv) {
sd.c:        bdrv_set_change_cb(sd->bdrv, sd_cardchange, sd);
sd.c:    sd->readonly_cb = readonly;
sd.c:    sd->inserted_cb = insert;
sd.c:    qemu_set_irq(readonly, bdrv_is_read_only(sd->bdrv));
sd.c:    qemu_set_irq(insert, bdrv_is_inserted(sd->bdrv));
sd.c:    if (!sd->erase_start || !sd->erase_end) {
sd.c:        sd->card_status |= ERASE_SEQ_ERROR;
sd.c:    start = sd->erase_start >>
sd.c:    end = sd->erase_end >>
sd.c:    sd->erase_start = 0;
sd.c:    sd->erase_end = 0;
sd.c:    sd->csd[14] |= 0x40;
sd.c:        if (sd->wp_groups[i])
sd.c:            sd->card_status |= WP_ERASE_SKIP;
sd.c:        if (addr < sd->size && sd->wp_groups[wpnum])
sd.c:    sd->data[0] = 0x00;		/* Maximum current consumption */
sd.c:    sd->data[1] = 0x01;
sd.c:    sd->data[2] = 0x80;		/* Supported group 6 functions */
sd.c:    sd->data[3] = 0x01;
sd.c:    sd->data[4] = 0x80;		/* Supported group 5 functions */
sd.c:    sd->data[5] = 0x01;
sd.c:    sd->data[6] = 0x80;		/* Supported group 4 functions */
sd.c:    sd->data[7] = 0x01;
sd.c:    sd->data[8] = 0x80;		/* Supported group 3 functions */
sd.c:    sd->data[9] = 0x01;
sd.c:    sd->data[10] = 0x80;	/* Supported group 2 functions */
sd.c:    sd->data[11] = 0x43;
sd.c:    sd->data[12] = 0x80;	/* Supported group 1 functions */
sd.c:    sd->data[13] = 0x03;
sd.c:            sd->function_group[i] = new_func;
sd.c:        sd->data[14 + (i >> 1)] = new_func << ((i * 4) & 4);
sd.c:    memset(&sd->data[17], 0, 47);
sd.c:    crc = sd_crc16(sd->data, 64);
sd.c:    sd->data[65] = crc >> 8;
sd.c:    sd->data[66] = crc & 0xff;
sd.c:    return sd->wp_groups[addr >>
sd.c:    erase = !!(sd->data[0] & 0x08);
sd.c:    lock = sd->data[0] & 0x04;
sd.c:    clr_pwd = sd->data[0] & 0x02;
sd.c:    set_pwd = sd->data[0] & 0x01;
sd.c:    if (sd->blk_len > 1)
sd.c:        pwd_len = sd->data[1];
sd.c:        if (!(sd->card_status & CARD_IS_LOCKED) || sd->blk_len > 1 ||
sd.c:                        set_pwd || clr_pwd || lock || sd->wp_switch ||
sd.c:                        (sd->csd[14] & 0x20)) {
sd.c:            sd->card_status |= LOCK_UNLOCK_FAILED;
sd.c:        memset(sd->wp_groups, 0, sizeof(int) * (sd->size >>
sd.c:        sd->csd[14] &= ~0x10;
sd.c:        sd->card_status &= ~CARD_IS_LOCKED;
sd.c:        sd->pwd_len = 0;
sd.c:        fprintf(stderr, "SD: Card force-erased by CMD42\n");
sd.c:    if (sd->blk_len < 2 + pwd_len ||
sd.c:                    pwd_len <= sd->pwd_len ||
sd.c:                    pwd_len > sd->pwd_len + 16) {
sd.c:        sd->card_status |= LOCK_UNLOCK_FAILED;
sd.c:    if (sd->pwd_len && memcmp(sd->pwd, sd->data + 2, sd->pwd_len)) {
sd.c:        sd->card_status |= LOCK_UNLOCK_FAILED;
sd.c:    pwd_len -= sd->pwd_len;
sd.c:                    (lock && !sd->pwd_len && !set_pwd) ||
sd.c:                     (((sd->card_status & CARD_IS_LOCKED) && lock) ||
sd.c:                      (!(sd->card_status & CARD_IS_LOCKED) && !lock)))) {
sd.c:        sd->card_status |= LOCK_UNLOCK_FAILED;
sd.c:        memcpy(sd->pwd, sd->data + 2 + sd->pwd_len, pwd_len);
sd.c:        sd->pwd_len = pwd_len;
sd.c:        sd->pwd_len = 0;
sd.c:        sd->card_status |= CARD_IS_LOCKED;
sd.c:        sd->card_status &= ~CARD_IS_LOCKED;
sd.c:    uint64_t addr = (sd->ocr & (1 << 30)) ? (uint64_t) req.arg << 9 : req.arg;
sd.c:    DPRINTF("CMD%d 0x%08x state %d\n", req.cmd, req.arg, sd->state);
sd.c:        switch (sd->state) {
sd.c:            return sd->spi ? sd_r1 : sd_r0;
sd.c:            sd->state = sd_idle_state;
sd.c:            sd_reset(sd, sd->bdrv);
sd.c:            return sd->spi ? sd_r1 : sd_r0;
sd.c:        if (!sd->spi)
sd.c:        sd->state = sd_transfer_state;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_identification_state;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_standby_state;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:        if (sd->spi)
sd.c:        switch (sd->mode) {
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            if (sd->rca != rca)
sd.c:            sd->state = sd_transfer_state;
sd.c:            if (sd->rca == rca)
sd.c:            sd->state = sd_standby_state;
sd.c:            if (sd->rca != rca)
sd.c:            sd->state = sd_programming_state;
sd.c:            if (sd->rca == rca)
sd.c:            sd->state = sd_disconnect_state;
sd.c:        switch (sd->state) {
sd.c:            sd->vhs = 0;
sd.c:                return sd->spi ? sd_r7 : sd_r0;
sd.c:            sd->vhs = req.arg;
sd.c:        switch (sd->state) {
sd.c:            if (sd->rca != rca)
sd.c:            if (!sd->spi)
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            memcpy(sd->data, sd->csd, 16);
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:        switch (sd->state) {
sd.c:            if (sd->rca != rca)
sd.c:            if (!sd->spi)
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            memcpy(sd->data, sd->cid, 16);
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            sd->data_start = req.arg;
sd.c:            sd->data_offset = 0;
sd.c:            if (sd->data_start + sd->blk_len > sd->size)
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_transfer_state;
sd.c:            sd->state = sd_programming_state;
sd.c:            sd->state = sd_transfer_state;
sd.c:        switch (sd->mode) {
sd.c:            if (sd->rca != rca)
sd.c:        if (sd->spi)
sd.c:        switch (sd->mode) {
sd.c:            if (sd->rca != rca)
sd.c:            sd->state = sd_inactive_state;
sd.c:        switch (sd->state) {
sd.c:                sd->card_status |= BLOCK_LEN_ERROR;
sd.c:                sd->blk_len = req.arg;
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:            if (sd->data_start + sd->blk_len > sd->size)
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:            if (sd->data_start + sd->blk_len > sd->size)
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            if (sd->spi)
sd.c:            sd->state = sd_receivingdata_state;
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:            sd->blk_written = 0;
sd.c:            if (sd->data_start + sd->blk_len > sd->size)
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:            if (sd_wp_addr(sd, sd->data_start))
sd.c:                sd->card_status |= WP_VIOLATION;
sd.c:            if (sd->csd[14] & 0x30)
sd.c:                sd->card_status |= WP_VIOLATION;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            if (sd->spi)
sd.c:            sd->state = sd_receivingdata_state;
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:            sd->blk_written = 0;
sd.c:            if (sd->data_start + sd->blk_len > sd->size)
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:            if (sd_wp_addr(sd, sd->data_start))
sd.c:                sd->card_status |= WP_VIOLATION;
sd.c:            if (sd->csd[14] & 0x30)
sd.c:                sd->card_status |= WP_VIOLATION;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_receivingdata_state;
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_receivingdata_state;
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        switch (sd->state) {
sd.c:            if (addr >= sd->size) {
sd.c:                sd->card_status = ADDRESS_ERROR;
sd.c:            sd->state = sd_programming_state;
sd.c:            sd->wp_groups[addr >> (HWBLOCK_SHIFT +
sd.c:            sd->state = sd_transfer_state;
sd.c:        switch (sd->state) {
sd.c:            if (addr >= sd->size) {
sd.c:                sd->card_status = ADDRESS_ERROR;
sd.c:            sd->state = sd_programming_state;
sd.c:            sd->wp_groups[addr >> (HWBLOCK_SHIFT +
sd.c:            sd->state = sd_transfer_state;
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            *(uint32_t *) sd->data = sd_wpbits(sd, req.arg);
sd.c:            sd->data_start = addr;
sd.c:            sd->data_offset = 0;
sd.c:        switch (sd->state) {
sd.c:            sd->erase_start = req.arg;
sd.c:        switch (sd->state) {
sd.c:            sd->erase_end = req.arg;
sd.c:        switch (sd->state) {
sd.c:            if (sd->csd[14] & 0x30) {
sd.c:                sd->card_status |= WP_VIOLATION;
sd.c:            sd->state = sd_programming_state;
sd.c:            sd->state = sd_transfer_state;
sd.c:        if (sd->spi)
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_receivingdata_state;
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        if (sd->rca != rca)
sd.c:        sd->card_status |= APP_CMD;
sd.c:        switch (sd->state) {
sd.c:            sd->data_offset = 0;
sd.c:                sd->state = sd_sendingdata_state;
sd.c:                sd->state = sd_receivingdata_state;
sd.c:        sd->card_status |= ILLEGAL_COMMAND;
sd.c:        sd->card_status |= ILLEGAL_COMMAND;
sd.c:    sd->card_status |= ILLEGAL_COMMAND;
sd.c:        switch (sd->state) {
sd.c:            sd->sd_status[0] &= 0x3f;
sd.c:            sd->sd_status[0] |= (req.arg & 0x03) << 6;
sd.c:        switch (sd->state) {
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        switch (sd->state) {
sd.c:            *(uint32_t *) sd->data = sd->blk_written;
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        switch (sd->state) {
sd.c:        if (sd->spi) {
sd.c:            sd->state = sd_transfer_state;
sd.c:        switch (sd->state) {
sd.c:                sd->state = sd_ready_state;
sd.c:        switch (sd->state) {
sd.c:            /* Bringing in the 50KOhm pull-up resistor... Done.  */
sd.c:        switch (sd->state) {
sd.c:            sd->state = sd_sendingdata_state;
sd.c:            sd->data_start = 0;
sd.c:            sd->data_offset = 0;
sd.c:        sd->card_status &= ~APP_CMD;
sd.c:    uint32_t last_status = sd->card_status;
sd.c:    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {
sd.c:        sd->card_status &= ~COM_CRC_ERROR;
sd.c:    sd->card_status &= ~CARD_STATUS_B;
sd.c:                                 req->cmd == 41) ||
sd.c:                         (sd_cmd_class[req->cmd] == 0 ||
sd.c:                          sd_cmd_class[req->cmd] == 7 ||
sd.c:                          req->cmd == 16 || req->cmd == 55))) {
sd.c:            sd->card_status |= ILLEGAL_COMMAND;
sd.c:        sd->card_status &= ~APP_CMD;
sd.c:    sd->current_cmd = req->cmd;
sd.c:        memcpy(response, sd->cid, sizeof(sd->cid));
sd.c:        memcpy(response, sd->csd, sizeof(sd->csd));
sd.c:    if (sd->card_status & ILLEGAL_COMMAND)
sd.c:        printf(" state %d\n", sd->state);
sd.c:        DPRINTF("No response %d\n", sd->state);
sd.c:    if (!sd->bdrv || bdrv_read(sd->bdrv, addr >> 9, sd->buf, 1) == -1) {
sd.c:        memcpy(sd->data, sd->buf + (addr & 511), 512 - (addr & 511));
sd.c:        if (bdrv_read(sd->bdrv, end >> 9, sd->buf, 1) == -1) {
sd.c:        memcpy(sd->data + 512 - (addr & 511), sd->buf, end & 511);
sd.c:        memcpy(sd->data, sd->buf + (addr & 511), len);
sd.c:        if (!sd->bdrv || bdrv_read(sd->bdrv, addr >> 9, sd->buf, 1) == -1) {
sd.c:        memcpy(sd->buf + (addr & 511), sd->data, 512 - (addr & 511));
sd.c:        if (bdrv_write(sd->bdrv, addr >> 9, sd->buf, 1) == -1) {
sd.c:        if (bdrv_read(sd->bdrv, end >> 9, sd->buf, 1) == -1) {
sd.c:        memcpy(sd->buf, sd->data + 512 - (addr & 511), end & 511);
sd.c:        if (bdrv_write(sd->bdrv, end >> 9, sd->buf, 1) == -1)
sd.c:        memcpy(sd->buf + (addr & 511), sd->data, len);
sd.c:        if (!sd->bdrv || bdrv_write(sd->bdrv, addr >> 9, sd->buf, 1) == -1)
sd.c:#define APP_READ_BLOCK(a, len)	memset(sd->data, 0xec, len)
sd.c:    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)
sd.c:    if (sd->state != sd_receivingdata_state) {
sd.c:        fprintf(stderr, "sd_write_data: not in Receiving-Data state\n");
sd.c:    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))
sd.c:    switch (sd->current_cmd) {
sd.c:        sd->data[sd->data_offset ++] = value;
sd.c:        if (sd->data_offset >= sd->blk_len) {
sd.c:            sd->state = sd_programming_state;
sd.c:            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);
sd.c:            sd->blk_written ++;
sd.c:            sd->csd[14] |= 0x40;
sd.c:            sd->state = sd_transfer_state;
sd.c:        sd->data[sd->data_offset ++] = value;
sd.c:        if (sd->data_offset >= sd->blk_len) {
sd.c:            sd->state = sd_programming_state;
sd.c:            BLK_WRITE_BLOCK(sd->data_start, sd->data_offset);
sd.c:            sd->blk_written ++;
sd.c:            sd->data_start += sd->blk_len;
sd.c:            sd->data_offset = 0;
sd.c:            if (sd->data_start + sd->blk_len > sd->size) {
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:            if (sd_wp_addr(sd, sd->data_start)) {
sd.c:                sd->card_status |= WP_VIOLATION;
sd.c:            sd->csd[14] |= 0x40;
sd.c:            sd->state = sd_receivingdata_state;
sd.c:        sd->data[sd->data_offset ++] = value;
sd.c:        if (sd->data_offset >= sizeof(sd->cid)) {
sd.c:            sd->state = sd_programming_state;
sd.c:            for (i = 0; i < sizeof(sd->cid); i ++)
sd.c:                if ((sd->cid[i] | 0x00) != sd->data[i])
sd.c:                    sd->card_status |= CID_CSD_OVERWRITE;
sd.c:            if (!(sd->card_status & CID_CSD_OVERWRITE))
sd.c:                for (i = 0; i < sizeof(sd->cid); i ++) {
sd.c:                    sd->cid[i] |= 0x00;
sd.c:                    sd->cid[i] &= sd->data[i];
sd.c:            sd->state = sd_transfer_state;
sd.c:        sd->data[sd->data_offset ++] = value;
sd.c:        if (sd->data_offset >= sizeof(sd->csd)) {
sd.c:            sd->state = sd_programming_state;
sd.c:            for (i = 0; i < sizeof(sd->csd); i ++)
sd.c:                if ((sd->csd[i] | sd_csd_rw_mask[i]) !=
sd.c:                    (sd->data[i] | sd_csd_rw_mask[i]))
sd.c:                    sd->card_status |= CID_CSD_OVERWRITE;
sd.c:            if (sd->csd[14] & ~sd->data[14] & 0x60)
sd.c:                sd->card_status |= CID_CSD_OVERWRITE;
sd.c:            if (!(sd->card_status & CID_CSD_OVERWRITE))
sd.c:                for (i = 0; i < sizeof(sd->csd); i ++) {
sd.c:                    sd->csd[i] |= sd_csd_rw_mask[i];
sd.c:                    sd->csd[i] &= sd->data[i];
sd.c:            sd->state = sd_transfer_state;
sd.c:        sd->data[sd->data_offset ++] = value;
sd.c:        if (sd->data_offset >= sd->blk_len) {
sd.c:            sd->state = sd_programming_state;
sd.c:            sd->state = sd_transfer_state;
sd.c:        sd->data[sd->data_offset ++] = value;
sd.c:        if (sd->data_offset >= sd->blk_len) {
sd.c:            APP_WRITE_BLOCK(sd->data_start, sd->data_offset);
sd.c:            sd->state = sd_transfer_state;
sd.c:    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable)
sd.c:    if (sd->state != sd_sendingdata_state) {
sd.c:        fprintf(stderr, "sd_read_data: not in Sending-Data state\n");
sd.c:    if (sd->card_status & (ADDRESS_ERROR | WP_VIOLATION))
sd.c:    io_len = (sd->ocr & (1 << 30)) ? 512 : sd->blk_len;
sd.c:    switch (sd->current_cmd) {
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= 64)
sd.c:            sd->state = sd_transfer_state;
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= 16)
sd.c:            sd->state = sd_transfer_state;
sd.c:        if (sd->data_offset == 0)
sd.c:            BLK_READ_BLOCK(sd->data_start, io_len);
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= io_len) {
sd.c:            sd->data_start += io_len;
sd.c:            sd->data_offset = 0;
sd.c:            if (sd->data_start + io_len > sd->size) {
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:        ret = sd->sd_status[sd->data_offset ++];
sd.c:        if (sd->data_offset >= sizeof(sd->sd_status))
sd.c:            sd->state = sd_transfer_state;
sd.c:        if (sd->data_offset == 0)
sd.c:            BLK_READ_BLOCK(sd->data_start, io_len);
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= io_len)
sd.c:            sd->state = sd_transfer_state;
sd.c:        if (sd->data_offset == 0)
sd.c:            BLK_READ_BLOCK(sd->data_start, io_len);
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= io_len) {
sd.c:            sd->data_start += io_len;
sd.c:            sd->data_offset = 0;
sd.c:            if (sd->data_start + io_len > sd->size) {
sd.c:                sd->card_status |= ADDRESS_ERROR;
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= 4)
sd.c:            sd->state = sd_transfer_state;
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= 4)
sd.c:            sd->state = sd_transfer_state;
sd.c:        ret = sd->scr[sd->data_offset ++];
sd.c:        if (sd->data_offset >= sizeof(sd->scr))
sd.c:            sd->state = sd_transfer_state;
sd.c:        if (sd->data_offset == 0)
sd.c:            APP_READ_BLOCK(sd->data_start, sd->blk_len);
sd.c:        ret = sd->data[sd->data_offset ++];
sd.c:        if (sd->data_offset >= sd->blk_len)
sd.c:            sd->state = sd_transfer_state;
sd.c:    return sd->state == sd_sendingdata_state;
sd.c:    sd->enable = enable;
sd.h:    sd_none = -1,
sd.h:    sd_bc = 0,	/* broadcast -- no response */
sd.h:    sd_ac,	/* addressed -- no data transfer */
serial.c: * Copyright (c) 2003-2004 Fabrice Bellard
serial.c:#include "qemu-char.h"
serial.c:#include "qemu-timer.h"
serial.c:#define UART_LSR_THRE	0x20	/* Transmit-hold-register empty */
serial.c:#define UART_LSR_INT_ANY 0x1E	/* Any of the lsr-interrupt-triggering status bits */
serial.c:/* Interrupt trigger levels. The byte-counts are for 16550A - in newer UARTs the byte-count for each ITL is higher. */
serial.c:    SerialFIFO *f = (fifo) ? &s->recv_fifo : &s->xmit_fifo;
serial.c:    memset(f->data, 0, UART_FIFO_LENGTH);
serial.c:    f->count = 0;
serial.c:    f->head = 0;
serial.c:    f->tail = 0;
serial.c:    SerialFIFO *f = (fifo) ? &s->recv_fifo : &s->xmit_fifo;
serial.c:    f->data[f->head++] = chr;
serial.c:    if (f->head == UART_FIFO_LENGTH)
serial.c:        f->head = 0;
serial.c:    f->count++;
serial.c:    SerialFIFO *f = (fifo) ? &s->recv_fifo : &s->xmit_fifo;
serial.c:    if(f->count == 0)
serial.c:    c = f->data[f->tail++];
serial.c:    if (f->tail == UART_FIFO_LENGTH)
serial.c:        f->tail = 0;
serial.c:    f->count--;
serial.c:    if ((s->ier & UART_IER_RLSI) && (s->lsr & UART_LSR_INT_ANY)) {
serial.c:    } else if ((s->ier & UART_IER_RDI) && s->timeout_ipending) {
serial.c:        /* Note that(s->ier & UART_IER_RDI) can mask this interrupt,
serial.c:    } else if ((s->ier & UART_IER_RDI) && (s->lsr & UART_LSR_DR) &&
serial.c:               (!(s->fcr & UART_FCR_FE) ||
serial.c:                s->recv_fifo.count >= s->recv_fifo.itl)) {
serial.c:    } else if ((s->ier & UART_IER_THRI) && s->thr_ipending) {
serial.c:    } else if ((s->ier & UART_IER_MSI) && (s->msr & UART_MSR_ANY_DELTA)) {
serial.c:    s->iir = tmp_iir | (s->iir & 0xF0);
serial.c:        qemu_irq_raise(s->irq);
serial.c:        qemu_irq_lower(s->irq);
serial.c:    if (s->divider == 0)
serial.c:    if (s->lcr & 0x08) {
serial.c:        if (s->lcr & 0x10)
serial.c:    if (s->lcr & 0x04)
serial.c:    data_bits = (s->lcr & 0x03) + 5;
serial.c:    speed = s->baudbase / s->divider;
serial.c:    s->char_transmit_time =  (get_ticks_per_sec() / speed) * frame_size;
serial.c:    qemu_chr_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_PARAMS, &ssp);
serial.c:    qemu_del_timer(s->modem_status_poll);
serial.c:    if (qemu_chr_ioctl(s->chr,CHR_IOCTL_SERIAL_GET_TIOCM, &flags) == -ENOTSUP) {
serial.c:        s->poll_msl = -1;
serial.c:    omsr = s->msr;
serial.c:    s->msr = (flags & CHR_TIOCM_CTS) ? s->msr | UART_MSR_CTS : s->msr & ~UART_MSR_CTS;
serial.c:    s->msr = (flags & CHR_TIOCM_DSR) ? s->msr | UART_MSR_DSR : s->msr & ~UART_MSR_DSR;
serial.c:    s->msr = (flags & CHR_TIOCM_CAR) ? s->msr | UART_MSR_DCD : s->msr & ~UART_MSR_DCD;
serial.c:    s->msr = (flags & CHR_TIOCM_RI) ? s->msr | UART_MSR_RI : s->msr & ~UART_MSR_RI;
serial.c:    if (s->msr != omsr) {
serial.c:         s->msr = s->msr | ((s->msr >> 4) ^ (omsr >> 4));
serial.c:         /* UART_MSR_TERI only if change was from 1 -> 0 */
serial.c:         if ((s->msr & UART_MSR_TERI) && !(omsr & UART_MSR_RI))
serial.c:             s->msr &= ~UART_MSR_TERI;
serial.c:    if (s->poll_msl)
serial.c:        qemu_mod_timer(s->modem_status_poll, qemu_get_clock(vm_clock) + get_ticks_per_sec() / 100);
serial.c:    if (s->tsr_retry <= 0) {
serial.c:        if (s->fcr & UART_FCR_FE) {
serial.c:            s->tsr = fifo_get(s,XMIT_FIFO);
serial.c:            if (!s->xmit_fifo.count)
serial.c:                s->lsr |= UART_LSR_THRE;
serial.c:            s->tsr = s->thr;
serial.c:            s->lsr |= UART_LSR_THRE;
serial.c:    if (s->mcr & UART_MCR_LOOP) {
serial.c:        serial_receive1(s, &s->tsr, 1);
serial.c:    } else if (qemu_chr_write(s->chr, &s->tsr, 1) != 1) {
serial.c:        if ((s->tsr_retry > 0) && (s->tsr_retry <= MAX_XMIT_RETRY)) {
serial.c:            s->tsr_retry++;
serial.c:            qemu_mod_timer(s->transmit_timer,  new_xmit_ts + s->char_transmit_time);
serial.c:        } else if (s->poll_msl < 0) {
serial.c:            s->tsr_retry = -1;
serial.c:        s->tsr_retry = 0;
serial.c:    s->last_xmit_ts = qemu_get_clock(vm_clock);
serial.c:    if (!(s->lsr & UART_LSR_THRE))
serial.c:        qemu_mod_timer(s->transmit_timer, s->last_xmit_ts + s->char_transmit_time);
serial.c:    if (s->lsr & UART_LSR_THRE) {
serial.c:        s->lsr |= UART_LSR_TEMT;
serial.c:        s->thr_ipending = 1;
serial.c:        if (s->lcr & UART_LCR_DLAB) {
serial.c:            s->divider = (s->divider & 0xff00) | val;
serial.c:            s->thr = (uint8_t) val;
serial.c:            if(s->fcr & UART_FCR_FE) {
serial.c:                  fifo_put(s, XMIT_FIFO, s->thr);
serial.c:            s->thr_ipending = 0;
serial.c:                  s->lsr &= ~UART_LSR_TEMT;
serial.c:            s->lsr &= ~UART_LSR_THRE;
serial.c:                  s->thr_ipending = 0;
serial.c:                  s->lsr &= ~UART_LSR_THRE;
serial.c:        if (s->lcr & UART_LCR_DLAB) {
serial.c:            s->divider = (s->divider & 0x00ff) | (val << 8);
serial.c:            s->ier = val & 0x0f;
serial.c:            if (s->poll_msl >= 0) {
serial.c:                if (s->ier & UART_IER_MSI) {
serial.c:                     s->poll_msl = 1;
serial.c:                     qemu_del_timer(s->modem_status_poll);
serial.c:                     s->poll_msl = 0;
serial.c:            if (s->lsr & UART_LSR_THRE) {
serial.c:                s->thr_ipending = 1;
serial.c:        if (s->fcr == val)
serial.c:        if ((val ^ s->fcr) & UART_FCR_FE)
serial.c:            qemu_del_timer(s->fifo_timeout_timer);
serial.c:            s->timeout_ipending=0;
serial.c:            s->iir |= UART_IIR_FE;
serial.c:                s->recv_fifo.itl = 1;
serial.c:                s->recv_fifo.itl = 4;
serial.c:                s->recv_fifo.itl = 8;
serial.c:                s->recv_fifo.itl = 14;
serial.c:            s->iir &= ~UART_IIR_FE;
serial.c:        /* Set fcr - or at least the bits in it that are supposed to "stick" */
serial.c:        s->fcr = val & 0xC9;
serial.c:            s->lcr = val;
serial.c:            if (break_enable != s->last_break_enable) {
serial.c:                s->last_break_enable = break_enable;
serial.c:                qemu_chr_ioctl(s->chr, CHR_IOCTL_SERIAL_SET_BREAK,
serial.c:            int old_mcr = s->mcr;
serial.c:            s->mcr = val & 0x1f;
serial.c:            if (s->poll_msl >= 0 && old_mcr != s->mcr) {
serial.c:                qemu_chr_ioctl(s->chr,CHR_IOCTL_SERIAL_GET_TIOCM, &flags);
serial.c:                qemu_chr_ioctl(s->chr,CHR_IOCTL_SERIAL_SET_TIOCM, &flags);
serial.c:                /* Update the modem status after a one-character-send wait-time, since there may be a response
serial.c:                qemu_mod_timer(s->modem_status_poll, qemu_get_clock(vm_clock) + s->char_transmit_time);
serial.c:        s->scr = val;
serial.c:        if (s->lcr & UART_LCR_DLAB) {
serial.c:            ret = s->divider & 0xff;
serial.c:            if(s->fcr & UART_FCR_FE) {
serial.c:                if (s->recv_fifo.count == 0)
serial.c:                    s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);
serial.c:                    qemu_mod_timer(s->fifo_timeout_timer, qemu_get_clock (vm_clock) + s->char_transmit_time * 4);
serial.c:                s->timeout_ipending = 0;
serial.c:                ret = s->rbr;
serial.c:                s->lsr &= ~(UART_LSR_DR | UART_LSR_BI);
serial.c:            if (!(s->mcr & UART_MCR_LOOP)) {
serial.c:                qemu_chr_accept_input(s->chr);
serial.c:        if (s->lcr & UART_LCR_DLAB) {
serial.c:            ret = (s->divider >> 8) & 0xff;
serial.c:            ret = s->ier;
serial.c:        ret = s->iir;
serial.c:            s->thr_ipending = 0;
serial.c:        ret = s->lcr;
serial.c:        ret = s->mcr;
serial.c:        ret = s->lsr;
serial.c:        if (s->lsr & UART_LSR_BI) {
serial.c:            s->lsr &= ~UART_LSR_BI;
serial.c:        if (s->mcr & UART_MCR_LOOP) {
serial.c:            ret = (s->mcr & 0x0c) << 4;
serial.c:            ret |= (s->mcr & 0x02) << 3;
serial.c:            ret |= (s->mcr & 0x01) << 5;
serial.c:            if (s->poll_msl >= 0)
serial.c:            ret = s->msr;
serial.c:            if (s->msr & UART_MSR_ANY_DELTA) {
serial.c:                s->msr &= 0xF0;
serial.c:        ret = s->scr;
serial.c:    if(s->fcr & UART_FCR_FE) {
serial.c:        if(s->recv_fifo.count < UART_FIFO_LENGTH)
serial.c:        /* Advertise (fifo.itl - fifo.count) bytes when count < ITL, and 1 if above. If UART_FIFO_LENGTH - fifo.count is
serial.c:             return (s->recv_fifo.count <= s->recv_fifo.itl) ? s->recv_fifo.itl - s->recv_fifo.count : 1;
serial.c:    return !(s->lsr & UART_LSR_DR);
serial.c:    s->rbr = 0;
serial.c:    s->lsr |= UART_LSR_BI | UART_LSR_DR;
serial.c:/* There's data in recv_fifo and s->rbr has not been read for 4 char transmit times */
serial.c:    if (s->recv_fifo.count) {
serial.c:        s->timeout_ipending = 1;
serial.c:    if(s->fcr & UART_FCR_FE) {
serial.c:        s->lsr |= UART_LSR_DR;
serial.c:        qemu_mod_timer(s->fifo_timeout_timer, qemu_get_clock (vm_clock) + s->char_transmit_time * 4);
serial.c:        s->rbr = buf[0];
serial.c:        s->lsr |= UART_LSR_DR;
serial.c:    s->fcr_vmstate = s->fcr;
serial.c:        s->fcr_vmstate = 0;
serial.c:    /* Initialize fcr via setter to perform essential side-effects */
serial.c:    serial_ioport_write(s, 0x02, s->fcr_vmstate);
serial.c:    s->rbr = 0;
serial.c:    s->ier = 0;
serial.c:    s->iir = UART_IIR_NO_INT;
serial.c:    s->lcr = 0;
serial.c:    s->lsr = UART_LSR_TEMT | UART_LSR_THRE;
serial.c:    s->msr = UART_MSR_DCD | UART_MSR_DSR | UART_MSR_CTS;
serial.c:    s->divider = 0x0C;
serial.c:    s->mcr = UART_MCR_OUT2;
serial.c:    s->scr = 0;
serial.c:    s->tsr_retry = 0;
serial.c:    s->char_transmit_time = (get_ticks_per_sec() / 9600) * 10;
serial.c:    s->poll_msl = 0;
serial.c:    s->last_xmit_ts = qemu_get_clock(vm_clock);
serial.c:    s->thr_ipending = 0;
serial.c:    s->last_break_enable = 0;
serial.c:    qemu_irq_lower(s->irq);
serial.c:    if (!s->chr) {
serial.c:    s->modem_status_poll = qemu_new_timer(vm_clock, (QEMUTimerCB *) serial_update_msl, s);
serial.c:    s->fifo_timeout_timer = qemu_new_timer(vm_clock, (QEMUTimerCB *) fifo_timeout_int, s);
serial.c:    s->transmit_timer = qemu_new_timer(vm_clock, (QEMUTimerCB *) serial_xmit, s);
serial.c:    qemu_chr_add_handlers(s->chr, serial_can_receive1, serial_receive1,
serial.c:    s->baudbase = frequency;
serial.c:    SerialState *s = &isa->state;
serial.c:    if (isa->index == -1)
serial.c:        isa->index = index;
serial.c:    if (isa->index >= MAX_SERIAL_PORTS)
serial.c:        return -1;
serial.c:    if (isa->iobase == -1)
serial.c:        isa->iobase = isa_serial_io[isa->index];
serial.c:    if (isa->isairq == -1)
serial.c:        isa->isairq = isa_serial_irq[isa->index];
serial.c:    s->baudbase = 115200;
serial.c:    isa_init_irq(dev, &s->irq, isa->isairq);
serial.c:    vmstate_register(isa->iobase, &vmstate_serial, s);
serial.c:    register_ioport_write(isa->iobase, 8, 1, serial_ioport_write, s);
serial.c:    register_ioport_read(isa->iobase, 8, 1, serial_ioport_read, s);
serial.c:    dev = isa_create("isa-serial");
serial.c:    qdev_prop_set_uint32(&dev->qdev, "index", index);
serial.c:    qdev_prop_set_chr(&dev->qdev, "chardev", chr);
serial.c:    if (qdev_init(&dev->qdev) < 0)
serial.c:    return &DO_UPCAST(ISASerialState, dev, dev)->state;
serial.c:    s->irq = irq;
serial.c:    s->baudbase = baudbase;
serial.c:    s->chr = chr;
serial.c:    return serial_ioport_read(s, addr >> s->it_shift) & 0xFF;
serial.c:    serial_ioport_write(s, addr >> s->it_shift, value & 0xFF);
serial.c:    val = serial_ioport_read(s, addr >> s->it_shift) & 0xFFFF;
serial.c:    serial_ioport_write(s, addr >> s->it_shift, value & 0xFFFF);
serial.c:    val = serial_ioport_read(s, addr >> s->it_shift);
serial.c:    serial_ioport_write(s, addr >> s->it_shift, value);
serial.c:    s->it_shift = it_shift;
serial.c:    s->irq = irq;
serial.c:    s->baudbase = baudbase;
serial.c:    s->chr = chr;
serial.c:    .qdev.name  = "isa-serial",
serial.c:        DEFINE_PROP_UINT32("index", ISASerialState, index,   -1),
serial.c:        DEFINE_PROP_HEX32("iobase", ISASerialState, iobase,  -1),
serial.c:        DEFINE_PROP_UINT32("irq",   ISASerialState, isairq,  -1),
sh7750.c:#include "exec-all.h"
sh7750.c:	return (s->cpu->features & SH_FEATURE_BCR3_AND_BCR4);
sh7750.c:	if (s->devices[i] == NULL) {
sh7750.c:	    s->devices[i] = device;
sh7750.c:    return -1;
sh7750.c:    return (s->portdira & s->pdtra) |	/* CPU */
sh7750.c:	(s->periph_portdira & s->periph_pdtra) |	/* Peripherals */
sh7750.c:	(~(s->portdira | s->periph_portdira) & s->portpullupa);	/* Pullups */
sh7750.c:    return (s->portdirb & s->pdtrb) |	/* CPU */
sh7750.c:	(s->periph_portdirb & s->periph_pdtrb) |	/* Peripherals */
sh7750.c:	(~(s->portdirb | s->periph_portdirb) & s->portpullupb);	/* Pullups */
sh7750.c:    fprintf(stderr, "pdtra=0x%04x, pctra=0x%08x\n", s->pdtra, s->pctra);
sh7750.c:	if (s->devices[i] && (s->devices[i]->portamask_trigger & changes)) {
sh7750.c:	    r |= s->devices[i]->port_change_cb(currenta, portb_lines(s),
sh7750.c:					       &s->periph_pdtra,
sh7750.c:					       &s->periph_portdira,
sh7750.c:					       &s->periph_pdtrb,
sh7750.c:					       &s->periph_portdirb);
sh7750.c:	if (s->devices[i] && (s->devices[i]->portbmask_trigger & changes)) {
sh7750.c:	    r |= s->devices[i]->port_change_cb(portb_lines(s), currentb,
sh7750.c:					       &s->periph_pdtra,
sh7750.c:					       &s->periph_portdira,
sh7750.c:					       &s->periph_pdtrb,
sh7750.c:					       &s->periph_portdirb);
sh7750.c:	return s->bcr2;
sh7750.c:	return s->bcr3;
sh7750.c:	return s->pcr;
sh7750.c:	return s->rfcr++;
sh7750.c:	return s->bcr1;
sh7750.c:	return s->bcr4;
sh7750.c:	return s->cpu->mmucr;
sh7750.c:	return s->cpu->pteh;
sh7750.c:	return s->cpu->ptel;
sh7750.c:	return s->cpu->ttb;
sh7750.c:	return s->cpu->tea;
sh7750.c:	return s->cpu->tra;
sh7750.c:	return s->cpu->expevt;
sh7750.c:	return s->cpu->intevt;
sh7750.c:	return s->ccr;
sh7750.c:	return s->cpu->pvr;
sh7750.c:	return s->cpu->cvr;
sh7750.c:	return s->cpu->prr;
sh7750.c:        s->bcr2 = mem_value;
sh7750.c:	s->bcr3 = mem_value;
sh7750.c:	s->pcr = mem_value;
sh7750.c:	s->pdtra = mem_value;
sh7750.c:	s->pdtrb = mem_value;
sh7750.c:	s->rfcr = mem_value;
sh7750.c:	s->gpioic = mem_value;
sh7750.c:        s->bcr1 = mem_value;
sh7750.c:	s->bcr4 = mem_value;
sh7750.c:	s->pctra = mem_value;
sh7750.c:	s->portdira = portdir(mem_value);
sh7750.c:	s->portpullupa = portpullup(mem_value);
sh7750.c:	s->pctrb = mem_value;
sh7750.c:	s->portdirb = portdir(mem_value);
sh7750.c:	s->portpullupb = portpullup(mem_value);
sh7750.c:	s->cpu->mmucr = mem_value;
sh7750.c:	if ((s->cpu->pteh & 0xff) != (mem_value & 0xff))
sh7750.c:	    tlb_flush(s->cpu, 1);
sh7750.c:	s->cpu->pteh = mem_value;
sh7750.c:	s->cpu->ptel = mem_value;
sh7750.c:	s->cpu->ptea = mem_value & 0x0000000f;
sh7750.c:	s->cpu->ttb = mem_value;
sh7750.c:	s->cpu->tea = mem_value;
sh7750.c:	s->cpu->tra = mem_value & 0x000007ff;
sh7750.c:	s->cpu->expevt = mem_value & 0x000007ff;
sh7750.c:	s->cpu->intevt = mem_value & 0x000007ff;
sh7750.c:	s->ccr = mem_value;
sh7750.c: * stolen from linux/arch/sh/kernel/cpu/sh4/setup-sh7750.c
sh7750.c:/* SH7750, SH7750S, SH7751 and SH7091 all have 4-channel DMA controllers */
sh7750.c:/* SH7750R and SH7751R both have 8-channel DMA controllers */
sh7750.c:        cpu_sh4_write_mmaped_utlb_addr(s->cpu, addr, mem_value);
sh7750.c:    s->cpu = cpu;
sh7750.c:    s->periph_freq = 60000000;	/* 60MHz */
sh7750.c:    sh_intc_init(&s->intc, NR_SOURCES,
sh7750.c:    sh_intc_register_sources(&s->intc,
sh7750.c:    cpu->intc_handle = &s->intc;
sh7750.c:    sh_serial_init(0x1fe00000, 0, s->periph_freq, serial_hds[0],
sh7750.c:		   s->intc.irqs[SCI1_ERI],
sh7750.c:		   s->intc.irqs[SCI1_RXI],
sh7750.c:		   s->intc.irqs[SCI1_TXI],
sh7750.c:		   s->intc.irqs[SCI1_TEI],
sh7750.c:		   s->periph_freq, serial_hds[1],
sh7750.c:		   s->intc.irqs[SCIF_ERI],
sh7750.c:		   s->intc.irqs[SCIF_RXI],
sh7750.c:		   s->intc.irqs[SCIF_TXI],
sh7750.c:		   s->intc.irqs[SCIF_BRI]);
sh7750.c:		s->periph_freq,
sh7750.c:		s->intc.irqs[TMU0],
sh7750.c:		s->intc.irqs[TMU1],
sh7750.c:		s->intc.irqs[TMU2_TUNI],
sh7750.c:		s->intc.irqs[TMU2_TICPI]);
sh7750.c:    if (cpu->id & (SH_CPU_SH7750 | SH_CPU_SH7750S | SH_CPU_SH7751)) {
sh7750.c:        sh_intc_register_sources(&s->intc,
sh7750.c:    if (cpu->id & (SH_CPU_SH7750R | SH_CPU_SH7751R)) {
sh7750.c:        sh_intc_register_sources(&s->intc,
sh7750.c:    if (cpu->id & (SH_CPU_SH7750R | SH_CPU_SH7751 | SH_CPU_SH7751R)) {
sh7750.c:        sh_intc_register_sources(&s->intc,
sh7750.c:        tmu012_init(0x1e100000, 0, s->periph_freq,
sh7750.c:		    s->intc.irqs[TMU3],
sh7750.c:		    s->intc.irqs[TMU4],
sh7750.c:    if (cpu->id & (SH_CPU_SH7751_ALL)) {
sh7750.c:        sh_intc_register_sources(&s->intc,
sh7750.c:    if (cpu->id & (SH_CPU_SH7750S | SH_CPU_SH7750R | SH_CPU_SH7751_ALL)) {
sh7750.c:        sh_intc_register_sources(&s->intc,
sh7750.c:    sh_intc_register_sources(&s->intc,
sh7750.c:    sh_intc_toggle_source(sh_intc_source(&s->intc, IRL), 1, 0); /* enable */
sh7750.c:    return qemu_allocate_irqs(sh_intc_set_irl, sh_intc_source(&s->intc, IRL),
sh7750_regnames.c:	REGNAME(SH7750_SDMR3_A7) {(uint32_t) - 1, NULL}
sh7750_regnames.c:    for (i = 0; regnames[i].regaddr != (uint32_t) - 1; i++) {
sh7750_regs.h: * SH-7750 memory-mapped registers
sh7750_regs.h: *  Document Number ADE-602-124C, Rev. 4.0, 4/21/00, Hitachi Ltd.
sh7750_regs.h: * Copyright (C) 2001 OKTET Ltd., St.-Petersburg, Russia
sh7750_regs.h: * All register has 2 addresses: in 0xff000000 - 0xffffffff (P4 address)  and
sh7750_regs.h: * in 0x1f000000 - 0x1fffffff (area 7 address)
sh7750_regs.h:/* Page Table Entry High register - PTEH */
sh7750_regs.h:/* Page Table Entry Low register - PTEL */
sh7750_regs.h:#define SH7750_PTEL_V         0x00000100	/* Validity (0-entry is invalid) */
sh7750_regs.h:#define SH7750_PTEL_SZ_1KB    0x00000000	/*   1-kbyte page */
sh7750_regs.h:#define SH7750_PTEL_SZ_4KB    0x00000010	/*   4-kbyte page */
sh7750_regs.h:#define SH7750_PTEL_SZ_64KB   0x00000080	/*   64-kbyte page */
sh7750_regs.h:#define SH7750_PTEL_SZ_1MB    0x00000090	/*   1-Mbyte page */
sh7750_regs.h:#define SH7750_PTEL_PR_ROPO   0x00000000	/*   read-only in priv mode */
sh7750_regs.h:#define SH7750_PTEL_PR_RWPO   0x00000020	/*   read-write in priv mode */
sh7750_regs.h:#define SH7750_PTEL_PR_ROPU   0x00000040	/*   read-only in priv or user mode */
sh7750_regs.h:#define SH7750_PTEL_PR_RWPU   0x00000060	/*   read-write in priv or user mode */
sh7750_regs.h:						   (0 - page not cacheable) */
sh7750_regs.h:#define SH7750_PTEL_D         0x00000004	/* Dirty bit (1 - write has been
sh7750_regs.h:#define SH7750_PTEL_SH        0x00000002	/* Share Status bit (1 - page are
sh7750_regs.h:#define SH7750_PTEL_WT        0x00000001	/* Write-through bit, specifies the
sh7750_regs.h:						   0 - Copy-back mode
sh7750_regs.h:						   1 - Write-through mode */
sh7750_regs.h:/* Page Table Entry Assistance register - PTEA */
sh7750_regs.h:						   0 - use area 5 wait states
sh7750_regs.h:						   1 - use area 6 wait states */
sh7750_regs.h:#define SH7750_PTEA_SA_UNDEF  0x00000000	/*    0 - undefined */
sh7750_regs.h:#define SH7750_PTEA_SA_IOVAR  0x00000001	/*    1 - variable-size I/O space */
sh7750_regs.h:#define SH7750_PTEA_SA_IO8    0x00000002	/*    2 - 8-bit I/O space */
sh7750_regs.h:#define SH7750_PTEA_SA_IO16   0x00000003	/*    3 - 16-bit I/O space */
sh7750_regs.h:#define SH7750_PTEA_SA_CMEM8  0x00000004	/*    4 - 8-bit common memory space */
sh7750_regs.h:#define SH7750_PTEA_SA_CMEM16 0x00000005	/*    5 - 16-bit common memory space */
sh7750_regs.h:#define SH7750_PTEA_SA_AMEM8  0x00000006	/*    6 - 8-bit attr memory space */
sh7750_regs.h:#define SH7750_PTEA_SA_AMEM16 0x00000007	/*    7 - 16-bit attr memory space */
sh7750_regs.h:/* TLB exeption address register - TEA */
sh7750_regs.h:/* MMU control register - MMUCR */
sh7750_regs.h: *   IC -- instructions cache
sh7750_regs.h: *   OC -- operand cache
sh7750_regs.h:/* Cache Control Register - CCR */
sh7750_regs.h:#define SH7750_CCR_CB       0x00000004	/* Copy-back bit for P1 area */
sh7750_regs.h:#define SH7750_CCR_WT       0x00000002	/* Write-through bit for P0,U0,P3 area */
sh7750_regs.h:/* Queue address control register 0 - QACR0 */
sh7750_regs.h:/* Queue address control register 1 - QACR1 */
sh7750_regs.h: * Exeption-related registers
sh7750_regs.h:/* Immediate data for TRAPA instuction - TRA */
sh7750_regs.h:/* Exeption event register - EXPEVT */
sh7750_regs.h:#define SH7750_EVT_POWER_ON_RST        0x000	/* Power-on reset */
sh7750_regs.h:#define SH7750_EVT_TLB_MULT_HIT        0x140	/* TLB multiple-hit exception */
sh7750_regs.h:#define SH7750_EVT_NMI                 0x1C0	/* Non-maskable interrupt */
sh7750_regs.h:/* Peripheral Module Interrupts - Timer Unit (TMU) */
sh7750_regs.h:/* Peripheral Module Interrupts - Real-Time Clock (RTC) */
sh7750_regs.h:/* Peripheral Module Interrupts - Serial Communication Interface (SCI) */
sh7750_regs.h:/* Peripheral Module Interrupts - Watchdog Timer (WDT) */
sh7750_regs.h:/* Peripheral Module Interrupts - Memory Refresh Unit (REF) */
sh7750_regs.h:#define SH7750_EVT_REF_RCMI            0x580	/* Compare-match Interrupt */
sh7750_regs.h:/* Peripheral Module Interrupts - Hitachi User Debug Interface (H-UDI) */
sh7750_regs.h:/* Peripheral Module Interrupts - General-Purpose I/O (GPIO) */
sh7750_regs.h:/* Peripheral Module Interrupts - DMA Controller (DMAC) */
sh7750_regs.h:/* Peripheral Module Interrupts - Serial Communication Interface with FIFO */
sh7750_regs.h:					   0 - Transition to SLEEP mode on SLEEP
sh7750_regs.h:					   1 - Transition to STANDBY mode on SLEEP */
sh7750_regs.h:					   0 - normal state
sh7750_regs.h:					   1 - high-impendance state */
sh7750_regs.h:#define SH7750_STBCR_PPU      0x20	/* Peripheral module pins pull-up controls */
sh7750_regs.h:					   0 - transition to sleep or standby mode
sh7750_regs.h:					   1 - transition to deep sleep mode on
sh7750_regs.h:					   0 - CKIO pin goes to HiZ/pullup
sh7750_regs.h:					   1 - Clock is output from CKIO */
sh7750_regs.h:#define SH7750_FRQCR_IFCDIV1  0x0000	/*    0 - * 1 */
sh7750_regs.h:#define SH7750_FRQCR_IFCDIV2  0x0040	/*    1 - * 1/2 */
sh7750_regs.h:#define SH7750_FRQCR_IFCDIV3  0x0080	/*    2 - * 1/3 */
sh7750_regs.h:#define SH7750_FRQCR_IFCDIV4  0x00C0	/*    3 - * 1/4 */
sh7750_regs.h:#define SH7750_FRQCR_IFCDIV6  0x0100	/*    4 - * 1/6 */
sh7750_regs.h:#define SH7750_FRQCR_IFCDIV8  0x0140	/*    5 - * 1/8 */
sh7750_regs.h:#define SH7750_FRQCR_BFCDIV1  0x0000	/*    0 - * 1 */
sh7750_regs.h:#define SH7750_FRQCR_BFCDIV2  0x0008	/*    1 - * 1/2 */
sh7750_regs.h:#define SH7750_FRQCR_BFCDIV3  0x0010	/*    2 - * 1/3 */
sh7750_regs.h:#define SH7750_FRQCR_BFCDIV4  0x0018	/*    3 - * 1/4 */
sh7750_regs.h:#define SH7750_FRQCR_BFCDIV6  0x0020	/*    4 - * 1/6 */
sh7750_regs.h:#define SH7750_FRQCR_BFCDIV8  0x0028	/*    5 - * 1/8 */
sh7750_regs.h:#define SH7750_FRQCR_PFCDIV2  0x0000	/*    0 - * 1/2 */
sh7750_regs.h:#define SH7750_FRQCR_PFCDIV3  0x0001	/*    1 - * 1/3 */
sh7750_regs.h:#define SH7750_FRQCR_PFCDIV4  0x0002	/*    2 - * 1/4 */
sh7750_regs.h:#define SH7750_FRQCR_PFCDIV6  0x0003	/*    3 - * 1/6 */
sh7750_regs.h:#define SH7750_FRQCR_PFCDIV8  0x0004	/*    4 - * 1/8 */
sh7750_regs.h:/* Watchdog Timer Counter register - WTCNT */
sh7750_regs.h:/* Watchdog Timer Control/Status register - WTCSR */
sh7750_regs.h:#define SH7750_WTCSR_TME      0x80	/* Timer enable (1-upcount start) */
sh7750_regs.h:#define SH7750_WTCSR_RST_PWR  0x00	/*    Power-on Reset */
sh7750_regs.h: * Real-Time Clock (RTC)
sh7750_regs.h:/* 64-Hz Counter Register (byte, read-only) - R64CNT */
sh7750_regs.h:/* Second Counter Register (byte, BCD-coded) - RSECCNT */
sh7750_regs.h:/* Minute Counter Register (byte, BCD-coded) - RMINCNT */
sh7750_regs.h:/* Hour Counter Register (byte, BCD-coded) - RHRCNT */
sh7750_regs.h:/* Day-of-Week Counter Register (byte) - RWKCNT */
sh7750_regs.h:/* Day Counter Register (byte, BCD-coded) - RDAYCNT */
sh7750_regs.h:/* Month Counter Register (byte, BCD-coded) - RMONCNT */
sh7750_regs.h:/* Year Counter Register (half, BCD-coded) - RYRCNT */
sh7750_regs.h:/* Second Alarm Register (byte, BCD-coded) - RSECAR */
sh7750_regs.h:/* Minute Alarm Register (byte, BCD-coded) - RMINAR */
sh7750_regs.h:/* Hour Alarm Register (byte, BCD-coded) - RHRAR */
sh7750_regs.h:/* Day-of-Week Alarm Register (byte) - RWKAR */
sh7750_regs.h:#define SH7750_RWKAR_ENB      0x80	/* Day-of-week Alarm Enable */
sh7750_regs.h:/* Day Alarm Register (byte, BCD-coded) - RDAYAR */
sh7750_regs.h:/* Month Counter Register (byte, BCD-coded) - RMONAR */
sh7750_regs.h:/* RTC Control Register 1 (byte) - RCR1 */
sh7750_regs.h:/* RTC Control Register 2 (byte) - RCR2 */
sh7750_regs.h:#define SH7750_RCR2_ADJ        0x04	/* 30-Second Adjastment */
sh7750_regs.h:#define SH7750_RCR2_START      0x01	/* 0 - sec, min, hr, day-of-week, month,
sh7750_regs.h:					   1 - sec, min, hr, day-of-week, month,
sh7750_regs.h: * Bus State Controller - BSC
sh7750_regs.h:/* Bus Control Register 1 - BCR1 */
sh7750_regs.h:#define SH7750_BCR1_ENDIAN    0x80000000	/* Endianness (1 - little endian) */
sh7750_regs.h:#define SH7750_BCR1_MASTER    0x40000000	/* Master/Slave mode (1-master) */
sh7750_regs.h:#define SH7750_BCR1_A0MPX     0x20000000	/* Area 0 Memory Type (0-SRAM,1-MPX) */
sh7750_regs.h:#define SH7750_BCR1_IPUP      0x02000000	/* Input Pin Pull-up Control:
sh7750_regs.h:						   0 - pull-up resistor is on for
sh7750_regs.h:						   1 - pull-up resistor is off */
sh7750_regs.h:#define SH7750_BCR1_OPUP      0x01000000	/* Output Pin Pull-up Control:
sh7750_regs.h:						   0 - pull-up resistor is on for
sh7750_regs.h:						   1 - pull-up resistor is off */
sh7750_regs.h:						   0 - Area 1 SRAM is set to
sh7750_regs.h:						   1 - Area 1 SRAM is set to byte
sh7750_regs.h:						   0 - Area 4 SRAM is set to
sh7750_regs.h:						   1 - Area 4 SRAM is set to byte
sh7750_regs.h:						   0 - External requests are  not
sh7750_regs.h:						   1 - External requests are
sh7750_regs.h:						   0 - Master Mode
sh7750_regs.h:						   1 - Partial-sharing Mode */
sh7750_regs.h:						   0 - SRAM/burst ROM interface
sh7750_regs.h:						   1 - MPX interface */
sh7750_regs.h:						   0 - signals go to High-Z mode
sh7750_regs.h:						   1 - signals driven */
sh7750_regs.h:						   0 - signals go to High-Z mode
sh7750_regs.h:						   1 - signals driven */
sh7750_regs.h:#define SH7750_BCR1_DRAMTP_2SRAM_3SDRAM  0x0008	/* Area 2 - SRAM/MPX, Area 3 -
sh7750_regs.h:#define SH7750_BCR1_DRAMTP_2SRAM_3DRAM   0x0010	/* Area 2 - SRAM/MPX, Area 3 -
sh7750_regs.h:						   0 - SRAM interface
sh7750_regs.h:						   1 - PCMCIA interface */
sh7750_regs.h:/* Bus Control Register 2 (half) - BCR2 */
sh7750_regs.h:					   0 - D51-D32 are not used as a port
sh7750_regs.h:					   1 - D51-D32 are used as a port */
sh7750_regs.h:/* Wait Control Register 1 - WCR1 */
sh7750_regs.h:#define SH7750_WCR1_DMAIW     0x70000000	/* DACK Device Inter-Cycle Idle
sh7750_regs.h:#define SH7750_WCR1_A6IW      0x07000000	/* Area 6 Inter-Cycle Idle spec. */
sh7750_regs.h:#define SH7750_WCR1_A5IW      0x00700000	/* Area 5 Inter-Cycle Idle spec. */
sh7750_regs.h:#define SH7750_WCR1_A4IW      0x00070000	/* Area 4 Inter-Cycle Idle spec. */
sh7750_regs.h:#define SH7750_WCR1_A3IW      0x00007000	/* Area 3 Inter-Cycle Idle spec. */
sh7750_regs.h:#define SH7750_WCR1_A2IW      0x00000700	/* Area 2 Inter-Cycle Idle spec. */
sh7750_regs.h:#define SH7750_WCR1_A1IW      0x00000070	/* Area 1 Inter-Cycle Idle spec. */
sh7750_regs.h:#define SH7750_WCR1_A0IW      0x00000007	/* Area 0 Inter-Cycle Idle spec. */
sh7750_regs.h:/* Wait Control Register 2 - WCR2 */
sh7750_regs.h:/* Wait Control Register 3 - WCR3 */
sh7750_regs.h:#define SH7750_MCR_RCD        0x00030000	/* DRAM: RAS-CAS Assertion Delay time
sh7750_regs.h:						   SDRAM: bank active-read/write cmd
sh7750_regs.h:#define SH7750_MCR_TRAS       0x00001C00	/* DRAM: CAS-Before-RAS Refresh RAS
sh7750_regs.h:#define SH7750_MCR_AMX_DRAM_8BIT_COL    0x00000000	/* 8-bit column addr */
sh7750_regs.h:#define SH7750_MCR_AMX_DRAM_9BIT_COL    0x00000008	/* 9-bit column addr */
sh7750_regs.h:#define SH7750_MCR_AMX_DRAM_10BIT_COL   0x00000010	/* 10-bit column addr */
sh7750_regs.h:#define SH7750_MCR_AMX_DRAM_11BIT_COL   0x00000018	/* 11-bit column addr */
sh7750_regs.h:#define SH7750_MCR_AMX_DRAM_12BIT_COL   0x00000020	/* 12-bit column addr */
sh7750_regs.h:#define SH7750_MCR_RMODE_SELF   0x00000002	/* Self-Refresh Mode */
sh7750_regs.h:/* PCMCIA Control Register (half) - PCR */
sh7750_regs.h:#define SH7750_PCR_A5PCW      0xC000	/* Area 5 PCMCIA Wait - Number of wait
sh7750_regs.h:					   waits specified by WCR2 in a low-speed
sh7750_regs.h:#define SH7750_PCR_A6PCW      0x3000	/* Area 6 PCMCIA Wait - Number of wait
sh7750_regs.h:					   waits specified by WCR2 in a low-speed
sh7750_regs.h:#define SH7750_PCR_A5TED      0x0E00	/* Area 5 Address-OE\/WE\ Assertion Delay,
sh7750_regs.h:#define SH7750_PCR_A6TED      0x01C0	/* Area 6 Address-OE\/WE\ Assertion Delay */
sh7750_regs.h:/* Refresh Timer Control/Status Register (half) - RTSCR */
sh7750_regs.h:#define SH7750_RTCSR_CMF      0x0080	/* Compare-Match Flag (indicates a
sh7750_regs.h:#define SH7750_RTCSR_CMIE     0x0040	/* Compare-Match Interrupt Enable */
sh7750_regs.h:/* Refresh Timer Counter (half) - RTCNT */
sh7750_regs.h:/* Refresh Time Constant Register (half) - RTCOR */
sh7750_regs.h:/* Refresh Count Register (half) - RFCR */
sh7750_regs.h:/* Synchronous DRAM mode registers - SDMR */
sh7750_regs.h:/* DMA Source Address Register - SAR0, SAR1, SAR2, SAR3 */
sh7750_regs.h:/* DMA Destination Address Register - DAR0, DAR1, DAR2, DAR3 */
sh7750_regs.h:/* DMA Transfer Count Register - DMATCR0, DMATCR1, DMATCR2, DMATCR3 */
sh7750_regs.h:/* DMA Channel Control Register - CHCR0, CHCR1, CHCR2, CHCR3 */
sh7750_regs.h:#define SH7750_CHCR_SSA_IO8     0x40000000	/* 8-bit I/O space */
sh7750_regs.h:#define SH7750_CHCR_SSA_IO16    0x60000000	/* 16-bit I/O space */
sh7750_regs.h:#define SH7750_CHCR_SSA_CMEM8   0x80000000	/* 8-bit common memory space */
sh7750_regs.h:#define SH7750_CHCR_SSA_CMEM16  0xA0000000	/* 16-bit common memory space */
sh7750_regs.h:#define SH7750_CHCR_SSA_AMEM8   0xC0000000	/* 8-bit attribute memory space */
sh7750_regs.h:#define SH7750_CHCR_SSA_AMEM16  0xE0000000	/* 16-bit attribute memory space */
sh7750_regs.h:#define SH7750_CHCR_DSA_IO8     0x04000000	/* 8-bit I/O space */
sh7750_regs.h:#define SH7750_CHCR_DSA_IO16    0x06000000	/* 16-bit I/O space */
sh7750_regs.h:#define SH7750_CHCR_DSA_CMEM8   0x08000000	/* 8-bit common memory space */
sh7750_regs.h:#define SH7750_CHCR_DSA_CMEM16  0x0A000000	/* 16-bit common memory space */
sh7750_regs.h:#define SH7750_CHCR_DSA_AMEM8   0x0C000000	/* 8-bit attribute memory space */
sh7750_regs.h:#define SH7750_CHCR_DSA_AMEM16  0x0E000000	/* 16-bit attribute memory space */
sh7750_regs.h:						   Mode (External Addr Space->
sh7750_regs.h:						   Space -> External Device) */
sh7750_regs.h:						   Device -> External Addr
sh7750_regs.h:#define SH7750_CHCR_RS_AR_EA_TO_EA      0x400	/* Auto-Request (External Addr
sh7750_regs.h:						   Space -> External Addr Space) */
sh7750_regs.h:#define SH7750_CHCR_RS_AR_EA_TO_OCP     0x500	/* Auto-Request (External Addr
sh7750_regs.h:						   Space -> On-chip Peripheral
sh7750_regs.h:#define SH7750_CHCR_RS_AR_OCP_TO_EA     0x600	/* Auto-Request (On-chip
sh7750_regs.h:						   Peripheral Module ->
sh7750_regs.h:#define SH7750_CHCR_RS_SCITX_EA_TO_SC   0x800	/* SCI Transmit-Data-Empty intr
sh7750_regs.h:						   address space -> SCTDR1) */
sh7750_regs.h:#define SH7750_CHCR_RS_SCIRX_SC_TO_EA   0x900	/* SCI Receive-Data-Full intr
sh7750_regs.h:						   transfer request (SCRDR1 ->
sh7750_regs.h:#define SH7750_CHCR_RS_SCIFTX_EA_TO_SC  0xA00	/* SCIF Transmit-Data-Empty intr
sh7750_regs.h:						   address space -> SCFTDR1) */
sh7750_regs.h:#define SH7750_CHCR_RS_SCIFRX_SC_TO_EA  0xB00	/* SCIF Receive-Data-Full intr
sh7750_regs.h:						   transfer request (SCFRDR2 ->
sh7750_regs.h:						   space -> external address
sh7750_regs.h:						   space -> on-chip peripheral
sh7750_regs.h:						   interrupt), (on-chip
sh7750_regs.h:						   peripheral module -> external
sh7750_regs.h:#define SH7750_CHCR_TS_BLOCK  0x00000040	/*     32-byte block transfer */
sh7750_regs.h:/* DMA Operation Register - DMAOR */
sh7750_regs.h:#define SH7750_DMAOR_DDT      0x00008000	/* On-Demand Data Transfer Mode */
sh7750_regs.h:#define SH7750_DMAOR_PR_RR    0x00000300	/*     Round-robin mode */
sh7750_regs.h:/* Port Control Register A - PCTRA */
sh7750_regs.h:/* Port Data Register A - PDTRA(half) */
sh7750_regs.h:/* Port Control Register B - PCTRB */
sh7750_regs.h:#define SH7750_PCTRB_PBNPUP(n) (1 << ((n-16)*2+1))	/* Bit n is not pulled up */
sh7750_regs.h:#define SH7750_PCTRB_PBOUT(n) (1 << ((n-16)*2))	/* Bit n is an output */
sh7750_regs.h:/* Port Data Register B - PDTRB(half) */
sh7750_regs.h:#define SH7750_PDTRB_BIT(n) (1 << ((n)-16))
sh7750_regs.h:/* GPIO Interrupt Control Register - GPIOIC(half) */
sh7750_regs.h: * Interrupt Controller - INTC
sh7750_regs.h:/* Interrupt Control Register - ICR (half) */
sh7750_regs.h:#define SH7750_ICR_IRLM_ENC   0x0000	/*   IRL\ pins used as a level-encoded
sh_intc.c: * Copyright (c) 2005-2006 CodeSourcery.
sh_intc.c:    if ((source->enable_count == source->enable_max) && (enable_adj == -1))
sh_intc.c:        enable_changed = -1;
sh_intc.c:    source->enable_count += enable_adj;
sh_intc.c:    if (source->enable_count == source->enable_max)
sh_intc.c:    source->asserted += assert_adj;
sh_intc.c:    old_pending = source->pending;
sh_intc.c:    source->pending = source->asserted &&
sh_intc.c:      (source->enable_count == source->enable_max);
sh_intc.c:    if (old_pending != source->pending)
sh_intc.c:        if (source->pending) {
sh_intc.c:            source->parent->pending++;
sh_intc.c:	    if (source->parent->pending == 1)
sh_intc.c:            source->parent->pending--;
sh_intc.c:	    if (source->parent->pending == 0)
sh_intc.c:		   source->parent->pending,
sh_intc.c:		   source->asserted,
sh_intc.c:		   source->enable_count,
sh_intc.c:		   source->enable_max,
sh_intc.c:		   source->vect,
sh_intc.c:		   source->asserted ? "asserted " :
sh_intc.c:		   enable_changed == -1 ? "disabled " : "",
sh_intc.c:		   source->pending ? "pending" : "");
sh_intc.c:  struct intc_source *source = &(desc->sources[n]);
sh_intc.c:  if (level && !source->asserted)
sh_intc.c:  else if (!level && source->asserted)
sh_intc.c:    sh_intc_toggle_source(source, 0, -1);
sh_intc.c:        return -1; /* FIXME, update code to include priority per source */
sh_intc.c:    for (i = 0; i < desc->nr_sources; i++) {
sh_intc.c:        struct intc_source *source = desc->sources + i;
sh_intc.c:	if (source->pending) {
sh_intc.c:		   desc->pending, source->vect);
sh_intc.c:            return source->vect;
sh_intc.c:    if (desc->mask_regs) {
sh_intc.c:        for (i = 0; i < desc->nr_mask_regs; i++) {
sh_intc.c:	    struct intc_mask_reg *mr = desc->mask_regs + i;
sh_intc.c:	    mode = sh_intc_mode(address, mr->set_reg, mr->clr_reg);
sh_intc.c:	    *datap = &mr->value;
sh_intc.c:	    *enums = mr->enum_ids;
sh_intc.c:	    *first = mr->reg_width - 1;
sh_intc.c:    if (desc->prio_regs) {
sh_intc.c:        for (i = 0; i < desc->nr_prio_regs; i++) {
sh_intc.c:	    struct intc_prio_reg *pr = desc->prio_regs + i;
sh_intc.c:	    mode = sh_intc_mode(address, pr->set_reg, pr->clr_reg);
sh_intc.c:	    *datap = &pr->value;
sh_intc.c:	    *enums = pr->enum_ids;
sh_intc.c:	    *first = (pr->reg_width / pr->field_width) - 1;
sh_intc.c:	    *width = pr->field_width;
sh_intc.c:    struct intc_source *source = desc->sources + id;
sh_intc.c:    if (!source->next_enum_id && (!source->enable_max || !source->vect)) {
sh_intc.c:    if (source->vect)
sh_intc.c:        sh_intc_toggle_source(source, enable ? 1 : -1, 0);
sh_intc.c:    if ((is_group || !source->vect) && source->next_enum_id) {
sh_intc.c:        sh_intc_toggle_mask(desc, source->next_enum_id, enable, 1);
sh_intc.c:    if (!source->vect) {
sh_intc.c:        printf("setting interrupt group %d to %d - done\n", id, !!enable);
sh_intc.c:        mask = ((1 << width) - 1) << ((first - k) * width);
sh_intc.c:    printf("sh_intc_write 0x%lx -> 0x%08x\n", (unsigned long) offset, value);
sh_intc.c:        return desc->sources + id;
sh_intc.c:                                            desc->iomemtype, INTC_A7(address));
sh_intc.c:                                            desc->iomemtype, INTC_A7(address));
sh_intc.c:    if (desc->mask_regs) {
sh_intc.c:        for (i = 0; i < desc->nr_mask_regs; i++) {
sh_intc.c:	    struct intc_mask_reg *mr = desc->mask_regs + i;
sh_intc.c:	    for (k = 0; k < ARRAY_SIZE(mr->enum_ids); k++) {
sh_intc.c:                if (mr->enum_ids[k] != source)
sh_intc.c:		s = sh_intc_source(desc, mr->enum_ids[k]);
sh_intc.c:                    s->enable_max++;
sh_intc.c:    if (desc->prio_regs) {
sh_intc.c:        for (i = 0; i < desc->nr_prio_regs; i++) {
sh_intc.c:	    struct intc_prio_reg *pr = desc->prio_regs + i;
sh_intc.c:	    for (k = 0; k < ARRAY_SIZE(pr->enum_ids); k++) {
sh_intc.c:                if (pr->enum_ids[k] != source)
sh_intc.c:		s = sh_intc_source(desc, pr->enum_ids[k]);
sh_intc.c:                    s->enable_max++;
sh_intc.c:	    for (k = 0; k < ARRAY_SIZE(gr->enum_ids); k++) {
sh_intc.c:                if (gr->enum_ids[k] != source)
sh_intc.c:		s = sh_intc_source(desc, gr->enum_ids[k]);
sh_intc.c:                    s->enable_max++;
sh_intc.c:	sh_intc_register_source(desc, vect->enum_id, groups, nr_groups);
sh_intc.c:	s = sh_intc_source(desc, vect->enum_id);
sh_intc.c:	    s->vect = vect->vect;
sh_intc.c:	printf("sh_intc: registered source %d -> 0x%04x (%d/%d)\n",
sh_intc.c:	       vect->enum_id, s->vect, s->enable_count, s->enable_max);
sh_intc.c:	    s = sh_intc_source(desc, gr->enum_id);
sh_intc.c:	    s->next_enum_id = gr->enum_ids[0];
sh_intc.c:	    for (k = 1; k < ARRAY_SIZE(gr->enum_ids); k++) {
sh_intc.c:                if (!gr->enum_ids[k])
sh_intc.c:		s = sh_intc_source(desc, gr->enum_ids[k - 1]);
sh_intc.c:		s->next_enum_id = gr->enum_ids[k];
sh_intc.c:		   gr->enum_id, s->enable_count, s->enable_max);
sh_intc.c:    desc->pending = 0;
sh_intc.c:    desc->nr_sources = nr_sources;
sh_intc.c:    desc->mask_regs = mask_regs;
sh_intc.c:    desc->nr_mask_regs = nr_mask_regs;
sh_intc.c:    desc->prio_regs = prio_regs;
sh_intc.c:    desc->nr_prio_regs = nr_prio_regs;
sh_intc.c:    desc->sources = qemu_malloc(i);
sh_intc.c:    memset(desc->sources, 0, i);
sh_intc.c:    for (i = 0; i < desc->nr_sources; i++) {
sh_intc.c:        struct intc_source *source = desc->sources + i;
sh_intc.c:        source->parent = desc;
sh_intc.c:    desc->irqs = qemu_allocate_irqs(sh_intc_set_irq, desc, nr_sources);
sh_intc.c:    desc->iomemtype = cpu_register_io_memory(sh_intc_readfn,
sh_intc.c:    if (desc->mask_regs) {
sh_intc.c:        for (i = 0; i < desc->nr_mask_regs; i++) {
sh_intc.c:	    struct intc_mask_reg *mr = desc->mask_regs + i;
sh_intc.c:	    sh_intc_register(desc, mr->set_reg);
sh_intc.c:	    sh_intc_register(desc, mr->clr_reg);
sh_intc.c:    if (desc->prio_regs) {
sh_intc.c:        for (i = 0; i < desc->nr_prio_regs; i++) {
sh_intc.c:	    struct intc_prio_reg *pr = desc->prio_regs + i;
sh_intc.c:	    sh_intc_register(desc, pr->set_reg);
sh_intc.c:	    sh_intc_register(desc, pr->clr_reg);
sh_intc.c:    for (i = 0; (s = sh_intc_source(s->parent, s->next_enum_id)); i++) {
sh_intc.c:	    sh_intc_toggle_source(s, s->enable_count?0:1, s->asserted?0:1);
sh_intc.c:	    if (s->asserted)
sh_intc.c:	        sh_intc_toggle_source(s, 0, -1);
sh_intc.h:#include "qemu-common.h"
shix.c:   More information in target-sh4/README.sh4
sh_pci.c: * SuperH on-chip PCIC emulation.
sh_pci.c:        cpu_to_le32w((uint32_t*)(pcic->dev->config + addr), val);
sh_pci.c:        pcic->par = val;
sh_pci.c:        pcic->mbr = val;
sh_pci.c:        pcic->iobr = val;
sh_pci.c:        pci_data_write(pcic->bus, pcic->par, val, 4);
sh_pci.c:        return le32_to_cpup((uint32_t*)(pcic->dev->config + addr));
sh_pci.c:        return pcic->par;
sh_pci.c:        return pci_data_read(pcic->bus, pcic->par, 4);
sh_pci.c:    pci_data_write(pcic->bus, addr + pcic->mbr, val, size);
sh_pci.c:    return pci_data_read(pcic->bus, addr + pcic->mbr, size);
sh_pci.c:    return addr + pcic->iobr;
sh_pci.c:    p->bus = pci_register_bus(NULL, "pci",
sh_pci.c:    p->dev = pci_register_device(p->bus, "SH PCIC", sizeof(PCIDevice),
sh_pci.c:                                 -1, NULL, NULL);
sh_pci.c:    pci_config_set_vendor_id(p->dev->config, PCI_VENDOR_ID_HITACHI);
sh_pci.c:    pci_config_set_device_id(p->dev->config, PCI_DEVICE_ID_HITACHI_SH7751R);
sh_pci.c:    p->dev->config[0x04] = 0x80;
sh_pci.c:    p->dev->config[0x05] = 0x00;
sh_pci.c:    p->dev->config[0x06] = 0x90;
sh_pci.c:    p->dev->config[0x07] = 0x02;
sh_pci.c:    return p->bus;
sh_pci.h:#include "qemu-common.h"
sh_serial.c: * Based on serial.c - QEMU 16450 UART emulation
sh_serial.c: * Copyright (c) 2003-2004 Fabrice Bellard
sh_serial.c:#include "qemu-char.h"
sh_serial.c:    memset(s->rx_fifo, 0, SH_RX_FIFO_LENGTH);
sh_serial.c:    s->rx_cnt = 0;
sh_serial.c:    s->rx_head = 0;
sh_serial.c:    s->rx_tail = 0;
sh_serial.c:        s->smr = val & ((s->feat & SH_SERIAL_FEAT_SCIF) ? 0x7b : 0xff);
sh_serial.c:        s->brr = val;
sh_serial.c:        s->scr = val & ((s->feat & SH_SERIAL_FEAT_SCIF) ? 0xfa : 0xff);
sh_serial.c:            s->flags |= SH_SERIAL_FLAG_TEND;
sh_serial.c:        if ((s->feat & SH_SERIAL_FEAT_SCIF) && s->txi) {
sh_serial.c:	    qemu_set_irq(s->txi, val & (1 << 7));
sh_serial.c:	    qemu_set_irq(s->rxi, 0);
sh_serial.c:        if (s->chr) {
sh_serial.c:            qemu_chr_write(s->chr, &ch, 1);
sh_serial.c:	s->dr = val;
sh_serial.c:	s->flags &= ~SH_SERIAL_FLAG_TDE;
sh_serial.c:    if (s->feat & SH_SERIAL_FEAT_SCIF) {
sh_serial.c:                s->flags &= ~SH_SERIAL_FLAG_TEND;
sh_serial.c:                s->flags &= ~SH_SERIAL_FLAG_TDE;
sh_serial.c:                s->flags &= ~SH_SERIAL_FLAG_BRK;
sh_serial.c:                s->flags &= ~SH_SERIAL_FLAG_RDF;
sh_serial.c:                s->flags &= ~SH_SERIAL_FLAG_DR;
sh_serial.c:                if (s->rxi) {
sh_serial.c:                    qemu_set_irq(s->rxi, 0);
sh_serial.c:            s->fcr = val;
sh_serial.c:                s->rtrg = 1;
sh_serial.c:                s->rtrg = 4;
sh_serial.c:                s->rtrg = 8;
sh_serial.c:                s->rtrg = 14;
sh_serial.c:                s->sr &= ~(1 << 1);
sh_serial.c:            s->sptr = val & 0xf3;
sh_serial.c:            ret = s->dr;
sh_serial.c:            s->sptr = val & 0x8f;
sh_serial.c:        ret = s->smr;
sh_serial.c:        ret = s->brr;
sh_serial.c:        ret = s->scr;
sh_serial.c:    if (s->feat & SH_SERIAL_FEAT_SCIF) {
sh_serial.c:            ret = s->smr;
sh_serial.c:            ret = s->scr;
sh_serial.c:            if (s->flags & SH_SERIAL_FLAG_TEND)
sh_serial.c:            if (s->flags & SH_SERIAL_FLAG_TDE)
sh_serial.c:            if (s->flags & SH_SERIAL_FLAG_BRK)
sh_serial.c:            if (s->flags & SH_SERIAL_FLAG_RDF)
sh_serial.c:            if (s->flags & SH_SERIAL_FLAG_DR)
sh_serial.c:            if (s->scr & (1 << 5))
sh_serial.c:                s->flags |= SH_SERIAL_FLAG_TDE | SH_SERIAL_FLAG_TEND;
sh_serial.c:            if (s->rx_cnt > 0) {
sh_serial.c:                ret = s->rx_fifo[s->rx_tail++];
sh_serial.c:                s->rx_cnt--;
sh_serial.c:                if (s->rx_tail == SH_RX_FIFO_LENGTH)
sh_serial.c:                    s->rx_tail = 0;
sh_serial.c:                if (s->rx_cnt < s->rtrg)
sh_serial.c:                    s->flags &= ~SH_SERIAL_FLAG_RDF;
sh_serial.c:            ret = s->fcr;
sh_serial.c:            ret = s->rx_cnt;
sh_serial.c:            ret = s->sptr;
sh_serial.c:            ret = s->dr;
sh_serial.c:            ret = s->rx_fifo[0];
sh_serial.c:            ret = s->sptr;
sh_serial.c:    if (ret & ~((1 << 16) - 1)) {
sh_serial.c:    return s->scr & (1 << 4);
sh_serial.c:    if (s->feat & SH_SERIAL_FEAT_SCIF) {
sh_serial.c:        if (s->rx_cnt < SH_RX_FIFO_LENGTH) {
sh_serial.c:            s->rx_fifo[s->rx_head++] = ch;
sh_serial.c:            if (s->rx_head == SH_RX_FIFO_LENGTH)
sh_serial.c:                s->rx_head = 0;
sh_serial.c:            s->rx_cnt++;
sh_serial.c:            if (s->rx_cnt >= s->rtrg) {
sh_serial.c:                s->flags |= SH_SERIAL_FLAG_RDF;
sh_serial.c:                if (s->scr & (1 << 6) && s->rxi) {
sh_serial.c:                    qemu_set_irq(s->rxi, 1);
sh_serial.c:        s->rx_fifo[0] = ch;
sh_serial.c:    if (s->feat & SH_SERIAL_FEAT_SCIF)
sh_serial.c:        s->sr |= (1 << 4);
sh_serial.c:    s->feat = feat;
sh_serial.c:    s->flags = SH_SERIAL_FLAG_TEND | SH_SERIAL_FLAG_TDE;
sh_serial.c:    s->rtrg = 1;
sh_serial.c:    s->smr = 0;
sh_serial.c:    s->brr = 0xff;
sh_serial.c:    s->scr = 1 << 5; /* pretend that TX is enabled so early printk works */
sh_serial.c:    s->sptr = 0;
sh_serial.c:        s->fcr = 0;
sh_serial.c:        s->dr = 0xff;
sh_serial.c:    s->chr = chr;
sh_serial.c:    s->eri = eri_source;
sh_serial.c:    s->rxi = rxi_source;
sh_serial.c:    s->txi = txi_source;
sh_serial.c:    s->tei = tei_source;
sh_serial.c:    s->bri = bri_source;
sh_timer.c: * Copyright (c) 2005-2006 CodeSourcery.
sh_timer.c:#include "qemu-timer.h"
sh_timer.c:    int new_level = s->int_level && (s->tcr & TIMER_TCR_UNIE);
sh_timer.c:    if (new_level != s->old_level)
sh_timer.c:      qemu_set_irq (s->irq, new_level);
sh_timer.c:    s->old_level = s->int_level;
sh_timer.c:    s->int_level = new_level;
sh_timer.c:        return s->tcor;
sh_timer.c:        return ptimer_get_count(s->timer);
sh_timer.c:        return s->tcr | (s->int_level ? TIMER_TCR_UNF : 0);
sh_timer.c:        if (s->feat & TIMER_FEAT_CAPT)
sh_timer.c:            return s->tcpr;
sh_timer.c:        s->tcor = value;
sh_timer.c:        ptimer_set_limit(s->timer, s->tcor, 0);
sh_timer.c:        s->tcnt = value;
sh_timer.c:        ptimer_set_count(s->timer, s->tcnt);
sh_timer.c:        if (s->enabled) {
sh_timer.c:            ptimer_stop(s->timer);
sh_timer.c:        freq = s->freq;
sh_timer.c:	case 7: if (s->feat & TIMER_FEAT_EXTCLK) break;
sh_timer.c:        case 3: if (s->feat & TIMER_FEAT_EXTCLK) break;
sh_timer.c:        case 3: if (s->feat & TIMER_FEAT_CAPT) break;
sh_timer.c:            s->int_level = 0;
sh_timer.c:	if ((value & TIMER_TCR_ICPF) && (!(s->feat & TIMER_FEAT_CAPT)))
sh_timer.c:        s->tcr = value;
sh_timer.c:        ptimer_set_limit(s->timer, s->tcor, 0);
sh_timer.c:        ptimer_set_freq(s->timer, freq);
sh_timer.c:        if (s->enabled) {
sh_timer.c:            ptimer_run(s->timer, 0);
sh_timer.c:        if (s->feat & TIMER_FEAT_CAPT) {
sh_timer.c:            s->tcpr = value;
sh_timer.c:    printf("sh_timer_start_stop %d (%d)\n", enable, s->enabled);
sh_timer.c:    if (s->enabled && !enable) {
sh_timer.c:        ptimer_stop(s->timer);
sh_timer.c:    if (!s->enabled && enable) {
sh_timer.c:        ptimer_run(s->timer, 0);
sh_timer.c:    s->enabled = !!enable;
sh_timer.c:    printf("sh_timer_start_stop done %d\n", s->enabled);
sh_timer.c:    s->int_level = s->enabled;
sh_timer.c:    s->freq = freq;
sh_timer.c:    s->feat = feat;
sh_timer.c:    s->tcor = 0xffffffff;
sh_timer.c:    s->tcnt = 0xffffffff;
sh_timer.c:    s->tcpr = 0xdeadbeef;
sh_timer.c:    s->tcr = 0;
sh_timer.c:    s->enabled = 0;
sh_timer.c:    s->irq = irq;
sh_timer.c:    s->timer = ptimer_init(bh);
sh_timer.c:    sh_timer_write(s, OFFSET_TCOR >> 2, s->tcor);
sh_timer.c:    sh_timer_write(s, OFFSET_TCNT >> 2, s->tcnt);
sh_timer.c:    sh_timer_write(s, OFFSET_TCPR >> 2, s->tcpr);
sh_timer.c:    sh_timer_write(s, OFFSET_TCR  >> 2, s->tcpr);
sh_timer.c:        if (!(s->feat & TMU012_FEAT_3CHAN))
sh_timer.c:        return sh_timer_read(s->timer[2], offset - 0x20);
sh_timer.c:        return sh_timer_read(s->timer[1], offset - 0x14);
sh_timer.c:        return sh_timer_read(s->timer[0], offset - 0x08);
sh_timer.c:        return s->tstr;
sh_timer.c:    if ((s->feat & TMU012_FEAT_TOCR) && offset == 0)
sh_timer.c:        return s->tocr;
sh_timer.c:        if (!(s->feat & TMU012_FEAT_3CHAN))
sh_timer.c:        sh_timer_write(s->timer[2], offset - 0x20, value);
sh_timer.c:        sh_timer_write(s->timer[1], offset - 0x14, value);
sh_timer.c:        sh_timer_write(s->timer[0], offset - 0x08, value);
sh_timer.c:        sh_timer_start_stop(s->timer[0], value & (1 << 0));
sh_timer.c:        sh_timer_start_stop(s->timer[1], value & (1 << 1));
sh_timer.c:        if (s->feat & TMU012_FEAT_3CHAN)
sh_timer.c:            sh_timer_start_stop(s->timer[2], value & (1 << 2));
sh_timer.c:	s->tstr = value;
sh_timer.c:    if ((s->feat & TMU012_FEAT_TOCR) && offset == 0) {
sh_timer.c:        s->tocr = value & (1 << 0);
sh_timer.c:    s->feat = feat;
sh_timer.c:    s->timer[0] = sh_timer_init(freq, timer_feat, ch0_irq);
sh_timer.c:    s->timer[1] = sh_timer_init(freq, timer_feat, ch1_irq);
sh_timer.c:        s->timer[2] = sh_timer_init(freq, timer_feat | TIMER_FEAT_CAPT,
slavio_intctl.c: * Copyright (c) 2003-2005 Fabrice Bellard
slavio_intctl.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C105.txt
slavio_intctl.c:// per-cpu interrupt controller
slavio_intctl.c:        ret = s->intreg_pending;
slavio_intctl.c:    DPRINTF("read cpu %d reg 0x" TARGET_FMT_plx " = %x\n", s->cpu, addr, ret);
slavio_intctl.c:    DPRINTF("write cpu %d reg 0x" TARGET_FMT_plx " = %x\n", s->cpu, addr, val);
slavio_intctl.c:        s->intreg_pending &= ~val;
slavio_intctl.c:        slavio_check_interrupts(s->master, 1);
slavio_intctl.c:        DPRINTF("Cleared cpu %d irq mask %x, curmask %x\n", s->cpu, val,
slavio_intctl.c:                s->intreg_pending);
slavio_intctl.c:        s->intreg_pending |= val;
slavio_intctl.c:        slavio_check_interrupts(s->master, 1);
slavio_intctl.c:        DPRINTF("Set cpu %d irq mask %x, curmask %x\n", s->cpu, val,
slavio_intctl.c:                s->intreg_pending);
slavio_intctl.c:        ret = s->intregm_pending & ~MASTER_DISABLE;
slavio_intctl.c:        ret = s->intregm_disabled & MASTER_IRQ_MASK;
slavio_intctl.c:        ret = s->target_cpu;
slavio_intctl.c:        s->intregm_disabled &= ~val;
slavio_intctl.c:                s->intregm_disabled);
slavio_intctl.c:        s->intregm_disabled |= val;
slavio_intctl.c:        s->intregm_pending &= ~val;
slavio_intctl.c:                s->intregm_disabled);
slavio_intctl.c:        s->target_cpu = val & (MAX_CPUS - 1);
slavio_intctl.c:        DPRINTF("Set master irq cpu %d\n", s->target_cpu);
slavio_intctl.c:        monitor_printf(mon, "per-cpu %d: pending 0x%08x\n", i,
slavio_intctl.c:                       s->slaves[i].intreg_pending);
slavio_intctl.c:                   s->intregm_pending, s->intregm_disabled);
slavio_intctl.c:        count = s->irq_count[i];
slavio_intctl.c:    uint32_t pending = s->intregm_pending, pil_pending;
slavio_intctl.c:    pending &= ~s->intregm_disabled;
slavio_intctl.c:    DPRINTF("pending %x disabled %x\n", pending, s->intregm_disabled);
slavio_intctl.c:        if (pending && !(s->intregm_disabled & MASTER_DISABLE) &&
slavio_intctl.c:            (i == s->target_cpu)) {
slavio_intctl.c:        s->slaves[i].intreg_pending &= CPU_SOFTIRQ_MASK | CPU_IRQ_INT15_IN |
slavio_intctl.c:        if (i == s->target_cpu) {
slavio_intctl.c:                if ((s->intregm_pending & (1 << j)) && intbit_to_level[j]) {
slavio_intctl.c:                    s->slaves[i].intreg_pending |= 1 << intbit_to_level[j];
slavio_intctl.c:        pil_pending |= s->slaves[i].intreg_pending &
slavio_intctl.c:        pil_pending |= (s->slaves[i].intreg_pending & CPU_SOFTIRQ_MASK) >> 16;
slavio_intctl.c:            for (j = MAX_PILS; j > 0; j--) {
slavio_intctl.c:                    if (!(s->slaves[i].irl_out & (1 << j))) {
slavio_intctl.c:                        qemu_irq_raise(s->cpu_irqs[i][j]);
slavio_intctl.c:                    if (s->slaves[i].irl_out & (1 << j)) {
slavio_intctl.c:                        qemu_irq_lower(s->cpu_irqs[i][j]);
slavio_intctl.c:        s->slaves[i].irl_out = pil_pending;
slavio_intctl.c:    DPRINTF("Set cpu %d irq %d -> pil %d level %d\n", s->target_cpu, irq, pil,
slavio_intctl.c:            s->irq_count[pil]++;
slavio_intctl.c:            s->intregm_pending |= mask;
slavio_intctl.c:                    s->slaves[i].intreg_pending |= 1 << pil;
slavio_intctl.c:            s->intregm_pending &= ~mask;
slavio_intctl.c:                    s->slaves[i].intreg_pending &= ~(1 << pil);
slavio_intctl.c:        s->slaves[cpu].intreg_pending |= CPU_IRQ_TIMER_IN;
slavio_intctl.c:        s->slaves[cpu].intreg_pending &= ~CPU_IRQ_TIMER_IN;
slavio_intctl.c:        slavio_set_timer_irq_cpu(opaque, irq - 32, level);
slavio_intctl.c:        s->slaves[i].intreg_pending = 0;
slavio_intctl.c:        s->slaves[i].irl_out = 0;
slavio_intctl.c:    s->intregm_disabled = ~MASTER_IRQ_MASK;
slavio_intctl.c:    s->intregm_pending = 0;
slavio_intctl.c:    s->target_cpu = 0;
slavio_intctl.c:    qdev_init_gpio_in(&dev->qdev, slavio_set_irq_all, 32 + MAX_CPUS);
slavio_intctl.c:            sysbus_init_irq(dev, &s->cpu_irqs[i][j]);
slavio_intctl.c:                                           &s->slaves[i]);
slavio_intctl.c:        s->slaves[i].cpu = i;
slavio_intctl.c:        s->slaves[i].master = s;
slavio_misc.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C105.txt
slavio_misc.c:    if ((s->aux2 & AUX2_PWRFAIL) && (s->config & CFG_PWRINTEN)) {
slavio_misc.c:        qemu_irq_raise(s->irq);
slavio_misc.c:        qemu_irq_lower(s->irq);
slavio_misc.c:    s->config = s->aux1 = s->aux2 = s->mctrl = 0;
slavio_misc.c:    MISC_DPRINTF("Power fail: %d, config: %d\n", power_failing, s->config);
slavio_misc.c:    if (power_failing && (s->config & CFG_PWRINTEN)) {
slavio_misc.c:        s->aux2 |= AUX2_PWRFAIL;
slavio_misc.c:        s->aux2 &= ~AUX2_PWRFAIL;
slavio_misc.c:    s->config = val & 0xff;
slavio_misc.c:    ret = s->config;
slavio_misc.c:    s->diag = val & 0xff;
slavio_misc.c:    ret = s->diag;
slavio_misc.c:    s->mctrl = val & 0xff;
slavio_misc.c:    ret = s->mctrl;
slavio_misc.c:        if (s->fdc_tc) {
slavio_misc.c:            qemu_irq_raise(s->fdc_tc);
slavio_misc.c:            qemu_irq_lower(s->fdc_tc);
slavio_misc.c:    s->aux1 = val & 0xff;
slavio_misc.c:    ret = s->aux1;
slavio_misc.c:    val |= s->aux2 & AUX2_PWRFAIL;
slavio_misc.c:    s->aux2 = val;
slavio_misc.c:    ret = s->aux2;
slavio_misc.c:    qemu_irq_raise(s->cpu_halt);
slavio_misc.c:        ret = s->sysctrl;
slavio_misc.c:            s->sysctrl = SYS_RESETSTAT;
slavio_misc.c:        ret = s->leds;
slavio_misc.c:        s->leds = val;
slavio_misc.c:    sysbus_init_irq(dev, &s->cpu_halt);
slavio_misc.c:    sysbus_init_irq(dev, &s->irq);
slavio_misc.c:    sysbus_init_irq(dev, &s->fdc_tc);
slavio_misc.c:    qdev_init_gpio_in(&dev->qdev, slavio_set_power_fail, 1);
slavio_timer.c: * Copyright (c) 2003-2005 Fabrice Bellard
slavio_timer.c:#include "qemu-timer.h"
slavio_timer.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C105.txt
slavio_timer.c: * The 31-bit counter is incremented every 500ns by bit 9. Bits 8..0
slavio_timer.c: * Per-CPU timers interrupt local CPU, system timer uses normal
slavio_timer.c:    SLAVIO_TIMERState *s = tc->s;
slavio_timer.c:    unsigned int timer_index = tc->timer_index;
slavio_timer.c:    return timer_index != 0 && (s->cputimer_mode & (1 << (timer_index - 1)));
slavio_timer.c:    if (t->limit == 0) { /* free-run system or processor counter */
slavio_timer.c:        limit = t->limit;
slavio_timer.c:    count = limit - PERIODS_TO_LIMIT(ptimer_get_count(t->timer));
slavio_timer.c:    DPRINTF("get_out: limit %" PRIx64 " count %x%08x\n", t->limit, t->counthigh,
slavio_timer.c:            t->count);
slavio_timer.c:    t->count = count & TIMER_COUNT_MASK32;
slavio_timer.c:    t->counthigh = count >> 32;
slavio_timer.c:    SLAVIO_TIMERState *s = tc->s;
slavio_timer.c:    CPUTimerState *t = &s->cputimer[tc->timer_index];
slavio_timer.c:    DPRINTF("callback: count %x%08x\n", t->counthigh, t->count);
slavio_timer.c:    t->reached = TIMER_REACHED;
slavio_timer.c:        qemu_irq_raise(t->irq);
slavio_timer.c:    SLAVIO_TIMERState *s = tc->s;
slavio_timer.c:    unsigned int timer_index = tc->timer_index;
slavio_timer.c:    CPUTimerState *t = &s->cputimer[timer_index];
slavio_timer.c:            ret = t->counthigh | t->reached;
slavio_timer.c:            qemu_irq_lower(t->irq);
slavio_timer.c:            t->reached = 0;
slavio_timer.c:            ret = t->limit & TIMER_LIMIT_MASK32;
slavio_timer.c:            ret = t->count & TIMER_MAX_COUNT64;
slavio_timer.c:            ret = (t->count & TIMER_MAX_COUNT32) |
slavio_timer.c:                t->reached;
slavio_timer.c:            ret = t->running;
slavio_timer.c:        ret = s->cputimer_mode;
slavio_timer.c:    SLAVIO_TIMERState *s = tc->s;
slavio_timer.c:    unsigned int timer_index = tc->timer_index;
slavio_timer.c:    CPUTimerState *t = &s->cputimer[timer_index];
slavio_timer.c:            t->limit = TIMER_MAX_COUNT64;
slavio_timer.c:            t->counthigh = val & (TIMER_MAX_COUNT64 >> 32);
slavio_timer.c:            t->reached = 0;
slavio_timer.c:            count = ((uint64_t)t->counthigh << 32) | t->count;
slavio_timer.c:            ptimer_set_count(t->timer, LIMIT_TO_PERIODS(t->limit - count));
slavio_timer.c:            qemu_irq_lower(t->irq);
slavio_timer.c:            t->limit = val & TIMER_MAX_COUNT32;
slavio_timer.c:            if (t->timer) {
slavio_timer.c:                if (t->limit == 0) { /* free-run */
slavio_timer.c:                    ptimer_set_limit(t->timer,
slavio_timer.c:                    ptimer_set_limit(t->timer, LIMIT_TO_PERIODS(t->limit), 1);
slavio_timer.c:            t->limit = TIMER_MAX_COUNT64;
slavio_timer.c:            t->count = val & TIMER_MAX_COUNT64;
slavio_timer.c:            t->reached = 0;
slavio_timer.c:            count = ((uint64_t)t->counthigh) << 32 | t->count;
slavio_timer.c:            ptimer_set_count(t->timer, LIMIT_TO_PERIODS(t->limit - count));
slavio_timer.c:        t->limit = val & TIMER_MAX_COUNT32;
slavio_timer.c:        if (t->limit == 0) { /* free-run */
slavio_timer.c:            ptimer_set_limit(t->timer, LIMIT_TO_PERIODS(TIMER_MAX_COUNT32), 0);
slavio_timer.c:            ptimer_set_limit(t->timer, LIMIT_TO_PERIODS(t->limit), 0);
slavio_timer.c:            if ((val & 1) && !t->running) {
slavio_timer.c:                ptimer_run(t->timer, 0);
slavio_timer.c:                t->running = 1;
slavio_timer.c:            } else if (!(val & 1) && t->running) {
slavio_timer.c:                ptimer_stop(t->timer);
slavio_timer.c:                t->running = 0;
slavio_timer.c:            for (i = 0; i < s->num_cpus; i++) {
slavio_timer.c:                CPUTimerState *curr_timer = &s->cputimer[i + 1];
slavio_timer.c:                if ((val & processor) != (s->cputimer_mode & processor)) {
slavio_timer.c:                    if (val & processor) { // counter -> user timer
slavio_timer.c:                        qemu_irq_lower(curr_timer->irq);
slavio_timer.c:                        ptimer_stop(curr_timer->timer);
slavio_timer.c:                        curr_timer->running = 0;
slavio_timer.c:                        curr_timer->limit = TIMER_MAX_COUNT64;
slavio_timer.c:                        ptimer_set_limit(curr_timer->timer,
slavio_timer.c:                                         LIMIT_TO_PERIODS(curr_timer->limit),
slavio_timer.c:                        s->cputimer_mode |= processor;
slavio_timer.c:                    } else { // user timer -> counter
slavio_timer.c:                        if (curr_timer->running) {
slavio_timer.c:                            ptimer_stop(curr_timer->timer);
slavio_timer.c:                        ptimer_run(curr_timer->timer, 0);
slavio_timer.c:                        curr_timer->running = 1;
slavio_timer.c:                        s->cputimer_mode &= ~processor;
slavio_timer.c:        curr_timer = &s->cputimer[i];
slavio_timer.c:        curr_timer->limit = 0;
slavio_timer.c:        curr_timer->count = 0;
slavio_timer.c:        curr_timer->reached = 0;
slavio_timer.c:        if (i < s->num_cpus) {
slavio_timer.c:            ptimer_set_limit(curr_timer->timer,
slavio_timer.c:            ptimer_run(curr_timer->timer, 0);
slavio_timer.c:        curr_timer->running = 1;
slavio_timer.c:    s->cputimer_mode = 0;
slavio_timer.c:        tc->s = s;
slavio_timer.c:        tc->timer_index = i;
slavio_timer.c:        s->cputimer[i].timer = ptimer_init(bh);
slavio_timer.c:        ptimer_set_period(s->cputimer[i].timer, TIMER_PERIOD);
slavio_timer.c:        sysbus_init_irq(dev, &s->cputimer[i].irq);
sm501.c: * Copyright (c) 2008 Shin-ichiro KAWASAKI
sm501.c: *   - Minimum implementation for Linux console : mmio regs and CRT layer.
sm501.c: *   - Always updates full screen.
sm501.c: *   - Panel support
sm501.c: *   - Hardware cursor support
sm501.c: *   - Touch panel support
sm501.c: *   - USB support
sm501.c: *   - UART support
sm501.c: *   - Performance tuning
sm501.c:/* SM501 register definitions taken from "linux/include/linux/sm501-regs.h" */
sm501.c:#define get_local_mem_size(s) sm501_mem_local_size[(s)->local_mem_size_index]
sm501.c:	ret = s->system_control;
sm501.c:	ret = s->misc_control;
sm501.c:	ret = s->gpio_31_0_control;
sm501.c:	ret = s->gpio_63_32_control;
sm501.c:	ret = (s->dram_control & 0x07F107C0) | s->local_mem_size_index << 13;
sm501.c:	ret = s->irq_mask;
sm501.c:	ret = s->misc_timing;
sm501.c:	ret = s->power_mode_control;
sm501.c:	s->system_control = value & 0xE300B8F7;
sm501.c:	s->misc_control = value & 0xFF7FFF20;
sm501.c:	s->gpio_31_0_control = value;
sm501.c:	s->gpio_63_32_control = value;
sm501.c:	s->local_mem_size_index = (value >> 13) & 0x7;
sm501.c:	s->dram_control |=  value & 0x7FFFFFC3;
sm501.c:	s->irq_mask = value;
sm501.c:	s->misc_timing = value & 0xF31F1FFF;
sm501.c:	s->power_mode_control = value & 0x00000003;
sm501.c:    return *(uint32_t*)&s->dc_palette[addr];
sm501.c:    *(uint32_t*)&s->dc_palette[addr] = value;
sm501.c:	ret = s->dc_panel_control;
sm501.c:	ret = s->dc_panel_panning_control;
sm501.c:	ret = s->dc_panel_fb_addr;
sm501.c:	ret = s->dc_panel_fb_offset;
sm501.c:	ret = s->dc_panel_fb_width;
sm501.c:	ret = s->dc_panel_fb_height;
sm501.c:	ret = s->dc_panel_tl_location;
sm501.c:	ret = s->dc_panel_br_location;
sm501.c:	ret = s->dc_panel_h_total;
sm501.c:	ret = s->dc_panel_h_sync;
sm501.c:	ret = s->dc_panel_v_total;
sm501.c:	ret = s->dc_panel_v_sync;
sm501.c:	ret = s->dc_crt_control;
sm501.c:	ret = s->dc_crt_fb_addr;
sm501.c:	ret = s->dc_crt_fb_offset;
sm501.c:	ret = s->dc_crt_h_total;
sm501.c:	ret = s->dc_crt_h_sync;
sm501.c:	ret = s->dc_crt_v_total;
sm501.c:	ret = s->dc_crt_v_sync;
sm501.c:	ret = s->dc_crt_hwc_addr;
sm501.c:	ret = s->dc_crt_hwc_addr;
sm501.c:	ret = s->dc_crt_hwc_addr;
sm501.c:	ret = s->dc_crt_hwc_addr;
sm501.c:    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400*3 - 4:
sm501.c:        ret = sm501_palette_read(opaque, addr - SM501_DC_PANEL_PALETTE);
sm501.c:	s->dc_panel_control = value & 0x0FFF73FF;
sm501.c:	s->dc_panel_panning_control = value & 0xFF3FFF3F;
sm501.c:	s->dc_panel_fb_addr = value & 0x8FFFFFF0;
sm501.c:	s->dc_panel_fb_offset = value & 0x3FF03FF0;
sm501.c:	s->dc_panel_fb_width = value & 0x0FFF0FFF;
sm501.c:	s->dc_panel_fb_height = value & 0x0FFF0FFF;
sm501.c:	s->dc_panel_tl_location = value & 0x07FF07FF;
sm501.c:	s->dc_panel_br_location = value & 0x07FF07FF;
sm501.c:	s->dc_panel_h_total = value & 0x0FFF0FFF;
sm501.c:	s->dc_panel_h_sync = value & 0x00FF0FFF;
sm501.c:	s->dc_panel_v_total = value & 0x0FFF0FFF;
sm501.c:	s->dc_panel_v_sync = value & 0x003F0FFF;
sm501.c:	s->dc_panel_hwc_addr = value & 0x8FFFFFF0;
sm501.c:	s->dc_panel_hwc_addr = value & 0x0FFF0FFF;
sm501.c:	s->dc_panel_hwc_addr = value;
sm501.c:	s->dc_panel_hwc_addr = value & 0x0000FFFF;
sm501.c:	s->dc_crt_control = value & 0x0003FFFF;
sm501.c:	s->dc_crt_fb_addr = value & 0x8FFFFFF0;
sm501.c:	s->dc_crt_fb_offset = value & 0x3FF03FF0;
sm501.c:	s->dc_crt_h_total = value & 0x0FFF0FFF;
sm501.c:	s->dc_crt_h_sync = value & 0x00FF0FFF;
sm501.c:	s->dc_crt_v_total = value & 0x0FFF0FFF;
sm501.c:	s->dc_crt_v_sync = value & 0x003F0FFF;
sm501.c:	s->dc_crt_hwc_addr = value & 0x8FFFFFF0;
sm501.c:	s->dc_crt_hwc_addr = value & 0x0FFF0FFF;
sm501.c:	s->dc_crt_hwc_addr = value;
sm501.c:	s->dc_crt_hwc_addr = value & 0x0000FFFF;
sm501.c:    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400*3 - 4:
sm501.c:        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);
sm501.c:	if (is_surface_bgr(s->surface))
sm501.c:    int width = (s->dc_crt_h_total & 0x00000FFF) + 1;
sm501.c:    int height = (s->dc_crt_v_total & 0x00000FFF) + 1;
sm501.c:    uint8_t  * src = s->local_mem;
sm501.c:    int dst_bpp = ds_get_bytes_per_pixel(s->ds) + (ds_get_bits_per_pixel(s->ds) % 8 ? 1 : 0);
sm501.c:    uint32_t * palette = (uint32_t *)&s->dc_palette[SM501_DC_CRT_PALETTE
sm501.c:						    - SM501_DC_PANEL_PALETTE];
sm501.c:    int ds_depth_index = get_depth_index(s->ds);
sm501.c:    int y_start = -1;
sm501.c:    int page_max = -1;
sm501.c:    ram_addr_t offset = s->local_mem_offset;
sm501.c:    switch (s->dc_crt_control & 3) {
sm501.c:	       s->dc_crt_control);
sm501.c:    if (s->last_width != width || s->last_height != height) {
sm501.c:	qemu_console_resize(s->ds, width, height);
sm501.c:	s->last_width = width;
sm501.c:	s->last_height = height;
sm501.c:	ram_addr_t page1 = (offset + width * src_bpp - 1) & TARGET_PAGE_MASK;
sm501.c:	    draw_line(&(ds_get_data(s->ds)[y * width * dst_bpp]), src, width, palette);
sm501.c:		dpy_update(s->ds, 0, y_start, width, y - y_start);
sm501.c:		y_start = -1;
sm501.c:	dpy_update(s->ds, 0, y_start, width, y - y_start);
sm501.c:    if (page_max != -1)
sm501.c:    if (s->dc_crt_control & SM501_DC_CRT_CONTROL_ENABLE)
sm501.c:    s->base = base;
sm501.c:    s->local_mem_size_index
sm501.c:		  s->local_mem_size_index);
sm501.c:    s->system_control = 0x00100000;
sm501.c:    s->misc_control = 0x00001000; /* assumes SH, active=low */
sm501.c:    s->dc_panel_control = 0x00010000;
sm501.c:    s->dc_crt_control = 0x00010000;
sm501.c:    s->local_mem_offset = qemu_ram_alloc(local_mem_bytes);
sm501.c:    s->local_mem = qemu_get_ram_ptr(s->local_mem_offset);
sm501.c:    cpu_register_physical_memory(base, local_mem_bytes, s->local_mem_offset);
sm501.c:                        2, -1, irq);
sm501.c:    s->ds = graphic_console_init(sm501_update_display, NULL,
sm501_template.h: * Copyright (c) 2008 Shin-ichiro KAWASAKI
sm501_template.h:    } while (-- width != 0);
sm501_template.h:    } while (-- width != 0);
sm501_template.h:    } while (-- width != 0);
smbios.c: * Copyright (C) 2009 Hewlett-Packard Development Company, L.P.
smbios.c: * the COPYING file in the top-level directory.
smbios.c:        if (entry == SMBIOS_TABLE_ENTRY && header->type == SMBIOS_FIELD_ENTRY) {
smbios.c:            if (type == field->type) {
smbios.c:                   header->type == SMBIOS_TABLE_ENTRY) {
smbios.c:            if (type == table->type) {
smbios.c:        p += le16_to_cpu(header->length);
smbios.c:    field->header.type = SMBIOS_FIELD_ENTRY;
smbios.c:    field->header.length = cpu_to_le16(sizeof(*field) + len);
smbios.c:    field->type = type;
smbios.c:    field->offset = cpu_to_le16(offset);
smbios.c:    memcpy(field->data, data, len);
smbios.c:        if (size == -1 || size < sizeof(struct smbios_structure_header)) {
smbios.c:        table->header.type = SMBIOS_TABLE_ENTRY;
smbios.c:        table->header.length = cpu_to_le16(sizeof(*table) + size);
smbios.c:        if (load_image(buf, table->data) != size) {
smbios.c:        header = (struct smbios_structure_header *)(table->data);
smbios.c:        smbios_check_collision(header->type, SMBIOS_TABLE_ENTRY);
smbios.c:        if (header->type == 4) {
smbios.c:    return -1;
smbios.h: * Copyright (C) 2009 Hewlett-Packard Development Company, L.P.
smbios.h: * the COPYING file in the top-level directory.
smbios.h:/* SMBIOS type 0 - BIOS Information */
smbios.h:/* SMBIOS type 1 - System Information */
smbios.h:/* SMBIOS type 3 - System Enclosure (v2.3) */
smbios.h:/* SMBIOS type 4 - Processor Information (v2.0) */
smbios.h:/* SMBIOS type 16 - Physical Memory Array
smbios.h:/* SMBIOS type 17 - Memory Device
smbios.h:/* SMBIOS type 19 - Memory Array Mapped Address */
smbios.h:/* SMBIOS type 20 - Memory Device Mapped Address */
smbios.h:/* SMBIOS type 32 - System Boot Information */
smbios.h:/* SMBIOS type 127 -- End-of-table */
smbus.c:do { printf("smbus(%02x): " fmt , dev->i2c.address, ## __VA_ARGS__); } while (0)
smbus.c:    SMBUS_CONFUSED = -1
smbus.c:    SMBusDeviceInfo *t = container_of(dev->i2c.info, SMBusDeviceInfo, i2c);
smbus.c:    if (t->quick_cmd)
smbus.c:        t->quick_cmd(dev, recv);
smbus.c:    SMBusDeviceInfo *t = container_of(dev->i2c.info, SMBusDeviceInfo, i2c);
smbus.c:    if (dev->data_len == 0) {
smbus.c:    } else if (dev->data_len == 1) {
smbus.c:        if (t->send_byte) {
smbus.c:            t->send_byte(dev, dev->data_buf[0]);
smbus.c:        dev->command = dev->data_buf[0];
smbus.c:        DPRINTF("Command %d len %d\n", dev->command, dev->data_len - 1);
smbus.c:        if (t->write_data) {
smbus.c:            t->write_data(dev, dev->command, dev->data_buf + 1,
smbus.c:                          dev->data_len - 1);
smbus.c:        switch (dev->mode) {
smbus.c:            dev->mode = SMBUS_WRITE_DATA;
smbus.c:            BADF("Unexpected send start condition in state %d\n", dev->mode);
smbus.c:            dev->mode = SMBUS_CONFUSED;
smbus.c:        switch (dev->mode) {
smbus.c:            dev->mode = SMBUS_RECV_BYTE;
smbus.c:            if (dev->data_len == 0) {
smbus.c:                dev->mode = SMBUS_CONFUSED;
smbus.c:                if (dev->data_len > 1) {
smbus.c:                    dev->command = dev->data_buf[0];
smbus.c:                    DPRINTF("%02x: Command %d\n", dev->i2c.address,
smbus.c:                            dev->command);
smbus.c:                dev->data_len = 0;
smbus.c:                dev->mode = SMBUS_READ_DATA;
smbus.c:            BADF("Unexpected recv start condition in state %d\n", dev->mode);
smbus.c:            dev->mode = SMBUS_CONFUSED;
smbus.c:        switch (dev->mode) {
smbus.c:        dev->mode = SMBUS_IDLE;
smbus.c:        dev->data_len = 0;
smbus.c:        switch (dev->mode) {
smbus.c:            dev->mode = SMBUS_DONE;
smbus.c:            BADF("Unexpected NACK in state %d\n", dev->mode);
smbus.c:            dev->mode = SMBUS_CONFUSED;
smbus.c:    SMBusDeviceInfo *t = container_of(s->info, SMBusDeviceInfo, i2c);
smbus.c:    switch (dev->mode) {
smbus.c:        if (t->receive_byte) {
smbus.c:            ret = t->receive_byte(dev);
smbus.c:        dev->mode = SMBUS_DONE;
smbus.c:        if (t->read_data) {
smbus.c:            ret = t->read_data(dev, dev->command, dev->data_len);
smbus.c:            dev->data_len++;
smbus.c:        BADF("Unexpected read in state %d\n", dev->mode);
smbus.c:        dev->mode = SMBUS_CONFUSED;
smbus.c:    switch (dev->mode) {
smbus.c:        dev->data_buf[dev->data_len++] = data;
smbus.c:        BADF("Unexpected write in state %d\n", dev->mode);
smbus.c:    SMBusDeviceInfo *t = container_of(i2c->info, SMBusDeviceInfo, i2c);
smbus.c:    return t->init(dev);
smbus.c:    assert(info->i2c.qdev.size >= sizeof(SMBusDevice));
smbus.c:    info->i2c.init = smbus_device_init;
smbus.c:    info->i2c.event = smbus_i2c_event;
smbus.c:    info->i2c.recv = smbus_i2c_recv;
smbus.c:    info->i2c.send = smbus_i2c_send;
smbus.c:    i2c_register_slave(&info->i2c);
smbus_eeprom.c:    printf("eeprom_quick_cmd: addr=0x%02x read=%d\n", dev->i2c.address, read);
smbus_eeprom.c:           dev->i2c.address, val);
smbus_eeprom.c:    eeprom->offset = val;
smbus_eeprom.c:    uint8_t *data = eeprom->data;
smbus_eeprom.c:    uint8_t val = data[eeprom->offset++];
smbus_eeprom.c:           dev->i2c.address, val);
smbus_eeprom.c:           dev->i2c.address, cmd, buf[0]);
smbus_eeprom.c:        n = 256 - cmd;
smbus_eeprom.c:    memcpy(eeprom->data + cmd, buf, n);
smbus_eeprom.c:    len -= n;
smbus_eeprom.c:        memcpy(eeprom->data, buf + n, len);
smbus_eeprom.c:        eeprom->offset = cmd;
smbus_eeprom.c:    eeprom->offset = 0;
smbus_eeprom.c:    .i2c.qdev.name = "smbus-eeprom",
smc91c111.c:    if (s->tx_fifo_len == 0)
smc91c111.c:        s->int_level |= INT_TX_EMPTY;
smc91c111.c:    if (s->tx_fifo_done_len != 0)
smc91c111.c:        s->int_level |= INT_TX;
smc91c111.c:    level = (s->int_level & s->int_mask) != 0;
smc91c111.c:    qemu_set_irq(s->irq, level);
smc91c111.c:    if (s->allocated == (1 << NUM_PACKETS) - 1) {
smc91c111.c:        if ((s->allocated & (1 << i)) == 0)
smc91c111.c:    s->allocated |= 1 << i;
smc91c111.c:    s->tx_alloc = smc91c111_allocate_packet(s);
smc91c111.c:    if (s->tx_alloc == 0x80)
smc91c111.c:    s->int_level |= INT_ALLOC;
smc91c111.c:    s->rx_fifo_len--;
smc91c111.c:    if (s->rx_fifo_len) {
smc91c111.c:        for (i = 0; i < s->rx_fifo_len; i++)
smc91c111.c:            s->rx_fifo[i] = s->rx_fifo[i + 1];
smc91c111.c:        s->int_level |= INT_RCV;
smc91c111.c:        s->int_level &= ~INT_RCV;
smc91c111.c:    if (s->tx_fifo_done_len == 0)
smc91c111.c:    s->tx_fifo_done_len--;
smc91c111.c:    for (i = 0; i < s->tx_fifo_done_len; i++)
smc91c111.c:        s->tx_fifo_done[i] = s->tx_fifo_done[i + 1];
smc91c111.c:    s->allocated &= ~(1 << packet);
smc91c111.c:    if (s->tx_alloc == 0x80)
smc91c111.c:    if ((s->tcr & TCR_TXEN) == 0)
smc91c111.c:    if (s->tx_fifo_len == 0)
smc91c111.c:    for (i = 0; i < s->tx_fifo_len; i++) {
smc91c111.c:        packetnum = s->tx_fifo[i];
smc91c111.c:        p = &s->data[packetnum][0];
smc91c111.c:        len -= 6;
smc91c111.c:        if (len < 64 && (s->tcr & TCR_PAD_EN)) {
smc91c111.c:            memset(p + len, 0, 64 - len);
smc91c111.c:        add_crc = (control & 0x10) || (s->tcr & TCR_NOCRC) == 0;
smc91c111.c:        if (s->ctr & CTR_AUTO_RELEASE)
smc91c111.c:        else if (s->tx_fifo_done_len < NUM_PACKETS)
smc91c111.c:            s->tx_fifo_done[s->tx_fifo_done_len++] = packetnum;
smc91c111.c:        qemu_send_packet(&s->nic->nc, p, len);
smc91c111.c:    s->tx_fifo_len = 0;
smc91c111.c:    if (s->tx_fifo_len == NUM_PACKETS)
smc91c111.c:    s->tx_fifo[s->tx_fifo_len++] = packet;
smc91c111.c:    s->bank = 0;
smc91c111.c:    s->tx_fifo_len = 0;
smc91c111.c:    s->tx_fifo_done_len = 0;
smc91c111.c:    s->rx_fifo_len = 0;
smc91c111.c:    s->allocated = 0;
smc91c111.c:    s->packet_num = 0;
smc91c111.c:    s->tx_alloc = 0;
smc91c111.c:    s->tcr = 0;
smc91c111.c:    s->rcr = 0;
smc91c111.c:    s->cr = 0xa0b1;
smc91c111.c:    s->ctr = 0x1210;
smc91c111.c:    s->ptr = 0;
smc91c111.c:    s->ercv = 0x1f;
smc91c111.c:    s->int_level = INT_TX_EMPTY;
smc91c111.c:    s->int_mask = 0;
smc91c111.c:#define SET_LOW(name, val) s->name = (s->name & 0xff00) | val
smc91c111.c:#define SET_HIGH(name, val) s->name = (s->name & 0xff) | (val << 8)
smc91c111.c:        s->bank = value;
smc91c111.c:    switch (s->bank) {
smc91c111.c:            if (s->rcr & RCR_SOFT_RST)
smc91c111.c:            case 0: /* no-op */
smc91c111.c:                s->tx_alloc = 0x80;
smc91c111.c:                s->int_level &= ~INT_ALLOC;
smc91c111.c:                s->allocated = 0;
smc91c111.c:                s->tx_fifo_len = 0;
smc91c111.c:                s->tx_fifo_done_len = 0;
smc91c111.c:                s->rx_fifo_len = 0;
smc91c111.c:                s->tx_alloc = 0;
smc91c111.c:                if (s->rx_fifo_len > 0) {
smc91c111.c:                    smc91c111_release_packet(s, s->rx_fifo[0]);
smc91c111.c:                smc91c111_release_packet(s, s->packet_num);
smc91c111.c:                smc91c111_queue_tx(s, s->packet_num);
smc91c111.c:                s->tx_fifo_len = 0;
smc91c111.c:                s->tx_fifo_done_len = 0;
smc91c111.c:            s->packet_num = value;
smc91c111.c:                if (s->ptr & 0x8000)
smc91c111.c:                    n = s->rx_fifo[0];
smc91c111.c:                    n = s->packet_num;
smc91c111.c:                p = s->ptr & 0x07ff;
smc91c111.c:                if (s->ptr & 0x4000) {
smc91c111.c:                    s->ptr = (s->ptr & 0xf800) | ((s->ptr + 1) & 0x7ff);
smc91c111.c:                s->data[n][p] = value;
smc91c111.c:            s->int_level &= ~(value & 0xd6);
smc91c111.c:            s->int_mask = value;
smc91c111.c:            s->ercv = value & 0x1f;
smc91c111.c:    hw_error("smc91c111_write: Bad reg %d:%x\n", s->bank, (int)offset);
smc91c111.c:        return s->bank;
smc91c111.c:    switch (s->bank) {
smc91c111.c:            return s->tcr & 0xff;
smc91c111.c:            return s->tcr >> 8;
smc91c111.c:            return s->rcr & 0xff;
smc91c111.c:            return s->rcr >> 8;
smc91c111.c:                    if (s->allocated & (1 << i))
smc91c111.c:            return s->cr & 0xff;
smc91c111.c:            return s->cr >> 8;
smc91c111.c:            return s->conf.macaddr.a[offset - 4];
smc91c111.c:            return s->gpr & 0xff;
smc91c111.c:            return s->gpr >> 8;
smc91c111.c:            return s->ctr & 0xff;
smc91c111.c:            return s->ctr >> 8;
smc91c111.c:            return s->packet_num;
smc91c111.c:            return s->tx_alloc;
smc91c111.c:            if (s->tx_fifo_done_len == 0)
smc91c111.c:                return s->tx_fifo_done[0];
smc91c111.c:            if (s->rx_fifo_len == 0)
smc91c111.c:                return s->rx_fifo[0];
smc91c111.c:            return s->ptr & 0xff;
smc91c111.c:            return (s->ptr >> 8) & 0xf7;
smc91c111.c:                if (s->ptr & 0x8000)
smc91c111.c:                    n = s->rx_fifo[0];
smc91c111.c:                    n = s->packet_num;
smc91c111.c:                p = s->ptr & 0x07ff;
smc91c111.c:                if (s->ptr & 0x4000) {
smc91c111.c:                    s->ptr = (s->ptr & 0xf800) | ((s->ptr + 1) & 0x07ff);
smc91c111.c:                return s->data[n][p];
smc91c111.c:            return s->int_level;
smc91c111.c:            return s->int_mask;
smc91c111.c:            return s->ercv;
smc91c111.c:    hw_error("smc91c111_read: Bad reg %d:%x\n", s->bank, (int)offset);
smc91c111.c:    /* 32-bit writes to offset 0xc only actually write to the bank select
smc91c111.c:    smc91c111_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
smc91c111.c:    if ((s->rcr & RCR_RXEN) == 0 || (s->rcr & RCR_SOFT_RST))
smc91c111.c:    if (s->allocated == (1 << NUM_PACKETS) - 1)
smc91c111.c:    smc91c111_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
smc91c111.c:    if ((s->rcr & RCR_RXEN) == 0 || (s->rcr & RCR_SOFT_RST))
smc91c111.c:        return -1;
smc91c111.c:    crc = (s->rcr & RCR_STRIP_CRC) == 0;
smc91c111.c:        return -1;
smc91c111.c:        return -1;
smc91c111.c:    s->rx_fifo[s->rx_fifo_len++] = packetnum;
smc91c111.c:    p = &s->data[packetnum][0];
smc91c111.c:            *(p++) = buf[size - 1];
smc91c111.c:        pad = 64 - size;
smc91c111.c:       The pictures in the documentation show the CRC aligned on a 16-bit
smc91c111.c:        *(p++) = buf[size - 1];
smc91c111.c:    s->int_level |= INT_RCV;
smc91c111.c:    smc91c111_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
smc91c111.c:    s->nic = NULL;
smc91c111.c:    s->mmio_index = cpu_register_io_memory(smc91c111_readfn,
smc91c111.c:    sysbus_init_mmio(dev, 16, s->mmio_index);
smc91c111.c:    sysbus_init_irq(dev, &s->irq);
smc91c111.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
smc91c111.c:    s->nic = qemu_new_nic(&net_smc91c111_info, &s->conf,
smc91c111.c:                          dev->qdev.info->name, dev->qdev.id, s);
smc91c111.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
soc_dma.c: * On-chip DMA controller framework.
soc_dma.c:#include "qemu-common.h"
soc_dma.c:#include "qemu-timer.h"
soc_dma.c:    memcpy(ch->paddr[0], ch->paddr[1], ch->bytes);
soc_dma.c:    ch->paddr[0] += ch->bytes;
soc_dma.c:    ch->paddr[1] += ch->bytes;
soc_dma.c:    ch->io_fn[1](ch->io_opaque[1], ch->paddr[0], ch->bytes);
soc_dma.c:    ch->paddr[0] += ch->bytes;
soc_dma.c:    ch->io_fn[0](ch->io_opaque[0], ch->paddr[1], ch->bytes);
soc_dma.c:    ch->paddr[1] += ch->bytes;
soc_dma.c:    if (ch->bytes > fifo_size)
soc_dma.c:        fifo_buf = qemu_realloc(fifo_buf, fifo_size = ch->bytes);
soc_dma.c:    ch->io_fn[0](ch->io_opaque[0], fifo_buf, ch->bytes);
soc_dma.c:    ch->io_fn[1](ch->io_opaque[1], fifo_buf, ch->bytes);
soc_dma.c:    struct dma_s *dma = (struct dma_s *) ch->dma;
soc_dma.c:    qemu_mod_timer(ch->timer, now + delay_bytes / dma->channel_freq);
soc_dma.c:    ch->running = 1;
soc_dma.c:    ch->dma->setup_fn(ch);
soc_dma.c:    ch->transfer_fn(ch);
soc_dma.c:    ch->running = 0;
soc_dma.c:    if (ch->enable)
soc_dma.c:        soc_dma_ch_schedule(ch, ch->bytes);
soc_dma.c:    ch->bytes = 0;
soc_dma.c:    lo = dma->memmap;
soc_dma.c:    hi = dma->memmap_size;
soc_dma.c:    struct dma_s *dma = (struct dma_s *) ch->dma;
soc_dma.c:    struct memmap_entry_s *entry = soc_dma_lookup(dma, ch->vaddr[port]);
soc_dma.c:    if (entry->type == soc_dma_port_fifo) {
soc_dma.c:        while (entry < dma->memmap + dma->memmap_size &&
soc_dma.c:                        entry->u.fifo.out != port)
soc_dma.c:        if (entry->addr != ch->vaddr[port] || entry->u.fifo.out != port)
soc_dma.c:        if (ch->type[port] != soc_dma_access_const)
soc_dma.c:        ch->io_fn[port] = entry->u.fifo.fn;
soc_dma.c:        ch->io_opaque[port] = entry->u.fifo.opaque;
soc_dma.c:    } else if (entry->type == soc_dma_port_mem) {
soc_dma.c:        if (entry->addr > ch->vaddr[port] ||
soc_dma.c:                        entry->addr + entry->u.mem.size <= ch->vaddr[port])
soc_dma.c:        if (ch->type[port] != soc_dma_access_const)
soc_dma.c:        ch->paddr[port] = (uint8_t *) entry->u.mem.base +
soc_dma.c:                (ch->vaddr[port] - entry->addr);
soc_dma.c:        ch->update = 0;
soc_dma.c:        ch->transfer_fn = ch->dma->transfer_fn;
soc_dma.c:        ch->transfer_fn = transfer_mem2mem;
soc_dma.c:        ch->transfer_fn = transfer_mem2fifo;
soc_dma.c:        ch->transfer_fn = transfer_fifo2mem;
soc_dma.c:        ch->transfer_fn = transfer_fifo2fifo;
soc_dma.c:        ch->transfer_fn = ch->dma->transfer_fn;
soc_dma.c:    ch->update = (dst != soc_dma_port_other);
soc_dma.c:    if (s->enabled_count)
soc_dma.c:        s->channel_freq = s->soc.freq / s->enabled_count;
soc_dma.c:         * auto-idle is enabled in the clock controller and if we are stopping
soc_dma.c:         * user keeping them on and auto-idle enabled.  */;
soc_dma.c:    struct dma_s *dma = (struct dma_s *) ch->dma;
soc_dma.c:    dma->enabled_count += level - ch->enable;
soc_dma.c:        dma->ch_enable_mask |= 1 << ch->num;
soc_dma.c:        dma->ch_enable_mask &= ~(1 << ch->num);
soc_dma.c:    if (level != ch->enable) {
soc_dma.c:        ch->enable = level;
soc_dma.c:        if (!ch->enable)
soc_dma.c:            qemu_del_timer(ch->timer);
soc_dma.c:        else if (!ch->running)
soc_dma.c:    s->soc.drqbmp = 0;
soc_dma.c:    s->ch_enable_mask = 0;
soc_dma.c:    s->enabled_count = 0;
soc_dma.c:/* TODO: take a functional-clock argument */
soc_dma.c:    struct dma_s *s = qemu_mallocz(sizeof(*s) + n * sizeof(*s->ch));
soc_dma.c:    s->chnum = n;
soc_dma.c:    s->soc.ch = s->ch;
soc_dma.c:        s->ch[i].dma = &s->soc;
soc_dma.c:        s->ch[i].num = i;
soc_dma.c:        s->ch[i].timer = qemu_new_timer(vm_clock, soc_dma_ch_run, &s->ch[i]);
soc_dma.c:    soc_dma_reset(&s->soc);
soc_dma.c:    return &s->soc;
soc_dma.c:    dma->memmap = qemu_realloc(dma->memmap, sizeof(*entry) *
soc_dma.c:                    (dma->memmap_size + 1));
soc_dma.c:    if (dma->memmap_size) {
soc_dma.c:        if (entry->type == soc_dma_port_mem) {
soc_dma.c:            if (entry->addr <= virt_base &&
soc_dma.c:                            entry->addr + entry->u.mem.size > virt_base) {
soc_dma.c:                                "-" TARGET_FMT_lx "\n", __FUNCTION__,
soc_dma.c:                                (target_ulong) entry->addr, (target_ulong)
soc_dma.c:                                (entry->addr + entry->u.mem.size));
soc_dma.c:                exit(-1);
soc_dma.c:            if (entry->addr <= virt_base)
soc_dma.c:            while (entry < dma->memmap + dma->memmap_size &&
soc_dma.c:                            entry->addr <= virt_base) {
soc_dma.c:                if (entry->addr == virt_base && entry->u.fifo.out == out) {
soc_dma.c:                                    (target_ulong) entry->addr);
soc_dma.c:                    exit(-1);
soc_dma.c:                        (uint8_t *) (dma->memmap + dma->memmap_size ++) -
soc_dma.c:        dma->memmap_size ++;
soc_dma.c:    entry->addr          = virt_base;
soc_dma.c:    entry->type          = soc_dma_port_fifo;
soc_dma.c:    entry->u.fifo.fn     = fn;
soc_dma.c:    entry->u.fifo.opaque = opaque;
soc_dma.c:    entry->u.fifo.out    = out;
soc_dma.c:    dma->memmap = qemu_realloc(dma->memmap, sizeof(*entry) *
soc_dma.c:                    (dma->memmap_size + 1));
soc_dma.c:    if (dma->memmap_size) {
soc_dma.c:        if (entry->type == soc_dma_port_mem) {
soc_dma.c:            if ((entry->addr >= virt_base && entry->addr < virt_base + size) ||
soc_dma.c:                            (entry->addr <= virt_base &&
soc_dma.c:                             entry->addr + entry->u.mem.size > virt_base)) {
soc_dma.c:                fprintf(stderr, "%s: RAM at " TARGET_FMT_lx "-" TARGET_FMT_lx
soc_dma.c:                                "-" TARGET_FMT_lx "\n", __FUNCTION__,
soc_dma.c:                                (target_ulong) entry->addr, (target_ulong)
soc_dma.c:                                (entry->addr + entry->u.mem.size));
soc_dma.c:                exit(-1);
soc_dma.c:            if (entry->addr <= virt_base)
soc_dma.c:            if (entry->addr >= virt_base &&
soc_dma.c:                            entry->addr < virt_base + size) {
soc_dma.c:                fprintf(stderr, "%s: RAM at " TARGET_FMT_lx "-" TARGET_FMT_lx
soc_dma.c:                                (target_ulong) entry->addr);
soc_dma.c:                exit(-1);
soc_dma.c:            while (entry < dma->memmap + dma->memmap_size &&
soc_dma.c:                            entry->addr <= virt_base)
soc_dma.c:                        (uint8_t *) (dma->memmap + dma->memmap_size ++) -
soc_dma.c:        dma->memmap_size ++;
soc_dma.c:    entry->addr          = virt_base;
soc_dma.c:    entry->type          = soc_dma_port_mem;
soc_dma.c:    entry->u.mem.base    = phys_base;
soc_dma.c:    entry->u.mem.size    = size;
soc_dma.h: * On-chip DMA controller framework.
soc_dma.h:    /* This should be set by dma->setup_fn().  */
soc_dma.h: *   ch->type[0...1],
soc_dma.h: *   ch->vaddr[0...1],
soc_dma.h: *   ch->paddr[0...1],
sparc32_dma.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/NCR89C100.txt
sparc32_dma.c: * http://www.ibiblio.org/pub/historic-linux/early-ports/Sparc/NCR/DMA2.txt
sparc32_dma.c:#define DMA_MASK (DMA_SIZE - 1)
sparc32_dma.c:            s->dmaregs[0] & DMA_WRITE_MEM ? 'w': 'r', s->dmaregs[1]);
sparc32_dma.c:    addr |= s->dmaregs[3];
sparc32_dma.c:        sparc_iommu_memory_read(s->iommu, addr, buf, len);
sparc32_dma.c:        sparc_iommu_memory_read(s->iommu, addr, buf, len);
sparc32_dma.c:            s->dmaregs[0] & DMA_WRITE_MEM ? 'w': 'r', s->dmaregs[1]);
sparc32_dma.c:    addr |= s->dmaregs[3];
sparc32_dma.c:        sparc_iommu_memory_write(s->iommu, addr, buf, len);
sparc32_dma.c:            sparc_iommu_memory_write(s->iommu, addr, (uint8_t *)tmp_buf, l);
sparc32_dma.c:            len -= l;
sparc32_dma.c:        s->dmaregs[0] |= DMA_INTR;
sparc32_dma.c:        qemu_irq_raise(s->irq);
sparc32_dma.c:        s->dmaregs[0] &= ~DMA_INTR;
sparc32_dma.c:        qemu_irq_lower(s->irq);
sparc32_dma.c:            s->dmaregs[0] & DMA_WRITE_MEM ? 'w': 'r', s->dmaregs[1]);
sparc32_dma.c:    sparc_iommu_memory_read(s->iommu, s->dmaregs[1], buf, len);
sparc32_dma.c:    s->dmaregs[0] |= DMA_INTR;
sparc32_dma.c:    s->dmaregs[1] += len;
sparc32_dma.c:            s->dmaregs[0] & DMA_WRITE_MEM ? 'w': 'r', s->dmaregs[1]);
sparc32_dma.c:    sparc_iommu_memory_write(s->iommu, s->dmaregs[1], buf, len);
sparc32_dma.c:    s->dmaregs[0] |= DMA_INTR;
sparc32_dma.c:    s->dmaregs[1] += len;
sparc32_dma.c:            s->dmaregs[saddr]);
sparc32_dma.c:    return s->dmaregs[saddr];
sparc32_dma.c:    DPRINTF("write dmareg " TARGET_FMT_plx ": 0x%8.8x -> 0x%8.8x\n", addr,
sparc32_dma.c:            s->dmaregs[saddr], val);
sparc32_dma.c:            qemu_irq_lower(s->irq);
sparc32_dma.c:            qemu_irq_raise(s->dev_reset);
sparc32_dma.c:            qemu_irq_lower(s->dev_reset);
sparc32_dma.c:        s->dmaregs[0] |= DMA_LOADED;
sparc32_dma.c:    s->dmaregs[saddr] = val;
sparc32_dma.c:    memset(s->dmaregs, 0, DMA_SIZE);
sparc32_dma.c:    s->dmaregs[0] = DMA_VER;
sparc32_dma.c:    sysbus_init_irq(dev, &s->irq);
sparc32_dma.c:    qdev_init_gpio_in(&dev->qdev, dma_set_irq, 1);
sparc32_dma.c:    qdev_init_gpio_out(&dev->qdev, &s->dev_reset, 1);
spitz.c: * PXA270-based Clamshell PDA platforms.
spitz.c:#include "arm-misc.h"
spitz.c:#include "qemu-timer.h"
spitz.c:#define FLASH_ECCLPLB		0x00	/* Line parity 7 - 0 bit */
spitz.c:#define FLASH_ECCLPUB		0x04	/* Line parity 15 - 8 bit */
spitz.c:#define FLASH_ECCCP		0x08	/* Column parity 5 - 0 bit */
spitz.c:#define BSHR(byte, from, to)	((s->ecc.lp[byte] >> (from - to)) & (1 << to))
spitz.c:#define BSHL(byte, from, to)	((s->ecc.lp[byte] << (to - from)) & (1 << to))
spitz.c:        return s->ecc.cp;
spitz.c:        return s->ecc.count & 0xff;
spitz.c:        nand_getpins(s->nand, &ryby);
spitz.c:            return s->ctl | FLASHCTL_RYBY;
spitz.c:            return s->ctl;
spitz.c:        return ecc_digest(&s->ecc, nand_getio(s->nand));
spitz.c:        return ecc_digest(&s->ecc, nand_getio(s->nand)) |
spitz.c:                (ecc_digest(&s->ecc, nand_getio(s->nand)) << 16);
spitz.c:        ecc_reset(&s->ecc);
spitz.c:        s->ctl = value & 0xff & ~FLASHCTL_RYBY;
spitz.c:        nand_setpins(s->nand,
spitz.c:                        s->ctl & FLASHCTL_CLE,
spitz.c:                        s->ctl & FLASHCTL_ALE,
spitz.c:                        s->ctl & FLASHCTL_NCE,
spitz.c:                        s->ctl & FLASHCTL_WP,
spitz.c:        nand_setio(s->nand, ecc_digest(&s->ecc, value & 0xff));
spitz.c:    qemu_put_8s(f, &s->ctl);
spitz.c:    ecc_put(f, &s->ecc);
spitz.c:    qemu_get_8s(f, &s->ctl);
spitz.c:    ecc_get(f, &s->ecc);
spitz.c:    s->ctl = 0;
spitz.c:        s->nand = nand_init(NAND_MFR_SAMSUNG, 0x73);
spitz.c:        s->nand = nand_init(NAND_MFR_SAMSUNG, 0xf1);
spitz.c:    {  -1 , 0x03, 0x05, 0x13, 0x15, 0x09, 0x17, 0x18, 0x19, 0x41, 0x42 },
spitz.c:    { 0x0f, 0x10, 0x12, 0x14, 0x22, 0x16, 0x24, 0x25,  -1 ,  -1 ,  -1  },
spitz.c:    { 0x3c, 0x11, 0x1f, 0x21, 0x2f, 0x23, 0x32, 0x26,  -1 , 0x36,  -1  },
spitz.c:    { 0x3b, 0x1e, 0x20, 0x2e, 0x30, 0x31, 0x34,  -1 , 0x1c, 0x2a,  -1  },
spitz.c:    { 0x44, 0x2c, 0x2d, 0x0c, 0x39, 0x33,  -1 , 0x48,  -1 ,  -1 , 0x38 },
spitz.c:    { 0x37, 0x3d,  -1 , 0x45, 0x57, 0x58, 0x4b, 0x50, 0x4d,  -1 ,  -1  },
spitz.c:    { 0x52, 0x43, 0x01, 0x47, 0x49,  -1 ,  -1 ,  -1 ,  -1 ,  -1 ,  -1  },
spitz.c:        strobe = s->keyrow[i] & s->strobe_state;
spitz.c:            if (!(s->sense_state & (1 << i)))
spitz.c:                qemu_irq_raise(s->sense[i]);
spitz.c:        } else if (s->sense_state & (1 << i))
spitz.c:            qemu_irq_lower(s->sense[i]);
spitz.c:    s->sense_state = sense;
spitz.c:        s->strobe_state |= 1 << line;
spitz.c:        s->strobe_state &= ~(1 << line);
spitz.c:    int spitz_keycode = s->keymap[keycode & 0x7f];
spitz.c:    if (spitz_keycode == -1)
spitz.c:        qemu_set_irq(s->gpiomap[spitz_keycode & 0xf], (keycode < 0x80) ^
spitz.c:        s->keyrow[spitz_keycode >> 4] &= ~(1 << (spitz_keycode & 0xf));
spitz.c:        s->keyrow[spitz_keycode >> 4] |= 1 << (spitz_keycode & 0xf);
spitz.c:#define QUEUE_KEY(c)	s->fifo[(s->fifopos + s->fifolen ++) & 0xf] = c
spitz.c:        s->modifiers |= 1;
spitz.c:        s->modifiers &= ~1;
spitz.c:        s->modifiers |= 2;
spitz.c:        s->modifiers &= ~2;
spitz.c:        s->modifiers |= 4;
spitz.c:        s->modifiers &= ~4;
spitz.c:        s->modifiers |= 8;
spitz.c:        s->modifiers &= ~8;
spitz.c:    code = s->pre_map[mapcode = ((s->modifiers & 3) ?
spitz.c:        if ((code & SHIFT) && !(s->modifiers & 1))
spitz.c:        if ((code & CTRL ) && !(s->modifiers & 4))
spitz.c:        if ((code & FN   ) && !(s->modifiers & 8))
spitz.c:        if ((code & FN   ) && (s->modifiers & 1))
spitz.c:        if ((code & FN   ) && (s->modifiers & 2))
spitz.c:            if ((s->imodifiers & 1   ) && !(s->modifiers & 1))
spitz.c:            if ((s->imodifiers & 4   ) && !(s->modifiers & 4))
spitz.c:            if ((s->imodifiers & 8   ) && !(s->modifiers & 8))
spitz.c:            if ((s->imodifiers & 0x10) && (s->modifiers & 1))
spitz.c:            if ((s->imodifiers & 0x20) && (s->modifiers & 2))
spitz.c:            s->imodifiers = 0;
spitz.c:            if ((code & SHIFT) && !((s->modifiers | s->imodifiers) & 1)) {
spitz.c:                s->imodifiers |= 1;
spitz.c:            if ((code & CTRL ) && !((s->modifiers | s->imodifiers) & 4)) {
spitz.c:                s->imodifiers |= 4;
spitz.c:            if ((code & FN   ) && !((s->modifiers | s->imodifiers) & 8)) {
spitz.c:                s->imodifiers |= 8;
spitz.c:            if ((code & FN   ) && (s->modifiers & 1) &&
spitz.c:                            !(s->imodifiers & 0x10)) {
spitz.c:                s->imodifiers |= 0x10;
spitz.c:            if ((code & FN   ) && (s->modifiers & 2) &&
spitz.c:                            !(s->imodifiers & 0x20)) {
spitz.c:                s->imodifiers |= 0x20;
spitz.c:    if (s->fifolen) {
spitz.c:        spitz_keyboard_keydown(s, s->fifo[s->fifopos ++]);
spitz.c:        s->fifolen --;
spitz.c:        if (s->fifopos >= 16)
spitz.c:            s->fifopos = 0;
spitz.c:    qemu_mod_timer(s->kbdtimer, qemu_get_clock(vm_clock) +
spitz.c:        s->pre_map[i] = i;
spitz.c:    s->pre_map[0x02 | SHIFT	] = 0x02 | SHIFT;	/* exclam */
spitz.c:    s->pre_map[0x28 | SHIFT	] = 0x03 | SHIFT;	/* quotedbl */
spitz.c:    s->pre_map[0x04 | SHIFT	] = 0x04 | SHIFT;	/* numbersign */
spitz.c:    s->pre_map[0x05 | SHIFT	] = 0x05 | SHIFT;	/* dollar */
spitz.c:    s->pre_map[0x06 | SHIFT	] = 0x06 | SHIFT;	/* percent */
spitz.c:    s->pre_map[0x08 | SHIFT	] = 0x07 | SHIFT;	/* ampersand */
spitz.c:    s->pre_map[0x28		] = 0x08 | SHIFT;	/* apostrophe */
spitz.c:    s->pre_map[0x0a | SHIFT	] = 0x09 | SHIFT;	/* parenleft */
spitz.c:    s->pre_map[0x0b | SHIFT	] = 0x0a | SHIFT;	/* parenright */
spitz.c:    s->pre_map[0x29 | SHIFT	] = 0x0b | SHIFT;	/* asciitilde */
spitz.c:    s->pre_map[0x03 | SHIFT	] = 0x0c | SHIFT;	/* at */
spitz.c:    s->pre_map[0xd3		] = 0x0e | FN;		/* Delete */
spitz.c:    s->pre_map[0x3a		] = 0x0f | FN;		/* Caps_Lock */
spitz.c:    s->pre_map[0x07 | SHIFT	] = 0x11 | FN;		/* asciicircum */
spitz.c:    s->pre_map[0x0d		] = 0x12 | FN;		/* equal */
spitz.c:    s->pre_map[0x0d | SHIFT	] = 0x13 | FN;		/* plus */
spitz.c:    s->pre_map[0x1a		] = 0x14 | FN;		/* bracketleft */
spitz.c:    s->pre_map[0x1b		] = 0x15 | FN;		/* bracketright */
spitz.c:    s->pre_map[0x1a | SHIFT	] = 0x16 | FN;		/* braceleft */
spitz.c:    s->pre_map[0x1b | SHIFT	] = 0x17 | FN;		/* braceright */
spitz.c:    s->pre_map[0x27		] = 0x22 | FN;		/* semicolon */
spitz.c:    s->pre_map[0x27 | SHIFT	] = 0x23 | FN;		/* colon */
spitz.c:    s->pre_map[0x09 | SHIFT	] = 0x24 | FN;		/* asterisk */
spitz.c:    s->pre_map[0x2b		] = 0x25 | FN;		/* backslash */
spitz.c:    s->pre_map[0x2b | SHIFT	] = 0x26 | FN;		/* bar */
spitz.c:    s->pre_map[0x0c | SHIFT	] = 0x30 | FN;		/* underscore */
spitz.c:    s->pre_map[0x33 | SHIFT	] = 0x33 | FN;		/* less */
spitz.c:    s->pre_map[0x35		] = 0x33 | SHIFT;	/* slash */
spitz.c:    s->pre_map[0x34 | SHIFT	] = 0x34 | FN;		/* greater */
spitz.c:    s->pre_map[0x35 | SHIFT	] = 0x34 | SHIFT;	/* question */
spitz.c:    s->pre_map[0x49		] = 0x48 | FN;		/* Page_Up */
spitz.c:    s->pre_map[0x51		] = 0x50 | FN;		/* Page_Down */
spitz.c:    s->modifiers = 0;
spitz.c:    s->imodifiers = 0;
spitz.c:    s->fifopos = 0;
spitz.c:    s->fifolen = 0;
spitz.c:    s->kbdtimer = qemu_new_timer(vm_clock, spitz_keyboard_tick, s);
spitz.c:    qemu_put_be16s(f, &s->sense_state);
spitz.c:    qemu_put_be16s(f, &s->strobe_state);
spitz.c:    qemu_get_be16s(f, &s->sense_state);
spitz.c:    qemu_get_be16s(f, &s->strobe_state);
spitz.c:    memset(s->keyrow, 0, sizeof(s->keyrow));
spitz.c:    s->modifiers = 0;
spitz.c:    s->imodifiers = 0;
spitz.c:    s->fifopos = 0;
spitz.c:    s->fifolen = 0;
spitz.c:        s->keymap[i] = -1;
spitz.c:            if (spitz_keymap[i][j] != -1)
spitz.c:                s->keymap[spitz_keymap[i][j]] = (i << 4) | j;
spitz.c:        s->sense[i] = pxa2xx_gpio_in_get(cpu->gpio)[spitz_gpio_key_sense[i]];
spitz.c:        s->gpiomap[i] = pxa2xx_gpio_in_get(cpu->gpio)[spitz_gpiomap[i]];
spitz.c:    s->strobe = qemu_allocate_irqs(spitz_keyboard_strobe, s,
spitz.c:        pxa2xx_gpio_out_set(cpu->gpio, spitz_gpio_key_strobe[i], s->strobe[i]);
spitz.c:    if (s->bl_power && s->bl_intensity)
spitz.c:        zaurus_printf("LCD Backlight now at %i/63\n", s->bl_intensity);
spitz.c:    int prev = s->bl_intensity;
spitz.c:        s->bl_intensity &= ~0x20;
spitz.c:        s->bl_intensity |= 0x20;
spitz.c:    if (s->bl_power && prev != s->bl_intensity)
spitz.c:    s->bl_power = !!level;
spitz.c:        s->bl_intensity &= ~0x1f;
spitz.c:        s->bl_intensity |= value;
spitz.c:        if (s->bl_power)
spitz.c:    qemu_put_be32(f, s->bl_intensity);
spitz.c:    qemu_put_be32(f, s->bl_power);
spitz.c:    s->bl_intensity = qemu_get_be32(f);
spitz.c:    s->bl_power = qemu_get_be32(f);
spitz.c:    s->bl_power = 0;
spitz.c:    s->bl_intensity = 0x20;
spitz.c:    register_savevm("spitz-lcdtg", -1, 1,
spitz.c:        if (s->enable[i]) {
spitz.c:            return ssi_transfer(s->bus[i], value);
spitz.c:    s->enable[line] = !level;
spitz.c:        qemu_put_be32(f, s->enable[i]);
spitz.c:        return -EINVAL;
spitz.c:        s->enable[i] = qemu_get_be32(f);
spitz.c:    qdev_init_gpio_in(&dev->qdev, corgi_ssp_gpio_cs, 3);
spitz.c:    s->bus[0] = ssi_create_bus(&dev->qdev, "ssi0");
spitz.c:    s->bus[1] = ssi_create_bus(&dev->qdev, "ssi1");
spitz.c:    s->bus[2] = ssi_create_bus(&dev->qdev, "ssi2");
spitz.c:    register_savevm("spitz_ssp", -1, 1, spitz_ssp_save, spitz_ssp_load, s);
spitz.c:    mux = ssi_create_slave(cpu->ssp[CORGI_SSP_PORT - 1], "corgi-ssp");
spitz.c:    dev = ssi_create_slave(bus, "spitz-lcdtg");
spitz.c:                          pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_TP_INT]);
spitz.c:    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_LCDCON_CS,
spitz.c:    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_ADS7846_CS,
spitz.c:    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_MAX1111_CS,
spitz.c:    bs = dinfo->bdrv;
spitz.c:        pxa2xx_pcmcia_attach(cpu->pcmcia[slot], md);
spitz.c:    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);
spitz.c:    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_WM,
spitz.c:    cpu->i2s->opaque = wm;
spitz.c:    cpu->i2s->codec_out = wm8750_dac_dat;
spitz.c:    cpu->i2s->codec_in = wm8750_adc_dat;
spitz.c:    wm8750_data_req_set(wm, cpu->i2s->data_req, cpu->i2s);
spitz.c:    i2c_create_slave(pxa2xx_i2c_bus(cpu->i2c[0]), "max7310",
spitz.c:    qemu_set_irq(pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_HSYNC], spitz_hsync);
spitz.c:     * read to satisfy broken guests that poll-wait for hsync.
spitz.c:    pxa2xx_gpio_read_notifier(cpu->gpio, lcd_hsync);
spitz.c:    pxa2xx_lcd_vsync_notifier(cpu->lcd, lcd_hsync);
spitz.c:    pxa2xx_mmci_handlers(cpu->mmc,
spitz.c:                    pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_SD_WP],
spitz.c:                    pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_SD_DETECT]);
spitz.c:    qemu_irq_raise(pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_BAT_COVER]);
spitz.c:    pxa2xx_gpio_out_set(cpu->gpio, SPITZ_GPIO_ON_RESET, cpu->reset);
spitz.c:    /* PCMCIA signals: card's IRQ and Card-Detect */
spitz.c:        pxa2xx_pcmcia_set_irq_cb(cpu->pcmcia[0],
spitz.c:                        pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_CF1_IRQ],
spitz.c:                        pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_CF1_CD]);
spitz.c:        pxa2xx_pcmcia_set_irq_cb(cpu->pcmcia[1],
spitz.c:                        pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_CF2_IRQ],
spitz.c:                        pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_CF2_CD]);
spitz.c:    qemu_set_irq(pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_SWA],
spitz.c:    qemu_set_irq(pxa2xx_gpio_in_get(cpu->gpio)[SPITZ_GPIO_SWB],
spitz.c:        cpu_model = (model == terrier) ? "pxa270-c5" : "pxa270-c0";
spitz.c:    cpu->env->regs[15] = spitz_binfo.loader_start;
spitz.c:    arm_load_kernel(cpu->env, &spitz_binfo);
spitz.c:    .qdev.name = "corgi-ssp",
spitz.c:    .qdev.name = "spitz-lcdtg",
ssd0303.c: * Copyright (c) 2006-2007 CodeSourcery.
ssd0303.c:    return -1;
ssd0303.c:    switch (s->mode) {
ssd0303.c:            s->mode = SSD0303_CMD;
ssd0303.c:            s->mode = SSD0303_DATA;
ssd0303.c:        if (s->col < 132) {
ssd0303.c:            s->framebuffer[s->col + s->row * 132] = data;
ssd0303.c:            s->col++;
ssd0303.c:            s->redraw = 1;
ssd0303.c:        old_cmd_state = s->cmd_state;
ssd0303.c:        s->cmd_state = SSD0303_CMD_NONE;
ssd0303.c:            s->mode = SSD0303_IDLE;
ssd0303.c:                s->col = (s->col & 0xf0) | (data & 0xf);
ssd0303.c:                s->col = (s->col & 0x0f) | ((data & 0xf) << 4);
ssd0303.c:                s->start_line = 0;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:                s->mirror = 0;
ssd0303.c:                s->mirror = 1;
ssd0303.c:                s->flash = 0;
ssd0303.c:                s->flash = 1;
ssd0303.c:                s->inverse = 0;
ssd0303.c:                s->inverse = 1;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:            case 0xad: /* DC-DC power control.  */
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:                s->enabled = 0;
ssd0303.c:                s->enabled = 1;
ssd0303.c:                s->row = data & 7;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:            case 0xd9: /* Set pre-charge period (Ignored).  */
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:                s->cmd_state = SSD0303_CMD_SKIP1;
ssd0303.c:            case 0xe3: /* no-op.  */
ssd0303.c:        s->mode = SSD0303_IDLE;
ssd0303.c:    if (!s->redraw)
ssd0303.c:    switch (ds_get_bits_per_pixel(s->ds)) {
ssd0303.c:    if (s->flash) {
ssd0303.c:    } else if (s->inverse) {
ssd0303.c:    dest = ds_get_data(s->ds);
ssd0303.c:        line = (y + s->start_line) & 63;
ssd0303.c:        src = s->framebuffer + 132 * (line >> 3) + 36;
ssd0303.c:            memcpy(dest, dest - dest_width * 96, dest_width * 96);
ssd0303.c:    s->redraw = 0;
ssd0303.c:    dpy_update(s->ds, 0, 0, 96 * MAGNIFY, 16 * MAGNIFY);
ssd0303.c:    s->redraw = 1;
ssd0303.c:    s->ds = graphic_console_init(ssd0303_update_display,
ssd0303.c:    qemu_console_resize(s->ds, 96 * MAGNIFY, 16 * MAGNIFY);
ssd0323.c: * Copyright (c) 2006-2007 CodeSourcery.
ssd0323.c:    switch (s->mode) {
ssd0323.c:        s->framebuffer[s->col + s->row * 64] = data;
ssd0323.c:        if (s->remap & REMAP_VERTICAL) {
ssd0323.c:            s->row++;
ssd0323.c:            if (s->row > s->row_end) {
ssd0323.c:                s->row = s->row_start;
ssd0323.c:                s->col++;
ssd0323.c:            if (s->col > s->col_end) {
ssd0323.c:                s->col = s->col_start;
ssd0323.c:            s->col++;
ssd0323.c:            if (s->col > s->col_end) {
ssd0323.c:                s->row++;
ssd0323.c:                s->col = s->col_start;
ssd0323.c:            if (s->row > s->row_end) {
ssd0323.c:                s->row = s->row_start;
ssd0323.c:        s->redraw = 1;
ssd0323.c:        if (s->cmd_len == 0) {
ssd0323.c:            s->cmd = data;
ssd0323.c:            s->cmd_data[s->cmd_len - 1] = data;
ssd0323.c:        s->cmd_len++;
ssd0323.c:        switch (s->cmd) {
ssd0323.c:#define DATA(x) if (s->cmd_len <= (x)) return 0
ssd0323.c:            s->col = s->col_start = s->cmd_data[0] % 64;
ssd0323.c:            s->col_end = s->cmd_data[1] % 64;
ssd0323.c:            s->row = s->row_start = s->cmd_data[0] % 80;
ssd0323.c:            s->row_end = s->cmd_data[1] % 80;
ssd0323.c:            s->remap = s->cmd_data[0];
ssd0323.c:        case 0xad: /* Set DC-DC converter.  */
ssd0323.c:        s->cmd_len = 0;
ssd0323.c:    if (!s->redraw)
ssd0323.c:    switch (ds_get_bits_per_pixel(s->ds)) {
ssd0323.c:        switch (ds_get_bits_per_pixel(s->ds)) {
ssd0323.c:    dest = ds_get_data(s->ds);
ssd0323.c:        src = s->framebuffer + 64 * line;
ssd0323.c:            memcpy(dest, dest - dest_width * MAGNIFY * 128,
ssd0323.c:    s->redraw = 0;
ssd0323.c:    dpy_update(s->ds, 0, 0, 128 * MAGNIFY, 64 * MAGNIFY);
ssd0323.c:    s->redraw = 1;
ssd0323.c:    s->mode = level ? SSD0323_DATA : SSD0323_CMD;
ssd0323.c:    qemu_put_be32(f, s->cmd_len);
ssd0323.c:    qemu_put_be32(f, s->cmd);
ssd0323.c:        qemu_put_be32(f, s->cmd_data[i]);
ssd0323.c:    qemu_put_be32(f, s->row);
ssd0323.c:    qemu_put_be32(f, s->row_start);
ssd0323.c:    qemu_put_be32(f, s->row_end);
ssd0323.c:    qemu_put_be32(f, s->col);
ssd0323.c:    qemu_put_be32(f, s->col_start);
ssd0323.c:    qemu_put_be32(f, s->col_end);
ssd0323.c:    qemu_put_be32(f, s->redraw);
ssd0323.c:    qemu_put_be32(f, s->remap);
ssd0323.c:    qemu_put_be32(f, s->mode);
ssd0323.c:    qemu_put_buffer(f, s->framebuffer, sizeof(s->framebuffer));
ssd0323.c:        return -EINVAL;
ssd0323.c:    s->cmd_len = qemu_get_be32(f);
ssd0323.c:    s->cmd = qemu_get_be32(f);
ssd0323.c:        s->cmd_data[i] = qemu_get_be32(f);
ssd0323.c:    s->row = qemu_get_be32(f);
ssd0323.c:    s->row_start = qemu_get_be32(f);
ssd0323.c:    s->row_end = qemu_get_be32(f);
ssd0323.c:    s->col = qemu_get_be32(f);
ssd0323.c:    s->col_start = qemu_get_be32(f);
ssd0323.c:    s->col_end = qemu_get_be32(f);
ssd0323.c:    s->redraw = qemu_get_be32(f);
ssd0323.c:    s->remap = qemu_get_be32(f);
ssd0323.c:    s->mode = qemu_get_be32(f);
ssd0323.c:    qemu_get_buffer(f, s->framebuffer, sizeof(s->framebuffer));
ssd0323.c:    s->col_end = 63;
ssd0323.c:    s->row_end = 79;
ssd0323.c:    s->ds = graphic_console_init(ssd0323_update_display,
ssd0323.c:    qemu_console_resize(s->ds, 128 * MAGNIFY, 64 * MAGNIFY);
ssd0323.c:    qdev_init_gpio_in(&dev->qdev, ssd0323_cd, 1);
ssd0323.c:    register_savevm("ssd0323_oled", -1, 1, ssd0323_save, ssd0323_load, s);
ssi.c:    if (QLIST_FIRST(&bus->qbus.children) != dev
ssi.c:    s->info = info;
ssi.c:    return info->init(s);
ssi.c:    assert(info->qdev.size >= sizeof(SSISlave));
ssi.c:    info->qdev.init = ssi_slave_init;
ssi.c:    info->qdev.bus_info = &ssi_bus_info;
ssi.c:    qdev_register(&info->qdev);
ssi.c:    dev = qdev_create(&bus->qbus, name);
ssi.c:    dev = QLIST_FIRST(&bus->qbus.children);
ssi.c:    return slave->info->transfer(slave, val);
ssi.h:/* In principle SSI is a point-point interface.  As such the qemu
ssi-sd.c: * Copyright (c) 2007-2009 CodeSourcery.
ssi-sd.c:    if (s->mode == SSI_SD_DATA_READ && val == 0x4d) {
ssi-sd.c:        s->mode = SSI_SD_CMD;
ssi-sd.c:        s->stopping = 1;
ssi-sd.c:    switch (s->mode) {
ssi-sd.c:        s->cmd = val & 0x3f;
ssi-sd.c:        s->mode = SSI_SD_CMDARG;
ssi-sd.c:        s->arglen = 0;
ssi-sd.c:        if (s->arglen == 4) {
ssi-sd.c:            request.cmd = s->cmd;
ssi-sd.c:            request.arg = (s->cmdarg[0] << 24) | (s->cmdarg[1] << 16)
ssi-sd.c:                           | (s->cmdarg[2] << 8) | s->cmdarg[3];
ssi-sd.c:            DPRINTF("CMD%d arg 0x%08x\n", s->cmd, request.arg);
ssi-sd.c:            s->arglen = sd_do_command(s->sd, &request, longresp);
ssi-sd.c:            if (s->arglen <= 0) {
ssi-sd.c:                s->arglen = 1;
ssi-sd.c:                s->response[0] = 4;
ssi-sd.c:            } else if (s->cmd == 58) {
ssi-sd.c:                s->arglen = 5;
ssi-sd.c:                s->response[0] = 1;
ssi-sd.c:                memcpy(&s->response[1], longresp, 4);
ssi-sd.c:            } else if (s->arglen != 4) {
ssi-sd.c:                BADF("Unexpected response to cmd %d\n", s->cmd);
ssi-sd.c:                s->arglen = 1;
ssi-sd.c:                s->response[0] = 4;
ssi-sd.c:                /* CMD13 returns a 2-byte statuse work. Other commands
ssi-sd.c:                s->arglen = (s->cmd == 13) ? 2 : 1;
ssi-sd.c:                s->response[0] = status >> 8;
ssi-sd.c:                s->response[1] = status;
ssi-sd.c:            s->mode = SSI_SD_RESPONSE;
ssi-sd.c:            s->response_pos = 0;
ssi-sd.c:            s->cmdarg[s->arglen++] = val;
ssi-sd.c:        if (s->stopping) {
ssi-sd.c:            s->stopping = 0;
ssi-sd.c:        if (s->response_pos < s->arglen) {
ssi-sd.c:            DPRINTF("Response 0x%02x\n", s->response[s->response_pos]);
ssi-sd.c:            return s->response[s->response_pos++];
ssi-sd.c:        if (sd_data_ready(s->sd)) {
ssi-sd.c:            s->mode = SSI_SD_DATA_START;
ssi-sd.c:            s->mode = SSI_SD_CMD;
ssi-sd.c:        s->mode = SSI_SD_DATA_READ;
ssi-sd.c:        val = sd_read_data(s->sd);
ssi-sd.c:        if (!sd_data_ready(s->sd)) {
ssi-sd.c:            s->mode = SSI_SD_CMD;
ssi-sd.c:    qemu_put_be32(f, s->mode);
ssi-sd.c:    qemu_put_be32(f, s->cmd);
ssi-sd.c:        qemu_put_be32(f, s->cmdarg[i]);
ssi-sd.c:        qemu_put_be32(f, s->response[i]);
ssi-sd.c:    qemu_put_be32(f, s->arglen);
ssi-sd.c:    qemu_put_be32(f, s->response_pos);
ssi-sd.c:    qemu_put_be32(f, s->stopping);
ssi-sd.c:        return -EINVAL;
ssi-sd.c:    s->mode = qemu_get_be32(f);
ssi-sd.c:    s->cmd = qemu_get_be32(f);
ssi-sd.c:        s->cmdarg[i] = qemu_get_be32(f);
ssi-sd.c:        s->response[i] = qemu_get_be32(f);
ssi-sd.c:    s->arglen = qemu_get_be32(f);
ssi-sd.c:    s->response_pos = qemu_get_be32(f);
ssi-sd.c:    s->stopping = qemu_get_be32(f);
ssi-sd.c:    s->mode = SSI_SD_CMD;
ssi-sd.c:    bs = qdev_init_bdrv(&dev->qdev, IF_SD);
ssi-sd.c:    s->sd = sd_init(bs, 1);
ssi-sd.c:    register_savevm("ssi_sd", -1, 1, ssi_sd_save, ssi_sd_load, s);
ssi-sd.c:    .qdev.name = "ssi-sd",
stellaris.c:#include "arm-misc.h"
stellaris.c:#include "qemu-timer.h"
stellaris.c:    level = (s->state & s->mask) != 0;
stellaris.c:    qemu_set_irq(s->irq, level);
stellaris.c:    qemu_del_timer(s->timer[n]);
stellaris.c:        tick = s->tick[n];
stellaris.c:    if (s->config == 0) {
stellaris.c:        /* 32-bit CountDown.  */
stellaris.c:        count = s->load[0] | (s->load[1] << 16);
stellaris.c:    } else if (s->config == 1) {
stellaris.c:        /* 32-bit RTC.  1Hz tick.  */
stellaris.c:    } else if (s->mode[n] == 0xa) {
stellaris.c:        hw_error("TODO: 16-bit timer mode 0x%x\n", s->mode[n]);
stellaris.c:    s->tick[n] = tick;
stellaris.c:    qemu_mod_timer(s->timer[n], tick);
stellaris.c:    n = p - s->opaque;
stellaris.c:    if (s->config == 0) {
stellaris.c:        s->state |= 1;
stellaris.c:        if ((s->control & 0x20)) {
stellaris.c:	    qemu_irq_pulse(s->trigger);
stellaris.c:        if (s->mode[0] & 1) {
stellaris.c:            /* One-shot.  */
stellaris.c:            s->control &= ~1;
stellaris.c:    } else if (s->config == 1) {
stellaris.c:        s->rtc++;
stellaris.c:        match = s->match[0] | (s->match[1] << 16);
stellaris.c:        if (s->rtc > match)
stellaris.c:            s->rtc = 0;
stellaris.c:        if (s->rtc == 0) {
stellaris.c:            s->state |= 8;
stellaris.c:    } else if (s->mode[n] == 0xa) {
stellaris.c:        hw_error("TODO: 16-bit timer mode 0x%x\n", s->mode[n]);
stellaris.c:        return s->config;
stellaris.c:        return s->mode[0];
stellaris.c:        return s->mode[1];
stellaris.c:        return s->control;
stellaris.c:        return s->mask;
stellaris.c:        return s->state;
stellaris.c:        return s->state & s->mask;
stellaris.c:        return s->load[0] | ((s->config < 4) ? (s->load[1] << 16) : 0);
stellaris.c:        return s->load[1];
stellaris.c:        return s->match[0] | ((s->config < 4) ? (s->match[1] << 16) : 0);
stellaris.c:        return s->match[1];
stellaris.c:        return s->prescale[0];
stellaris.c:        return s->prescale[1];
stellaris.c:        return s->match_prescale[0];
stellaris.c:        return s->match_prescale[1];
stellaris.c:        if (s->control == 1)
stellaris.c:            return s->rtc;
stellaris.c:        s->config = value;
stellaris.c:        s->mode[0] = value;
stellaris.c:        s->mode[1] = value;
stellaris.c:        oldval = s->control;
stellaris.c:        s->control = value;
stellaris.c:        if (((oldval ^ value) & 0x100) && s->config >= 4) {
stellaris.c:        s->mask = value & 0x77;
stellaris.c:        s->state &= ~value;
stellaris.c:        s->load[0] = value & 0xffff;
stellaris.c:        if (s->config < 4) {
stellaris.c:            s->load[1] = value >> 16;
stellaris.c:        s->load[1] = value & 0xffff;
stellaris.c:        s->match[0] = value & 0xffff;
stellaris.c:        if (s->config < 4) {
stellaris.c:            s->match[1] = value >> 16;
stellaris.c:        s->match[1] = value >> 16;
stellaris.c:        s->prescale[0] = value;
stellaris.c:        s->prescale[1] = value;
stellaris.c:        s->match_prescale[0] = value;
stellaris.c:        s->match_prescale[0] = value;
stellaris.c:    qemu_put_be32(f, s->config);
stellaris.c:    qemu_put_be32(f, s->mode[0]);
stellaris.c:    qemu_put_be32(f, s->mode[1]);
stellaris.c:    qemu_put_be32(f, s->control);
stellaris.c:    qemu_put_be32(f, s->state);
stellaris.c:    qemu_put_be32(f, s->mask);
stellaris.c:    qemu_put_be32(f, s->mode[0]);
stellaris.c:    qemu_put_be32(f, s->mode[0]);
stellaris.c:    qemu_put_be32(f, s->load[0]);
stellaris.c:    qemu_put_be32(f, s->load[1]);
stellaris.c:    qemu_put_be32(f, s->match[0]);
stellaris.c:    qemu_put_be32(f, s->match[1]);
stellaris.c:    qemu_put_be32(f, s->prescale[0]);
stellaris.c:    qemu_put_be32(f, s->prescale[1]);
stellaris.c:    qemu_put_be32(f, s->match_prescale[0]);
stellaris.c:    qemu_put_be32(f, s->match_prescale[1]);
stellaris.c:    qemu_put_be32(f, s->rtc);
stellaris.c:    qemu_put_be64(f, s->tick[0]);
stellaris.c:    qemu_put_be64(f, s->tick[1]);
stellaris.c:    qemu_put_timer(f, s->timer[0]);
stellaris.c:    qemu_put_timer(f, s->timer[1]);
stellaris.c:        return -EINVAL;
stellaris.c:    s->config = qemu_get_be32(f);
stellaris.c:    s->mode[0] = qemu_get_be32(f);
stellaris.c:    s->mode[1] = qemu_get_be32(f);
stellaris.c:    s->control = qemu_get_be32(f);
stellaris.c:    s->state = qemu_get_be32(f);
stellaris.c:    s->mask = qemu_get_be32(f);
stellaris.c:    s->mode[0] = qemu_get_be32(f);
stellaris.c:    s->mode[0] = qemu_get_be32(f);
stellaris.c:    s->load[0] = qemu_get_be32(f);
stellaris.c:    s->load[1] = qemu_get_be32(f);
stellaris.c:    s->match[0] = qemu_get_be32(f);
stellaris.c:    s->match[1] = qemu_get_be32(f);
stellaris.c:    s->prescale[0] = qemu_get_be32(f);
stellaris.c:    s->prescale[1] = qemu_get_be32(f);
stellaris.c:    s->match_prescale[0] = qemu_get_be32(f);
stellaris.c:    s->match_prescale[1] = qemu_get_be32(f);
stellaris.c:    s->rtc = qemu_get_be32(f);
stellaris.c:    s->tick[0] = qemu_get_be64(f);
stellaris.c:    s->tick[1] = qemu_get_be64(f);
stellaris.c:    qemu_get_timer(f, s->timer[0]);
stellaris.c:    qemu_get_timer(f, s->timer[1]);
stellaris.c:    sysbus_init_irq(dev, &s->irq);
stellaris.c:    qdev_init_gpio_out(&dev->qdev, &s->trigger, 1);
stellaris.c:    s->opaque[0] = s->opaque[1] = s;
stellaris.c:    s->timer[0] = qemu_new_timer(vm_clock, gptm_tick, &s->opaque[0]);
stellaris.c:    s->timer[1] = qemu_new_timer(vm_clock, gptm_tick, &s->opaque[1]);
stellaris.c:    register_savevm("stellaris_gptm", -1, 1, gptm_save, gptm_load, s);
stellaris.c:  qemu_set_irq(s->irq, (s->int_status & s->int_mask) != 0);
stellaris.c:        return s->board->did0;
stellaris.c:        return s->board->did1;
stellaris.c:        return s->board->dc0;
stellaris.c:        return s->board->dc1;
stellaris.c:        return s->board->dc2;
stellaris.c:        return s->board->dc3;
stellaris.c:        return s->board->dc4;
stellaris.c:        return s->pborctl;
stellaris.c:        return s->ldopctl;
stellaris.c:        return s->int_status;
stellaris.c:        return s->int_mask;
stellaris.c:        return s->int_status & s->int_mask;
stellaris.c:        return s->resc;
stellaris.c:        return s->rcc;
stellaris.c:            xtal = (s->rcc >> 6) & 0xf;
stellaris.c:            if (s->board->did0 & (1 << 16)) {
stellaris.c:        return s->rcgc[0];
stellaris.c:        return s->rcgc[1];
stellaris.c:        return s->rcgc[2];
stellaris.c:        return s->scgc[0];
stellaris.c:        return s->scgc[1];
stellaris.c:        return s->scgc[2];
stellaris.c:        return s->dcgc[0];
stellaris.c:        return s->dcgc[1];
stellaris.c:        return s->dcgc[2];
stellaris.c:        return s->clkvclr;
stellaris.c:        return s->ldoarst;
stellaris.c:        return s->user0;
stellaris.c:        return s->user1;
stellaris.c:    system_clock_scale = 5 * (((s->rcc >> 23) & 0xf) + 1);
stellaris.c:        s->pborctl = value & 0xffff;
stellaris.c:        s->ldopctl = value & 0x1f;
stellaris.c:        s->int_mask = value & 0x7f;
stellaris.c:        s->int_status &= ~value;
stellaris.c:        s->resc = value & 0x3f;
stellaris.c:        if ((s->rcc & (1 << 13)) != 0 && (value & (1 << 13)) == 0) {
stellaris.c:            s->int_status |= (1 << 6);
stellaris.c:        s->rcc = value;
stellaris.c:        s->rcgc[0] = value;
stellaris.c:        s->rcgc[1] = value;
stellaris.c:        s->rcgc[2] = value;
stellaris.c:        s->scgc[0] = value;
stellaris.c:        s->scgc[1] = value;
stellaris.c:        s->scgc[2] = value;
stellaris.c:        s->dcgc[0] = value;
stellaris.c:        s->dcgc[1] = value;
stellaris.c:        s->dcgc[2] = value;
stellaris.c:        s->clkvclr = value;
stellaris.c:        s->ldoarst = value;
stellaris.c:    s->pborctl = 0x7ffd;
stellaris.c:    s->rcc = 0x078e3ac0;
stellaris.c:    s->rcgc[0] = 1;
stellaris.c:    s->scgc[0] = 1;
stellaris.c:    s->dcgc[0] = 1;
stellaris.c:    qemu_put_be32(f, s->pborctl);
stellaris.c:    qemu_put_be32(f, s->ldopctl);
stellaris.c:    qemu_put_be32(f, s->int_mask);
stellaris.c:    qemu_put_be32(f, s->int_status);
stellaris.c:    qemu_put_be32(f, s->resc);
stellaris.c:    qemu_put_be32(f, s->rcc);
stellaris.c:    qemu_put_be32(f, s->rcgc[0]);
stellaris.c:    qemu_put_be32(f, s->rcgc[1]);
stellaris.c:    qemu_put_be32(f, s->rcgc[2]);
stellaris.c:    qemu_put_be32(f, s->scgc[0]);
stellaris.c:    qemu_put_be32(f, s->scgc[1]);
stellaris.c:    qemu_put_be32(f, s->scgc[2]);
stellaris.c:    qemu_put_be32(f, s->dcgc[0]);
stellaris.c:    qemu_put_be32(f, s->dcgc[1]);
stellaris.c:    qemu_put_be32(f, s->dcgc[2]);
stellaris.c:    qemu_put_be32(f, s->clkvclr);
stellaris.c:    qemu_put_be32(f, s->ldoarst);
stellaris.c:        return -EINVAL;
stellaris.c:    s->pborctl = qemu_get_be32(f);
stellaris.c:    s->ldopctl = qemu_get_be32(f);
stellaris.c:    s->int_mask = qemu_get_be32(f);
stellaris.c:    s->int_status = qemu_get_be32(f);
stellaris.c:    s->resc = qemu_get_be32(f);
stellaris.c:    s->rcc = qemu_get_be32(f);
stellaris.c:    s->rcgc[0] = qemu_get_be32(f);
stellaris.c:    s->rcgc[1] = qemu_get_be32(f);
stellaris.c:    s->rcgc[2] = qemu_get_be32(f);
stellaris.c:    s->scgc[0] = qemu_get_be32(f);
stellaris.c:    s->scgc[1] = qemu_get_be32(f);
stellaris.c:    s->scgc[2] = qemu_get_be32(f);
stellaris.c:    s->dcgc[0] = qemu_get_be32(f);
stellaris.c:    s->dcgc[1] = qemu_get_be32(f);
stellaris.c:    s->dcgc[2] = qemu_get_be32(f);
stellaris.c:    s->clkvclr = qemu_get_be32(f);
stellaris.c:    s->ldoarst = qemu_get_be32(f);
stellaris.c:    s->irq = irq;
stellaris.c:    s->board = board;
stellaris.c:    s->user0 = macaddr[0] | (macaddr[1] << 8) | (macaddr[2] << 16);
stellaris.c:    s->user1 = macaddr[3] | (macaddr[4] << 8) | (macaddr[5] << 16);
stellaris.c:    register_savevm("stellaris_sys", -1, 1, ssys_save, ssys_load, s);
stellaris.c:        return s->msa;
stellaris.c:        return s->mcs | STELLARIS_I2C_MCS_IDLE;
stellaris.c:        return s->mdr;
stellaris.c:        return s->mtpr;
stellaris.c:        return s->mimr;
stellaris.c:        return s->mris;
stellaris.c:        return s->mris & s->mimr;
stellaris.c:        return s->mcr;
stellaris.c:    level = (s->mris & s->mimr) != 0;
stellaris.c:    qemu_set_irq(s->irq, level);
stellaris.c:        s->msa = value & 0xff;
stellaris.c:        if ((s->mcr & 0x10) == 0) {
stellaris.c:        if ((value & 2) && (s->mcs & STELLARIS_I2C_MCS_BUSBSY) == 0) {
stellaris.c:            if (i2c_start_transfer(s->bus, s->msa >> 1, s->msa & 1)) {
stellaris.c:                s->mcs |= STELLARIS_I2C_MCS_ARBLST;
stellaris.c:                s->mcs &= ~STELLARIS_I2C_MCS_ARBLST;
stellaris.c:                s->mcs |= STELLARIS_I2C_MCS_BUSBSY;
stellaris.c:        if (!i2c_bus_busy(s->bus)
stellaris.c:                || (s->mcs & STELLARIS_I2C_MCS_BUSBSY) == 0) {
stellaris.c:            s->mcs |= STELLARIS_I2C_MCS_ERROR;
stellaris.c:        s->mcs &= ~STELLARIS_I2C_MCS_ERROR;
stellaris.c:            if (s->msa & 1) {
stellaris.c:                s->mdr = i2c_recv(s->bus) & 0xff;
stellaris.c:                i2c_send(s->bus, s->mdr);
stellaris.c:            s->mris |= 1;
stellaris.c:            i2c_end_transfer(s->bus);
stellaris.c:            s->mcs &= ~STELLARIS_I2C_MCS_BUSBSY;
stellaris.c:        s->mdr = value & 0xff;
stellaris.c:        s->mtpr = value & 0xff;
stellaris.c:        s->mimr = 1;
stellaris.c:        s->mris &= ~value;
stellaris.c:        s->mcr = value & 0x31;
stellaris.c:    if (s->mcs & STELLARIS_I2C_MCS_BUSBSY)
stellaris.c:        i2c_end_transfer(s->bus);
stellaris.c:    s->msa = 0;
stellaris.c:    s->mcs = 0;
stellaris.c:    s->mdr = 0;
stellaris.c:    s->mtpr = 1;
stellaris.c:    s->mimr = 0;
stellaris.c:    s->mris = 0;
stellaris.c:    s->mcr = 0;
stellaris.c:    qemu_put_be32(f, s->msa);
stellaris.c:    qemu_put_be32(f, s->mcs);
stellaris.c:    qemu_put_be32(f, s->mdr);
stellaris.c:    qemu_put_be32(f, s->mtpr);
stellaris.c:    qemu_put_be32(f, s->mimr);
stellaris.c:    qemu_put_be32(f, s->mris);
stellaris.c:    qemu_put_be32(f, s->mcr);
stellaris.c:        return -EINVAL;
stellaris.c:    s->msa = qemu_get_be32(f);
stellaris.c:    s->mcs = qemu_get_be32(f);
stellaris.c:    s->mdr = qemu_get_be32(f);
stellaris.c:    s->mtpr = qemu_get_be32(f);
stellaris.c:    s->mimr = qemu_get_be32(f);
stellaris.c:    s->mris = qemu_get_be32(f);
stellaris.c:    s->mcr = qemu_get_be32(f);
stellaris.c:    sysbus_init_irq(dev, &s->irq);
stellaris.c:    bus = i2c_init_bus(&dev->qdev, "i2c");
stellaris.c:    s->bus = bus;
stellaris.c:    register_savevm("stellaris_i2c", -1, 1,
stellaris.c:    tail = s->fifo[n].state & 0xf;
stellaris.c:    if (s->fifo[n].state & STELLARIS_ADC_FIFO_EMPTY) {
stellaris.c:        s->ustat |= 1 << n;
stellaris.c:        s->fifo[n].state = (s->fifo[n].state & ~0xf) | ((tail + 1) & 0xf);
stellaris.c:        s->fifo[n].state &= ~STELLARIS_ADC_FIFO_FULL;
stellaris.c:        if (tail + 1 == ((s->fifo[n].state >> 4) & 0xf))
stellaris.c:            s->fifo[n].state |= STELLARIS_ADC_FIFO_EMPTY;
stellaris.c:    return s->fifo[n].data[tail];
stellaris.c:    head = (s->fifo[n].state >> 4) & 0xf;
stellaris.c:    if (s->fifo[n].state & STELLARIS_ADC_FIFO_FULL) {
stellaris.c:        s->ostat |= 1 << n;
stellaris.c:    s->fifo[n].data[head] = value;
stellaris.c:    s->fifo[n].state &= ~STELLARIS_ADC_FIFO_EMPTY;
stellaris.c:    s->fifo[n].state = (s->fifo[n].state & ~0xf0) | (head << 4);
stellaris.c:    if ((s->fifo[n].state & 0xf) == head)
stellaris.c:        s->fifo[n].state |= STELLARIS_ADC_FIFO_FULL;
stellaris.c:        level = (s->ris & s->im & (1 << n)) != 0;
stellaris.c:        qemu_set_irq(s->irq[n], level);
stellaris.c:        if ((s->actss & (1 << n)) == 0) {
stellaris.c:        if (((s->emux >> (n * 4)) & 0xff) != 5) {
stellaris.c:        s->noise = s->noise * 314159 + 1;
stellaris.c:        stellaris_adc_fifo_write(s, n, 0x200 + ((s->noise >> 16) & 7));
stellaris.c:        s->ris |= (1 << n);
stellaris.c:        s->ssmux[n] = 0;
stellaris.c:        s->ssctl[n] = 0;
stellaris.c:        s->fifo[n].state = STELLARIS_ADC_FIFO_EMPTY;
stellaris.c:        n = (offset - 0x40) >> 5;
stellaris.c:            return s->ssmux[n];
stellaris.c:            return s->ssctl[n];
stellaris.c:            return s->fifo[n].state;
stellaris.c:        return s->actss;
stellaris.c:        return s->ris;
stellaris.c:        return s->im;
stellaris.c:        return s->ris & s->im;
stellaris.c:        return s->ostat;
stellaris.c:        return s->emux;
stellaris.c:        return s->ustat;
stellaris.c:        return s->sspri;
stellaris.c:        return s->sac;
stellaris.c:        n = (offset - 0x40) >> 5;
stellaris.c:            s->ssmux[n] = value & 0x33333333;
stellaris.c:            s->ssctl[n] = value;
stellaris.c:        s->actss = value & 0xf;
stellaris.c:        s->im = value;
stellaris.c:        s->ris &= ~value;
stellaris.c:        s->ostat &= ~value;
stellaris.c:        s->emux = value;
stellaris.c:        s->ustat &= ~value;
stellaris.c:        s->sspri = value;
stellaris.c:        s->sac = value;
stellaris.c:    qemu_put_be32(f, s->actss);
stellaris.c:    qemu_put_be32(f, s->ris);
stellaris.c:    qemu_put_be32(f, s->im);
stellaris.c:    qemu_put_be32(f, s->emux);
stellaris.c:    qemu_put_be32(f, s->ostat);
stellaris.c:    qemu_put_be32(f, s->ustat);
stellaris.c:    qemu_put_be32(f, s->sspri);
stellaris.c:    qemu_put_be32(f, s->sac);
stellaris.c:        qemu_put_be32(f, s->fifo[i].state);
stellaris.c:            qemu_put_be32(f, s->fifo[i].data[j]);
stellaris.c:        qemu_put_be32(f, s->ssmux[i]);
stellaris.c:        qemu_put_be32(f, s->ssctl[i]);
stellaris.c:    qemu_put_be32(f, s->noise);
stellaris.c:        return -EINVAL;
stellaris.c:    s->actss = qemu_get_be32(f);
stellaris.c:    s->ris = qemu_get_be32(f);
stellaris.c:    s->im = qemu_get_be32(f);
stellaris.c:    s->emux = qemu_get_be32(f);
stellaris.c:    s->ostat = qemu_get_be32(f);
stellaris.c:    s->ustat = qemu_get_be32(f);
stellaris.c:    s->sspri = qemu_get_be32(f);
stellaris.c:    s->sac = qemu_get_be32(f);
stellaris.c:        s->fifo[i].state = qemu_get_be32(f);
stellaris.c:            s->fifo[i].data[j] = qemu_get_be32(f);
stellaris.c:        s->ssmux[i] = qemu_get_be32(f);
stellaris.c:        s->ssctl[i] = qemu_get_be32(f);
stellaris.c:    s->noise = qemu_get_be32(f);
stellaris.c:        sysbus_init_irq(dev, &s->irq[n]);
stellaris.c:    qdev_init_gpio_in(&dev->qdev, stellaris_adc_trigger, 1);
stellaris.c:    register_savevm("stellaris_adc", -1, 1,
stellaris.c:    s->current_dev = level;
stellaris.c:    return ssi_transfer(s->bus[s->current_dev], val);
stellaris.c:    qemu_put_be32(f, s->current_dev);
stellaris.c:        return -EINVAL;
stellaris.c:    s->current_dev = qemu_get_be32(f);
stellaris.c:    s->bus[0] = ssi_create_bus(&dev->qdev, "ssi0");
stellaris.c:    s->bus[1] = ssi_create_bus(&dev->qdev, "ssi1");
stellaris.c:    qdev_init_gpio_in(&dev->qdev, stellaris_ssi_bus_select, 1);
stellaris.c:    register_savevm("stellaris_ssi_bus", -1, 1,
stellaris.c:    flash_size = ((board->dc0 & 0xffff) + 1) << 1;
stellaris.c:    sram_size = (board->dc0 >> 18) + 1;
stellaris.c:    if (board->dc1 & (1 << 16)) {
stellaris.c:        dev = sysbus_create_varargs("stellaris-adc", 0x40038000,
stellaris.c:        if (board->dc2 & (0x10000 << i)) {
stellaris.c:            dev = sysbus_create_simple("stellaris-gptm",
stellaris.c:        if (board->dc4 & (1 << i)) {
stellaris.c:    if (board->dc2 & (1 << 12)) {
stellaris.c:        dev = sysbus_create_simple("stellaris-i2c", 0x40020000, pic[8]);
stellaris.c:        if (board->peripherals & BP_OLED_I2C) {
stellaris.c:        if (board->dc2 & (1 << i)) {
stellaris.c:    if (board->dc2 & (1 << 4)) {
stellaris.c:        if (board->peripherals & BP_OLED_SSI) {
stellaris.c:            mux = ssi_create_slave(bus, "evb6965-ssi");
stellaris.c:            dev = ssi_create_slave(bus, "ssi-sd");
stellaris.c:    if (board->dc4 & (1 << 28)) {
stellaris.c:    if (board->peripherals & BP_GAMEPAD) {
stellaris.c:        if (board->dc4 & (1 << i)) {
stellaris.c:    .qdev.name = "evb6965-ssi",
stellaris.c:    sysbus_register_dev("stellaris-i2c", sizeof(stellaris_i2c_state),
stellaris.c:    sysbus_register_dev("stellaris-gptm", sizeof(gptm_state),
stellaris.c:    sysbus_register_dev("stellaris-adc", sizeof(stellaris_adc_state),
stellaris_enet.c:    qemu_set_irq(s->irq, (s->ris & s->im) != 0);
stellaris_enet.c:    stellaris_enet_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
stellaris_enet.c:    if ((s->rctl & SE_RCTL_RXEN) == 0)
stellaris_enet.c:        return -1;
stellaris_enet.c:    if (s->np >= 31) {
stellaris_enet.c:        return -1;
stellaris_enet.c:    n = s->next_packet + s->np;
stellaris_enet.c:        n -= 31;
stellaris_enet.c:    s->np++;
stellaris_enet.c:    s->rx[n].len = size + 6;
stellaris_enet.c:    p = s->rx[n].data;
stellaris_enet.c:        memset(p, 0, (6 - size) & 3);
stellaris_enet.c:    s->ris |= SE_INT_RX;
stellaris_enet.c:    stellaris_enet_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
stellaris_enet.c:    if ((s->rctl & SE_RCTL_RXEN) == 0)
stellaris_enet.c:    return (s->np < 31);
stellaris_enet.c:        DPRINTF("IRQ status %02x\n", s->ris);
stellaris_enet.c:        return s->ris;
stellaris_enet.c:        return s->im;
stellaris_enet.c:        return s->rctl;
stellaris_enet.c:        return s->tctl;
stellaris_enet.c:        if (s->rx_fifo_len == 0) {
stellaris_enet.c:            if (s->np == 0) {
stellaris_enet.c:            s->rx_fifo_len = s->rx[s->next_packet].len;
stellaris_enet.c:            s->rx_fifo = s->rx[s->next_packet].data;
stellaris_enet.c:            DPRINTF("RX FIFO start packet len=%d\n", s->rx_fifo_len);
stellaris_enet.c:        val = s->rx_fifo[0] | (s->rx_fifo[1] << 8) | (s->rx_fifo[2] << 16)
stellaris_enet.c:              | (s->rx_fifo[3] << 24);
stellaris_enet.c:        s->rx_fifo += 4;
stellaris_enet.c:        s->rx_fifo_len -= 4;
stellaris_enet.c:        if (s->rx_fifo_len <= 0) {
stellaris_enet.c:            s->rx_fifo_len = 0;
stellaris_enet.c:            s->next_packet++;
stellaris_enet.c:            if (s->next_packet >= 31)
stellaris_enet.c:                s->next_packet = 0;
stellaris_enet.c:            s->np--;
stellaris_enet.c:            DPRINTF("RX done np=%d\n", s->np);
stellaris_enet.c:        return s->conf.macaddr.a[0] | (s->conf.macaddr.a[1] << 8)
stellaris_enet.c:               | (s->conf.macaddr.a[2] << 16) | (s->conf.macaddr.a[3] << 24);
stellaris_enet.c:        return s->conf.macaddr.a[4] | (s->conf.macaddr.a[5] << 8);
stellaris_enet.c:        return s->thr;
stellaris_enet.c:        return s->mctl;
stellaris_enet.c:        return s->mdv;
stellaris_enet.c:        return s->mtxd;
stellaris_enet.c:        return s->mrxd;
stellaris_enet.c:        return s->np;
stellaris_enet.c:        s->ris &= ~value;
stellaris_enet.c:        DPRINTF("IRQ ack %02x/%02x\n", value, s->ris);
stellaris_enet.c:            s->tx_frame_len = -1;
stellaris_enet.c:        DPRINTF("IRQ mask %02x/%02x\n", value, s->ris);
stellaris_enet.c:        s->im = value;
stellaris_enet.c:        s->rctl = value;
stellaris_enet.c:            s->rx_fifo_len = 0;
stellaris_enet.c:            s->np = 0;
stellaris_enet.c:        s->tctl = value;
stellaris_enet.c:        if (s->tx_frame_len == -1) {
stellaris_enet.c:            s->tx_frame_len = value & 0xffff;
stellaris_enet.c:            if (s->tx_frame_len > 2032) {
stellaris_enet.c:                DPRINTF("TX frame too long (%d)\n", s->tx_frame_len);
stellaris_enet.c:                s->tx_frame_len = 0;
stellaris_enet.c:                s->ris |= SE_INT_TXER;
stellaris_enet.c:                DPRINTF("Start TX frame len=%d\n", s->tx_frame_len);
stellaris_enet.c:                s->tx_frame_len += 14;
stellaris_enet.c:                if ((s->tctl & SE_TCTL_CRC) == 0)
stellaris_enet.c:                    s->tx_frame_len += 4;
stellaris_enet.c:                s->tx_fifo_len = 0;
stellaris_enet.c:                s->tx_fifo[s->tx_fifo_len++] = value >> 16;
stellaris_enet.c:                s->tx_fifo[s->tx_fifo_len++] = value >> 24;
stellaris_enet.c:            s->tx_fifo[s->tx_fifo_len++] = value;
stellaris_enet.c:            s->tx_fifo[s->tx_fifo_len++] = value >> 8;
stellaris_enet.c:            s->tx_fifo[s->tx_fifo_len++] = value >> 16;
stellaris_enet.c:            s->tx_fifo[s->tx_fifo_len++] = value >> 24;
stellaris_enet.c:            if (s->tx_fifo_len >= s->tx_frame_len) {
stellaris_enet.c:                if ((s->tctl & SE_TCTL_CRC) == 0)
stellaris_enet.c:                    s->tx_frame_len -= 4;
stellaris_enet.c:                if ((s->tctl & SE_TCTL_PADEN) && s->tx_frame_len < 60) {
stellaris_enet.c:                    memset(&s->tx_fifo[s->tx_frame_len], 0, 60 - s->tx_frame_len);
stellaris_enet.c:                    s->tx_fifo_len = 60;
stellaris_enet.c:                qemu_send_packet(&s->nic->nc, s->tx_fifo, s->tx_frame_len);
stellaris_enet.c:                s->tx_frame_len = -1;
stellaris_enet.c:                s->ris |= SE_INT_TXEMP;
stellaris_enet.c:        s->conf.macaddr.a[0] = value;
stellaris_enet.c:        s->conf.macaddr.a[1] = value >> 8;
stellaris_enet.c:        s->conf.macaddr.a[2] = value >> 16;
stellaris_enet.c:        s->conf.macaddr.a[3] = value >> 24;
stellaris_enet.c:        s->conf.macaddr.a[4] = value;
stellaris_enet.c:        s->conf.macaddr.a[5] = value >> 8;
stellaris_enet.c:        s->thr = value;
stellaris_enet.c:        s->mctl = value;
stellaris_enet.c:        s->mdv = value;
stellaris_enet.c:        s->mtxd = value & 0xff;
stellaris_enet.c:    s->mdv = 0x80;
stellaris_enet.c:    s->rctl = SE_RCTL_BADCRC;
stellaris_enet.c:    s->im = SE_INT_PHY | SE_INT_MD | SE_INT_RXER | SE_INT_FOV | SE_INT_TXEMP
stellaris_enet.c:    s->thr = 0x3f;
stellaris_enet.c:    s->tx_frame_len = -1;
stellaris_enet.c:    qemu_put_be32(f, s->ris);
stellaris_enet.c:    qemu_put_be32(f, s->im);
stellaris_enet.c:    qemu_put_be32(f, s->rctl);
stellaris_enet.c:    qemu_put_be32(f, s->tctl);
stellaris_enet.c:    qemu_put_be32(f, s->thr);
stellaris_enet.c:    qemu_put_be32(f, s->mctl);
stellaris_enet.c:    qemu_put_be32(f, s->mdv);
stellaris_enet.c:    qemu_put_be32(f, s->mtxd);
stellaris_enet.c:    qemu_put_be32(f, s->mrxd);
stellaris_enet.c:    qemu_put_be32(f, s->np);
stellaris_enet.c:    qemu_put_be32(f, s->tx_frame_len);
stellaris_enet.c:    qemu_put_be32(f, s->tx_fifo_len);
stellaris_enet.c:    qemu_put_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
stellaris_enet.c:        qemu_put_be32(f, s->rx[i].len);
stellaris_enet.c:        qemu_put_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));
stellaris_enet.c:    qemu_put_be32(f, s->next_packet);
stellaris_enet.c:    qemu_put_be32(f, s->rx_fifo - s->rx[s->next_packet].data);
stellaris_enet.c:    qemu_put_be32(f, s->rx_fifo_len);
stellaris_enet.c:        return -EINVAL;
stellaris_enet.c:    s->ris = qemu_get_be32(f);
stellaris_enet.c:    s->im = qemu_get_be32(f);
stellaris_enet.c:    s->rctl = qemu_get_be32(f);
stellaris_enet.c:    s->tctl = qemu_get_be32(f);
stellaris_enet.c:    s->thr = qemu_get_be32(f);
stellaris_enet.c:    s->mctl = qemu_get_be32(f);
stellaris_enet.c:    s->mdv = qemu_get_be32(f);
stellaris_enet.c:    s->mtxd = qemu_get_be32(f);
stellaris_enet.c:    s->mrxd = qemu_get_be32(f);
stellaris_enet.c:    s->np = qemu_get_be32(f);
stellaris_enet.c:    s->tx_frame_len = qemu_get_be32(f);
stellaris_enet.c:    s->tx_fifo_len = qemu_get_be32(f);
stellaris_enet.c:    qemu_get_buffer(f, s->tx_fifo, sizeof(s->tx_fifo));
stellaris_enet.c:        s->rx[i].len = qemu_get_be32(f);
stellaris_enet.c:        qemu_get_buffer(f, s->rx[i].data, sizeof(s->rx[i].data));
stellaris_enet.c:    s->next_packet = qemu_get_be32(f);
stellaris_enet.c:    s->rx_fifo = s->rx[s->next_packet].data + qemu_get_be32(f);
stellaris_enet.c:    s->rx_fifo_len = qemu_get_be32(f);
stellaris_enet.c:    stellaris_enet_state *s = DO_UPCAST(NICState, nc, nc)->opaque;
stellaris_enet.c:    cpu_unregister_io_memory(s->mmio_index);
stellaris_enet.c:    s->mmio_index = cpu_register_io_memory(stellaris_enet_readfn,
stellaris_enet.c:    sysbus_init_mmio(dev, 0x1000, s->mmio_index);
stellaris_enet.c:    sysbus_init_irq(dev, &s->irq);
stellaris_enet.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
stellaris_enet.c:    s->nic = qemu_new_nic(&net_stellaris_enet_info, &s->conf,
stellaris_enet.c:                          dev->qdev.info->name, dev->qdev.id, s);
stellaris_enet.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
stellaris_enet.c:    register_savevm("stellaris_enet", -1, 1,
stellaris_input.c:    if (keycode == 0xe0 && !s->extension) {
stellaris_input.c:        s->extension = 0x80;
stellaris_input.c:    keycode = (keycode & 0x7f) | s->extension;
stellaris_input.c:    for (i = 0; i < s->num_buttons; i++) {
stellaris_input.c:        if (s->buttons[i].keycode == keycode
stellaris_input.c:                && s->buttons[i].pressed != down) {
stellaris_input.c:            s->buttons[i].pressed = down;
stellaris_input.c:            qemu_set_irq(s->buttons[i].irq, down);
stellaris_input.c:    s->extension = 0;
stellaris_input.c:    qemu_put_be32(f, s->extension);
stellaris_input.c:    for (i = 0; i < s->num_buttons; i++)
stellaris_input.c:        qemu_put_byte(f, s->buttons[i].pressed);
stellaris_input.c:        return -EINVAL;
stellaris_input.c:    s->extension = qemu_get_be32(f);
stellaris_input.c:    for (i = 0; i < s->num_buttons; i++)
stellaris_input.c:        s->buttons[i].pressed = qemu_get_byte(f);
stellaris_input.c:    s->buttons = (gamepad_button *)qemu_mallocz(n * sizeof (gamepad_button));
stellaris_input.c:        s->buttons[i].irq = irq[i];
stellaris_input.c:        s->buttons[i].keycode = keycode[i];
stellaris_input.c:    s->num_buttons = n;
stellaris_input.c:    register_savevm("stellaris_gamepad", -1, 1,
sun4c_intctl.c: * Based on slavio_intctl, copyright (c) 2003-2005 Fabrice Bellard
sun4c_intctl.c:    ret = s->reg;
sun4c_intctl.c:    s->reg = val;
sun4c_intctl.c:                   s->pending, s->reg);
sun4c_intctl.c:    count = s->irq_count;
sun4c_intctl.c:    if (s->pending && !(s->reg & 0x80000000)) {
sun4c_intctl.c:            if (s->pending & (1 << i))
sun4c_intctl.c:            if (!(s->pil_out & (1 << i)))
sun4c_intctl.c:                qemu_irq_raise(s->cpu_irqs[i]);
sun4c_intctl.c:            if (s->pil_out & (1 << i))
sun4c_intctl.c:                qemu_irq_lower(s->cpu_irqs[i]);
sun4c_intctl.c:    s->pil_out = pil_pending;
sun4c_intctl.c:    DPRINTF("Set irq %d -> pil %d level %d\n", irq, pil,
sun4c_intctl.c:            s->irq_count++;
sun4c_intctl.c:            s->pending |= mask;
sun4c_intctl.c:            s->pending &= ~mask;
sun4c_intctl.c:    s->reg = 1;
sun4c_intctl.c:    s->pending = 0;
sun4c_intctl.c:    qdev_init_gpio_in(&dev->qdev, sun4c_set_irq, 8);
sun4c_intctl.c:        sysbus_init_irq(dev, &s->cpu_irqs[i]);
sun4m.c: * Copyright (c) 2003-2005 Fabrice Bellard
sun4m.c:#include "qemu-timer.h"
sun4m.c:#include "qdev-addr.h"
sun4m.c:#define PROM_FILENAME        "openbios-sparc32"
sun4m.c:    part_header->signature = OPENBIOS_PART_SYSTEM;
sun4m.c:    pstrcpy(part_header->name, sizeof(part_header->name), "system");
sun4m.c:    end = start + ((end - start + 15) & ~15);
sun4m.c:    OpenBIOS_finish_partition(part_header, end - start);
sun4m.c:    part_header->signature = OPENBIOS_PART_FREE;
sun4m.c:    pstrcpy(part_header->name, sizeof(part_header->name), "free");
sun4m.c:    OpenBIOS_finish_partition(part_header, end - start);
sun4m.c:    if (env->pil_in && (env->interrupt_index == 0 ||
sun4m.c:                        (env->interrupt_index & ~15) == TT_EXTINT)) {
sun4m.c:        for (i = 15; i > 0; i--) {
sun4m.c:            if (env->pil_in & (1 << i)) {
sun4m.c:                int old_interrupt = env->interrupt_index;
sun4m.c:                env->interrupt_index = TT_EXTINT | i;
sun4m.c:                if (old_interrupt != env->interrupt_index) {
sun4m.c:    } else if (!env->pil_in && (env->interrupt_index & ~15) == TT_EXTINT) {
sun4m.c:        DPRINTF("Reset CPU IRQ %d\n", env->interrupt_index & 15);
sun4m.c:        env->interrupt_index = 0;
sun4m.c:        env->halted = 0;
sun4m.c:        env->pil_in |= 1 << irq;
sun4m.c:        env->pil_in &= ~(1 << irq);
sun4m.c:    env->halted = 0;
sun4m.c:    env->halted = 1;
sun4m.c:        kernel_size = load_elf(kernel_filename, -0xf0000000ULL, NULL, NULL,
sun4m.c:                                    RAM_size - KERNEL_LOAD_ADDR, bswap_needed,
sun4m.c:                                              RAM_size - KERNEL_LOAD_ADDR);
sun4m.c:                                              RAM_size - INITRD_LOAD_ADDR);
sun4m.c:    if (version == 0) { // SS-600MP only
sun4m.c:    /* 8-bit plane */
sun4m.c:    /* THC 24 bit: NetBSD writes here even with 8-bit display: dummy */
sun4m.c:        /* 24-bit plane */
sun4m.c:        ret = load_elf(filename, addr - PROM_VADDR, NULL, NULL, NULL,
sun4m.c:        ret = -1;
sun4m.c:    RAM_size = d->size;
sun4m.c:    d->size = RAM_size;
sun4m.c:        env->halted = 1;
sun4m.c:    env->prom_addr = prom_addr;
sun4m.c:        cpu_model = hwdef->default_cpu_model;
sun4m.c:        envs[i] = cpu_devinit(cpu_model, i, hwdef->slavio_base, &cpu_irqs[i]);
sun4m.c:    ram_init(0, RAM_size, hwdef->max_mem);
sun4m.c:    prom_init(hwdef->slavio_base, bios_name);
sun4m.c:    slavio_intctl = slavio_intctl_init(hwdef->intctl_base,
sun4m.c:                                       hwdef->intctl_base + 0x10000ULL,
sun4m.c:    if (hwdef->idreg_base) {
sun4m.c:        idreg_init(hwdef->idreg_base);
sun4m.c:    iommu = iommu_init(hwdef->iommu_base, hwdef->iommu_version,
sun4m.c:    espdma = sparc32_dma_init(hwdef->dma_base, slavio_irq[18],
sun4m.c:    ledma = sparc32_dma_init(hwdef->dma_base + 16ULL,
sun4m.c:    tcx_init(hwdef->tcx_base, 0x00100000, graphic_width, graphic_height,
sun4m.c:    lance_init(&nd_table[0], hwdef->le_base, ledma, ledma_irq);
sun4m.c:    nvram = m48t59_init(slavio_irq[0], hwdef->nvram_base, 0, 0x2000, 8);
sun4m.c:    slavio_timer_init_all(hwdef->counter_base, slavio_irq[19], slavio_cpu_irq, smp_cpus);
sun4m.c:    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, slavio_irq[14],
sun4m.c:    escc_init(hwdef->serial_base, slavio_irq[15], slavio_irq[15],
sun4m.c:    slavio_misc_init(hwdef->slavio_base, hwdef->aux1_base, hwdef->aux2_base,
sun4m.c:    if (hwdef->apc_base) {
sun4m.c:        apc_init(hwdef->apc_base, cpu_halt[0]);
sun4m.c:    if (hwdef->fd_base) {
sun4m.c:        sun4m_fdctrl_init(slavio_irq[22], hwdef->fd_base, fd,
sun4m.c:    esp_init(hwdef->esp_base, 2,
sun4m.c:    if (hwdef->cs_base) {
sun4m.c:        sysbus_create_simple("SUNW,CS4231", hwdef->cs_base,
sun4m.c:               graphic_height, graphic_depth, hwdef->nvram_machine_id,
sun4m.c:    if (hwdef->ecc_base)
sun4m.c:        ecc_init(hwdef->ecc_base, slavio_irq[28],
sun4m.c:                 hwdef->ecc_version);
sun4m.c:    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);
sun4m.c:    /* SS-5 */
sun4m.c:    /* SS-10 */
sun4m.c:    /* SS-600MP */
sun4m.c:    /* SS-20 */
sun4m.c:    /* SS-4 */
sun4m.c:    .name = "SS-5",
sun4m.c:    .name = "SS-10",
sun4m.c:    .name = "SS-600MP",
sun4m.c:    .name = "SS-20",
sun4m.c:    .name = "SS-4",
sun4m.c:    /* SS-1000 */
sun4m.c:            -1,
sun4m.c:    /* SS-2000 */
sun4m.c:        cpu_model = hwdef->default_cpu_model;
sun4m.c:        envs[i] = cpu_devinit(cpu_model, i, hwdef->slavio_base, &cpu_irqs[i]);
sun4m.c:    ram_init(0, RAM_size, hwdef->max_mem);
sun4m.c:    prom_init(hwdef->slavio_base, bios_name);
sun4m.c:    dev = sbi_init(hwdef->sbi_base, cpu_irqs);
sun4m.c:        if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1)
sun4m.c:            iounits[i] = iommu_init(hwdef->iounit_bases[i],
sun4m.c:                                    hwdef->iounit_version,
sun4m.c:    espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[3],
sun4m.c:    ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[4],
sun4m.c:    tcx_init(hwdef->tcx_base, 0x00100000, graphic_width, graphic_height,
sun4m.c:    lance_init(&nd_table[0], hwdef->le_base, ledma, ledma_irq);
sun4m.c:    nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0, 0x2000, 8);
sun4m.c:    slavio_timer_init_all(hwdef->counter_base, sbi_irq[10], sbi_cpu_irq, smp_cpus);
sun4m.c:    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[12],
sun4m.c:    escc_init(hwdef->serial_base, sbi_irq[12], sbi_irq[12],
sun4m.c:    esp_init(hwdef->esp_base, 2,
sun4m.c:               graphic_height, graphic_depth, hwdef->nvram_machine_id,
sun4m.c:    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);
sun4m.c:    .name = "SS-1000",
sun4m.c:    .name = "SS-2000",
sun4m.c:    /* SS-2 */
sun4m.c:        cpu_model = hwdef->default_cpu_model;
sun4m.c:    env = cpu_devinit(cpu_model, 0, hwdef->slavio_base, &cpu_irqs);
sun4m.c:    ram_init(0, RAM_size, hwdef->max_mem);
sun4m.c:    prom_init(hwdef->slavio_base, bios_name);
sun4m.c:    dev = sun4c_intctl_init(hwdef->intctl_base, cpu_irqs);
sun4m.c:    iommu = iommu_init(hwdef->iommu_base, hwdef->iommu_version,
sun4m.c:    espdma = sparc32_dma_init(hwdef->dma_base, slavio_irq[2],
sun4m.c:    ledma = sparc32_dma_init(hwdef->dma_base + 16ULL,
sun4m.c:    tcx_init(hwdef->tcx_base, 0x00100000, graphic_width, graphic_height,
sun4m.c:    lance_init(&nd_table[0], hwdef->le_base, ledma, ledma_irq);
sun4m.c:    nvram = m48t59_init(slavio_irq[0], hwdef->nvram_base, 0, 0x800, 2);
sun4m.c:    slavio_serial_ms_kbd_init(hwdef->ms_kb_base, slavio_irq[1],
sun4m.c:    escc_init(hwdef->serial_base, slavio_irq[1],
sun4m.c:    slavio_misc_init(0, hwdef->aux1_base, 0, slavio_irq[1], fdc_tc);
sun4m.c:    if (hwdef->fd_base != (target_phys_addr_t)-1) {
sun4m.c:        sun4m_fdctrl_init(slavio_irq[1], hwdef->fd_base, fd,
sun4m.c:    esp_init(hwdef->esp_base, 2,
sun4m.c:               graphic_height, graphic_depth, hwdef->nvram_machine_id,
sun4m.c:    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);
sun4m.c:    .name = "SS-2",
sun4m.h:#include "qemu-common.h"
sun4u.c:#include "qemu-timer.h"
sun4u.c:#define PROM_FILENAME        "openbios-sparc64"
sun4u.c:    part_header->signature = OPENBIOS_PART_SYSTEM;
sun4u.c:    pstrcpy(part_header->name, sizeof(part_header->name), "system");
sun4u.c:    end = start + ((end - start + 15) & ~15);
sun4u.c:    OpenBIOS_finish_partition(part_header, end - start);
sun4u.c:    part_header->signature = OPENBIOS_PART_FREE;
sun4u.c:    pstrcpy(part_header->name, sizeof(part_header->name), "free");
sun4u.c:    OpenBIOS_finish_partition(part_header, end - start);
sun4u.c:                                    RAM_size - KERNEL_LOAD_ADDR, bswap_needed,
sun4u.c:                                              RAM_size - KERNEL_LOAD_ADDR);
sun4u.c:                                               RAM_size - INITRD_LOAD_ADDR);
sun4u.c:    uint32_t pil = env->pil_in | (env->softint & ~SOFTINT_TIMER) |
sun4u.c:        ((env->softint & SOFTINT_TIMER) << 14);
sun4u.c:    if (pil && (env->interrupt_index == 0 ||
sun4u.c:                (env->interrupt_index & ~15) == TT_EXTINT)) {
sun4u.c:        for (i = 15; i > 0; i--) {
sun4u.c:                int old_interrupt = env->interrupt_index;
sun4u.c:                env->interrupt_index = TT_EXTINT | i;
sun4u.c:                if (old_interrupt != env->interrupt_index) {
sun4u.c:    } else if (!pil && (env->interrupt_index & ~15) == TT_EXTINT) {
sun4u.c:        DPRINTF("Reset CPU IRQ %d\n", env->interrupt_index & 15);
sun4u.c:        env->interrupt_index = 0;
sun4u.c:        env->halted = 0;
sun4u.c:        env->pil_in |= 1 << irq;
sun4u.c:        env->pil_in &= ~(1 << irq);
sun4u.c:    CPUState *env = s->env;
sun4u.c:    env->tick_cmpr = TICK_INT_DIS | 0;
sun4u.c:    ptimer_set_limit(env->tick, TICK_MAX, 1);
sun4u.c:    ptimer_run(env->tick, 1);
sun4u.c:    env->stick_cmpr = TICK_INT_DIS | 0;
sun4u.c:    ptimer_set_limit(env->stick, TICK_MAX, 1);
sun4u.c:    ptimer_run(env->stick, 1);
sun4u.c:    env->hstick_cmpr = TICK_INT_DIS | 0;
sun4u.c:    ptimer_set_limit(env->hstick, TICK_MAX, 1);
sun4u.c:    ptimer_run(env->hstick, 1);
sun4u.c:    env->gregs[1] = 0; // Memory start
sun4u.c:    env->gregs[2] = ram_size; // Memory size
sun4u.c:    env->gregs[3] = 0; // Machine description XXX
sun4u.c:        env->pc = s->prom_addr + 0x20ULL;
sun4u.c:        env->pc = s->prom_addr + 0x40ULL;
sun4u.c:    env->npc = env->pc + 4;
sun4u.c:    if (!(env->tick_cmpr & TICK_INT_DIS)) {
sun4u.c:        env->softint |= SOFTINT_TIMER;
sun4u.c:    if (!(env->stick_cmpr & TICK_INT_DIS)) {
sun4u.c:        env->softint |= SOFTINT_STIMER;
sun4u.c:    if (!(env->hstick_cmpr & TICK_INT_DIS)) {
sun4u.c:    ptimer_set_count(opaque, -count);
sun4u.c:    return -ptimer_get_count(opaque);
sun4u.c:    ptimer_set_limit(opaque, -limit, 0);
sun4u.c:    isa_bus_new(&s->qdev);
sun4u.c:    pci_config_set_vendor_id(s->config, PCI_VENDOR_ID_SUN);
sun4u.c:    pci_config_set_device_id(s->config, PCI_DEVICE_ID_SUN_EBUS);
sun4u.c:    s->config[0x04] = 0x06; // command = bus master, pci mem
sun4u.c:    s->config[0x05] = 0x00;
sun4u.c:    s->config[0x06] = 0xa0; // status = fast back-to-back, 66MHz, no error
sun4u.c:    s->config[0x07] = 0x03; // status = medium devsel
sun4u.c:    s->config[0x08] = 0x01; // revision
sun4u.c:    s->config[0x09] = 0x00; // programming i/f
sun4u.c:    pci_config_set_class(s->config, PCI_CLASS_BRIDGE_OTHER);
sun4u.c:    s->config[0x0D] = 0x0a; // latency_timer
sun4u.c:    s->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
sun4u.c:        ret = load_elf(filename, addr - PROM_VADDR, NULL, NULL, NULL,
sun4u.c:        ret = -1;
sun4u.c:    RAM_size = d->size;
sun4u.c:    d->size = RAM_size;
sun4u.c:        cpu_model = hwdef->default_cpu_model;
sun4u.c:    env->tick = ptimer_init(bh);
sun4u.c:    ptimer_set_period(env->tick, 1ULL);
sun4u.c:    env->stick = ptimer_init(bh);
sun4u.c:    ptimer_set_period(env->stick, 1ULL);
sun4u.c:    env->hstick = ptimer_init(bh);
sun4u.c:    ptimer_set_period(env->hstick, 1ULL);
sun4u.c:    reset_info->env = env;
sun4u.c:    reset_info->prom_addr = hwdef->prom_addr;
sun4u.c:    prom_init(hwdef->prom_addr, bios_name);
sun4u.c:    pci_ebus_init(pci_bus, -1);
sun4u.c:    if (hwdef->console_serial_base) {
sun4u.c:        serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200,
sun4u.c:    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id);
sun4u.c:    /* Sun4u generic PC-like machine */
sun4u.c:    /* Sun4v generic PC-like machine */
syborg.c:#include "arm-misc.h"
syborg.c:        cpu_model = "cortex-a8";
syborg.c:        dev = qdev_create(NULL, "syborg,virtio-net");
syborg_fb.c:    FB_PALETTE_END   = FB_PALETTE_START+256-1,
syborg_fb.c:    BPP_SRC_15 = -1,
syborg_fb.c:    BPP_SRC_24 = -2
syborg_fb.c:    if ((s->int_status & s->int_enable) != 0) {
syborg_fb.c:        qemu_irq_raise(s->irq);
syborg_fb.c:        qemu_irq_lower(s->irq);
syborg_fb.c:    return s->enabled;
syborg_fb.c:    switch (s->bpp) {
syborg_fb.c:        raw = s->raw_palette[i];
syborg_fb.c:        switch (ds_get_bits_per_pixel(s->ds)) {
syborg_fb.c:            s->palette[i] = rgb_to_pixel8(r, g, b);
syborg_fb.c:            s->palette[i] = rgb_to_pixel15(r, g, b);
syborg_fb.c:            s->palette[i] = rgb_to_pixel16(r, g, b);
syborg_fb.c:            s->palette[i] = rgb_to_pixel32(r, g, b);
syborg_fb.c:    switch (ds_get_bits_per_pixel(s->ds)) {
syborg_fb.c:    if (s->need_int) {
syborg_fb.c:        s->int_status |= FB_INT_BASE_UPDATE_DONE;
syborg_fb.c:        s->need_int = 0;
syborg_fb.c:    if (s->rgb) {
syborg_fb.c:    if (s->endian) {
syborg_fb.c:    fn = fntable[s->bpp + bpp_offset];
syborg_fb.c:    if (s->pitch) {
syborg_fb.c:        src_width = s->pitch;
syborg_fb.c:        src_width = s->cols;
syborg_fb.c:        switch (s->bpp) {
syborg_fb.c:    dest_width *= s->cols;
syborg_fb.c:    if (!s->blank) {
syborg_fb.c:        if (s->need_update && s->bpp <= BPP_SRC_8) {
syborg_fb.c:        framebuffer_update_display(s->ds,
syborg_fb.c:                                   s->base, s->cols, s->rows,
syborg_fb.c:                                   s->need_update,
syborg_fb.c:                                   fn, s->palette,
syborg_fb.c:            dpy_update(s->ds, 0, first, s->cols, last - first + 1);
syborg_fb.c:        s->int_status |= FB_INT_VSYNC;
syborg_fb.c:    s->need_update = 0;
syborg_fb.c:    s->need_update = 1;
syborg_fb.c:        return s->base;
syborg_fb.c:        return s->rows;
syborg_fb.c:        return s->cols;
syborg_fb.c:        return s->blank;
syborg_fb.c:        return s->int_enable;
syborg_fb.c:        return s->int_status;
syborg_fb.c:        switch (s->bpp) {
syborg_fb.c:        return s->rgb;
syborg_fb.c:        return s->endian;
syborg_fb.c:        return s->pitch;
syborg_fb.c:        return s->enabled;
syborg_fb.c:            return s->raw_palette[(offset >> 2) - FB_PALETTE_START];
syborg_fb.c:    s->need_update = 1;
syborg_fb.c:        s->base = val;
syborg_fb.c:        s->need_int = 1;
syborg_fb.c:        s->need_update = 1;
syborg_fb.c:        s->rows = val;
syborg_fb.c:        s->cols = val;
syborg_fb.c:        s->blank = val & 1;
syborg_fb.c:        s->int_enable = val;
syborg_fb.c:        s->int_status &= ~val;
syborg_fb.c:        default: val = s->bpp; break;
syborg_fb.c:        s->bpp = val;
syborg_fb.c:        s->rgb = (val != 0);
syborg_fb.c:        s->endian = (val != 0);
syborg_fb.c:        s->pitch = val;
syborg_fb.c:        s->enabled = val;
syborg_fb.c:            s->raw_palette[(offset >> 2) - FB_PALETTE_START] = val;
syborg_fb.c:    qemu_put_be32(f, s->need_int);
syborg_fb.c:    qemu_put_be32(f, s->int_status);
syborg_fb.c:    qemu_put_be32(f, s->int_enable);
syborg_fb.c:    qemu_put_be32(f, s->enabled);
syborg_fb.c:    qemu_put_be32(f, s->base);
syborg_fb.c:    qemu_put_be32(f, s->pitch);
syborg_fb.c:    qemu_put_be32(f, s->rows);
syborg_fb.c:    qemu_put_be32(f, s->cols);
syborg_fb.c:    qemu_put_be32(f, s->bpp);
syborg_fb.c:    qemu_put_be32(f, s->rgb);
syborg_fb.c:        qemu_put_be32(f, s->raw_palette[i]);
syborg_fb.c:        return -EINVAL;
syborg_fb.c:    s->need_int = qemu_get_be32(f);
syborg_fb.c:    s->int_status = qemu_get_be32(f);
syborg_fb.c:    s->int_enable = qemu_get_be32(f);
syborg_fb.c:    s->enabled = qemu_get_be32(f);
syborg_fb.c:    s->base = qemu_get_be32(f);
syborg_fb.c:    s->pitch = qemu_get_be32(f);
syborg_fb.c:    s->rows = qemu_get_be32(f);
syborg_fb.c:    s->cols = qemu_get_be32(f);
syborg_fb.c:    s->bpp = qemu_get_be32(f);
syborg_fb.c:    s->rgb = qemu_get_be32(f);
syborg_fb.c:        s->raw_palette[i] = qemu_get_be32(f);
syborg_fb.c:    s->need_update = 1;
syborg_fb.c:    sysbus_init_irq(dev, &s->irq);
syborg_fb.c:    s->ds = graphic_console_init(syborg_fb_update_display,
syborg_fb.c:    if (s->cols != 0 && s->rows != 0) {
syborg_fb.c:        qemu_console_resize(s->ds, s->cols, s->rows);
syborg_fb.c:    if (!s->cols)
syborg_fb.c:        s->cols = ds_get_width(s->ds);
syborg_fb.c:    if (!s->rows)
syborg_fb.c:        s->rows = ds_get_height(s->ds);
syborg_fb.c:    register_savevm("syborg_framebuffer", -1, 1,
syborg_interrupt.c:    DPRINTF("pending %d\n", s->pending_count);
syborg_interrupt.c:    qemu_set_irq(s->parent_irq, s->pending_count > 0);
syborg_interrupt.c:    if (s->flags[irq].level == level)
syborg_interrupt.c:    s->flags[irq].level = level;
syborg_interrupt.c:    if (s->flags[irq].enabled) {
syborg_interrupt.c:            s->pending_count++;
syborg_interrupt.c:            s->pending_count--;
syborg_interrupt.c:        DPRINTF("read status=%d\n", s->pending_count);
syborg_interrupt.c:        return s->pending_count;
syborg_interrupt.c:        for (i = 0; i < s->num_irqs; i++) {
syborg_interrupt.c:            if (s->flags[i].level & s->flags[i].enabled) {
syborg_interrupt.c:        s->pending_count = 0;
syborg_interrupt.c:        for (i = 0; i < s->num_irqs; i++)
syborg_interrupt.c:            s->flags[i].enabled = 0;
syborg_interrupt.c:        if (value >= s->num_irqs)
syborg_interrupt.c:        if (s->flags[value].enabled) {
syborg_interrupt.c:            if (s->flags[value].enabled)
syborg_interrupt.c:                s->pending_count--;
syborg_interrupt.c:            s->flags[value].enabled = 0;
syborg_interrupt.c:      if (value >= s->num_irqs)
syborg_interrupt.c:      if (!(s->flags[value].enabled)) {
syborg_interrupt.c:          if(s->flags[value].level)
syborg_interrupt.c:              s->pending_count++;
syborg_interrupt.c:          s->flags[value].enabled = 1;
syborg_interrupt.c:    qemu_put_be32(f, s->num_irqs);
syborg_interrupt.c:    qemu_put_be32(f, s->pending_count);
syborg_interrupt.c:    for (i = 0; i < s->num_irqs; i++) {
syborg_interrupt.c:        qemu_put_be32(f, s->flags[i].enabled
syborg_interrupt.c:                         | ((unsigned)s->flags[i].level << 1));
syborg_interrupt.c:        return -EINVAL;
syborg_interrupt.c:    if (val != s->num_irqs)
syborg_interrupt.c:        return -EINVAL;
syborg_interrupt.c:    s->pending_count = qemu_get_be32(f);
syborg_interrupt.c:    for (i = 0; i < s->num_irqs; i++) {
syborg_interrupt.c:        s->flags[i].enabled = val & 1;
syborg_interrupt.c:        s->flags[i].level = (val >> 1) & 1;
syborg_interrupt.c:    sysbus_init_irq(dev, &s->parent_irq);
syborg_interrupt.c:    qdev_init_gpio_in(&dev->qdev, syborg_int_set_irq, s->num_irqs);
syborg_interrupt.c:    s->flags = qemu_mallocz(s->num_irqs * sizeof(syborg_int_flags));
syborg_interrupt.c:    register_savevm("syborg_int", -1, 1, syborg_int_save, syborg_int_load, s);
syborg_interrupt.c:        DEFINE_PROP_UINT32("num-interrupts", SyborgIntState, num_irqs, 64),
syborg_keyboard.c:    int level = s->read_count && s->int_enabled;
syborg_keyboard.c:    qemu_set_irq(s->irq, level);
syborg_keyboard.c:        return s->read_count;
syborg_keyboard.c:        if (s->read_count == 0) {
syborg_keyboard.c:            c = -1;
syborg_keyboard.c:            c = s->key_fifo[s->read_pos];
syborg_keyboard.c:            s->read_count--;
syborg_keyboard.c:            s->read_pos++;
syborg_keyboard.c:            if (s->read_pos == s->fifo_size)
syborg_keyboard.c:                s->read_pos = 0;
syborg_keyboard.c:        return s->int_enabled;
syborg_keyboard.c:        return s->fifo_size;
syborg_keyboard.c:        s->int_enabled = value;
syborg_keyboard.c:    if (keycode == 0xe0 && !s->extension_bit) {
syborg_keyboard.c:        s->extension_bit = 0x80;
syborg_keyboard.c:    val = (keycode & 0x7f) | s->extension_bit;
syborg_keyboard.c:    s->extension_bit = 0;
syborg_keyboard.c:    slot = s->read_pos + s->read_count;
syborg_keyboard.c:    if (slot >= s->fifo_size)
syborg_keyboard.c:        slot -= s->fifo_size;
syborg_keyboard.c:    if (s->read_count < s->fifo_size) {
syborg_keyboard.c:        s->read_count++;
syborg_keyboard.c:        s->key_fifo[slot] = val;
syborg_keyboard.c:    qemu_put_be32(f, s->fifo_size);
syborg_keyboard.c:    qemu_put_be32(f, s->int_enabled);
syborg_keyboard.c:    qemu_put_be32(f, s->extension_bit);
syborg_keyboard.c:    qemu_put_be32(f, s->read_pos);
syborg_keyboard.c:    qemu_put_be32(f, s->read_count);
syborg_keyboard.c:    for (i = 0; i < s->fifo_size; i++) {
syborg_keyboard.c:        qemu_put_be32(f, s->key_fifo[i]);
syborg_keyboard.c:        return -EINVAL;
syborg_keyboard.c:    if (val != s->fifo_size)
syborg_keyboard.c:        return -EINVAL;
syborg_keyboard.c:    s->int_enabled = qemu_get_be32(f);
syborg_keyboard.c:    s->extension_bit = qemu_get_be32(f);
syborg_keyboard.c:    s->read_pos = qemu_get_be32(f);
syborg_keyboard.c:    s->read_count = qemu_get_be32(f);
syborg_keyboard.c:    for (i = 0; i < s->fifo_size; i++) {
syborg_keyboard.c:        s->key_fifo[i] = qemu_get_be32(f);
syborg_keyboard.c:    sysbus_init_irq(dev, &s->irq);
syborg_keyboard.c:    if (s->fifo_size <= 0) {
syborg_keyboard.c:        s->fifo_size = 16;
syborg_keyboard.c:    s->key_fifo = qemu_mallocz(s->fifo_size * sizeof(s->key_fifo[0]));
syborg_keyboard.c:    register_savevm("syborg_keyboard", -1, 1,
syborg_keyboard.c:        DEFINE_PROP_UINT32("fifo-size", SyborgKeyboardState, fifo_size, 16),
syborg_pointer.c:    qemu_set_irq(s->irq, s->read_count && s->int_enabled);
syborg_pointer.c:        return s->absolute ? SYBORG_ID_TOUCHSCREEN : SYBORG_ID_MOUSE;
syborg_pointer.c:        return s->read_count;
syborg_pointer.c:        return s->event_fifo[s->read_pos].x;
syborg_pointer.c:        return s->event_fifo[s->read_pos].y;
syborg_pointer.c:        return s->event_fifo[s->read_pos].z;
syborg_pointer.c:        return s->event_fifo[s->read_pos].pointer_buttons;
syborg_pointer.c:        return s->int_enabled;
syborg_pointer.c:        return s->fifo_size;
syborg_pointer.c:        if (s->read_count > 0) {
syborg_pointer.c:            s->read_count--;
syborg_pointer.c:            if (++s->read_pos == s->fifo_size)
syborg_pointer.c:                s->read_pos = 0;
syborg_pointer.c:        s->int_enabled = value;
syborg_pointer.c:    int slot = s->read_pos + s->read_count;
syborg_pointer.c:    if (s->read_count < s->fifo_size - 1) {
syborg_pointer.c:        s->read_count++;
syborg_pointer.c:    if (slot >= s->fifo_size)
syborg_pointer.c:          slot -= s->fifo_size;
syborg_pointer.c:    if (s->read_count == s->fifo_size && !s->absolute) {
syborg_pointer.c:        s->event_fifo[slot].x += dx;
syborg_pointer.c:        s->event_fifo[slot].y += dy;
syborg_pointer.c:        s->event_fifo[slot].z += dz;
syborg_pointer.c:        s->event_fifo[slot].x = dx;
syborg_pointer.c:        s->event_fifo[slot].y = dy;
syborg_pointer.c:        s->event_fifo[slot].z = dz;
syborg_pointer.c:    s->event_fifo[slot].pointer_buttons = buttons_state;
syborg_pointer.c:    qemu_put_be32(f, s->fifo_size);
syborg_pointer.c:    qemu_put_be32(f, s->absolute);
syborg_pointer.c:    qemu_put_be32(f, s->int_enabled);
syborg_pointer.c:    qemu_put_be32(f, s->read_pos);
syborg_pointer.c:    qemu_put_be32(f, s->read_count);
syborg_pointer.c:    for (i = 0; i < s->fifo_size; i++) {
syborg_pointer.c:        qemu_put_be32(f, s->event_fifo[i].x);
syborg_pointer.c:        qemu_put_be32(f, s->event_fifo[i].y);
syborg_pointer.c:        qemu_put_be32(f, s->event_fifo[i].z);
syborg_pointer.c:        qemu_put_be32(f, s->event_fifo[i].pointer_buttons);
syborg_pointer.c:        return -EINVAL;
syborg_pointer.c:    if (val != s->fifo_size)
syborg_pointer.c:        return -EINVAL;
syborg_pointer.c:    if (val != s->absolute)
syborg_pointer.c:        return -EINVAL;
syborg_pointer.c:    s->int_enabled = qemu_get_be32(f);
syborg_pointer.c:    s->read_pos = qemu_get_be32(f);
syborg_pointer.c:    s->read_count = qemu_get_be32(f);
syborg_pointer.c:    for (i = 0; i < s->fifo_size; i++) {
syborg_pointer.c:        s->event_fifo[i].x = qemu_get_be32(f);
syborg_pointer.c:        s->event_fifo[i].y = qemu_get_be32(f);
syborg_pointer.c:        s->event_fifo[i].z = qemu_get_be32(f);
syborg_pointer.c:        s->event_fifo[i].pointer_buttons = qemu_get_be32(f);
syborg_pointer.c:    sysbus_init_irq(dev, &s->irq);
syborg_pointer.c:    if (s->fifo_size <= 0) {
syborg_pointer.c:        s->fifo_size = 16;
syborg_pointer.c:    s->event_fifo = qemu_mallocz(s->fifo_size * sizeof(s->event_fifo[0]));
syborg_pointer.c:    qemu_add_mouse_event_handler(syborg_pointer_event, s, s->absolute,
syborg_pointer.c:    register_savevm("syborg_pointer", -1, 1,
syborg_pointer.c:        DEFINE_PROP_UINT32("fifo-size", SyborgPointerState, fifo_size, 16),
syborg_rtc.c:#include "qemu-timer.h"
syborg_rtc.c:        return (uint32_t)s->data;
syborg_rtc.c:        return (uint32_t)(s->data >> 32);
syborg_rtc.c:            s->offset = s->data - now;
syborg_rtc.c:            s->data = now + s->offset;
syborg_rtc.c:                s->data /= 1000;
syborg_rtc.c:                value--;
syborg_rtc.c:        s->data = (s->data & ~(uint64_t)0xffffffffu) | value;
syborg_rtc.c:        s->data = (s->data & 0xffffffffu) | ((uint64_t)value << 32);
syborg_rtc.c:    qemu_put_be64(f, s->offset);
syborg_rtc.c:    qemu_put_be64(f, s->data);
syborg_rtc.c:        return -EINVAL;
syborg_rtc.c:    s->offset = qemu_get_be64(f);
syborg_rtc.c:    s->data = qemu_get_be64(f);
syborg_rtc.c:    s->offset = (uint64_t)mktime(&tm) * 1000000000;
syborg_rtc.c:    register_savevm("syborg_rtc", -1, 1, syborg_rtc_save, syborg_rtc_load, s);
syborg_serial.c:#include "qemu-char.h"
syborg_serial.c:    if ((s->int_enable & SERIAL_INT_FIFO) && s->read_count)
syborg_serial.c:    if (s->int_enable & SERIAL_INT_DMA_TX)
syborg_serial.c:    if ((s->int_enable & SERIAL_INT_DMA_RX) && s->dma_rx_size == 0)
syborg_serial.c:    qemu_set_irq(s->irq, level);
syborg_serial.c:    const uint32_t c = s->read_fifo[s->read_pos];
syborg_serial.c:    s->read_count--;
syborg_serial.c:    s->read_pos++;
syborg_serial.c:    if (s->read_pos == s->fifo_size)
syborg_serial.c:        s->read_pos = 0;
syborg_serial.c:    DPRINTF("FIFO pop %x (%d)\n", c, s->read_count);
syborg_serial.c:    DPRINTF("FIFO push %x (%d)\n", new_value, s->read_count);
syborg_serial.c:    slot = s->read_pos + s->read_count;
syborg_serial.c:    if (slot >= s->fifo_size)
syborg_serial.c:          slot -= s->fifo_size;
syborg_serial.c:    s->read_fifo[slot] = new_value;
syborg_serial.c:    s->read_count++;
syborg_serial.c:    if (s->chr != NULL) {
syborg_serial.c:        while (count--) {
syborg_serial.c:            cpu_physical_memory_read(s->dma_tx_ptr, &ch, 1);
syborg_serial.c:            qemu_chr_write(s->chr, &ch, 1);
syborg_serial.c:            s->dma_tx_ptr++;
syborg_serial.c:        s->dma_tx_ptr += count;
syborg_serial.c:    dest = s->dma_rx_ptr;
syborg_serial.c:    if (s->read_count < len) {
syborg_serial.c:        s->dma_rx_size = len - s->read_count;
syborg_serial.c:        len = s->read_count;
syborg_serial.c:        s->dma_rx_size = 0;
syborg_serial.c:    while (len--) {
syborg_serial.c:    s->dma_rx_ptr = dest;
syborg_serial.c:        if (s->read_count > 0)
syborg_serial.c:            c = -1;
syborg_serial.c:        return s->read_count;
syborg_serial.c:        return s->int_enable;
syborg_serial.c:        return s->dma_tx_ptr;
syborg_serial.c:        return s->dma_rx_ptr;
syborg_serial.c:        return s->dma_rx_size;
syborg_serial.c:        return s->fifo_size;
syborg_serial.c:        if (s->chr)
syborg_serial.c:            qemu_chr_write(s->chr, &ch, 1);
syborg_serial.c:        s->int_enable = value;
syborg_serial.c:        s->dma_tx_ptr = value;
syborg_serial.c:        s->dma_rx_size = 0;
syborg_serial.c:        s->dma_rx_ptr = value;
syborg_serial.c:    if (s->dma_rx_size)
syborg_serial.c:        return s->dma_rx_size;
syborg_serial.c:    return s->fifo_size - s->read_count;
syborg_serial.c:    if (s->dma_rx_size) {
syborg_serial.c:        cpu_physical_memory_write(s->dma_rx_ptr, buf, size);
syborg_serial.c:        s->dma_rx_size -= size;
syborg_serial.c:        s->dma_rx_ptr += size;
syborg_serial.c:        while (size--)
syborg_serial.c:    qemu_put_be32(f, s->fifo_size);
syborg_serial.c:    qemu_put_be32(f, s->int_enable);
syborg_serial.c:    qemu_put_be32(f, s->read_pos);
syborg_serial.c:    qemu_put_be32(f, s->read_count);
syborg_serial.c:    qemu_put_be32(f, s->dma_tx_ptr);
syborg_serial.c:    qemu_put_be32(f, s->dma_rx_ptr);
syborg_serial.c:    qemu_put_be32(f, s->dma_rx_size);
syborg_serial.c:    for (i = 0; i < s->fifo_size; i++) {
syborg_serial.c:        qemu_put_be32(f, s->read_fifo[i]);
syborg_serial.c:        return -EINVAL;
syborg_serial.c:    if (s->fifo_size != i)
syborg_serial.c:        return -EINVAL;
syborg_serial.c:    s->int_enable = qemu_get_be32(f);
syborg_serial.c:    s->read_pos = qemu_get_be32(f);
syborg_serial.c:    s->read_count = qemu_get_be32(f);
syborg_serial.c:    s->dma_tx_ptr = qemu_get_be32(f);
syborg_serial.c:    s->dma_rx_ptr = qemu_get_be32(f);
syborg_serial.c:    s->dma_rx_size = qemu_get_be32(f);
syborg_serial.c:    for (i = 0; i < s->fifo_size; i++) {
syborg_serial.c:        s->read_fifo[i] = qemu_get_be32(f);
syborg_serial.c:    sysbus_init_irq(dev, &s->irq);
syborg_serial.c:    s->chr = qdev_init_chardev(&dev->qdev);
syborg_serial.c:    if (s->chr) {
syborg_serial.c:        qemu_chr_add_handlers(s->chr, syborg_serial_can_receive,
syborg_serial.c:    if (s->fifo_size <= 0) {
syborg_serial.c:        s->fifo_size = 16;
syborg_serial.c:    s->read_fifo = qemu_mallocz(s->fifo_size * sizeof(s->read_fifo[0]));
syborg_serial.c:    register_savevm("syborg_serial", -1, 1,
syborg_serial.c:        DEFINE_PROP_UINT32("fifo-size", SyborgSerialState, fifo_size, 16),
syborg_timer.c:#include "qemu-timer.h"
syborg_timer.c:    if (s->int_level && s->int_enabled) {
syborg_timer.c:        qemu_irq_raise(s->irq);
syborg_timer.c:        qemu_irq_lower(s->irq);
syborg_timer.c:    s->int_level = 1;
syborg_timer.c:    if (s->oneshot)
syborg_timer.c:        s->running = 0;
syborg_timer.c:        return s->running;
syborg_timer.c:        return s->oneshot;
syborg_timer.c:        return s->limit;
syborg_timer.c:        return ptimer_get_count(s->timer);
syborg_timer.c:        return s->int_enabled;
syborg_timer.c:        return s->int_level;
syborg_timer.c:        return s->freq;
syborg_timer.c:        if (value == s->running)
syborg_timer.c:        s->running = value;
syborg_timer.c:            ptimer_run(s->timer, s->oneshot);
syborg_timer.c:            ptimer_stop(s->timer);
syborg_timer.c:        if (s->running) {
syborg_timer.c:            ptimer_stop(s->timer);
syborg_timer.c:        s->oneshot = value;
syborg_timer.c:        if (s->running) {
syborg_timer.c:            ptimer_run(s->timer, s->oneshot);
syborg_timer.c:        s->limit = value;
syborg_timer.c:        ptimer_set_limit(s->timer, value, 1);
syborg_timer.c:        ptimer_set_count(s->timer, value);
syborg_timer.c:        s->int_enabled = value;
syborg_timer.c:        s->int_level &= ~value;
syborg_timer.c:    qemu_put_be32(f, s->running);
syborg_timer.c:    qemu_put_be32(f, s->oneshot);
syborg_timer.c:    qemu_put_be32(f, s->limit);
syborg_timer.c:    qemu_put_be32(f, s->int_level);
syborg_timer.c:    qemu_put_be32(f, s->int_enabled);
syborg_timer.c:    qemu_put_ptimer(f, s->timer);
syborg_timer.c:        return -EINVAL;
syborg_timer.c:    s->running = qemu_get_be32(f);
syborg_timer.c:    s->oneshot = qemu_get_be32(f);
syborg_timer.c:    s->limit = qemu_get_be32(f);
syborg_timer.c:    s->int_level = qemu_get_be32(f);
syborg_timer.c:    s->int_enabled = qemu_get_be32(f);
syborg_timer.c:    qemu_get_ptimer(f, s->timer);
syborg_timer.c:    if (s->freq == 0) {
syborg_timer.c:    sysbus_init_irq(dev, &s->irq);
syborg_timer.c:    s->timer = ptimer_init(bh);
syborg_timer.c:    ptimer_set_freq(s->timer, s->freq);
syborg_timer.c:    register_savevm("syborg_timer", -1, 1,
syborg_virtio.c:    VirtIODevice *vdev = s->vdev;
syborg_virtio.c:        return virtio_config_readl(vdev, offset - SYBORG_VIRTIO_CONFIG);
syborg_virtio.c:        ret = s->id;
syborg_virtio.c:        ret = vdev->get_features(vdev);
syborg_virtio.c:        ret |= vdev->binding->get_features(s);
syborg_virtio.c:        ret = vdev->features;
syborg_virtio.c:        ret = virtio_queue_get_addr(vdev, vdev->queue_sel);
syborg_virtio.c:        ret = virtio_queue_get_num(vdev, vdev->queue_sel);
syborg_virtio.c:        ret = vdev->queue_sel;
syborg_virtio.c:        ret = vdev->status;
syborg_virtio.c:        ret = s->int_enable;
syborg_virtio.c:        ret = vdev->isr;
syborg_virtio.c:    VirtIODevice *vdev = s->vdev;
syborg_virtio.c:        return virtio_config_writel(vdev, offset - SYBORG_VIRTIO_CONFIG,
syborg_virtio.c:        if (vdev->set_features)
syborg_virtio.c:            vdev->set_features(vdev, value);
syborg_virtio.c:        vdev->features = value;
syborg_virtio.c:            virtio_queue_set_addr(vdev, vdev->queue_sel, value);
syborg_virtio.c:            vdev->queue_sel = value;
syborg_virtio.c:        vdev->status = value & 0xFF;
syborg_virtio.c:        if (vdev->status == 0)
syborg_virtio.c:        s->int_enable = value;
syborg_virtio.c:        vdev->isr &= ~value;
syborg_virtio.c:    VirtIODevice *vdev = s->vdev;
syborg_virtio.c:        return virtio_config_readw(vdev, offset - SYBORG_VIRTIO_CONFIG);
syborg_virtio.c:    return -1;
syborg_virtio.c:    VirtIODevice *vdev = s->vdev;
syborg_virtio.c:        return virtio_config_writew(vdev, offset - SYBORG_VIRTIO_CONFIG,
syborg_virtio.c:    VirtIODevice *vdev = s->vdev;
syborg_virtio.c:        return virtio_config_readb(vdev, offset - SYBORG_VIRTIO_CONFIG);
syborg_virtio.c:    return -1;
syborg_virtio.c:    VirtIODevice *vdev = s->vdev;
syborg_virtio.c:        return virtio_config_writeb(vdev, offset - SYBORG_VIRTIO_CONFIG,
syborg_virtio.c:    level = proxy->int_enable & proxy->vdev->isr;
syborg_virtio.c:    qemu_set_irq(proxy->irq, level != 0);
syborg_virtio.c:    proxy->vdev = vdev;
syborg_virtio.c:    proxy->vdev->nvectors = 0;
syborg_virtio.c:    sysbus_init_irq(&proxy->busdev, &proxy->irq);
syborg_virtio.c:    sysbus_init_mmio(&proxy->busdev, 0x1000, iomemtype);
syborg_virtio.c:    proxy->id = ((uint32_t)0x1af4 << 16) | vdev->device_id;
syborg_virtio.c:    vdev = virtio_net_init(&dev->qdev, &proxy->nic);
syborg_virtio.c:    .qdev.name  = "syborg,virtio-net",
sysbus.c:    assert(n >= 0 && n < dev->num_irq);
sysbus.c:    dev->irqs[n] = NULL;
sysbus.c:    if (dev->irqp[n]) {
sysbus.c:        *dev->irqp[n] = irq;
sysbus.c:    assert(n >= 0 && n < dev->num_mmio);
sysbus.c:    if (dev->mmio[n].addr == addr) {
sysbus.c:    if (dev->mmio[n].addr != (target_phys_addr_t)-1) {
sysbus.c:        cpu_register_physical_memory(dev->mmio[n].addr, dev->mmio[n].size,
sysbus.c:    dev->mmio[n].addr = addr;
sysbus.c:    if (dev->mmio[n].cb) {
sysbus.c:        dev->mmio[n].cb(dev, addr);
sysbus.c:        cpu_register_physical_memory(addr, dev->mmio[n].size,
sysbus.c:                                     dev->mmio[n].iofunc);
sysbus.c:    assert(dev->num_irq < QDEV_MAX_IRQ);
sysbus.c:    n = dev->num_irq++;
sysbus.c:    dev->irqp[n] = p;
sysbus.c:    assert(dev->num_irq == 0);
sysbus.c:    dev->num_irq = target->num_irq;
sysbus.c:    for (i = 0; i < dev->num_irq; i++) {
sysbus.c:        dev->irqp[i] = target->irqp[i];
sysbus.c:    assert(dev->num_mmio < QDEV_MAX_MMIO);
sysbus.c:    n = dev->num_mmio++;
sysbus.c:    dev->mmio[n].addr = -1;
sysbus.c:    dev->mmio[n].size = size;
sysbus.c:    dev->mmio[n].iofunc = iofunc;
sysbus.c:    assert(dev->num_mmio < QDEV_MAX_MMIO);
sysbus.c:    n = dev->num_mmio++;
sysbus.c:    dev->mmio[n].addr = -1;
sysbus.c:    dev->mmio[n].size = size;
sysbus.c:    dev->mmio[n].cb = cb;
sysbus.c:    return info->init(sysbus_from_qdev(dev));
sysbus.c:    info->qdev.init = sysbus_device_init;
sysbus.c:    info->qdev.bus_info = &system_bus_info;
sysbus.c:    assert(info->qdev.size >= sizeof(SysBusDevice));
sysbus.c:    qdev_register(&info->qdev);
sysbus.c:    info->qdev.name = qemu_strdup(name);
sysbus.c:    info->qdev.size = size;
sysbus.c:    info->init = init;
sysbus.c:    if (addr != (target_phys_addr_t)-1) {
sysbus.c:    for (i = 0; i < s->num_mmio; i++) {
sysbus.c:                       indent, "", s->mmio[i].addr, s->mmio[i].size);
tc58128.c:    dev->state = WAIT;
tc58128.c:    dev->flash_contents = qemu_mallocz(FLASH_SIZE);
tc58128.c:    memset(dev->flash_contents, 0xff, FLASH_SIZE);
tc58128.c:    if (!dev->flash_contents) {
tc58128.c:	ret = load_image(filename, dev->flash_contents + 528 * 32);
tc58128.c:	    blocks = (ret + 528 * 32 - 1) / (528 * 32);
tc58128.c:	    dev->flash_contents[0] = blocks & 0xff;
tc58128.c:	    dev->flash_contents[1] = (blocks >> 8) & 0xff;
tc58128.c:	    dev->flash_contents[2] = (blocks >> 16) & 0xff;
tc58128.c:	    dev->flash_contents[3] = (blocks >> 24) & 0xff;
tc58128.c:	dev->state = WAIT;
tc58128.c:	dev->state = READ1;
tc58128.c:	dev->address_cycle = 0;
tc58128.c:	dev->state = READ2;
tc58128.c:	dev->address_cycle = 0;
tc58128.c:	dev->state = READ3;
tc58128.c:	dev->address_cycle = 0;
tc58128.c:    switch (dev->state) {
tc58128.c:	switch (dev->address_cycle) {
tc58128.c:	    dev->address = data;
tc58128.c:	    if (dev->state == READ2)
tc58128.c:		dev->address |= 0x100;
tc58128.c:	    else if (dev->state == READ3)
tc58128.c:		dev->address |= 0x200;
tc58128.c:	    dev->address += data * 528 * 0x100;
tc58128.c:	    dev->address += data * 528;
tc58128.c:		    dev->address);
tc58128.c:	dev->address_cycle++;
tc58128.c:    if (dev->address % 0x100000 == 0)
tc58128.c:	fprintf(stderr, "reading flash at address 0x%08x\n", dev->address);
tc58128.c:    return dev->flash_contents[dev->address++];
tc6393xb.c: * Found in Sharp Zaurus SL-6000 (tosa) or some
tc6393xb.c: * Toshiba e-Series PDAs.
tc6393xb.c:    return s->gpio_in;
tc6393xb.c:    s->handler[line] = handler;
tc6393xb.c:    level = s->gpio_level & s->gpio_dir;
tc6393xb.c:    for (diff = s->prev_level ^ level; diff; diff ^= 1 << bit) {
tc6393xb.c:        bit = ffs(diff) - 1;
tc6393xb.c:        qemu_set_irq(s->handler[bit], (level >> bit) & 1);
tc6393xb.c:    s->prev_level = level;
tc6393xb.c:    return s->l3v;
tc6393xb.c:    s->blank = !level;
tc6393xb.c:    uint8_t isr = s->scr.ISR;
tc6393xb.c:    s->scr.ISR = isr;
tc6393xb.c:    qemu_set_irq(s->irq, isr & s->scr.IMR);
tc6393xb.c:    case SCR_ ##N: return s->scr.N
tc6393xb.c:    case SCR_ ##N: return s->scr.N;             \
tc6393xb.c:    case SCR_ ##N + 1: return s->scr.N >> 8;
tc6393xb.c:    case SCR_ ##N: return s->scr.N;             \
tc6393xb.c:    case SCR_ ##N + 1: return s->scr.N >> 8;    \
tc6393xb.c:    case SCR_ ##N + 2: return s->scr.N >> 16;   \
tc6393xb.c:    case SCR_ ##N + 3: return s->scr.N >> 24;
tc6393xb.c:    case SCR_ ##N(0): return s->scr.N[0];       \
tc6393xb.c:    case SCR_ ##N(1): return s->scr.N[1];       \
tc6393xb.c:    case SCR_ ##N(2): return s->scr.N[2]
tc6393xb.c:            return (s->gpio_level >> ((addr - SCR_GPO_DSR(0)) * 8)) & 0xff;
tc6393xb.c:            return (s->gpio_dir >> ((addr - SCR_GPO_DOECR(0)) * 8)) & 0xff;
tc6393xb.c:    case SCR_ ##N: s->scr.N = value; return;
tc6393xb.c:    case SCR_ ##N: s->scr.N = (s->scr.N & ~0xff) | (value & 0xff); return; \
tc6393xb.c:    case SCR_ ##N + 1: s->scr.N = (s->scr.N & 0xff) | (value << 8); return
tc6393xb.c:    case SCR_ ##N: s->scr.N = (s->scr.N & ~0xff) | (value & 0xff); return;   \
tc6393xb.c:    case SCR_ ##N + 1: s->scr.N = (s->scr.N & ~(0xff << 8)) | (value & (0xff << 8)); return;     \
tc6393xb.c:    case SCR_ ##N + 2: s->scr.N = (s->scr.N & ~(0xff << 16)) | (value & (0xff << 16)); return;   \
tc6393xb.c:    case SCR_ ##N + 3: s->scr.N = (s->scr.N & ~(0xff << 24)) | (value & (0xff << 24)); return;
tc6393xb.c:    case SCR_ ##N(0): s->scr.N[0] = value; return;   \
tc6393xb.c:    case SCR_ ##N(1): s->scr.N[1] = value; return;   \
tc6393xb.c:    case SCR_ ##N(2): s->scr.N[2] = value; return
tc6393xb.c:            s->gpio_level = (s->gpio_level & ~(0xff << ((addr - SCR_GPO_DSR(0))*8))) | ((value & 0xff) << ((addr - SCR_GPO_DSR(0))*8));
tc6393xb.c:            s->gpio_dir = (s->gpio_dir & ~(0xff << ((addr - SCR_GPO_DOECR(0))*8))) | ((value & 0xff) << ((addr - SCR_GPO_DOECR(0))*8));
tc6393xb.c:    qemu_set_irq(s->sub_irqs[IRQ_TC6393_NAND],
tc6393xb.c:            (s->nand.imr & 0x80) && (s->nand.imr & s->nand.isr));
tc6393xb.c:            return s->nand_enable ? 2 : 0;
tc6393xb.c:            return s->nand_phys >> (addr - NAND_CFG_BASE);
tc6393xb.c:            s->nand_enable = (value & 0x2);
tc6393xb.c:            s->nand_phys &= ~(0xff << ((addr - NAND_CFG_BASE) * 8));
tc6393xb.c:            s->nand_phys |= (value & 0xff) << ((addr - NAND_CFG_BASE) * 8);
tc6393xb.c:            return nand_getio(s->flash);
tc6393xb.c:            return s->nand.mode;
tc6393xb.c:            return s->nand.isr;
tc6393xb.c:            return s->nand.imr;
tc6393xb.c:            nand_setio(s->flash, value);
tc6393xb.c:            s->nand.isr &= 1;
tc6393xb.c:            s->nand.mode = value;
tc6393xb.c:            nand_setpins(s->flash,
tc6393xb.c:                    ecc_reset(&s->ecc);
tc6393xb.c:                    ecc_reset(&s->ecc);
tc6393xb.c:            s->nand.isr = value;
tc6393xb.c:            s->nand.imr = value;
tc6393xb.c:    switch (ds_get_bits_per_pixel(s->ds)) {
tc6393xb.c:            printf("tc6393xb: unknown depth %d\n", ds_get_bits_per_pixel(s->ds));
tc6393xb.c:    dpy_update(s->ds, 0, 0, s->scr_width, s->scr_height);
tc6393xb.c:    w = s->scr_width * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);
tc6393xb.c:    d = ds_get_data(s->ds);
tc6393xb.c:    for(i = 0; i < s->scr_height; i++) {
tc6393xb.c:        d += ds_get_linesize(s->ds);
tc6393xb.c:    dpy_update(s->ds, 0, 0, s->scr_width, s->scr_height);
tc6393xb.c:    if (s->scr_width == 0 || s->scr_height == 0)
tc6393xb.c:    if (s->blanked != s->blank) {
tc6393xb.c:        s->blanked = s->blank;
tc6393xb.c:    if (s->scr_width != ds_get_width(s->ds) || s->scr_height != ds_get_height(s->ds)) {
tc6393xb.c:        qemu_console_resize(s->ds, s->scr_width, s->scr_height);
tc6393xb.c:    if (s->blanked)
tc6393xb.c:    if ((addr &~0xff) == s->nand_phys && s->nand_enable) {
tc6393xb.c:    if ((addr &~0xff) == s->nand_phys && s->nand_enable)
tc6393xb.c:    s->irq = irq;
tc6393xb.c:    s->gpio_in = qemu_allocate_irqs(tc6393xb_gpio_set, s, TC6393XB_GPIOS);
tc6393xb.c:    s->l3v = *qemu_allocate_irqs(tc6393xb_l3v, s, 1);
tc6393xb.c:    s->blanked = 1;
tc6393xb.c:    s->sub_irqs = qemu_allocate_irqs(tc6393xb_sub_irq, s, TC6393XB_NR_IRQS);
tc6393xb.c:    s->flash = nand_init(NAND_MFR_TOSHIBA, 0x76);
tc6393xb.c:    s->vram_addr = qemu_ram_alloc(0x100000);
tc6393xb.c:    s->vram_ptr = qemu_get_ram_ptr(s->vram_addr);
tc6393xb.c:    cpu_register_physical_memory(base + 0x100000, 0x100000, s->vram_addr);
tc6393xb.c:    s->scr_width = 480;
tc6393xb.c:    s->scr_height = 640;
tc6393xb.c:    s->ds = graphic_console_init(tc6393xb_update_display,
tc6393xb_template.h: * Found in Sharp Zaurus SL-6000 (tosa) or some
tc6393xb_template.h: * Toshiba e-Series PDAs.
tc6393xb_template.h:    data_buffer = s->vram_ptr;
tc6393xb_template.h:    w_display = s->scr_width * BITS / 8;
tc6393xb_template.h:    data_display = ds_get_data(s->ds);
tc6393xb_template.h:    for(i = 0; i < s->scr_height; i++) {
tc6393xb_template.h:        memcpy(data_display, data_buffer, s->scr_width * 2);
tc6393xb_template.h:        data_buffer += s->scr_width;
tc6393xb_template.h:        data_display += ds_get_linesize(s->ds);
tc6393xb_template.h:        for (j = 0; j < s->scr_width; j++, data_display += BITS / 8, data_buffer++) {
tcx.c: * Copyright (c) 2003-2005 Fabrice Bellard
tcx.c:#include "qdev-addr.h"
tcx.c:        cpu_physical_memory_set_dirty(s->vram_offset + i);
tcx.c:        cpu_physical_memory_set_dirty(s->vram24_offset + i);
tcx.c:        cpu_physical_memory_set_dirty(s->cplane_offset + i);
tcx.c:        switch(ds_get_bits_per_pixel(s->ds)) {
tcx.c:            s->palette[i] = rgb_to_pixel8(s->r[i], s->g[i], s->b[i]);
tcx.c:            s->palette[i] = rgb_to_pixel15(s->r[i], s->g[i], s->b[i]);
tcx.c:            s->palette[i] = rgb_to_pixel16(s->r[i], s->g[i], s->b[i]);
tcx.c:            if (is_surface_bgr(s->ds->surface))
tcx.c:                s->palette[i] = rgb_to_pixel32bgr(s->r[i], s->g[i], s->b[i]);
tcx.c:                s->palette[i] = rgb_to_pixel32(s->r[i], s->g[i], s->b[i]);
tcx.c:    if (s->depth == 24) {
tcx.c:        *p++ = s1->palette[val];
tcx.c:        *p++ = s1->palette[val];
tcx.c:        *d++ = s1->palette[val];
tcx.c:    bgr = is_surface_bgr(s1->ds->surface);
tcx.c:            // 24-bit direct, BGR order
tcx.c:            dval = s1->palette[val];
tcx.c:    page_min -= ts->vram_offset;
tcx.c:    page_max -= ts->vram_offset;
tcx.c:    if (ds_get_bits_per_pixel(ts->ds) == 0)
tcx.c:    page = ts->vram_offset;
tcx.c:    y_start = -1;
tcx.c:    page_min = -1;
tcx.c:    d = ds_get_data(ts->ds);
tcx.c:    s = ts->vram;
tcx.c:    dd = ds_get_linesize(ts->ds);
tcx.c:    switch (ds_get_bits_per_pixel(ts->ds)) {
tcx.c:    for(y = 0; y < ts->height; y += 4, page += TARGET_PAGE_SIZE) {
tcx.c:            f(ts, d, s, ts->width);
tcx.c:            f(ts, d, s, ts->width);
tcx.c:            f(ts, d, s, ts->width);
tcx.c:            f(ts, d, s, ts->width);
tcx.c:                dpy_update(ts->ds, 0, y_start,
tcx.c:                           ts->width, y - y_start);
tcx.c:                y_start = -1;
tcx.c:        dpy_update(ts->ds, 0, y_start,
tcx.c:                   ts->width, y - y_start);
tcx.c:    if (ds_get_bits_per_pixel(ts->ds) != 32)
tcx.c:    page = ts->vram_offset;
tcx.c:    page24 = ts->vram24_offset;
tcx.c:    cpage = ts->cplane_offset;
tcx.c:    y_start = -1;
tcx.c:    page_min = -1;
tcx.c:    d = ds_get_data(ts->ds);
tcx.c:    s = ts->vram;
tcx.c:    s24 = ts->vram24;
tcx.c:    cptr = ts->cplane;
tcx.c:    dd = ds_get_linesize(ts->ds);
tcx.c:    for(y = 0; y < ts->height; y += 4, page += TARGET_PAGE_SIZE,
tcx.c:            tcx24_draw_line32(ts, d, s, ts->width, cptr, s24);
tcx.c:            tcx24_draw_line32(ts, d, s, ts->width, cptr, s24);
tcx.c:            tcx24_draw_line32(ts, d, s, ts->width, cptr, s24);
tcx.c:            tcx24_draw_line32(ts, d, s, ts->width, cptr, s24);
tcx.c:                dpy_update(ts->ds, 0, y_start,
tcx.c:                           ts->width, y - y_start);
tcx.c:                y_start = -1;
tcx.c:        dpy_update(ts->ds, 0, y_start,
tcx.c:                   ts->width, y - y_start);
tcx.c:    qemu_console_resize(s->ds, s->width, s->height);
tcx.c:    qemu_console_resize(s->ds, s->width, s->height);
tcx.c:    if (s->depth == 24) {
tcx.c:    memset(s->r, 0, 256);
tcx.c:    memset(s->g, 0, 256);
tcx.c:    memset(s->b, 0, 256);
tcx.c:    s->r[255] = s->g[255] = s->b[255] = 255;
tcx.c:    memset(s->vram, 0, MAXX*MAXY);
tcx.c:    cpu_physical_memory_reset_dirty(s->vram_offset, s->vram_offset +
tcx.c:    s->dac_index = 0;
tcx.c:    s->dac_state = 0;
tcx.c:        s->dac_index = val >> 24;
tcx.c:        s->dac_state = 0;
tcx.c:        switch (s->dac_state) {
tcx.c:            s->r[s->dac_index] = val >> 24;
tcx.c:            update_palette_entries(s, s->dac_index, s->dac_index + 1);
tcx.c:            s->dac_state++;
tcx.c:            s->g[s->dac_index] = val >> 24;
tcx.c:            update_palette_entries(s, s->dac_index, s->dac_index + 1);
tcx.c:            s->dac_state++;
tcx.c:            s->b[s->dac_index] = val >> 24;
tcx.c:            update_palette_entries(s, s->dac_index, s->dac_index + 1);
tcx.c:            s->dac_index = (s->dac_index + 1) & 255; // Index autoincrement
tcx.c:            s->dac_state = 0;
tcx.c:    vram_offset = qemu_ram_alloc(s->vram_size * (1 + 4 + 4));
tcx.c:    s->vram_offset = vram_offset;
tcx.c:    /* 8-bit plane */
tcx.c:    s->vram = vram_base;
tcx.c:    size = s->vram_size;
tcx.c:    sysbus_init_mmio(dev, size, s->vram_offset);
tcx.c:    /* THC: NetBSD writes here even with 8-bit display: dummy */
tcx.c:    if (s->depth == 24) {
tcx.c:        /* 24-bit plane */
tcx.c:        size = s->vram_size * 4;
tcx.c:        s->vram24 = (uint32_t *)vram_base;
tcx.c:        s->vram24_offset = vram_offset;
tcx.c:        size = s->vram_size * 4;
tcx.c:        s->cplane = (uint32_t *)vram_base;
tcx.c:        s->cplane_offset = vram_offset;
tcx.c:        s->ds = graphic_console_init(tcx24_update_display,
tcx.c:        s->ds = graphic_console_init(tcx_update_display,
tcx.c:    qemu_console_resize(s->ds, s->width, s->height);
tcx.c:    fprintf(f, "P6\n%d %d\n%d\n", s->width, s->height, 255);
tcx.c:    d1 = s->vram;
tcx.c:    for(y = 0; y < s->height; y++) {
tcx.c:        for(x = 0; x < s->width; x++) {
tcx.c:            fputc(s->r[v], f);
tcx.c:            fputc(s->g[v], f);
tcx.c:            fputc(s->b[v], f);
tcx.c:    fprintf(f, "P6\n%d %d\n%d\n", s->width, s->height, 255);
tcx.c:    d1 = s->vram;
tcx.c:    s24 = s->vram24;
tcx.c:    cptr = s->cplane;
tcx.c:    for(y = 0; y < s->height; y++) {
tcx.c:        for(x = 0; x < s->width; x++, d++, s24++) {
tcx.c:            if ((*cptr++ & 0xff000000) == 0x03000000) { // 24-bit direct
tcx.c:                fputc(s->r[v], f);
tcx.c:                fputc(s->g[v], f);
tcx.c:                fputc(s->b[v], f);
tcx.c:        DEFINE_PROP_TADDR("addr",      TCXState, addr,      -1),
tcx.c:        DEFINE_PROP_HEX32("vram_size", TCXState, vram_size, -1),
tcx.c:        DEFINE_PROP_UINT16("width",    TCXState, width,     -1),
tcx.c:        DEFINE_PROP_UINT16("height",   TCXState, height,    -1),
tcx.c:        DEFINE_PROP_UINT16("depth",    TCXState, depth,     -1),
testdev.c:    if (dev->chr) {
testdev.c:        qemu_chr_write(dev->chr, buf, 1);
testdev.c:    qemu_set_irq(ioapic_irq_hack[addr - 0x2000], !!data);
tmp105.c:    qemu_set_irq(s->pin, s->alarm ^ ((~s->config >> 2) & 1));	/* POL */
tmp105.c:    if ((s->config >> 0) & 1) {					/* SD */
tmp105.c:        if ((s->config >> 7) & 1)				/* OS */
tmp105.c:            s->config &= ~(1 << 7);				/* OS */
tmp105.c:    if ((s->config >> 1) & 1) {					/* TM */
tmp105.c:        if (s->temperature >= s->limit[1])
tmp105.c:            s->alarm = 1;
tmp105.c:        else if (s->temperature < s->limit[0])
tmp105.c:            s->alarm = 1;
tmp105.c:        if (s->temperature >= s->limit[1])
tmp105.c:            s->alarm = 1;
tmp105.c:        else if (s->temperature < s->limit[0])
tmp105.c:            s->alarm = 0;
tmp105.c:    if (temp >= 128000 || temp < -128000) {
tmp105.c:        exit(-1);
tmp105.c:    s->temperature = ((int16_t) (temp * 0x800 / 128000)) << 4;
tmp105.c:    s->len = 0;
tmp105.c:    if ((s->config >> 1) & 1) {					/* TM */
tmp105.c:        s->alarm = 0;
tmp105.c:    switch (s->pointer & 3) {
tmp105.c:        s->buf[s->len ++] = (((uint16_t) s->temperature) >> 8);
tmp105.c:        s->buf[s->len ++] = (((uint16_t) s->temperature) >> 0) &
tmp105.c:                (0xf0 << ((~s->config >> 5) & 3));		/* R */
tmp105.c:        s->buf[s->len ++] = s->config;
tmp105.c:        s->buf[s->len ++] = ((uint16_t) s->limit[0]) >> 8;
tmp105.c:        s->buf[s->len ++] = ((uint16_t) s->limit[0]) >> 0;
tmp105.c:        s->buf[s->len ++] = ((uint16_t) s->limit[1]) >> 8;
tmp105.c:        s->buf[s->len ++] = ((uint16_t) s->limit[1]) >> 0;
tmp105.c:    switch (s->pointer & 3) {
tmp105.c:        if (s->buf[0] & ~s->config & (1 << 0))			/* SD */
tmp105.c:        s->config = s->buf[0];
tmp105.c:        s->faults = tmp105_faultq[(s->config >> 3) & 3];	/* F */
tmp105.c:        if (s->len >= 3)
tmp105.c:            s->limit[s->pointer & 1] = (int16_t)
tmp105.c:                    ((((uint16_t) s->buf[0]) << 8) | s->buf[1]);
tmp105.c:    if (s->len < 2)
tmp105.c:        return s->buf[s->len ++];
tmp105.c:    if (!s->len ++)
tmp105.c:        s->pointer = data;
tmp105.c:        if (s->len <= 2)
tmp105.c:            s->buf[s->len - 1] = data;
tmp105.c:    s->len = 0;
tmp105.c:    s->faults = tmp105_faultq[(s->config >> 3) & 3];		/* F */
tmp105.c:    s->temperature = 0;
tmp105.c:    s->pointer = 0;
tmp105.c:    s->config = 0;
tmp105.c:    s->faults = tmp105_faultq[(s->config >> 3) & 3];
tmp105.c:    s->alarm = 0;
tmp105.c:    qdev_init_gpio_out(&i2c->qdev, &s->pin, 1);
tmp105.c:    tmp105_reset(&s->i2c);
tosa.c: * PXA255 Sharp Zaurus SL-6000 PDA platform
tosa.c:#include "arm-misc.h"
tosa.c:    bs = dinfo->bdrv;
tosa.c:        pxa2xx_pcmcia_attach(cpu->pcmcia[0], md);
tosa.c:    pxa2xx_mmci_handlers(cpu->mmc,
tosa.c:                    qemu_irq_invert(pxa2xx_gpio_in_get(cpu->gpio)[TOSA_GPIO_nSD_DETECT]));
tosa.c:    pxa2xx_gpio_out_set(cpu->gpio, TOSA_GPIO_ON_RESET, cpu->reset);
tosa.c:    /* PCMCIA signals: card's IRQ and Card-Detect */
tosa.c:    pxa2xx_pcmcia_set_irq_cb(cpu->pcmcia[0],
tosa.c:                        pxa2xx_gpio_in_get(cpu->gpio)[TOSA_GPIO_CF_IRQ],
tosa.c:                        pxa2xx_gpio_in_get(cpu->gpio)[TOSA_GPIO_CF_CD]);
tosa.c:    pxa2xx_pcmcia_set_irq_cb(cpu->pcmcia[1],
tosa.c:                        pxa2xx_gpio_in_get(cpu->gpio)[TOSA_GPIO_JC_CF_IRQ],
tosa.c:    s->buf[s->len] = data;
tosa.c:    if (s->len ++ > 2) {
tosa.c:        fprintf(stderr, "%s: message too long (%i bytes)\n", __FUNCTION__, s->len);
tosa.c:    if (s->len == 2) {
tosa.c:                s->buf[0], s->buf[1]);
tosa.c:    s->len = 0;
tosa.c:        if (s->len < 2)
tosa.c:            printf("%s: message too short (%i bytes)\n", __FUNCTION__, s->len);
tosa.c:        if (s->len > 2)
tosa.c:    return -1;
tosa.c:    i2c_bus *bus = pxa2xx_i2c_bus(cpu->i2c[0]);
tosa.c:    ssi_create_slave(cpu->ssp[1], "tosa-ssp");
tosa.c:            pxa2xx_gpio_in_get(cpu->gpio)[TOSA_GPIO_TC6393XB_INT]);
tosa.c:    cpu->env->regs[15] = tosa_binfo.loader_start;
tosa.c:    arm_load_kernel(cpu->env, &tosa_binfo);
tosa.c:    .qdev.name = "tosa-ssp",
tsc2005.c:#include "qemu-timer.h"
tsc2005.c:#define TSC_CUT_RESOLUTION(value, p)	((value) >> (16 - (p ? 12 : 10)))
tsc2005.c:    0x0080,	/* Short-circuit test */
tsc2005.c:    0x0000,	/* X+, X- drivers */
tsc2005.c:    0x0000,	/* Y+, Y- drivers */
tsc2005.c:    0x0000,	/* Y+, X- drivers */
tsc2005.c:    ((s->y * s->tr[0] - s->x * s->tr[1]) / s->tr[2] + s->tr[3])
tsc2005.c:    ((s->y * s->tr[4] - s->x * s->tr[5]) / s->tr[6] + s->tr[7])
tsc2005.c:    ((400 - ((s)->x >> 7) + ((s)->pressure << 10)) << 4)
tsc2005.c:    ((4000 + ((s)->y >> 7) - ((s)->pressure << 10)) << 4)
tsc2005.c:#define AUX_VAL				(700 << 4)	/* +/- 3 at 12-bit */
tsc2005.c:#define TEMP1_VAL			(1264 << 4)	/* +/- 5 at 12-bit */
tsc2005.c:#define TEMP2_VAL			(1531 << 4)	/* +/- 5 at 12-bit */
tsc2005.c:        s->dav &= ~mode_regs[TSC_MODE_X];
tsc2005.c:        return TSC_CUT_RESOLUTION(X_TRANSFORM(s), s->precision) +
tsc2005.c:                (s->noise & 3);
tsc2005.c:        s->dav &= ~mode_regs[TSC_MODE_Y];
tsc2005.c:        s->noise ++;
tsc2005.c:        return TSC_CUT_RESOLUTION(Y_TRANSFORM(s), s->precision) ^
tsc2005.c:                (s->noise & 3);
tsc2005.c:        s->dav &= 0xdfff;
tsc2005.c:        return TSC_CUT_RESOLUTION(Z1_TRANSFORM(s), s->precision) -
tsc2005.c:                (s->noise & 3);
tsc2005.c:        s->dav &= 0xefff;
tsc2005.c:        return TSC_CUT_RESOLUTION(Z2_TRANSFORM(s), s->precision) |
tsc2005.c:                (s->noise & 3);
tsc2005.c:        s->dav &= ~mode_regs[TSC_MODE_AUX];
tsc2005.c:        return TSC_CUT_RESOLUTION(AUX_VAL, s->precision);
tsc2005.c:        s->dav &= ~mode_regs[TSC_MODE_TEMP1];
tsc2005.c:        return TSC_CUT_RESOLUTION(TEMP1_VAL, s->precision) -
tsc2005.c:                (s->noise & 5);
tsc2005.c:        s->dav &= 0xdfff;
tsc2005.c:        s->dav &= ~mode_regs[TSC_MODE_TEMP2];
tsc2005.c:        return TSC_CUT_RESOLUTION(TEMP2_VAL, s->precision) ^
tsc2005.c:                (s->noise & 3);
tsc2005.c:        ret = s->dav | (s->reset << 7) | (s->pdst << 2) | 0x0;
tsc2005.c:        s->dav &= ~(mode_regs[TSC_MODE_X_TEST] | mode_regs[TSC_MODE_Y_TEST] |
tsc2005.c:        s->reset = 1;
tsc2005.c:        return s->aux_thr[1];
tsc2005.c:        return s->aux_thr[0];
tsc2005.c:        return s->temp_thr[1];
tsc2005.c:        return s->temp_thr[0];
tsc2005.c:        return (s->pressure << 15) | ((!s->busy) << 14) |
tsc2005.c:                (s->nextprecision << 13) | s->timing[0]; 
tsc2005.c:        return s->timing[1];
tsc2005.c:        return (s->pin_func << 14) | s->filter;
tsc2005.c:        return s->function >= 0 ? 1 << s->function : 0;
tsc2005.c:        s->aux_thr[1] = data;
tsc2005.c:        s->aux_thr[0] = data;
tsc2005.c:        s->temp_thr[1] = data;
tsc2005.c:        s->temp_thr[0] = data;
tsc2005.c:        s->host_mode = data >> 15;
tsc2005.c:        if (s->enabled != !(data & 0x4000)) {
tsc2005.c:            s->enabled = !(data & 0x4000);
tsc2005.c:                            __FUNCTION__, s->enabled ? "en" : "dis");
tsc2005.c:            if (s->busy && !s->enabled)
tsc2005.c:                qemu_del_timer(s->timer);
tsc2005.c:            s->busy &= s->enabled;
tsc2005.c:        s->nextprecision = (data >> 13) & 1;
tsc2005.c:        s->timing[0] = data & 0x1fff;
tsc2005.c:        if ((s->timing[0] >> 11) == 3)
tsc2005.c:        s->timing[1] = data & 0xf07;
tsc2005.c:        s->pin_func = (data >> 14) & 3;
tsc2005.c:        s->filter = data & 0x3fff;
tsc2005.c:        fprintf(stderr, "%s: write into read-only register %x\n",
tsc2005.c:    switch (s->pin_func) {
tsc2005.c:        pin_state = !s->pressure && !!s->dav;
tsc2005.c:        pin_state = !s->dav;
tsc2005.c:        pin_state = !s->pressure;
tsc2005.c:    if (pin_state != s->irq) {
tsc2005.c:        s->irq = pin_state;
tsc2005.c:        qemu_set_irq(s->pint, s->irq);
tsc2005.c:    switch (s->nextfunction) {
tsc2005.c:        if (!s->host_mode && s->dav)
tsc2005.c:            s->enabled = 0;
tsc2005.c:        if (!s->pressure)
tsc2005.c:        if (!s->pressure)
tsc2005.c:        if (s->dav)
tsc2005.c:            s->enabled = 0;
tsc2005.c:    if (!s->enabled || s->busy)
tsc2005.c:    s->busy = 1;
tsc2005.c:    s->precision = s->nextprecision;
tsc2005.c:    s->function = s->nextfunction;
tsc2005.c:    s->pdst = !s->pnd0;	/* Synchronised on internal clock */
tsc2005.c:    qemu_mod_timer(s->timer, expires);
tsc2005.c:    s->state = 0;
tsc2005.c:    s->pin_func = 0;
tsc2005.c:    s->enabled = 0;
tsc2005.c:    s->busy = 0;
tsc2005.c:    s->nextprecision = 0;
tsc2005.c:    s->nextfunction = 0;
tsc2005.c:    s->timing[0] = 0;
tsc2005.c:    s->timing[1] = 0;
tsc2005.c:    s->irq = 0;
tsc2005.c:    s->dav = 0;
tsc2005.c:    s->reset = 0;
tsc2005.c:    s->pdst = 1;
tsc2005.c:    s->pnd0 = 0;
tsc2005.c:    s->function = -1;
tsc2005.c:    s->temp_thr[0] = 0x000;
tsc2005.c:    s->temp_thr[1] = 0xfff;
tsc2005.c:    s->aux_thr[0] = 0x000;
tsc2005.c:    s->aux_thr[1] = 0xfff;
tsc2005.c:    switch (s->state ++) {
tsc2005.c:                s->nextfunction = (value >> 3) & 0xf;
tsc2005.c:                s->nextprecision = (value >> 2) & 1;
tsc2005.c:                if (s->enabled != !(value & 1)) {
tsc2005.c:                    s->enabled = !(value & 1);
tsc2005.c:                                    __FUNCTION__, s->enabled ? "en" : "dis");
tsc2005.c:                    if (s->busy && !s->enabled)
tsc2005.c:                        qemu_del_timer(s->timer);
tsc2005.c:                    s->busy &= s->enabled;
tsc2005.c:            s->state = 0;
tsc2005.c:            s->reg = (value >> 3) & 0xf;
tsc2005.c:            s->pnd0 = (value >> 1) & 1;
tsc2005.c:            s->command = value & 1;
tsc2005.c:            if (s->command) {
tsc2005.c:                s->data = tsc2005_read(s, s->reg);
tsc2005.c:                s->data = 0;
tsc2005.c:            s->state = 0;
tsc2005.c:        if (s->command)
tsc2005.c:            ret = (s->data >> 8) & 0xff;
tsc2005.c:            s->data |= value << 8;
tsc2005.c:        if (s->command)
tsc2005.c:            ret = s->data & 0xff;
tsc2005.c:            s->data |= value;
tsc2005.c:            tsc2005_write(s, s->reg, s->data);
tsc2005.c:        s->state = 0;
tsc2005.c:        len -= 8;
tsc2005.c:    /* Timer ticked -- a set of conversions has been finished.  */
tsc2005.c:    if (!s->busy)
tsc2005.c:    s->busy = 0;
tsc2005.c:    s->dav |= mode_regs[s->function];
tsc2005.c:    s->function = -1;
tsc2005.c:    int p = s->pressure;
tsc2005.c:        s->x = x;
tsc2005.c:        s->y = y;
tsc2005.c:    s->pressure = !!buttons_state;
tsc2005.c:    if (p != s->pressure)
tsc2005.c:    qemu_put_be16(f, s->x);
tsc2005.c:    qemu_put_be16(f, s->y);
tsc2005.c:    qemu_put_byte(f, s->pressure);
tsc2005.c:    qemu_put_byte(f, s->state);
tsc2005.c:    qemu_put_byte(f, s->reg);
tsc2005.c:    qemu_put_byte(f, s->command);
tsc2005.c:    qemu_put_byte(f, s->irq);
tsc2005.c:    qemu_put_be16s(f, &s->dav);
tsc2005.c:    qemu_put_be16s(f, &s->data);
tsc2005.c:    qemu_put_timer(f, s->timer);
tsc2005.c:    qemu_put_byte(f, s->enabled);
tsc2005.c:    qemu_put_byte(f, s->host_mode);
tsc2005.c:    qemu_put_byte(f, s->function);
tsc2005.c:    qemu_put_byte(f, s->nextfunction);
tsc2005.c:    qemu_put_byte(f, s->precision);
tsc2005.c:    qemu_put_byte(f, s->nextprecision);
tsc2005.c:    qemu_put_be16(f, s->filter);
tsc2005.c:    qemu_put_byte(f, s->pin_func);
tsc2005.c:    qemu_put_be16(f, s->timing[0]);
tsc2005.c:    qemu_put_be16(f, s->timing[1]);
tsc2005.c:    qemu_put_be16s(f, &s->temp_thr[0]);
tsc2005.c:    qemu_put_be16s(f, &s->temp_thr[1]);
tsc2005.c:    qemu_put_be16s(f, &s->aux_thr[0]);
tsc2005.c:    qemu_put_be16s(f, &s->aux_thr[1]);
tsc2005.c:    qemu_put_be32(f, s->noise);
tsc2005.c:    qemu_put_byte(f, s->reset);
tsc2005.c:    qemu_put_byte(f, s->pdst);
tsc2005.c:    qemu_put_byte(f, s->pnd0);
tsc2005.c:        qemu_put_be32(f, s->tr[i]);
tsc2005.c:    s->x = qemu_get_be16(f);
tsc2005.c:    s->y = qemu_get_be16(f);
tsc2005.c:    s->pressure = qemu_get_byte(f);
tsc2005.c:    s->state = qemu_get_byte(f);
tsc2005.c:    s->reg = qemu_get_byte(f);
tsc2005.c:    s->command = qemu_get_byte(f);
tsc2005.c:    s->irq = qemu_get_byte(f);
tsc2005.c:    qemu_get_be16s(f, &s->dav);
tsc2005.c:    qemu_get_be16s(f, &s->data);
tsc2005.c:    qemu_get_timer(f, s->timer);
tsc2005.c:    s->enabled = qemu_get_byte(f);
tsc2005.c:    s->host_mode = qemu_get_byte(f);
tsc2005.c:    s->function = qemu_get_byte(f);
tsc2005.c:    s->nextfunction = qemu_get_byte(f);
tsc2005.c:    s->precision = qemu_get_byte(f);
tsc2005.c:    s->nextprecision = qemu_get_byte(f);
tsc2005.c:    s->filter = qemu_get_be16(f);
tsc2005.c:    s->pin_func = qemu_get_byte(f);
tsc2005.c:    s->timing[0] = qemu_get_be16(f);
tsc2005.c:    s->timing[1] = qemu_get_be16(f);
tsc2005.c:    qemu_get_be16s(f, &s->temp_thr[0]);
tsc2005.c:    qemu_get_be16s(f, &s->temp_thr[1]);
tsc2005.c:    qemu_get_be16s(f, &s->aux_thr[0]);
tsc2005.c:    qemu_get_be16s(f, &s->aux_thr[1]);
tsc2005.c:    s->noise = qemu_get_be32(f);
tsc2005.c:    s->reset = qemu_get_byte(f);
tsc2005.c:    s->pdst = qemu_get_byte(f);
tsc2005.c:    s->pnd0 = qemu_get_byte(f);
tsc2005.c:        s->tr[i] = qemu_get_be32(f);
tsc2005.c:    s->busy = qemu_timer_pending(s->timer);
tsc2005.c:    s->x = 400;
tsc2005.c:    s->y = 240;
tsc2005.c:    s->pressure = 0;
tsc2005.c:    s->precision = s->nextprecision = 0;
tsc2005.c:    s->timer = qemu_new_timer(vm_clock, tsc2005_timer_tick, s);
tsc2005.c:    s->pint = pintdav;
tsc2005.c:    s->model = 0x2005;
tsc2005.c:    s->tr[0] = 0;
tsc2005.c:    s->tr[1] = 1;
tsc2005.c:    s->tr[2] = 1;
tsc2005.c:    s->tr[3] = 0;
tsc2005.c:    s->tr[4] = 1;
tsc2005.c:    s->tr[5] = 0;
tsc2005.c:    s->tr[6] = 1;
tsc2005.c:    s->tr[7] = 0;
tsc2005.c:                    "QEMU TSC2005-driven Touchscreen");
tsc2005.c:    register_savevm("tsc2005", -1, 0, tsc2005_save, tsc2005_load, s);
tsc2005.c: * from the touchscreen.  Assuming 12-bit precision was used during
tsc2005.c:    if (abs(info->a[0]) > abs(info->a[1])) {
tsc2005.c:        s->tr[0] = 0;
tsc2005.c:        s->tr[1] = -info->a[6] * info->x;
tsc2005.c:        s->tr[2] = info->a[0];
tsc2005.c:        s->tr[3] = -info->a[2] / info->a[0];
tsc2005.c:        s->tr[4] = info->a[6] * info->y;
tsc2005.c:        s->tr[5] = 0;
tsc2005.c:        s->tr[6] = info->a[4];
tsc2005.c:        s->tr[7] = -info->a[5] / info->a[4];
tsc2005.c:        s->tr[0] = info->a[6] * info->y;
tsc2005.c:        s->tr[1] = 0;
tsc2005.c:        s->tr[2] = info->a[1];
tsc2005.c:        s->tr[3] = -info->a[2] / info->a[1];
tsc2005.c:        s->tr[4] = 0;
tsc2005.c:        s->tr[5] = -info->a[6] * info->x;
tsc2005.c:        s->tr[6] = info->a[3];
tsc2005.c:        s->tr[7] = -info->a[5] / info->a[3];
tsc2005.c:    s->tr[0] >>= 11;
tsc2005.c:    s->tr[1] >>= 11;
tsc2005.c:    s->tr[3] <<= 4;
tsc2005.c:    s->tr[4] >>= 11;
tsc2005.c:    s->tr[5] >>= 11;
tsc2005.c:    s->tr[7] <<= 4;
tsc210x.c:#include "qemu-timer.h"
tsc210x.c:#define TSC_CUT_RESOLUTION(value, p)	((value) >> (16 - resolution[p]))
tsc210x.c:    0x0000,	/* X+, X- drivers */
tsc210x.c:    0x0000,	/* Y+, Y- drivers */
tsc210x.c:    0x0000,	/* Y+, X- drivers */
tsc210x.c:    ((s->y * s->tr[0] - s->x * s->tr[1]) / s->tr[2] + s->tr[3])
tsc210x.c:    ((s->y * s->tr[4] - s->x * s->tr[5]) / s->tr[6] + s->tr[7])
tsc210x.c:    ((400 - ((s)->x >> 7) + ((s)->pressure << 10)) << 4)
tsc210x.c:    ((4000 + ((s)->y >> 7) - ((s)->pressure << 10)) << 4)
tsc210x.c:    s->state = 0;
tsc210x.c:    s->pin_func = 2;
tsc210x.c:    s->enabled = 0;
tsc210x.c:    s->busy = 0;
tsc210x.c:    s->nextfunction = 0;
tsc210x.c:    s->ref = 0;
tsc210x.c:    s->timing = 0;
tsc210x.c:    s->irq = 0;
tsc210x.c:    s->dav = 0;
tsc210x.c:    s->audio_ctrl1 = 0x0000;
tsc210x.c:    s->audio_ctrl2 = 0x4410;
tsc210x.c:    s->audio_ctrl3 = 0x0000;
tsc210x.c:    s->pll[0] = 0x1004;
tsc210x.c:    s->pll[1] = 0x0000;
tsc210x.c:    s->pll[2] = 0x1fff;
tsc210x.c:    s->volume = 0xffff;
tsc210x.c:    s->dac_power = 0x8540;
tsc210x.c:    s->softstep = 1;
tsc210x.c:    s->volume_change = 0;
tsc210x.c:    s->powerdown = 0;
tsc210x.c:    s->filter_data[0x00] = 0x6be3;
tsc210x.c:    s->filter_data[0x01] = 0x9666;
tsc210x.c:    s->filter_data[0x02] = 0x675d;
tsc210x.c:    s->filter_data[0x03] = 0x6be3;
tsc210x.c:    s->filter_data[0x04] = 0x9666;
tsc210x.c:    s->filter_data[0x05] = 0x675d;
tsc210x.c:    s->filter_data[0x06] = 0x7d83;
tsc210x.c:    s->filter_data[0x07] = 0x84ee;
tsc210x.c:    s->filter_data[0x08] = 0x7d83;
tsc210x.c:    s->filter_data[0x09] = 0x84ee;
tsc210x.c:    s->filter_data[0x0a] = 0x6be3;
tsc210x.c:    s->filter_data[0x0b] = 0x9666;
tsc210x.c:    s->filter_data[0x0c] = 0x675d;
tsc210x.c:    s->filter_data[0x0d] = 0x6be3;
tsc210x.c:    s->filter_data[0x0e] = 0x9666;
tsc210x.c:    s->filter_data[0x0f] = 0x675d;
tsc210x.c:    s->filter_data[0x10] = 0x7d83;
tsc210x.c:    s->filter_data[0x11] = 0x84ee;
tsc210x.c:    s->filter_data[0x12] = 0x7d83;
tsc210x.c:    s->filter_data[0x13] = 0x84ee;
tsc210x.c:    s->i2s_tx_rate = 0;
tsc210x.c:    s->i2s_rx_rate = 0;
tsc210x.c:    s->kb.scan = 1;
tsc210x.c:    s->kb.debounce = 0;
tsc210x.c:    s->kb.mask = 0x0000;
tsc210x.c:    s->kb.mode = 3;
tsc210x.c:    s->kb.intr = 0;
tsc210x.c:    qemu_set_irq(s->pint, !s->irq);
tsc210x.c:    qemu_set_irq(s->davint, !s->dav);
tsc210x.c:    qemu_irq_raise(s->kbint);
tsc210x.c:    uint8_t *data = s->codec.out.fifo + s->codec.out.start;
tsc210x.c:        data += AUD_write(s->dac_voice[0], data, end - data) ?: (end - data);
tsc210x.c:    s->codec.out.len -= len;
tsc210x.c:    if (s->codec.out.len)
tsc210x.c:        memmove(s->codec.out.fifo, end, s->codec.out.len);
tsc210x.c:    s->codec.out.start = 0;
tsc210x.c:    if (s->codec.out.len >= free_b) {
tsc210x.c:    s->codec.out.size = MIN(free_b, 16384);
tsc210x.c:    qemu_irq_raise(s->codec.tx_start);
tsc210x.c:    s->codec.tx_rate = 0;
tsc210x.c:    s->codec.rx_rate = 0;
tsc210x.c:    if (s->dac_power & (1 << 15))				/* PWDNC */
tsc210x.c:    for (rate = tsc2102_rates; rate->rate; rate ++)
tsc210x.c:        if (rate->dsor == (s->audio_ctrl1 & 0x3f) &&		/* DACFS */
tsc210x.c:                        rate->fsref == ((s->audio_ctrl3 >> 13) & 1))/* REFFS */
tsc210x.c:    if (!rate->rate) {
tsc210x.c:    s->codec.tx_rate = rate->rate;
tsc210x.c:    if (s->dac_voice[0]) {
tsc210x.c:        tsc210x_out_flush(s, s->codec.out.len);
tsc210x.c:        s->codec.out.size = 0;
tsc210x.c:        AUD_set_active_out(s->dac_voice[0], 0);
tsc210x.c:        AUD_close_out(&s->card, s->dac_voice[0]);
tsc210x.c:        s->dac_voice[0] = NULL;
tsc210x.c:    s->codec.cts = 0;
tsc210x.c:            (~s->dac_power & (1 << 15)) &&			/* PWDNC */
tsc210x.c:            (~s->dac_power & (1 << 10));			/* DAPWDN */
tsc210x.c:    if (!enable || !s->codec.tx_rate)
tsc210x.c:    fmt.freq = s->codec.tx_rate;
tsc210x.c:    s->dac_voice[0] = AUD_open_out(&s->card, s->dac_voice[0],
tsc210x.c:    if (s->dac_voice[0]) {
tsc210x.c:        s->codec.cts = 1;
tsc210x.c:        AUD_set_active_out(s->dac_voice[0], 1);
tsc210x.c:        s->dav &= 0xfbff;
tsc210x.c:        return TSC_CUT_RESOLUTION(X_TRANSFORM(s), s->precision) +
tsc210x.c:                (s->noise & 3);
tsc210x.c:        s->noise ++;
tsc210x.c:        s->dav &= 0xfdff;
tsc210x.c:        return TSC_CUT_RESOLUTION(Y_TRANSFORM(s), s->precision) ^
tsc210x.c:                (s->noise & 3);
tsc210x.c:        s->dav &= 0xfeff;
tsc210x.c:        return TSC_CUT_RESOLUTION(Z1_TRANSFORM(s), s->precision) -
tsc210x.c:                (s->noise & 3);
tsc210x.c:        s->dav &= 0xff7f;
tsc210x.c:        return TSC_CUT_RESOLUTION(Z2_TRANSFORM(s), s->precision) |
tsc210x.c:                (s->noise & 3);
tsc210x.c:        if ((s->model & 0xff00) == 0x2300) {
tsc210x.c:            if (s->kb.intr && (s->kb.mode & 2)) {
tsc210x.c:                s->kb.intr = 0;
tsc210x.c:                qemu_irq_raise(s->kbint);
tsc210x.c:            return s->kb.down;
tsc210x.c:        s->dav &= 0xffbf;
tsc210x.c:        return TSC_CUT_RESOLUTION(BAT1_VAL, s->precision) +
tsc210x.c:                (s->noise & 6);
tsc210x.c:        s->dav &= 0xffdf;
tsc210x.c:        return TSC_CUT_RESOLUTION(BAT2_VAL, s->precision);
tsc210x.c:        s->dav &= 0xffef;
tsc210x.c:        return TSC_CUT_RESOLUTION(AUX1_VAL, s->precision);
tsc210x.c:        s->dav &= 0xfff7;
tsc210x.c:        s->dav &= 0xfffb;
tsc210x.c:        return TSC_CUT_RESOLUTION(TEMP1_VAL, s->precision) -
tsc210x.c:                (s->noise & 5);
tsc210x.c:        s->dav &= 0xfffd;
tsc210x.c:        return TSC_CUT_RESOLUTION(TEMP2_VAL, s->precision) ^
tsc210x.c:                (s->noise & 3);
tsc210x.c:        s->dav &= 0xfffe;
tsc210x.c:        return (s->pressure << 15) | ((!s->busy) << 14) |
tsc210x.c:                (s->nextfunction << 10) | (s->nextprecision << 8) | s->filter; 
tsc210x.c:        if ((s->model & 0xff00) == 0x2100)
tsc210x.c:            return (s->pin_func << 14) | ((!s->enabled) << 13) |
tsc210x.c:                    (s->host_mode << 12) | ((!!s->dav) << 11) | s->dav;
tsc210x.c:            return (s->kb.intr << 15) | ((s->kb.scan || !s->kb.down) << 14) |
tsc210x.c:                    (s->kb.debounce << 11);
tsc210x.c:        if ((s->model & 0xff00) == 0x2300)
tsc210x.c:            return s->dac_power & 0x8000;
tsc210x.c:        return s->ref;
tsc210x.c:        return s->timing;
tsc210x.c:        if ((s->model & 0xff00) == 0x2100)
tsc210x.c:        return ((!s->dav) << 15) | ((s->kb.mode & 1) << 14) | s->pll[2];
tsc210x.c:        if ((s->model & 0xff00) == 0x2100)
tsc210x.c:        return s->kb.mask;
tsc210x.c:        return s->audio_ctrl1;
tsc210x.c:        return s->volume;
tsc210x.c:        if (s->softstep && !(s->dac_power & (1 << 10))) {
tsc210x.c:                            s->volume_change + TSC_SOFTSTEP_DELAY);
tsc210x.c:                            s->volume_change + TSC_SOFTSTEP_DELAY);
tsc210x.c:        return s->audio_ctrl2 | (l_ch << 3) | (r_ch << 2);
tsc210x.c:        return 0x2aa0 | s->dac_power |
tsc210x.c:                (((s->dac_power & (1 << 10)) &&
tsc210x.c:                   s->powerdown + TSC_POWEROFF_DELAY)) << 6);
tsc210x.c:        val = s->audio_ctrl3 | 0x0001;
tsc210x.c:        s->audio_ctrl3 &= 0xff3f;
tsc210x.c:        return s->filter_data[reg - 0x07];
tsc210x.c:        return s->pll[0];
tsc210x.c:        return s->pll[1];
tsc210x.c:        return (!s->softstep) << 14;
tsc210x.c:        s->host_mode = value >> 15;
tsc210x.c:        s->enabled = !(value & 0x4000);
tsc210x.c:        if (s->busy && !s->enabled)
tsc210x.c:            qemu_del_timer(s->timer);
tsc210x.c:        s->busy &= s->enabled;
tsc210x.c:        s->nextfunction = (value >> 10) & 0xf;
tsc210x.c:        s->nextprecision = (value >> 8) & 3;
tsc210x.c:        s->filter = value & 0xff;
tsc210x.c:        if ((s->model & 0xff00) == 0x2100)
tsc210x.c:            s->pin_func = value >> 14;
tsc210x.c:            s->kb.scan = (value >> 14) & 1;
tsc210x.c:            s->kb.debounce = (value >> 11) & 7;
tsc210x.c:            if (s->kb.intr && s->kb.scan) {
tsc210x.c:                s->kb.intr = 0;
tsc210x.c:                qemu_irq_raise(s->kbint);
tsc210x.c:        if ((s->model & 0xff00) == 0x2300) {
tsc210x.c:            s->dac_power &= 0x7fff;
tsc210x.c:            s->dac_power |= 0x8000 & value;
tsc210x.c:        s->ref = value & 0x1f;
tsc210x.c:            if (s->busy)
tsc210x.c:                qemu_del_timer(s->timer);
tsc210x.c:        s->timing = value & 0x3f;
tsc210x.c:        if ((s->model & 0xff00) == 0x2100)
tsc210x.c:        s->kb.mode = value >> 14;
tsc210x.c:        s->pll[2] = value & 0x3ffff;
tsc210x.c:        if ((s->model & 0xff00) == 0x2100)
tsc210x.c:        s->kb.mask = value;
tsc210x.c:        s->audio_ctrl1 = value & 0x0f3f;
tsc210x.c:        s->volume = value;
tsc210x.c:        s->volume_change = qemu_get_clock(vm_clock);
tsc210x.c:        s->audio_ctrl2 = value & 0xf7f2;
tsc210x.c:        if ((value & ~s->dac_power) & (1 << 10))
tsc210x.c:            s->powerdown = qemu_get_clock(vm_clock);
tsc210x.c:        s->dac_power = value & 0x9543;
tsc210x.c:        s->audio_ctrl3 &= 0x00c0;
tsc210x.c:        s->audio_ctrl3 |= value & 0xf800;
tsc210x.c:        s->filter_data[reg - 0x07] = value;
tsc210x.c:        s->pll[0] = value & 0xfffc;
tsc210x.c:        s->pll[1] = value & 0xfffc;
tsc210x.c:        s->softstep = !(value & 0x4000);
tsc210x.c:    switch (s->pin_func) {
tsc210x.c:        pin_state = s->pressure;
tsc210x.c:        pin_state = !!s->dav;
tsc210x.c:        pin_state = s->pressure && !s->dav;
tsc210x.c:    if (!s->enabled)
tsc210x.c:    if (pin_state != s->irq) {
tsc210x.c:        s->irq = pin_state;
tsc210x.c:        qemu_set_irq(s->pint, !s->irq);
tsc210x.c:    switch (s->nextfunction) {
tsc210x.c:        if (!s->pressure)
tsc210x.c:        if (!s->pressure)
tsc210x.c:        if (s->dav)
tsc210x.c:            s->enabled = 0;
tsc210x.c:    if (!s->enabled || s->busy || s->dav)
tsc210x.c:    s->busy = 1;
tsc210x.c:    s->precision = s->nextprecision;
tsc210x.c:    s->function = s->nextfunction;
tsc210x.c:    qemu_mod_timer(s->timer, expires);
tsc210x.c:    if (!s->command)
tsc210x.c:    switch (s->page) {
tsc210x.c:        ret = tsc2102_data_register_read(s, s->offset);
tsc210x.c:        if (!s->dav)
tsc210x.c:            qemu_irq_raise(s->davint);
tsc210x.c:        ret = tsc2102_control_register_read(s, s->offset);
tsc210x.c:        ret = tsc2102_audio_register_read(s, s->offset);
tsc210x.c:    s->offset ++;
tsc210x.c:    s->state = 0;
tsc210x.c:     * This is a two-state state machine for reading
tsc210x.c:    if (!s->state) {
tsc210x.c:        s->command = value >> 15;
tsc210x.c:        s->page = (value >> 11) & 0x0f;
tsc210x.c:        s->offset = (value >> 5) & 0x3f;
tsc210x.c:        s->state = 1;
tsc210x.c:        if (s->command)
tsc210x.c:            switch (s->page) {
tsc210x.c:                tsc2102_data_register_write(s, s->offset, value);
tsc210x.c:                tsc2102_control_register_write(s, s->offset, value);
tsc210x.c:                tsc2102_audio_register_write(s, s->offset, value);
tsc210x.c:        s->state = 0;
tsc210x.c:    /* TODO: sequential reads etc - how do we make sure the host doesn't
tsc210x.c:    if (!value || (s->state && s->command))
tsc210x.c:    if (value || (s->state && !s->command))
tsc210x.c:    /* Timer ticked -- a set of conversions has been finished.  */
tsc210x.c:    if (!s->busy)
tsc210x.c:    s->busy = 0;
tsc210x.c:    s->dav |= mode_regs[s->function];
tsc210x.c:    qemu_irq_lower(s->davint);
tsc210x.c:    int p = s->pressure;
tsc210x.c:        s->x = x;
tsc210x.c:        s->y = y;
tsc210x.c:    s->pressure = !!buttons_state;
tsc210x.c:    if (p != s->pressure)
tsc210x.c:    if (s->dac_voice[0])
tsc210x.c:        tsc210x_out_flush(s, s->codec.out.len);
tsc210x.c:        s->codec.out.len = 0;
tsc210x.c:    s->i2s_tx_rate = out;
tsc210x.c:    s->i2s_rx_rate = in;
tsc210x.c:    qemu_put_be16(f, s->x);
tsc210x.c:    qemu_put_be16(f, s->y);
tsc210x.c:    qemu_put_byte(f, s->pressure);
tsc210x.c:    qemu_put_byte(f, s->state);
tsc210x.c:    qemu_put_byte(f, s->page);
tsc210x.c:    qemu_put_byte(f, s->offset);
tsc210x.c:    qemu_put_byte(f, s->command);
tsc210x.c:    qemu_put_byte(f, s->irq);
tsc210x.c:    qemu_put_be16s(f, &s->dav);
tsc210x.c:    qemu_put_timer(f, s->timer);
tsc210x.c:    qemu_put_byte(f, s->enabled);
tsc210x.c:    qemu_put_byte(f, s->host_mode);
tsc210x.c:    qemu_put_byte(f, s->function);
tsc210x.c:    qemu_put_byte(f, s->nextfunction);
tsc210x.c:    qemu_put_byte(f, s->precision);
tsc210x.c:    qemu_put_byte(f, s->nextprecision);
tsc210x.c:    qemu_put_byte(f, s->filter);
tsc210x.c:    qemu_put_byte(f, s->pin_func);
tsc210x.c:    qemu_put_byte(f, s->ref);
tsc210x.c:    qemu_put_byte(f, s->timing);
tsc210x.c:    qemu_put_be32(f, s->noise);
tsc210x.c:    qemu_put_be16s(f, &s->audio_ctrl1);
tsc210x.c:    qemu_put_be16s(f, &s->audio_ctrl2);
tsc210x.c:    qemu_put_be16s(f, &s->audio_ctrl3);
tsc210x.c:    qemu_put_be16s(f, &s->pll[0]);
tsc210x.c:    qemu_put_be16s(f, &s->pll[1]);
tsc210x.c:    qemu_put_be16s(f, &s->volume);
tsc210x.c:    qemu_put_sbe64(f, (s->volume_change - now));
tsc210x.c:    qemu_put_sbe64(f, (s->powerdown - now));
tsc210x.c:    qemu_put_byte(f, s->softstep);
tsc210x.c:    qemu_put_be16s(f, &s->dac_power);
tsc210x.c:        qemu_put_be16s(f, &s->filter_data[i]);
tsc210x.c:    s->x = qemu_get_be16(f);
tsc210x.c:    s->y = qemu_get_be16(f);
tsc210x.c:    s->pressure = qemu_get_byte(f);
tsc210x.c:    s->state = qemu_get_byte(f);
tsc210x.c:    s->page = qemu_get_byte(f);
tsc210x.c:    s->offset = qemu_get_byte(f);
tsc210x.c:    s->command = qemu_get_byte(f);
tsc210x.c:    s->irq = qemu_get_byte(f);
tsc210x.c:    qemu_get_be16s(f, &s->dav);
tsc210x.c:    qemu_get_timer(f, s->timer);
tsc210x.c:    s->enabled = qemu_get_byte(f);
tsc210x.c:    s->host_mode = qemu_get_byte(f);
tsc210x.c:    s->function = qemu_get_byte(f);
tsc210x.c:    s->nextfunction = qemu_get_byte(f);
tsc210x.c:    s->precision = qemu_get_byte(f);
tsc210x.c:    s->nextprecision = qemu_get_byte(f);
tsc210x.c:    s->filter = qemu_get_byte(f);
tsc210x.c:    s->pin_func = qemu_get_byte(f);
tsc210x.c:    s->ref = qemu_get_byte(f);
tsc210x.c:    s->timing = qemu_get_byte(f);
tsc210x.c:    s->noise = qemu_get_be32(f);
tsc210x.c:    qemu_get_be16s(f, &s->audio_ctrl1);
tsc210x.c:    qemu_get_be16s(f, &s->audio_ctrl2);
tsc210x.c:    qemu_get_be16s(f, &s->audio_ctrl3);
tsc210x.c:    qemu_get_be16s(f, &s->pll[0]);
tsc210x.c:    qemu_get_be16s(f, &s->pll[1]);
tsc210x.c:    qemu_get_be16s(f, &s->volume);
tsc210x.c:    s->volume_change = qemu_get_sbe64(f) + now;
tsc210x.c:    s->powerdown = qemu_get_sbe64(f) + now;
tsc210x.c:    s->softstep = qemu_get_byte(f);
tsc210x.c:    qemu_get_be16s(f, &s->dac_power);
tsc210x.c:        qemu_get_be16s(f, &s->filter_data[i]);
tsc210x.c:    s->busy = qemu_timer_pending(s->timer);
tsc210x.c:    qemu_set_irq(s->pint, !s->irq);
tsc210x.c:    qemu_set_irq(s->davint, !s->dav);
tsc210x.c:    s->x = 160;
tsc210x.c:    s->y = 160;
tsc210x.c:    s->pressure = 0;
tsc210x.c:    s->precision = s->nextprecision = 0;
tsc210x.c:    s->timer = qemu_new_timer(vm_clock, tsc210x_timer_tick, s);
tsc210x.c:    s->pint = pint;
tsc210x.c:    s->model = 0x2102;
tsc210x.c:    s->name = "tsc2102";
tsc210x.c:    s->tr[0] = 0;
tsc210x.c:    s->tr[1] = 1;
tsc210x.c:    s->tr[2] = 1;
tsc210x.c:    s->tr[3] = 0;
tsc210x.c:    s->tr[4] = 1;
tsc210x.c:    s->tr[5] = 0;
tsc210x.c:    s->tr[6] = 1;
tsc210x.c:    s->tr[7] = 0;
tsc210x.c:    s->chip.opaque = s;
tsc210x.c:    s->chip.send = (void *) tsc210x_write;
tsc210x.c:    s->chip.receive = (void *) tsc210x_read;
tsc210x.c:    s->codec.opaque = s;
tsc210x.c:    s->codec.tx_swallow = (void *) tsc210x_i2s_swallow;
tsc210x.c:    s->codec.set_rate = (void *) tsc210x_i2s_set_rate;
tsc210x.c:    s->codec.in.fifo = s->in_fifo;
tsc210x.c:    s->codec.out.fifo = s->out_fifo;
tsc210x.c:                    "QEMU TSC2102-driven Touchscreen");
tsc210x.c:    AUD_register_card(s->name, &s->card);
tsc210x.c:    register_savevm(s->name, -1, 0,
tsc210x.c:    return &s->chip;
tsc210x.c:    s->x = 400;
tsc210x.c:    s->y = 240;
tsc210x.c:    s->pressure = 0;
tsc210x.c:    s->precision = s->nextprecision = 0;
tsc210x.c:    s->timer = qemu_new_timer(vm_clock, tsc210x_timer_tick, s);
tsc210x.c:    s->pint = penirq;
tsc210x.c:    s->kbint = kbirq;
tsc210x.c:    s->davint = dav;
tsc210x.c:    s->model = 0x2301;
tsc210x.c:    s->name = "tsc2301";
tsc210x.c:    s->tr[0] = 0;
tsc210x.c:    s->tr[1] = 1;
tsc210x.c:    s->tr[2] = 1;
tsc210x.c:    s->tr[3] = 0;
tsc210x.c:    s->tr[4] = 1;
tsc210x.c:    s->tr[5] = 0;
tsc210x.c:    s->tr[6] = 1;
tsc210x.c:    s->tr[7] = 0;
tsc210x.c:    s->chip.opaque = s;
tsc210x.c:    s->chip.send = (void *) tsc210x_write;
tsc210x.c:    s->chip.receive = (void *) tsc210x_read;
tsc210x.c:    s->codec.opaque = s;
tsc210x.c:    s->codec.tx_swallow = (void *) tsc210x_i2s_swallow;
tsc210x.c:    s->codec.set_rate = (void *) tsc210x_i2s_set_rate;
tsc210x.c:    s->codec.in.fifo = s->in_fifo;
tsc210x.c:    s->codec.out.fifo = s->out_fifo;
tsc210x.c:                    "QEMU TSC2301-driven Touchscreen");
tsc210x.c:    AUD_register_card(s->name, &s->card);
tsc210x.c:    register_savevm(s->name, -1, 0, tsc210x_save, tsc210x_load, s);
tsc210x.c:    return &s->chip;
tsc210x.c:    TSC210xState *s = (TSC210xState *) chip->opaque;
tsc210x.c:    return &s->codec;
tsc210x.c: * from the touchscreen.  Assuming 12-bit precision was used during
tsc210x.c:    TSC210xState *s = (TSC210xState *) chip->opaque;
tsc210x.c:    ltr[0] = (int64_t) info->a[1] * info->y;
tsc210x.c:    ltr[1] = (int64_t) info->a[4] * info->x;
tsc210x.c:    ltr[2] = (int64_t) info->a[1] * info->a[3] -
tsc210x.c:            (int64_t) info->a[4] * info->a[0];
tsc210x.c:    ltr[3] = (int64_t) info->a[2] * info->a[4] -
tsc210x.c:            (int64_t) info->a[5] * info->a[1];
tsc210x.c:    ltr[4] = (int64_t) info->a[0] * info->y;
tsc210x.c:    ltr[5] = (int64_t) info->a[3] * info->x;
tsc210x.c:    ltr[6] = (int64_t) info->a[4] * info->a[0] -
tsc210x.c:            (int64_t) info->a[1] * info->a[3];
tsc210x.c:    ltr[7] = (int64_t) info->a[2] * info->a[3] -
tsc210x.c:            (int64_t) info->a[5] * info->a[0];
tsc210x.c:    s->tr[0] = ltr[0] >> 11;
tsc210x.c:    s->tr[1] = ltr[1] >> 11;
tsc210x.c:    s->tr[2] = muldiv64(ltr[2], 1, info->a[6]);
tsc210x.c:    s->tr[3] = muldiv64(ltr[3], 1 << 4, ltr[2]);
tsc210x.c:    s->tr[4] = ltr[4] >> 11;
tsc210x.c:    s->tr[5] = ltr[5] >> 11;
tsc210x.c:    s->tr[6] = muldiv64(ltr[6], 1, info->a[6]);
tsc210x.c:    s->tr[7] = muldiv64(ltr[7], 1 << 4, ltr[6]);
tsc210x.c:    if (abs(info->a[0]) > abs(info->a[1])) {
tsc210x.c:        s->tr[0] = 0;
tsc210x.c:        s->tr[1] = -info->a[6] * info->x;
tsc210x.c:        s->tr[2] = info->a[0];
tsc210x.c:        s->tr[3] = -info->a[2] / info->a[0];
tsc210x.c:        s->tr[4] = info->a[6] * info->y;
tsc210x.c:        s->tr[5] = 0;
tsc210x.c:        s->tr[6] = info->a[4];
tsc210x.c:        s->tr[7] = -info->a[5] / info->a[4];
tsc210x.c:        s->tr[0] = info->a[6] * info->y;
tsc210x.c:        s->tr[1] = 0;
tsc210x.c:        s->tr[2] = info->a[1];
tsc210x.c:        s->tr[3] = -info->a[2] / info->a[1];
tsc210x.c:        s->tr[4] = 0;
tsc210x.c:        s->tr[5] = -info->a[6] * info->x;
tsc210x.c:        s->tr[6] = info->a[3];
tsc210x.c:        s->tr[7] = -info->a[5] / info->a[3];
tsc210x.c:    s->tr[0] >>= 11;
tsc210x.c:    s->tr[1] >>= 11;
tsc210x.c:    s->tr[3] <<= 4;
tsc210x.c:    s->tr[4] >>= 11;
tsc210x.c:    s->tr[5] >>= 11;
tsc210x.c:    s->tr[7] <<= 4;
tsc210x.c:    TSC210xState *s = (TSC210xState *) chip->opaque;
tsc210x.c:        s->kb.down |= 1 << key;
tsc210x.c:        s->kb.down &= ~(1 << key);
tsc210x.c:    if (down && (s->kb.down & ~s->kb.mask) && !s->kb.intr) {
tsc210x.c:        s->kb.intr = 1;
tsc210x.c:        qemu_irq_lower(s->kbint);
tsc210x.c:    } else if (s->kb.intr && !(s->kb.down & ~s->kb.mask) &&
tsc210x.c:                    !(s->kb.mode & 1)) {
tsc210x.c:        s->kb.intr = 0;
tsc210x.c:        qemu_irq_raise(s->kbint);
tusb6010.c: * Based on reverse-engineering of a linux driver.
tusb6010.c:#include "qemu-common.h"
tusb6010.c:#include "qemu-timer.h"
tusb6010.c:/* FIFO registers, 32-bit.  */
tusb6010.c:/* Device System & Control registers, 32-bit.  */
tusb6010.c:/* Wake-up source clear and mask registers */
tusb6010.c:    return s->iomemtype[0];
tusb6010.c:    return s->iomemtype[1];
tusb6010.c:    if (s->control_config & TUSB_INT_CTRL_CONF_INT_POLARITY)
tusb6010.c:        qemu_set_irq(s->irq, s->intr & ~s->mask & s->intr_ok);
tusb6010.c:        qemu_set_irq(s->irq, (!(s->intr & ~s->mask)) & s->intr_ok);
tusb6010.c:    if (s->usbip_intr & 0x0000ffff & ~s->usbip_mask)
tusb6010.c:        s->intr |= TUSB_INT_SRC_USB_IP_TX;
tusb6010.c:        s->intr &= ~TUSB_INT_SRC_USB_IP_TX;
tusb6010.c:    if (s->usbip_intr & 0xffff0000 & ~s->usbip_mask)
tusb6010.c:        s->intr |= TUSB_INT_SRC_USB_IP_RX;
tusb6010.c:        s->intr &= ~TUSB_INT_SRC_USB_IP_RX;
tusb6010.c:    if (s->dma_intr & ~s->dma_mask)
tusb6010.c:        s->intr |= TUSB_INT_SRC_TXRX_DMA_DONE;
tusb6010.c:        s->intr &= ~TUSB_INT_SRC_TXRX_DMA_DONE;
tusb6010.c:        return musb_read[0](s->musb, addr & 0x1ff);
tusb6010.c:        return musb_read[0](s->musb, 0x20 + ((addr >> 3) & 0x3c));
tusb6010.c:        return musb_read[1](s->musb, addr & 0x1ff);
tusb6010.c:        return musb_read[1](s->musb, 0x20 + ((addr >> 3) & 0x3c));
tusb6010.c:        return s->dev_config;
tusb6010.c:        return musb_read[2](s->musb, offset & 0x1ff);
tusb6010.c:        return musb_read[2](s->musb, 0x20 + ((addr >> 3) & 0x3c));
tusb6010.c:        ret = s->otg_status;
tusb6010.c:        if (!(s->prcm_mngmt & TUSB_PRCM_MNGMT_OTG_VBUS_DET_EN))
tusb6010.c:        return s->otg_timer_val;
tusb6010.c:        return s->prcm_config;
tusb6010.c:        return s->prcm_mngmt;
tusb6010.c:        return s->wkup_mask;
tusb6010.c:        return s->pullup[0];
tusb6010.c:        return s->pullup[1];
tusb6010.c:        return s->control_config;
tusb6010.c:        return s->usbip_intr;
tusb6010.c:        return s->usbip_mask;
tusb6010.c:        return s->dma_intr;
tusb6010.c:        return s->dma_mask;
tusb6010.c:        return s->gpio_intr;
tusb6010.c:        return s->gpio_mask;
tusb6010.c:        return s->intr;
tusb6010.c:        return s->mask;
tusb6010.c:        return s->gpio_config;
tusb6010.c:        return s->dma_config;
tusb6010.c:        return s->ep0_config;
tusb6010.c:        epnum = (offset - TUSB_EP_IN_SIZE) >> 2;
tusb6010.c:        return s->tx_config[epnum];
tusb6010.c:        return s->dma_map;
tusb6010.c:        epnum = (offset - TUSB_EP_OUT_SIZE) >> 2;
tusb6010.c:        return s->rx_config[epnum];
tusb6010.c:        epnum = (offset - TUSB_EP_MAX_PACKET_SIZE_OFFSET) >> 2;
tusb6010.c:        return s->scratch;
tusb6010.c:        return s->test_reset;
tusb6010.c:        musb_write[0](s->musb, addr & 0x1ff, value);
tusb6010.c:        musb_write[0](s->musb, 0x20 + ((addr >> 3) & 0x3c), value);
tusb6010.c:        musb_write[1](s->musb, addr & 0x1ff, value);
tusb6010.c:        musb_write[1](s->musb, 0x20 + ((addr >> 3) & 0x3c), value);
tusb6010.c:        musb_write[2](s->musb, offset & 0x1ff, value);
tusb6010.c:        musb_write[2](s->musb, 0x20 + ((addr >> 3) & 0x3c), value);
tusb6010.c:        s->dev_config = value;
tusb6010.c:        s->host_mode = (value & TUSB_DEV_CONF_USB_HOST_MODE);
tusb6010.c:        s->otg_timer_val = value;
tusb6010.c:            qemu_mod_timer(s->otg_timer, qemu_get_clock(vm_clock) +
tusb6010.c:            qemu_del_timer(s->otg_timer);
tusb6010.c:        s->prcm_config = value;
tusb6010.c:        s->prcm_mngmt = value;
tusb6010.c:        s->wkup_mask = value;
tusb6010.c:        s->pullup[0] = value;
tusb6010.c:        s->pullup[1] = value;
tusb6010.c:        s->control_config = value;
tusb6010.c:        s->usbip_intr |= value;
tusb6010.c:        s->usbip_intr &= ~value;
tusb6010.c:        musb_core_intr_clear(s->musb, ~value);
tusb6010.c:        s->usbip_mask = value;
tusb6010.c:        s->dma_intr |= value;
tusb6010.c:        s->dma_intr &= ~value;
tusb6010.c:        s->dma_mask = value;
tusb6010.c:        s->gpio_intr |= value;
tusb6010.c:        s->gpio_intr &= ~value;
tusb6010.c:        s->gpio_mask = value;
tusb6010.c:        s->intr |= value;
tusb6010.c:        s->intr &= ~value;
tusb6010.c:        s->mask = value;
tusb6010.c:        s->gpio_config = value;
tusb6010.c:        s->dma_config = value;
tusb6010.c:        s->ep0_config = value & 0x1ff;
tusb6010.c:        musb_set_size(s->musb, 0, TUSB_EP0_CONFIG_XFR_SIZE(value),
tusb6010.c:        epnum = (offset - TUSB_EP_IN_SIZE) >> 2;
tusb6010.c:        s->tx_config[epnum] = value;
tusb6010.c:        musb_set_size(s->musb, epnum + 1, TUSB_EP_CONFIG_XFR_SIZE(value), 1);
tusb6010.c:        s->dma_map = value;
tusb6010.c:        epnum = (offset - TUSB_EP_OUT_SIZE) >> 2;
tusb6010.c:        s->rx_config[epnum] = value;
tusb6010.c:        musb_set_size(s->musb, epnum + 1, TUSB_EP_CONFIG_XFR_SIZE(value), 0);
tusb6010.c:        epnum = (offset - TUSB_EP_MAX_PACKET_SIZE_OFFSET) >> 2;
tusb6010.c:        s->scratch = value;
tusb6010.c:        s->test_reset = value;
tusb6010.c:    s->otg_timer_val = 0;
tusb6010.c:    s->intr |= TUSB_INT_SRC_OTG_TIMEOUT;
tusb6010.c:    if (s->power) {
tusb6010.c:        s->intr_ok = ~0;
tusb6010.c:    uint16_t otg_status = s->otg_status;
tusb6010.c:        if (s->otg_status != otg_status) {
tusb6010.c:            s->otg_status = otg_status;
tusb6010.c:            s->intr |= TUSB_INT_SRC_VBUS_SENSE_CHNG;
tusb6010.c:            s->otg_status |= TUSB_DEV_OTG_STAT_SESS_VALID;
tusb6010.c:            s->otg_status &= ~TUSB_DEV_OTG_STAT_SESS_END;
tusb6010.c:            s->otg_status &= ~TUSB_DEV_OTG_STAT_SESS_VALID;
tusb6010.c:            s->otg_status |= TUSB_DEV_OTG_STAT_SESS_END;
tusb6010.c:        s->usbip_intr = musb_core_intr_get(s->musb);
tusb6010.c:            s->intr |= 1 << source;
tusb6010.c:            s->intr &= ~(1 << source);
tusb6010.c:    s->test_reset = TUSB_PROD_TEST_RESET_VAL;
tusb6010.c:    s->host_mode = 0;
tusb6010.c:    s->dev_config = 0;
tusb6010.c:    s->otg_status = 0;	/* !TUSB_DEV_OTG_STAT_ID_STATUS means host mode */
tusb6010.c:    s->power = 0;
tusb6010.c:    s->mask = 0xffffffff;
tusb6010.c:    s->intr = 0x00000000;
tusb6010.c:    s->otg_timer_val = 0;
tusb6010.c:    s->iomemtype[1] = cpu_register_io_memory(tusb_async_readfn,
tusb6010.c:    s->irq = intr;
tusb6010.c:    s->otg_timer = qemu_new_timer(vm_clock, tusb_otg_tick, s);
tusb6010.c:    s->pwr_timer = qemu_new_timer(vm_clock, tusb_power_tick, s);
tusb6010.c:    s->musb = musb_init(qemu_allocate_irqs(tusb_musb_core_intr, s,
tusb6010.c:        s->power = 0;
tusb6010.c:    else if (!s->power && on) {
tusb6010.c:        s->power = 1;
tusb6010.c:        s->intr_ok = 0;
tusb6010.c:        qemu_mod_timer(s->pwr_timer,
twl92230.c: * TI TWL92230C energy-management companion device for the OMAP24xx.
twl92230.c:#include "qemu-timer.h"
twl92230.c:    qemu_set_irq(s->out[3], s->status & ~s->mask);
twl92230.c:    s->rtc.next += qemu_get_clock(rt_clock);
twl92230.c:    qemu_mod_timer(s->rtc.hz_tm, s->rtc.next);
twl92230.c:    qemu_del_timer(s->rtc.hz_tm);
twl92230.c:    s->rtc.next -= qemu_get_clock(rt_clock);
twl92230.c:    if (s->rtc.next < 1)
twl92230.c:        s->rtc.next = 1;
twl92230.c:    qemu_get_timedate(&s->rtc.tm, s->rtc.sec_offset);
twl92230.c:    if ((s->rtc.ctrl & 3) == 3)
twl92230.c:        s->rtc.alm_sec = qemu_timedate_diff(&s->rtc.alm) - s->rtc.sec_offset;
twl92230.c:    s->rtc.next_comp --;
twl92230.c:    s->rtc.alm_sec --;
twl92230.c:    s->rtc.next += 1000;
twl92230.c:    qemu_mod_timer(s->rtc.hz_tm, s->rtc.next);
twl92230.c:    if ((s->rtc.ctrl >> 3) & 3) {				/* EVERY */
twl92230.c:        if (((s->rtc.ctrl >> 3) & 3) == 1 && !s->rtc.tm.tm_sec)
twl92230.c:            s->status |= 1 << 8;				/* RTCTMR */
twl92230.c:        else if (((s->rtc.ctrl >> 3) & 3) == 2 && !s->rtc.tm.tm_min)
twl92230.c:            s->status |= 1 << 8;				/* RTCTMR */
twl92230.c:        else if (!s->rtc.tm.tm_hour)
twl92230.c:            s->status |= 1 << 8;				/* RTCTMR */
twl92230.c:        s->status |= 1 << 8;					/* RTCTMR */
twl92230.c:    if ((s->rtc.ctrl >> 1) & 1) {				/* RTC_AL_EN */
twl92230.c:        if (s->rtc.alm_sec == 0)
twl92230.c:            s->status |= 1 << 9;				/* RTCALM */
twl92230.c:        /* TODO: wake-up */
twl92230.c:    if (s->rtc.next_comp <= 0) {
twl92230.c:        s->rtc.next -= muldiv64((int16_t) s->rtc.comp, 1000, 0x8000);
twl92230.c:        s->rtc.next_comp = 3600;
twl92230.c:    s->reg = 0x00;
twl92230.c:    s->vcore[0] = 0x0c;	/* XXX: X-loader needs 0x8c? check!  */
twl92230.c:    s->vcore[1] = 0x05;
twl92230.c:    s->vcore[2] = 0x02;
twl92230.c:    s->vcore[3] = 0x0c;
twl92230.c:    s->vcore[4] = 0x03;
twl92230.c:    s->dcdc[0] = 0x33;	/* Depends on wiring */
twl92230.c:    s->dcdc[1] = 0x03;
twl92230.c:    s->dcdc[2] = 0x00;
twl92230.c:    s->ldo[0] = 0x95;
twl92230.c:    s->ldo[1] = 0x7e;
twl92230.c:    s->ldo[2] = 0x00;
twl92230.c:    s->ldo[3] = 0x00;	/* Depends on wiring */
twl92230.c:    s->ldo[4] = 0x03;	/* Depends on wiring */
twl92230.c:    s->ldo[5] = 0x00;
twl92230.c:    s->ldo[6] = 0x00;
twl92230.c:    s->ldo[7] = 0x00;
twl92230.c:    s->sleep[0] = 0x00;
twl92230.c:    s->sleep[1] = 0x00;
twl92230.c:    s->osc = 0x01;
twl92230.c:    s->detect = 0x09;
twl92230.c:    s->mask = 0x0fff;
twl92230.c:    s->status = 0;
twl92230.c:    s->dir = 0x07;
twl92230.c:    s->outputs = 0x00;
twl92230.c:    s->bbsms = 0x00;
twl92230.c:    s->pull[0] = 0x00;
twl92230.c:    s->pull[1] = 0x00;
twl92230.c:    s->pull[2] = 0x00;
twl92230.c:    s->pull[3] = 0x00;
twl92230.c:    s->mmc_ctrl[0] = 0x03;
twl92230.c:    s->mmc_ctrl[1] = 0xc0;
twl92230.c:    s->mmc_ctrl[2] = 0x00;
twl92230.c:    s->mmc_debounce = 0x05;
twl92230.c:    if (s->rtc.ctrl & 1)
twl92230.c:    s->rtc.ctrl = 0x00;
twl92230.c:    s->rtc.comp = 0x0000;
twl92230.c:    s->rtc.next = 1000;
twl92230.c:    s->rtc.sec_offset = 0;
twl92230.c:    s->rtc.next_comp = 1800;
twl92230.c:    s->rtc.alm_sec = 1800;
twl92230.c:    s->rtc.alm.tm_sec = 0x00;
twl92230.c:    s->rtc.alm.tm_min = 0x00;
twl92230.c:    s->rtc.alm.tm_hour = 0x00;
twl92230.c:    s->rtc.alm.tm_mday = 0x01;
twl92230.c:    s->rtc.alm.tm_mon = 0x00;
twl92230.c:    s->rtc.alm.tm_year = 2004;
twl92230.c:    s->inputs &= ~(1 << line);
twl92230.c:    s->inputs |= level << line;
twl92230.c:    if (!s->pwrbtn_state && level) {
twl92230.c:        s->status |= 1 << 11;					/* PSHBTN */
twl92230.c:    s->pwrbtn_state = level;
twl92230.c:        return s->vcore[reg];
twl92230.c:        return s->dcdc[reg];
twl92230.c:        return s->ldo[reg];
twl92230.c:        return s->sleep[reg];
twl92230.c:        return s->osc | (1 << 7);			/* CLK32K_GOOD */
twl92230.c:        return s->detect;
twl92230.c:        return (s->mask >> 0) & 0xff;
twl92230.c:        return (s->mask >> 8) & 0xff;
twl92230.c:        return (s->status >> 0) & 0xff;
twl92230.c:        return (s->status >> 8) & 0xff;
twl92230.c:        return s->dir;
twl92230.c:        return s->inputs | (~s->dir & s->outputs);
twl92230.c:        return s->outputs;
twl92230.c:        return s->bbsms;
twl92230.c:        return s->rtc.ctrl;
twl92230.c:        return to_bcd(s->rtc.tm.tm_sec);
twl92230.c:        return to_bcd(s->rtc.tm.tm_min);
twl92230.c:        if ((s->rtc.ctrl >> 2) & 1)			/* MODE12_n24 */
twl92230.c:            return to_bcd((s->rtc.tm.tm_hour % 12) + 1) |
twl92230.c:                    (!!(s->rtc.tm.tm_hour >= 12) << 7);	/* PM_nAM */
twl92230.c:            return to_bcd(s->rtc.tm.tm_hour);
twl92230.c:        return to_bcd(s->rtc.tm.tm_mday);
twl92230.c:        return to_bcd(s->rtc.tm.tm_mon + 1);
twl92230.c:        return to_bcd(s->rtc.tm.tm_year - 2000);
twl92230.c:        return to_bcd(s->rtc.tm.tm_wday);
twl92230.c:        return to_bcd(s->rtc.alm.tm_sec);
twl92230.c:        return to_bcd(s->rtc.alm.tm_min);
twl92230.c:        if ((s->rtc.ctrl >> 2) & 1)			/* MODE12_n24 */
twl92230.c:            return to_bcd((s->rtc.alm.tm_hour % 12) + 1) |
twl92230.c:                    (!!(s->rtc.alm.tm_hour >= 12) << 7);/* AL_PM_nAM */
twl92230.c:            return to_bcd(s->rtc.alm.tm_hour);
twl92230.c:        return to_bcd(s->rtc.alm.tm_mday);
twl92230.c:        return to_bcd(s->rtc.alm.tm_mon + 1);
twl92230.c:        return to_bcd(s->rtc.alm.tm_year - 2000);
twl92230.c:        return (s->rtc.comp >> 8) & 0xff;
twl92230.c:        return (s->rtc.comp >> 0) & 0xff;
twl92230.c:        return s->pull[0];
twl92230.c:        return s->pull[1];
twl92230.c:        return s->pull[2];
twl92230.c:        return s->pull[3];
twl92230.c:        return s->mmc_ctrl[reg];
twl92230.c:        return s->mmc_debounce;
twl92230.c:        s->vcore[0] = (value & 0xe) | MIN(value & 0x1f, 0x12);
twl92230.c:        s->vcore[1] = value;
twl92230.c:        s->vcore[2] = MIN(value & 0x1f, 0x12);
twl92230.c:        s->vcore[3] = MIN(value & 0x1f, 0x12);
twl92230.c:        s->vcore[4] = value & 3;
twl92230.c:        s->dcdc[0] = value & 0x3f;
twl92230.c:        s->dcdc[1] = value & 0x07;
twl92230.c:        s->dcdc[2] = value & 0x07;
twl92230.c:        s->ldo[0] = value;
twl92230.c:        s->ldo[1] = value & 0x7f;
twl92230.c:        s->ldo[2] = value & 3;
twl92230.c:        s->ldo[3] = value & 3;
twl92230.c:        s->ldo[4] = value & 3;
twl92230.c:        s->ldo[5] = value & 3;
twl92230.c:        s->ldo[6] = value & 3;
twl92230.c:        s->ldo[7] = value & 3;
twl92230.c:        s->sleep[reg] = value;
twl92230.c:            menelaus_reset(&s->i2c);
twl92230.c:        s->osc = value & 7;
twl92230.c:        s->detect = value & 0x7f;
twl92230.c:        s->mask &= 0xf00;
twl92230.c:        s->mask |= value << 0;
twl92230.c:        s->mask &= 0x0ff;
twl92230.c:        s->mask |= value << 8;
twl92230.c:        s->status &= ~(((uint16_t) value) << 0);
twl92230.c:        s->status &= ~(((uint16_t) value) << 8);
twl92230.c:            if (((s->dir ^ value) >> line) & 1) {
twl92230.c:                qemu_set_irq(s->out[line],
twl92230.c:                             ((s->outputs & ~s->dir) >> line) & 1);
twl92230.c:        s->dir = value & 0x67;
twl92230.c:            if ((((s->outputs ^ value) & ~s->dir) >> line) & 1) {
twl92230.c:                qemu_set_irq(s->out[line], (s->outputs >> line) & 1);
twl92230.c:        s->outputs = value & 0x07;
twl92230.c:        s->bbsms = 0x0d;
twl92230.c:        if ((s->rtc.ctrl ^ value) & 1) {			/* RTC_EN */
twl92230.c:        s->rtc.ctrl = value & 0x1f;
twl92230.c:        memcpy(&tm, &s->rtc.tm, sizeof(tm));
twl92230.c:            tm.tm_sec = s->rtc.new.tm_sec;
twl92230.c:            tm.tm_min = s->rtc.new.tm_min;
twl92230.c:            if (s->rtc.new.tm_hour > 23)
twl92230.c:            tm.tm_hour = s->rtc.new.tm_hour;
twl92230.c:            if (s->rtc.new.tm_mday < 1)
twl92230.c:            tm.tm_mday = s->rtc.new.tm_mday;
twl92230.c:            if (s->rtc.new.tm_mon < 0 || s->rtc.new.tm_mon > 11)
twl92230.c:            tm.tm_mon = s->rtc.new.tm_mon;
twl92230.c:            tm.tm_year = s->rtc.new.tm_year;
twl92230.c:            tm.tm_wday = s->rtc.new.tm_wday;
twl92230.c:            if (s->rtc.new.tm_hour > 23)
twl92230.c:            if (s->rtc.new.tm_mday < 1)
twl92230.c:            if (s->rtc.new.tm_mon < 0 || s->rtc.new.tm_mon > 11)
twl92230.c:            tm.tm_sec = s->rtc.new.tm_sec;
twl92230.c:            tm.tm_min = s->rtc.new.tm_min;
twl92230.c:            tm.tm_hour = s->rtc.new.tm_hour;
twl92230.c:            tm.tm_mday = s->rtc.new.tm_mday;
twl92230.c:            tm.tm_mon = s->rtc.new.tm_mon;
twl92230.c:            tm.tm_year = s->rtc.new.tm_year;
twl92230.c:            s->status |= 1 << 10;				/* RTCERR */
twl92230.c:        s->rtc.sec_offset = qemu_timedate_diff(&tm);
twl92230.c:        s->rtc.tm.tm_sec = from_bcd(value & 0x7f);
twl92230.c:        s->rtc.tm.tm_min = from_bcd(value & 0x7f);
twl92230.c:        s->rtc.tm.tm_hour = (s->rtc.ctrl & (1 << 2)) ?	/* MODE12_n24 */
twl92230.c:                MIN(from_bcd(value & 0x3f), 12) + ((value >> 7) ? 11 : -1) :
twl92230.c:        s->rtc.tm.tm_mday = from_bcd(value);
twl92230.c:        s->rtc.tm.tm_mon = MAX(1, from_bcd(value)) - 1;
twl92230.c:        s->rtc.tm.tm_year = 2000 + from_bcd(value);
twl92230.c:        s->rtc.tm.tm_mday = from_bcd(value);
twl92230.c:        s->rtc.alm.tm_sec = from_bcd(value & 0x7f);
twl92230.c:        s->rtc.alm.tm_min = from_bcd(value & 0x7f);
twl92230.c:        s->rtc.alm.tm_hour = (s->rtc.ctrl & (1 << 2)) ?	/* MODE12_n24 */
twl92230.c:                MIN(from_bcd(value & 0x3f), 12) + ((value >> 7) ? 11 : -1) :
twl92230.c:        s->rtc.alm.tm_mday = from_bcd(value);
twl92230.c:        s->rtc.alm.tm_mon = MAX(1, from_bcd(value)) - 1;
twl92230.c:        s->rtc.alm.tm_year = 2000 + from_bcd(value);
twl92230.c:        s->rtc.comp &= 0xff;
twl92230.c:        s->rtc.comp |= value << 8;
twl92230.c:        s->rtc.comp &= 0xff << 8;
twl92230.c:        s->rtc.comp |= value;
twl92230.c:        s->pull[0] = value;
twl92230.c:        s->pull[1] = value & 0x1f;
twl92230.c:        s->pull[2] = value;
twl92230.c:        s->pull[3] = value & 0x1f;
twl92230.c:        s->mmc_ctrl[0] = value & 0x7f;
twl92230.c:        s->mmc_ctrl[1] = value;
twl92230.c:        s->mmc_ctrl[2] = value & 0xf;
twl92230.c:        s->mmc_debounce = value & 0x3f;
twl92230.c:        s->firstbyte = 1;
twl92230.c:    if (s->firstbyte) {
twl92230.c:        s->reg = data;
twl92230.c:        s->firstbyte = 0;
twl92230.c:        menelaus_write(s, s->reg ++, data);
twl92230.c:    return menelaus_read(s, s->reg ++);
twl92230.c:    s->rtc_next_vmstate =  s->rtc.next - qemu_get_clock(rt_clock);
twl92230.c:    if (s->rtc.ctrl & 1)					/* RTC_EN */
twl92230.c:    s->rtc.next = s->rtc_next_vmstate;
twl92230.c:    if (s->rtc.ctrl & 1)					/* RTC_EN */
twl92230.c:    s->rtc.hz_tm = qemu_new_timer(rt_clock, menelaus_rtc_hz, s);
twl92230.c:    qdev_init_gpio_out(&i2c->qdev, s->out, 4);
twl92230.c:    qdev_init_gpio_in(&i2c->qdev, menelaus_gpio_set, 3);
twl92230.c:    s->pwrbtn = qemu_allocate_irqs(menelaus_pwrbtn_set, s, 1)[0];
twl92230.c:    menelaus_reset(&s->i2c);
unin_pci.c:    return (irq_num + (pci_dev->devfn >> 3)) & 3;
unin_pci.c:        return -EINVAL;
unin_pci.c:    pci_mem_config = pci_host_conf_register_mmio(&s->host_state);
unin_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
unin_pci.c:    register_savevm("uninorth", 0, 1, pci_unin_save, pci_unin_load, &s->host_state);
unin_pci.c:    qemu_register_reset(pci_unin_reset, &s->host_state);
unin_pci.c:    pci_mem_config = pci_host_conf_register_mmio_noswap(&s->host_state);
unin_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
unin_pci.c:    pci_mem_config = pci_host_conf_register_mmio_noswap(&s->host_state);
unin_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
unin_pci.c:    pci_mem_config = pci_host_conf_register_mmio_noswap(&s->host_state);
unin_pci.c:    pci_mem_data = pci_host_data_register_mmio(&s->host_state);
unin_pci.c:    dev = qdev_create(NULL, "uni-north");
unin_pci.c:    d->host_state.bus = pci_register_bus(&d->busdev.qdev, "pci",
unin_pci.c:    pci_create_simple(d->host_state.bus, 11 << 3, "uni-north");
unin_pci.c:    pci_create_simple(d->host_state.bus, 12 << 3, "dec-21154");
unin_pci.c:    pci_create_simple(d->host_state.bus, 11 << 3, "uni-north-agp");
unin_pci.c:    dev = qdev_create(NULL, "uni-north-agp");
unin_pci.c:    pci_create_simple(d->host_state.bus, 14 << 3, "uni-north-pci");
unin_pci.c:    dev = qdev_create(NULL, "uni-north-pci");
unin_pci.c:    return d->host_state.bus;
unin_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_APPLE);
unin_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_APPLE_UNI_N_PCI);
unin_pci.c:    d->config[0x08] = 0x00; // revision
unin_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
unin_pci.c:    d->config[0x0C] = 0x08; // cache_line_size
unin_pci.c:    d->config[0x0D] = 0x10; // latency_timer
unin_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
unin_pci.c:    d->config[0x34] = 0x00; // capabilities_pointer
unin_pci.c:    /* pci-to-pci bridge */
unin_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_DEC);
unin_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_DEC_21154);
unin_pci.c:    d->config[0x08] = 0x05; // revision
unin_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);
unin_pci.c:    d->config[0x0C] = 0x08; // cache_line_size
unin_pci.c:    d->config[0x0D] = 0x20; // latency_timer
unin_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_BRIDGE; // header_type
unin_pci.c:    d->config[0x18] = 0x01; // primary_bus
unin_pci.c:    d->config[0x19] = 0x02; // secondary_bus
unin_pci.c:    d->config[0x1A] = 0x02; // subordinate_bus
unin_pci.c:    d->config[0x1B] = 0x20; // secondary_latency_timer
unin_pci.c:    d->config[0x1C] = 0x11; // io_base
unin_pci.c:    d->config[0x1D] = 0x01; // io_limit
unin_pci.c:    d->config[0x20] = 0x00; // memory_base
unin_pci.c:    d->config[0x21] = 0x80;
unin_pci.c:    d->config[0x22] = 0x00; // memory_limit
unin_pci.c:    d->config[0x23] = 0x80;
unin_pci.c:    d->config[0x24] = 0x01; // prefetchable_memory_base
unin_pci.c:    d->config[0x25] = 0x80;
unin_pci.c:    d->config[0x26] = 0xF1; // prefectchable_memory_limit
unin_pci.c:    d->config[0x27] = 0x7F;
unin_pci.c:    // d->config[0x34] = 0xdc // capabilities_pointer
unin_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_APPLE);
unin_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_APPLE_UNI_N_AGP);
unin_pci.c:    d->config[0x08] = 0x00; // revision
unin_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
unin_pci.c:    d->config[0x0C] = 0x08; // cache_line_size
unin_pci.c:    d->config[0x0D] = 0x10; // latency_timer
unin_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
unin_pci.c:    //    d->config[0x34] = 0x80; // capabilities_pointer
unin_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_APPLE);
unin_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_APPLE_UNI_N_I_PCI);
unin_pci.c:    d->config[0x08] = 0x00; // revision
unin_pci.c:    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_HOST);
unin_pci.c:    d->config[0x0C] = 0x08; // cache_line_size
unin_pci.c:    d->config[0x0D] = 0x10; // latency_timer
unin_pci.c:    d->config[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; // header_type
unin_pci.c:    d->config[0x34] = 0x00; // capabilities_pointer
unin_pci.c:    .qdev.name = "uni-north",
unin_pci.c:    .qdev.name = "dec-21154",
unin_pci.c:    .qdev.name = "uni-north-agp",
unin_pci.c:    .qdev.name = "uni-north-pci",
unin_pci.c:    sysbus_register_dev("uni-north", sizeof(UNINState),
unin_pci.c:    sysbus_register_dev("dec-21154", sizeof(UNINState),
unin_pci.c:    sysbus_register_dev("uni-north-agp", sizeof(UNINState),
unin_pci.c:    sysbus_register_dev("uni-north-pci", sizeof(UNINState),
usb-bt.c:#include "qemu-common.h"
usb-bt.c:					 6: Self-powered,
usb-bt.c:    0x0a,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x0a,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    0x01,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-bt.c:    fifo->dstart = 0;
usb-bt.c:    fifo->dlen = 0;
usb-bt.c:    fifo->dsize = DFIFO_LEN_MASK + 1;
usb-bt.c:    fifo->start = 0;
usb-bt.c:    fifo->len = 0;
usb-bt.c:    int off = fifo->dstart + fifo->dlen;
usb-bt.c:    fifo->dlen += len;
usb-bt.c:                        (fifo->dsize = off + len) > (DFIFO_LEN_MASK + 1) * 2) {
usb-bt.c:            exit(-1);
usb-bt.c:        buf = fifo->data + off;
usb-bt.c:        if (fifo->dlen > fifo->dsize) {
usb-bt.c:            exit(-1);
usb-bt.c:        buf = fifo->data + off - fifo->dsize;
usb-bt.c:    off = (fifo->start + fifo->len ++) & CFIFO_LEN_MASK;
usb-bt.c:    fifo->fifo[off].data = memcpy(buf, data, len);
usb-bt.c:    fifo->fifo[off].len = len;
usb-bt.c:    if (likely(!fifo->len))
usb-bt.c:    len = MIN(p->len, fifo->fifo[fifo->start].len);
usb-bt.c:    memcpy(p->data, fifo->fifo[fifo->start].data, len);
usb-bt.c:    if (len == p->len) {
usb-bt.c:        fifo->fifo[fifo->start].len -= len;
usb-bt.c:        fifo->fifo[fifo->start].data += len;
usb-bt.c:        fifo->start ++;
usb-bt.c:        fifo->start &= CFIFO_LEN_MASK;
usb-bt.c:        fifo->len --;
usb-bt.c:    fifo->dstart += len;
usb-bt.c:    fifo->dlen -= len;
usb-bt.c:    if (fifo->dstart >= fifo->dsize) {
usb-bt.c:        fifo->dstart = 0;
usb-bt.c:        fifo->dsize = DFIFO_LEN_MASK + 1;
usb-bt.c:    if (fifo->len) {
usb-bt.c:        memcpy(fifo->data + fifo->len, data, len);
usb-bt.c:        fifo->len += len;
usb-bt.c:        if (complete(fifo->data, fifo->len)) {
usb-bt.c:            send(s->hci, fifo->data, fifo->len);
usb-bt.c:            fifo->len = 0;
usb-bt.c:        send(s->hci, data, len);
usb-bt.c:        memcpy(fifo->data, data, len);
usb-bt.c:        fifo->len = len;
usb-bt.c:    len -= HCI_COMMAND_HDR_SIZE;
usb-bt.c:            len >= ((struct hci_command_hdr *) data)->plen;
usb-bt.c:    len -= HCI_ACL_HDR_SIZE;
usb-bt.c:            len >= le16_to_cpu(((struct hci_acl_hdr *) data)->dlen);
usb-bt.c:    len -= HCI_SCO_HDR_SIZE;
usb-bt.c:            len >= ((struct hci_sco_hdr *) data)->dlen;
usb-bt.c:    struct USBBtState *s = (struct USBBtState *) dev->opaque;
usb-bt.c:    usb_bt_fifo_reset(&s->evt);
usb-bt.c:    usb_bt_fifo_reset(&s->acl);
usb-bt.c:    usb_bt_fifo_reset(&s->sco);
usb-bt.c:    s->outcmd.len = 0;
usb-bt.c:    s->outacl.len = 0;
usb-bt.c:    s->outsco.len = 0;
usb-bt.c:    s->altsetting = 0;
usb-bt.c:    struct USBBtState *s = (struct USBBtState *) dev->opaque;
usb-bt.c:            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-bt.c:            dev->remote_wakeup = 0;
usb-bt.c:            dev->remote_wakeup = 1;
usb-bt.c:        dev->addr = value;
usb-bt.c:        s->config = 0;
usb-bt.c:        s->config = 1;
usb-bt.c:        usb_bt_fifo_reset(&s->evt);
usb-bt.c:        usb_bt_fifo_reset(&s->acl);
usb-bt.c:        usb_bt_fifo_reset(&s->sco);
usb-bt.c:            data[0] = s->altsetting;
usb-bt.c:        s->altsetting = value;
usb-bt.c:        if (s->config)
usb-bt.c:            usb_bt_fifo_out_enqueue(s, &s->outcmd, s->hci->cmd_send,
usb-bt.c:    struct USBBtState *s = (struct USBBtState *) dev->opaque;
usb-bt.c:    if (!s->config)
usb-bt.c:    switch (p->pid) {
usb-bt.c:        switch (p->devep & 0xf) {
usb-bt.c:            ret = usb_bt_fifo_dequeue(&s->evt, p);
usb-bt.c:            ret = usb_bt_fifo_dequeue(&s->acl, p);
usb-bt.c:            ret = usb_bt_fifo_dequeue(&s->sco, p);
usb-bt.c:        switch (p->devep & 0xf) {
usb-bt.c:            usb_bt_fifo_out_enqueue(s, &s->outacl, s->hci->acl_send,
usb-bt.c:                            usb_bt_hci_acl_complete, p->data, p->len);
usb-bt.c:            usb_bt_fifo_out_enqueue(s, &s->outsco, s->hci->sco_send,
usb-bt.c:                            usb_bt_hci_sco_complete, p->data, p->len);
usb-bt.c:    usb_bt_fifo_enqueue(&s->evt, data, len);
usb-bt.c:    usb_bt_fifo_enqueue(&s->acl, data, len);
usb-bt.c:    struct USBBtState *s = (struct USBBtState *) dev->opaque;
usb-bt.c:    s->hci->opaque = NULL;
usb-bt.c:    s->hci->evt_recv = NULL;
usb-bt.c:    s->hci->acl_recv = NULL;
usb-bt.c:    s->dev.speed = USB_SPEED_HIGH;
usb-bt.c:    dev = usb_create_simple(NULL /* FIXME */, "usb-bt-dongle");
usb-bt.c:    s->dev.opaque = s;
usb-bt.c:    s->hci = hci;
usb-bt.c:    s->hci->opaque = s;
usb-bt.c:    s->hci->evt_recv = usb_bt_out_hci_packet_event;
usb-bt.c:    s->hci->acl_recv = usb_bt_out_hci_packet_acl;
usb-bt.c:    usb_bt_handle_reset(&s->dev);
usb-bt.c:    .qdev.name      = "usb-bt-dongle",
usb-bus.c:    qbus_create_inplace(&bus->qbus, &usb_bus_info, host, NULL);
usb-bus.c:    bus->busnr = next_usb_bus++;
usb-bus.c:    bus->qbus.allow_hotplug = 1; /* Yes, we can */
usb-bus.c:    QTAILQ_INIT(&bus->free);
usb-bus.c:    QTAILQ_INIT(&bus->used);
usb-bus.c:    if (-1 == busnr)
usb-bus.c:        if (bus->busnr == busnr)
usb-bus.c:    pstrcpy(dev->product_desc, sizeof(dev->product_desc), info->product_desc);
usb-bus.c:    dev->info = info;
usb-bus.c:    dev->auto_attach = 1;
usb-bus.c:    rc = dev->info->init(dev);
usb-bus.c:    if (rc == 0 && dev->auto_attach)
usb-bus.c:    if (dev->info->handle_destroy) {
usb-bus.c:        dev->info->handle_destroy(dev);
usb-bus.c:    info->qdev.bus_info = &usb_bus_info;
usb-bus.c:    info->qdev.init     = usb_qdev_init;
usb-bus.c:    info->qdev.unplug   = qdev_simple_unplug_cb;
usb-bus.c:    info->qdev.exit     = usb_qdev_exit;
usb-bus.c:    qdev_register(&info->qdev);
usb-bus.c:    while (info->qdev.name) {
usb-bus.c:    /* temporary stopgap until all usb is properly qdev-ified */
usb-bus.c:        bus = usb_bus_find(-1);
usb-bus.c:                __FUNCTION__, bus->qbus.name, name);
usb-bus.c:    dev = qdev_create(&bus->qbus, name);
usb-bus.c:    qdev_init_nofail(&dev->qdev);
usb-bus.c:    port->opaque = opaque;
usb-bus.c:    port->index = index;
usb-bus.c:    port->attach = attach;
usb-bus.c:    QTAILQ_INSERT_TAIL(&bus->free, port, next);
usb-bus.c:    bus->nfree++;
usb-bus.c:    if (port->dev)
usb-bus.c:        qdev_free(&port->dev->qdev);
usb-bus.c:    QTAILQ_REMOVE(&bus->free, port, next);
usb-bus.c:    bus->nfree--;
usb-bus.c:    if (dev->attached) {
usb-bus.c:                dev->product_desc);
usb-bus.c:    dev->attached++;
usb-bus.c:    port = QTAILQ_FIRST(&bus->free);
usb-bus.c:    QTAILQ_REMOVE(&bus->free, port, next);
usb-bus.c:    bus->nfree--;
usb-bus.c:    QTAILQ_INSERT_TAIL(&bus->used, port, next);
usb-bus.c:    bus->nused++;
usb-bus.c:    if (bus->nfree == 1) {
usb-bus.c:        hub = usb_create_simple(bus, "usb-hub");
usb-bus.c:    if (!dev->attached) {
usb-bus.c:                dev->product_desc);
usb-bus.c:        return -1;
usb-bus.c:    dev->attached--;
usb-bus.c:    QTAILQ_FOREACH(port, &bus->used, next) {
usb-bus.c:        if (port->dev == dev)
usb-bus.c:    QTAILQ_REMOVE(&bus->used, port, next);
usb-bus.c:    bus->nused--;
usb-bus.c:    QTAILQ_INSERT_TAIL(&bus->free, port, next);
usb-bus.c:    bus->nfree++;
usb-bus.c:        return -1;
usb-bus.c:    QTAILQ_FOREACH(port, &bus->used, next) {
usb-bus.c:        if (port->dev->addr == addr)
usb-bus.c:        return -1;
usb-bus.c:    dev = port->dev;
usb-bus.c:    qdev_free(&dev->qdev);
usb-bus.c:                   indent, "", bus->busnr, dev->addr,
usb-bus.c:                   usb_speed(dev->speed), dev->product_desc,
usb-bus.c:                   dev->attached ? ", attached" : "");
usb-bus.c:        QTAILQ_FOREACH(port, &bus->used, next) {
usb-bus.c:            dev = port->dev;
usb-bus.c:                           bus->busnr, dev->addr, usb_speed(dev->speed),
usb-bus.c:                           dev->product_desc);
usb-bus.c:/* handle legacy -usbdevice cmd line option */
usb-bus.c:    USBBus *bus = usb_bus_find(-1 /* any */);
usb-bus.c:        len = params - cmdline;
usb-bus.c:    for (info = device_info_list; info != NULL; info = info->next) {
usb-bus.c:        if (info->bus_info != &usb_bus_info)
usb-bus.c:        if (usb->usbdevice_name == NULL)
usb-bus.c:        if (strcmp(usb->usbdevice_name, driver) != 0)
usb-bus.c:    if (!usb->usbdevice_init) {
usb-bus.c:        return usb_create_simple(bus, usb->qdev.name);
usb-bus.c:    return usb->usbdevice_init(params);
usb.c:#include "qemu-common.h"
usb.c:    port->attach(port, dev);
usb.c:    if (p->len != 8)
usb.c:    memcpy(s->setup_buf, p->data, 8);
usb.c:    s->setup_len   = (s->setup_buf[7] << 8) | s->setup_buf[6];
usb.c:    s->setup_index = 0;
usb.c:    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
usb.c:    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
usb.c:    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
usb.c:    if (s->setup_buf[0] & USB_DIR_IN) {
usb.c:        ret = s->info->handle_control(s, request, value, index, 
usb.c:                                      s->setup_len, s->data_buf);
usb.c:        if (ret < s->setup_len)
usb.c:            s->setup_len = ret;
usb.c:        s->setup_state = SETUP_STATE_DATA;
usb.c:        if (s->setup_len == 0)
usb.c:            s->setup_state = SETUP_STATE_ACK;
usb.c:            s->setup_state = SETUP_STATE_DATA;
usb.c:    if (p->devep != 0)
usb.c:        return s->info->handle_data(s, p);
usb.c:    request = (s->setup_buf[0] << 8) | s->setup_buf[1];
usb.c:    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];
usb.c:    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];
usb.c:    switch(s->setup_state) {
usb.c:        if (!(s->setup_buf[0] & USB_DIR_IN)) {
usb.c:            s->setup_state = SETUP_STATE_IDLE;
usb.c:            ret = s->info->handle_control(s, request, value, index,
usb.c:                                          s->setup_len, s->data_buf);
usb.c:        if (s->setup_buf[0] & USB_DIR_IN) {
usb.c:            int len = s->setup_len - s->setup_index;
usb.c:            if (len > p->len)
usb.c:                len = p->len;
usb.c:            memcpy(p->data, s->data_buf + s->setup_index, len);
usb.c:            s->setup_index += len;
usb.c:            if (s->setup_index >= s->setup_len)
usb.c:                s->setup_state = SETUP_STATE_ACK;
usb.c:        s->setup_state = SETUP_STATE_IDLE;
usb.c:    if (p->devep != 0)
usb.c:        return s->info->handle_data(s, p);
usb.c:    switch(s->setup_state) {
usb.c:        if (s->setup_buf[0] & USB_DIR_IN) {
usb.c:            s->setup_state = SETUP_STATE_IDLE;
usb.c:        if (!(s->setup_buf[0] & USB_DIR_IN)) {
usb.c:            int len = s->setup_len - s->setup_index;
usb.c:            if (len > p->len)
usb.c:                len = p->len;
usb.c:            memcpy(s->data_buf + s->setup_index, p->data, len);
usb.c:            s->setup_index += len;
usb.c:            if (s->setup_index >= s->setup_len)
usb.c:                s->setup_state = SETUP_STATE_ACK;
usb.c:        s->setup_state = SETUP_STATE_IDLE;
usb.c:    switch(p->pid) {
usb.c:        s->state = USB_STATE_ATTACHED;
usb.c:        s->state = USB_STATE_NOTATTACHED;
usb.c:        s->remote_wakeup = 0;
usb.c:        s->addr = 0;
usb.c:        s->state = USB_STATE_DEFAULT;
usb.c:        s->info->handle_reset(s);
usb.c:    if (s->state < USB_STATE_DEFAULT || p->devaddr != s->addr)
usb.c:    switch (p->pid) {
usb.c:    return q - buf;
usb.c:    dev->info->handle_packet(dev, &p);
usb.h:#include "qemu-queue.h"
usb.h:#define USB_TOKEN_IN    0x69 /* device -> host */
usb.h:#define USB_TOKEN_OUT   0xe1 /* host -> device */
usb.h:#define USB_RET_NODEV  (-1)
usb.h:#define USB_RET_NAK    (-2)
usb.h:#define USB_RET_STALL  (-3)
usb.h:#define USB_RET_BABBLE (-4)
usb.h:#define USB_RET_ASYNC  (-5)
usb.h:    /* handle legacy -usbdevice command line options */
usb.h:    p->cancel_cb = cancel;
usb.h:    p->cancel_opaque = opaque;
usb.h:    p->complete_cb(p, p->complete_opaque);
usb.h:    p->cancel_cb(p, p->cancel_opaque);
usb.h:/* usb-linux.c */
usb.h:/* usb-hid.c */
usb.h:/* usb-bt.c */
usb.h:/* usb-musb.c */
usb.h:/* usb-bus.c */
usb.h:    return DO_UPCAST(USBBus, qbus, d->qdev.parent_bus);
usb-hid.c:				     6: Self-powered,
usb-hid.c:	0x0a,       /*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-hid.c:				     6: Self-powered,
usb-hid.c:	0x0a,       /*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-hid.c:				    6: Self-powered,
usb-hid.c:    0x0a,		/*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-hid.c:    0x15, 0x81,		/*     Logical Minimum (-0x7f) */
usb-hid.c:    0x15, 0x81,		/*     Logical Minimum (-0x7f) */
usb-hid.c:    hs->changed = 1;
usb-hid.c:    if (hs->datain)
usb-hid.c:        hs->datain(hs->datain_opaque);
usb-hid.c:    USBMouseState *s = &hs->ptr;
usb-hid.c:    s->dx += dx1;
usb-hid.c:    s->dy += dy1;
usb-hid.c:    s->dz += dz1;
usb-hid.c:    s->buttons_state = buttons_state;
usb-hid.c:    USBMouseState *s = &hs->ptr;
usb-hid.c:    s->x = x;
usb-hid.c:    s->y = y;
usb-hid.c:    s->dz += dz;
usb-hid.c:    s->buttons_state = buttons_state;
usb-hid.c:    USBKeyboardState *s = &hs->kbd;
usb-hid.c:    hid_code = usb_hid_usage_keys[key | ((s->modifiers >> 1) & (1 << 7))];
usb-hid.c:    s->modifiers &= ~(1 << 8);
usb-hid.c:        if (s->modifiers & (1 << 9)) {
usb-hid.c:            s->modifiers ^= 3 << 8;
usb-hid.c:            s->modifiers &= ~(1 << (hid_code & 0x0f));
usb-hid.c:        s->modifiers |= 1 << (hid_code & 0x0f);
usb-hid.c:        for (i = s->keys - 1; i >= 0; i --)
usb-hid.c:            if (s->key[i] == hid_code) {
usb-hid.c:                s->key[i] = s->key[-- s->keys];
usb-hid.c:                s->key[s->keys] = 0x00;
usb-hid.c:        for (i = s->keys - 1; i >= 0; i --)
usb-hid.c:            if (s->key[i] == hid_code)
usb-hid.c:            if (s->keys < sizeof(s->key))
usb-hid.c:                s->key[s->keys ++] = hid_code;
usb-hid.c:    USBMouseState *s = &hs->ptr;
usb-hid.c:    if (!s->mouse_grabbed) {
usb-hid.c:	s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, hs,
usb-hid.c:	s->mouse_grabbed = 1;
usb-hid.c:    dx = int_clamp(s->dx, -127, 127);
usb-hid.c:    dy = int_clamp(s->dy, -127, 127);
usb-hid.c:    dz = int_clamp(s->dz, -127, 127);
usb-hid.c:    s->dx -= dx;
usb-hid.c:    s->dy -= dy;
usb-hid.c:    s->dz -= dz;
usb-hid.c:    dz = 0 - dz;
usb-hid.c:    if (s->buttons_state & MOUSE_EVENT_LBUTTON)
usb-hid.c:    if (s->buttons_state & MOUSE_EVENT_RBUTTON)
usb-hid.c:    if (s->buttons_state & MOUSE_EVENT_MBUTTON)
usb-hid.c:    USBMouseState *s = &hs->ptr;
usb-hid.c:    if (!s->mouse_grabbed) {
usb-hid.c:	s->eh_entry = qemu_add_mouse_event_handler(usb_tablet_event, hs,
usb-hid.c:	s->mouse_grabbed = 1;
usb-hid.c:    dz = int_clamp(s->dz, -127, 127);
usb-hid.c:    s->dz -= dz;
usb-hid.c:    dz = 0 - dz;
usb-hid.c:    if (s->buttons_state & MOUSE_EVENT_LBUTTON)
usb-hid.c:    if (s->buttons_state & MOUSE_EVENT_RBUTTON)
usb-hid.c:    if (s->buttons_state & MOUSE_EVENT_MBUTTON)
usb-hid.c:    buf[1] = s->x & 0xff;
usb-hid.c:    buf[2] = s->x >> 8;
usb-hid.c:    buf[3] = s->y & 0xff;
usb-hid.c:    buf[4] = s->y >> 8;
usb-hid.c:    buf[0] = s->modifiers & 0xff;
usb-hid.c:    if (s->keys > 6)
usb-hid.c:        memset(buf + 2, USB_HID_USAGE_ERROR_ROLLOVER, MIN(8, len) - 2);
usb-hid.c:        memcpy(buf + 2, s->key, MIN(8, len) - 2);
usb-hid.c:        s->leds = buf[0];
usb-hid.c:    s->ptr.dx = 0;
usb-hid.c:    s->ptr.dy = 0;
usb-hid.c:    s->ptr.dz = 0;
usb-hid.c:    s->ptr.x = 0;
usb-hid.c:    s->ptr.y = 0;
usb-hid.c:    s->ptr.buttons_state = 0;
usb-hid.c:    s->protocol = 1;
usb-hid.c:    s->protocol = 1;
usb-hid.c:            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-hid.c:            dev->remote_wakeup = 0;
usb-hid.c:            dev->remote_wakeup = 1;
usb-hid.c:        dev->addr = value;
usb-hid.c:	    if (s->kind == USB_MOUSE) {
usb-hid.c:	    } else if (s->kind == USB_TABLET) {
usb-hid.c:            } else if (s->kind == USB_KEYBOARD) {
usb-hid.c:                ret = set_usb_string(data, s->dev.product_desc);
usb-hid.c:	    if (s->kind == USB_MOUSE) {
usb-hid.c:	    } else if (s->kind == USB_TABLET) {
usb-hid.c:            } else if (s->kind == USB_KEYBOARD) {
usb-hid.c:	if (s->kind == USB_MOUSE)
usb-hid.c:	else if (s->kind == USB_TABLET)
usb-hid.c:        else if (s->kind == USB_KEYBOARD)
usb-hid.c:            ret = usb_keyboard_poll(&s->kbd, data, length);
usb-hid.c:        if (s->kind == USB_KEYBOARD)
usb-hid.c:            ret = usb_keyboard_write(&s->kbd, data, length);
usb-hid.c:        if (s->kind != USB_KEYBOARD)
usb-hid.c:        data[0] = s->protocol;
usb-hid.c:        if (s->kind != USB_KEYBOARD)
usb-hid.c:        s->protocol = value;
usb-hid.c:        data[0] = s->idle;
usb-hid.c:        s->idle = (uint8_t) (value >> 8);
usb-hid.c:    switch(p->pid) {
usb-hid.c:        if (p->devep == 1) {
usb-hid.c:            if (!(s->changed || s->idle))
usb-hid.c:            s->changed = 0;
usb-hid.c:            if (s->kind == USB_MOUSE)
usb-hid.c:                ret = usb_mouse_poll(s, p->data, p->len);
usb-hid.c:            else if (s->kind == USB_TABLET)
usb-hid.c:                ret = usb_tablet_poll(s, p->data, p->len);
usb-hid.c:            else if (s->kind == USB_KEYBOARD)
usb-hid.c:                ret = usb_keyboard_poll(&s->kbd, p->data, p->len);
usb-hid.c:    if (s->kind != USB_KEYBOARD)
usb-hid.c:        qemu_remove_mouse_event_handler(s->ptr.eh_entry);
usb-hid.c:    s->dev.speed = USB_SPEED_FULL;
usb-hid.c:    s->kind = kind;
usb-hid.c:    s->changed = 1;
usb-hid.c:    s->datain_opaque = opaque;
usb-hid.c:    s->datain = datain;
usb-hid.c:        .qdev.name      = "usb-tablet",
usb-hid.c:        .qdev.name      = "usb-mouse",
usb-hid.c:        .qdev.name      = "usb-kbd",
usb-hub.c:#include "qemu-common.h"
usb-hub.c:				     6: Self-powered,
usb-hub.c:	0xff        /*  u8  ep_bInterval; (255ms -- usb 2.0 spec) */
usb-hub.c:	0x29,			/*  u8  bDescriptorType; Hub-descriptor */
usb-hub.c:	0x00,			/*   (per-port OC, no power switching) */
usb-hub.c:    USBHubState *s = port1->opaque;
usb-hub.c:    USBHubPort *port = &s->ports[port1->index];
usb-hub.c:        if (port->port.dev)
usb-hub.c:        port->wPortStatus |= PORT_STAT_CONNECTION;
usb-hub.c:        port->wPortChange |= PORT_STAT_C_CONNECTION;
usb-hub.c:        if (dev->speed == USB_SPEED_LOW)
usb-hub.c:            port->wPortStatus |= PORT_STAT_LOW_SPEED;
usb-hub.c:            port->wPortStatus &= ~PORT_STAT_LOW_SPEED;
usb-hub.c:        port->port.dev = dev;
usb-hub.c:        dev = port->port.dev;
usb-hub.c:            port->wPortStatus &= ~PORT_STAT_CONNECTION;
usb-hub.c:            port->wPortChange |= PORT_STAT_C_CONNECTION;
usb-hub.c:            if (port->wPortStatus & PORT_STAT_ENABLE) {
usb-hub.c:                port->wPortStatus &= ~PORT_STAT_ENABLE;
usb-hub.c:                port->wPortChange |= PORT_STAT_C_ENABLE;
usb-hub.c:            port->port.dev = NULL;
usb-hub.c:            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-hub.c:            dev->remote_wakeup = 0;
usb-hub.c:            dev->remote_wakeup = 1;
usb-hub.c:        dev->addr = value;
usb-hub.c:            data[22] = (s->nb_ports + 1 + 7) / 8;
usb-hub.c:            unsigned int n = index - 1;
usb-hub.c:            if (n >= s->nb_ports)
usb-hub.c:            port = &s->ports[n];
usb-hub.c:            data[0] = port->wPortStatus;
usb-hub.c:            data[1] = port->wPortStatus >> 8;
usb-hub.c:            data[2] = port->wPortChange;
usb-hub.c:            data[3] = port->wPortChange >> 8;
usb-hub.c:            unsigned int n = index - 1;
usb-hub.c:            if (n >= s->nb_ports)
usb-hub.c:            port = &s->ports[n];
usb-hub.c:            dev = port->port.dev;
usb-hub.c:                port->wPortStatus |= PORT_STAT_SUSPEND;
usb-hub.c:                    port->wPortChange |= PORT_STAT_C_RESET;
usb-hub.c:                    port->wPortStatus |= PORT_STAT_ENABLE;
usb-hub.c:            unsigned int n = index - 1;
usb-hub.c:            if (n >= s->nb_ports)
usb-hub.c:            port = &s->ports[n];
usb-hub.c:            dev = port->port.dev;
usb-hub.c:                port->wPortStatus &= ~PORT_STAT_ENABLE;
usb-hub.c:                port->wPortChange &= ~PORT_STAT_C_ENABLE;
usb-hub.c:                port->wPortStatus &= ~PORT_STAT_SUSPEND;
usb-hub.c:                port->wPortChange &= ~PORT_STAT_C_SUSPEND;
usb-hub.c:                port->wPortChange &= ~PORT_STAT_C_CONNECTION;
usb-hub.c:                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;
usb-hub.c:                port->wPortChange &= ~PORT_STAT_C_RESET;
usb-hub.c:            data[2] = s->nb_ports;
usb-hub.c:            limit = ((s->nb_ports + 1 + 7) / 8) + 7;
usb-hub.c:            limit = limit + ((s->nb_ports + 7) / 8);
usb-hub.c:    switch(p->pid) {
usb-hub.c:        if (p->devep == 1) {
usb-hub.c:            n = (s->nb_ports + 1 + 7) / 8;
usb-hub.c:            if (p->len == 1) { /* FreeBSD workaround */
usb-hub.c:            } else if (n > p->len) {
usb-hub.c:            for(i = 0; i < s->nb_ports; i++) {
usb-hub.c:                port = &s->ports[i];
usb-hub.c:                if (port->wPortChange)
usb-hub.c:                    p->data[i] = status >> (8 * i);
usb-hub.c:    for(i = 0; i < s->nb_ports; i++) {
usb-hub.c:        port = &s->ports[i];
usb-hub.c:        dev = port->port.dev;
usb-hub.c:        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {
usb-hub.c:            ret = dev->info->handle_packet(dev, p);
usb-hub.c:    if (dev->state == USB_STATE_DEFAULT &&
usb-hub.c:        dev->addr != 0 &&
usb-hub.c:        p->devaddr != dev->addr &&
usb-hub.c:        (p->pid == USB_TOKEN_SETUP ||
usb-hub.c:         p->pid == USB_TOKEN_OUT ||
usb-hub.c:         p->pid == USB_TOKEN_IN)) {
usb-hub.c:    for (i = 0; i < s->nb_ports; i++) {
usb-hub.c:                            &s->ports[i].port);
usb-hub.c:    s->dev.speed  = USB_SPEED_FULL,
usb-hub.c:    s->nb_ports = MAX_PORTS; /* FIXME: make configurable */
usb-hub.c:    for (i = 0; i < s->nb_ports; i++) {
usb-hub.c:        port = &s->ports[i];
usb-hub.c:                          &port->port, s, i, usb_hub_attach);
usb-hub.c:        port->wPortStatus = PORT_STAT_POWER;
usb-hub.c:        port->wPortChange = 0;
usb-hub.c:    .qdev.name      = "usb-hub",
usb-msd.c:#include "qemu-common.h"
usb-msd.c:#include "qemu-option.h"
usb-msd.c:#include "qemu-config.h"
usb-msd.c:do { printf("usb-msd: " fmt , ## __VA_ARGS__); } while (0)
usb-msd.c:				     6: Self-powered,
usb-msd.c:	/* Bulk-In endpoint */
usb-msd.c:	/* Bulk-Out endpoint */
usb-msd.c:    len = s->usb_len;
usb-msd.c:    if (len > s->scsi_len)
usb-msd.c:        len = s->scsi_len;
usb-msd.c:    if (s->mode == USB_MSDM_DATAIN) {
usb-msd.c:        memcpy(s->usb_buf, s->scsi_buf, len);
usb-msd.c:        memcpy(s->scsi_buf, s->usb_buf, len);
usb-msd.c:    s->usb_len -= len;
usb-msd.c:    s->scsi_len -= len;
usb-msd.c:    s->usb_buf += len;
usb-msd.c:    s->scsi_buf += len;
usb-msd.c:    s->data_len -= len;
usb-msd.c:    if (s->scsi_len == 0) {
usb-msd.c:        if (s->mode == USB_MSDM_DATAIN) {
usb-msd.c:            s->scsi_dev->info->read_data(s->scsi_dev, s->tag);
usb-msd.c:        } else if (s->mode == USB_MSDM_DATAOUT) {
usb-msd.c:            s->scsi_dev->info->write_data(s->scsi_dev, s->tag);
usb-msd.c:    csw.tag = cpu_to_le32(s->tag);
usb-msd.c:    csw.residue = s->residue;
usb-msd.c:    csw.status = s->result;
usb-msd.c:    memcpy(s->usb_buf, &csw, 13);
usb-msd.c:    MSDState *s = DO_UPCAST(MSDState, dev.qdev, bus->qbus.parent);
usb-msd.c:    USBPacket *p = s->packet;
usb-msd.c:    if (tag != s->tag) {
usb-msd.c:        fprintf(stderr, "usb-msd: Unexpected SCSI Tag 0x%x\n", tag);
usb-msd.c:        s->residue = s->data_len;
usb-msd.c:        s->result = arg != 0;
usb-msd.c:        if (s->packet) {
usb-msd.c:            if (s->data_len == 0 && s->mode == USB_MSDM_DATAOUT) {
usb-msd.c:                s->mode = USB_MSDM_CBW;
usb-msd.c:                if (s->data_len) {
usb-msd.c:                    s->data_len -= s->usb_len;
usb-msd.c:                    if (s->mode == USB_MSDM_DATAIN)
usb-msd.c:                        memset(s->usb_buf, 0, s->usb_len);
usb-msd.c:                    s->usb_len = 0;
usb-msd.c:                if (s->data_len == 0)
usb-msd.c:                    s->mode = USB_MSDM_CSW;
usb-msd.c:            s->packet = NULL;
usb-msd.c:        } else if (s->data_len == 0) {
usb-msd.c:            s->mode = USB_MSDM_CSW;
usb-msd.c:    s->scsi_len = arg;
usb-msd.c:    s->scsi_buf = s->scsi_dev->info->get_buf(s->scsi_dev, tag);
usb-msd.c:        if (s->usb_len == 0) {
usb-msd.c:            /* Set s->packet to NULL before calling usb_packet_complete
usb-msd.c:            s->packet = NULL;
usb-msd.c:    s->mode = USB_MSDM_CBW;
usb-msd.c:            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-msd.c:            dev->remote_wakeup = 0;
usb-msd.c:            dev->remote_wakeup = 1;
usb-msd.c:        dev->addr = value;
usb-msd.c:        s->mode = USB_MSDM_CBW;
usb-msd.c:    s->scsi_dev->info->cancel_io(s->scsi_dev, s->tag);
usb-msd.c:    s->packet = NULL;
usb-msd.c:    s->scsi_len = 0;
usb-msd.c:    uint8_t devep = p->devep;
usb-msd.c:    uint8_t *data = p->data;
usb-msd.c:    int len = p->len;
usb-msd.c:    switch (p->pid) {
usb-msd.c:        switch (s->mode) {
usb-msd.c:                fprintf(stderr, "usb-msd: Bad CBW size");
usb-msd.c:                fprintf(stderr, "usb-msd: Bad signature %08x\n",
usb-msd.c:                fprintf(stderr, "usb-msd: Bad LUN %d\n", cbw.lun);
usb-msd.c:            s->tag = le32_to_cpu(cbw.tag);
usb-msd.c:            s->data_len = le32_to_cpu(cbw.data_len);
usb-msd.c:            if (s->data_len == 0) {
usb-msd.c:                s->mode = USB_MSDM_CSW;
usb-msd.c:                s->mode = USB_MSDM_DATAIN;
usb-msd.c:                s->mode = USB_MSDM_DATAOUT;
usb-msd.c:                    s->tag, cbw.flags, cbw.cmd_len, s->data_len);
usb-msd.c:            s->residue = 0;
usb-msd.c:            s->scsi_dev->info->send_command(s->scsi_dev, s->tag, cbw.cmd, 0);
usb-msd.c:            if (s->residue == 0) {
usb-msd.c:                if (s->mode == USB_MSDM_DATAIN) {
usb-msd.c:                    s->scsi_dev->info->read_data(s->scsi_dev, s->tag);
usb-msd.c:                } else if (s->mode == USB_MSDM_DATAOUT) {
usb-msd.c:                    s->scsi_dev->info->write_data(s->scsi_dev, s->tag);
usb-msd.c:            DPRINTF("Data out %d/%d\n", len, s->data_len);
usb-msd.c:            if (len > s->data_len)
usb-msd.c:            s->usb_buf = data;
usb-msd.c:            s->usb_len = len;
usb-msd.c:            if (s->scsi_len) {
usb-msd.c:            if (s->residue && s->usb_len) {
usb-msd.c:                s->data_len -= s->usb_len;
usb-msd.c:                if (s->data_len == 0)
usb-msd.c:                    s->mode = USB_MSDM_CSW;
usb-msd.c:                s->usb_len = 0;
usb-msd.c:            if (s->usb_len) {
usb-msd.c:                s->packet = p;
usb-msd.c:        switch (s->mode) {
usb-msd.c:            if (s->data_len != 0 || len < 13)
usb-msd.c:            s->packet = p;
usb-msd.c:                    s->result, s->tag, len);
usb-msd.c:            s->usb_len = len;
usb-msd.c:            s->usb_buf = data;
usb-msd.c:            s->mode = USB_MSDM_CBW;
usb-msd.c:            DPRINTF("Data in %d/%d\n", len, s->data_len);
usb-msd.c:            if (len > s->data_len)
usb-msd.c:                len = s->data_len;
usb-msd.c:            s->usb_buf = data;
usb-msd.c:            s->usb_len = len;
usb-msd.c:            if (s->scsi_len) {
usb-msd.c:            if (s->residue && s->usb_len) {
usb-msd.c:                s->data_len -= s->usb_len;
usb-msd.c:                memset(s->usb_buf, 0, s->usb_len);
usb-msd.c:                if (s->data_len == 0)
usb-msd.c:                    s->mode = USB_MSDM_CSW;
usb-msd.c:                s->usb_len = 0;
usb-msd.c:            if (s->usb_len) {
usb-msd.c:                s->packet = p;
usb-msd.c:        usb_device_attach(&s->dev);
usb-msd.c:        qdev_unplug(&s->dev.qdev);
usb-msd.c:    if (!s->dinfo || !s->dinfo->bdrv) {
usb-msd.c:        qemu_error("usb-msd: drive property not set\n");
usb-msd.c:        return -1;
usb-msd.c:    s->dev.speed = USB_SPEED_FULL;
usb-msd.c:    scsi_bus_new(&s->bus, &s->dev.qdev, 0, 1, usb_msd_command_complete);
usb-msd.c:    s->scsi_dev = scsi_bus_legacy_add_drive(&s->bus, s->dinfo, 0);
usb-msd.c:    s->bus.qbus.allow_hotplug = 0;
usb-msd.c:    if (bdrv_key_required(s->dinfo->bdrv)) {
usb-msd.c:        if (s->dev.qdev.hotplugged) {
usb-msd.c:            monitor_read_bdrv_key_start(cur_mon, s->dinfo->bdrv,
usb-msd.c:            s->dev.auto_attach = 0;
usb-msd.c:    /* parse -usbdevice disk: syntax into drive opts */
usb-msd.c:            int len = MIN(p1 - p2, sizeof(fmt));
usb-msd.c:            printf("unrecognized USB mass-storage option %s\n", filename);
usb-msd.c:    dev = usb_create(NULL /* FIXME */, "usb-storage");
usb-msd.c:    qdev_prop_set_drive(&dev->qdev, "drive", dinfo);
usb-msd.c:    if (qdev_init(&dev->qdev) < 0)
usb-msd.c:    .qdev.name      = "usb-storage",
usb-musb.c: * "Inventra" High-speed Dual-Role Controller (MUSB-HDRC), Mentor Graphics,
usb-musb.c: * Only host-mode and non-DMA accesses are currently supported.
usb-musb.c:#include "qemu-common.h"
usb-musb.c:#include "qemu-timer.h"
usb-musb.c:#define MUSB_HDRC_FADDR		0x00	/* 8-bit */
usb-musb.c:#define MUSB_HDRC_POWER		0x01	/* 8-bit */
usb-musb.c:#define MUSB_HDRC_INTRTX	0x02	/* 16-bit */
usb-musb.c:#define MUSB_HDRC_FRAME		0x0c	/* 16-bit */
usb-musb.c:/* Per-EP registers in indexed mode */
usb-musb.c:#define MUSB_HDRC_EP_IDX	0x10	/* 8-bit */
usb-musb.c:/* ULPI pass-through */
usb-musb.c:/* Per-EP BUSCTL registers */
usb-musb.c:/* Per-EP registers in flat mode */
usb-musb.c:#define MUSB_HDRC_CSR0		MUSB_HDRC_TXCSR		/* re-used for EP0 */
usb-musb.c:#define MUSB_HDRC_COUNT0	MUSB_HDRC_RXCOUNT	/* re-used for EP0 */
usb-musb.c:#define MUSB_HDRC_TYPE0		MUSB_HDRC_TXTYPE	/* re-used for EP0 */
usb-musb.c:#define MUSB_HDRC_NAKLIMIT0	MUSB_HDRC_TXINTERVAL	/* re-used for EP0 */
usb-musb.c:#define MUSB_HDRC_CONFIGDATA	MGC_O_HDRC_FIFOSIZE	/* re-used for EP0 */
usb-musb.c:#define MGC_M_CONFIGDATA_HBRXE		0x10	/* HB-ISO for RX */
usb-musb.c:#define MGC_M_CONFIGDATA_HBTXE		0x08	/* HB-ISO for TX */
usb-musb.c:    s->irqs = irqs;
usb-musb.c:    s->faddr = 0x00;
usb-musb.c:    s->power = MGC_M_POWER_HSENAB;
usb-musb.c:    s->tx_intr = 0x0000;
usb-musb.c:    s->rx_intr = 0x0000;
usb-musb.c:    s->tx_mask = 0xffff;
usb-musb.c:    s->rx_mask = 0xffff;
usb-musb.c:    s->intr = 0x00;
usb-musb.c:    s->mask = 0x06;
usb-musb.c:    s->idx = 0;
usb-musb.c:    s->ep[0].config = MGC_M_CONFIGDATA_SOFTCONE | MGC_M_CONFIGDATA_DYNFIFO;
usb-musb.c:        s->ep[i].fifosize = 64;
usb-musb.c:        s->ep[i].maxp[0] = 0x40;
usb-musb.c:        s->ep[i].maxp[1] = 0x40;
usb-musb.c:        s->ep[i].musb = s;
usb-musb.c:        s->ep[i].epnum = i;
usb-musb.c:    usb_bus_new(&s->bus, NULL /* FIXME */);
usb-musb.c:    usb_register_port(&s->bus, &s->port, s, 0, musb_attach);
usb-musb.c:        s->devctl |= 3 << MGC_S_DEVCTL_VBUS;
usb-musb.c:        s->devctl &= ~MGC_M_DEVCTL_VBUS;
usb-musb.c:    qemu_set_irq(s->irqs[musb_set_vbus], level);
usb-musb.c:        s->intr &= ~(1 << line);
usb-musb.c:        qemu_irq_lower(s->irqs[line]);
usb-musb.c:    } else if (s->mask & (1 << line)) {
usb-musb.c:        s->intr |= 1 << line;
usb-musb.c:        qemu_irq_raise(s->irqs[line]);
usb-musb.c:        s->tx_intr &= ~(1 << line);
usb-musb.c:        if (!s->tx_intr)
usb-musb.c:            qemu_irq_lower(s->irqs[musb_irq_tx]);
usb-musb.c:    } else if (s->tx_mask & (1 << line)) {
usb-musb.c:        s->tx_intr |= 1 << line;
usb-musb.c:        qemu_irq_raise(s->irqs[musb_irq_tx]);
usb-musb.c:            s->rx_intr &= ~(1 << line);
usb-musb.c:            if (!s->rx_intr)
usb-musb.c:                qemu_irq_lower(s->irqs[musb_irq_rx]);
usb-musb.c:        } else if (s->rx_mask & (1 << line)) {
usb-musb.c:            s->rx_intr |= 1 << line;
usb-musb.c:            qemu_irq_raise(s->irqs[musb_irq_rx]);
usb-musb.c:    return (s->rx_intr << 15) | s->tx_intr;
usb-musb.c:    if (s->rx_intr) {
usb-musb.c:        s->rx_intr &= mask >> 15;
usb-musb.c:        if (!s->rx_intr)
usb-musb.c:            qemu_irq_lower(s->irqs[musb_irq_rx]);
usb-musb.c:    if (s->tx_intr) {
usb-musb.c:        s->tx_intr &= mask & 0xffff;
usb-musb.c:        if (!s->tx_intr)
usb-musb.c:            qemu_irq_lower(s->irqs[musb_irq_tx]);
usb-musb.c:    s->ep[epnum].ext_size[!is_tx] = size;
usb-musb.c:    s->ep[epnum].fifostart[0] = 0;
usb-musb.c:    s->ep[epnum].fifostart[1] = 0;
usb-musb.c:    s->ep[epnum].fifolen[0] = 0;
usb-musb.c:    s->ep[epnum].fifolen[1] = 0;
usb-musb.c:    int detect = !!s->port.dev && s->session;
usb-musb.c:        if (s->port.dev->speed == USB_SPEED_LOW) {
usb-musb.c:            s->devctl &= ~MGC_M_DEVCTL_FSDEV;
usb-musb.c:            s->devctl |= MGC_M_DEVCTL_LSDEV;
usb-musb.c:            s->devctl |= MGC_M_DEVCTL_FSDEV;
usb-musb.c:            s->devctl &= ~MGC_M_DEVCTL_LSDEV;
usb-musb.c:        /* A-mode?  */
usb-musb.c:        s->devctl &= ~MGC_M_DEVCTL_BDEVICE;
usb-musb.c:        /* Host-mode bit?  */
usb-musb.c:        s->devctl |= MGC_M_DEVCTL_HM;
usb-musb.c:    MUSBState *s = (MUSBState *) port->opaque;
usb-musb.c:    port = &s->port;
usb-musb.c:    curr = port->dev;
usb-musb.c:    port->dev = dev;
usb-musb.c:    musb_session_update(s, !!curr, s->session);
usb-musb.c:    ep->delayed_cb[0](&ep->packey[0], opaque);
usb-musb.c:    ep->delayed_cb[1](&ep->packey[1], opaque);
usb-musb.c:    if (ep->status[dir] == USB_RET_NAK)
usb-musb.c:        timeout = ep->timeout[dir];
usb-musb.c:    else if (ep->interrupt[dir])
usb-musb.c:    if (!ep->intv_timer[dir])
usb-musb.c:        ep->intv_timer[dir] = qemu_new_timer(vm_clock, musb_cb_tick, opaque);
usb-musb.c:    qemu_mod_timer(ep->intv_timer[dir], qemu_get_clock(vm_clock) +
usb-musb.c:            return 1 << (val - 1);
usb-musb.c:            return 8 << (val - 1);
usb-musb.c:                return 1 << (val - 1);
usb-musb.c:            return 1 << (val - 1);
usb-musb.c:            return 8 << (val - 1);
usb-musb.c:        /* TODO: what with low-speed Bulk and Isochronous?  */
usb-musb.c:    /* ep->type[0,1] contains:
usb-musb.c:     * in bits 7:6 the speed (0 - invalid, 1 - high, 2 - full, 3 - slow)
usb-musb.c:    ttype = epnum ? (ep->type[idx] >> 4) & 3 : 0;
usb-musb.c:    ep->timeout[dir] = musb_timeout(ttype,
usb-musb.c:                    ep->type[idx] >> 6, ep->interval[idx]);
usb-musb.c:    ep->interrupt[dir] = ttype == USB_ENDPOINT_XFER_INT;
usb-musb.c:    ep->delayed_cb[dir] = cb;
usb-musb.c:    ep->packey[dir].pid = pid;
usb-musb.c:    ep->packey[dir].devaddr = ep->faddr[idx];
usb-musb.c:    ep->packey[dir].devep = ep->type[idx] & 0xf;
usb-musb.c:    ep->packey[dir].data = (void *) ep->buf[idx];
usb-musb.c:    ep->packey[dir].len = len;
usb-musb.c:    ep->packey[dir].complete_cb = cb;
usb-musb.c:    ep->packey[dir].complete_opaque = ep;
usb-musb.c:    if (s->port.dev)
usb-musb.c:        ret = s->port.dev->info->handle_packet(s->port.dev, &ep->packey[dir]);
usb-musb.c:        ep->status[dir] = len;
usb-musb.c:    ep->status[dir] = ret;
usb-musb.c:    usb_packet_complete(&ep->packey[dir]);
usb-musb.c:    /* Unfortunately we can't use packey->devep because that's the remote
usb-musb.c:    int epnum = ep->epnum;
usb-musb.c:    MUSBState *s = ep->musb;
usb-musb.c:    ep->fifostart[0] = 0;
usb-musb.c:    ep->fifolen[0] = 0;
usb-musb.c:    if (ep->status[0] != USB_RET_NAK) {
usb-musb.c:            ep->csr[0] &= ~(MGC_M_TXCSR_FIFONOTEMPTY | MGC_M_TXCSR_TXPKTRDY);
usb-musb.c:            ep->csr[0] &= ~MGC_M_CSR0_TXPKTRDY;
usb-musb.c:        ep->csr[0] &= ~(MGC_M_TXCSR_H_ERROR | MGC_M_TXCSR_H_RXSTALL |
usb-musb.c:        ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL |
usb-musb.c:    if (ep->status[0] == USB_RET_STALL) {
usb-musb.c:        ep->status[0] = 0;
usb-musb.c:            ep->csr[0] |= MGC_M_TXCSR_H_RXSTALL;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_H_RXSTALL;
usb-musb.c:    if (ep->status[0] == USB_RET_NAK) {
usb-musb.c:        ep->status[0] = 0;
usb-musb.c:         * Data-errors in Isochronous.  */
usb-musb.c:        if (ep->interrupt[0]) {
usb-musb.c:            ep->csr[0] |= MGC_M_TXCSR_H_NAKTIMEOUT;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_H_NAKTIMEOUT;
usb-musb.c:    if (ep->status[0] < 0) {
usb-musb.c:        if (ep->status[0] == USB_RET_BABBLE)
usb-musb.c:            ep->csr[0] |= MGC_M_TXCSR_H_ERROR;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_H_ERROR;
usb-musb.c:    if (!epnum && ep->packey[0].pid == USB_TOKEN_SETUP)
usb-musb.c:        s->setup_len = ep->packey[0].data[6];
usb-musb.c:    /* Unfortunately we can't use packey->devep because that's the remote
usb-musb.c:    int epnum = ep->epnum;
usb-musb.c:    MUSBState *s = ep->musb;
usb-musb.c:    ep->fifostart[1] = 0;
usb-musb.c:    ep->fifolen[1] = 0;
usb-musb.c:    if (ep->status[1] != USB_RET_NAK) {
usb-musb.c:        ep->csr[1] &= ~MGC_M_RXCSR_H_REQPKT;
usb-musb.c:            ep->csr[0] &= ~MGC_M_CSR0_H_REQPKT;
usb-musb.c:    ep->csr[1] &= ~(MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_H_RXSTALL |
usb-musb.c:        ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL |
usb-musb.c:    if (ep->status[1] == USB_RET_STALL) {
usb-musb.c:        ep->status[1] = 0;
usb-musb.c:        packey->len = 0;
usb-musb.c:        ep->csr[1] |= MGC_M_RXCSR_H_RXSTALL;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_H_RXSTALL;
usb-musb.c:    if (ep->status[1] == USB_RET_NAK) {
usb-musb.c:        ep->status[1] = 0;
usb-musb.c:         * Data-errors in Isochronous.  */
usb-musb.c:        if (ep->interrupt[1])
usb-musb.c:                            packey->len, musb_rx_packet_complete, 1);
usb-musb.c:        ep->csr[1] |= MGC_M_RXCSR_DATAERROR;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_H_NAKTIMEOUT;
usb-musb.c:    if (ep->status[1] < 0) {
usb-musb.c:        if (ep->status[1] == USB_RET_BABBLE) {
usb-musb.c:        ep->csr[1] |= MGC_M_RXCSR_H_ERROR;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_H_ERROR;
usb-musb.c:    /* TODO: perhaps make use of e->ext_size[1] here.  */
usb-musb.c:    packey->len = ep->status[1];
usb-musb.c:    if (!(ep->csr[1] & (MGC_M_RXCSR_H_RXSTALL | MGC_M_RXCSR_DATAERROR))) {
usb-musb.c:        ep->csr[1] |= MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_RXPKTRDY;
usb-musb.c:        ep->rxcount = packey->len; /* XXX: MIN(packey->len, ep->maxp[1]); */
usb-musb.c:    MUSBEndPoint *ep = s->ep + epnum;
usb-musb.c:    ep->fifostart[0] += ep->fifolen[0];
usb-musb.c:    ep->fifolen[0] = 0;
usb-musb.c:    total = ep->maxp[0] & 0x3ff;
usb-musb.c:    if (ep->ext_size[0]) {
usb-musb.c:        total = ep->ext_size[0];
usb-musb.c:        ep->ext_size[0] = 0;
usb-musb.c:    if (epnum && (ep->fifostart[0] << 2) < total)
usb-musb.c:        total = ep->fifostart[0] << 2;
usb-musb.c:    if (!epnum && (ep->csr[0] & MGC_M_CSR0_H_SETUPPKT)) {
usb-musb.c:    MUSBEndPoint *ep = s->ep + epnum;
usb-musb.c:    if (ep->packey[1].pid == USB_TOKEN_IN && ep->status[1] >= 0 &&
usb-musb.c:                    (ep->fifostart[1] << 2) + ep->rxcount <
usb-musb.c:                    ep->packey[1].len) {
usb-musb.c:        ep->fifostart[1] += ep->rxcount >> 2;
usb-musb.c:        ep->fifolen[1] = 0;
usb-musb.c:        ep->rxcount = MIN(ep->packey[0].len - (ep->fifostart[1] << 2),
usb-musb.c:                        ep->maxp[1]);
usb-musb.c:        ep->csr[1] &= ~MGC_M_RXCSR_H_REQPKT;
usb-musb.c:            ep->csr[0] &= ~MGC_M_CSR0_H_REQPKT;
usb-musb.c:        ep->csr[1] &= ~(MGC_M_RXCSR_H_ERROR | MGC_M_RXCSR_H_RXSTALL |
usb-musb.c:            ep->csr[0] &= ~(MGC_M_CSR0_H_ERROR | MGC_M_CSR0_H_RXSTALL |
usb-musb.c:        ep->csr[1] |= MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY;
usb-musb.c:            ep->csr[0] |= MGC_M_CSR0_RXPKTRDY;
usb-musb.c:     * ignore the limit set in ep->maxp[1].  The Linux MUSB driver deals
usb-musb.c:     * XXX: mind ep->fifosize.  */
usb-musb.c:    total = MIN(ep->maxp[1] & 0x3ff, sizeof(s->buf));
usb-musb.c:        if (ep->packey[0].devaddr == 2)
usb-musb.c:            total = MIN(s->setup_len, 8);
usb-musb.c:            total = MIN(s->setup_len, 64);
usb-musb.c:        s->setup_len -= total;
usb-musb.c:    if (ep->intv_timer[dir])
usb-musb.c:        qemu_del_timer(ep->intv_timer[dir]);
usb-musb.c:        return s->ep[ep].haddr[0];
usb-musb.c:        return s->ep[ep].hport[0];
usb-musb.c:        return s->ep[ep].haddr[1];
usb-musb.c:        return s->ep[ep].hport[1];
usb-musb.c:        s->ep[ep].haddr[0] = value;
usb-musb.c:        s->ep[ep].hport[0] = value;
usb-musb.c:        s->ep[ep].haddr[1] = value;
usb-musb.c:        s->ep[ep].hport[1] = value;
usb-musb.c:        return s->ep[ep].faddr[0];
usb-musb.c:        return s->ep[ep].faddr[1];
usb-musb.c:        s->ep[ep].faddr[0] = value;
usb-musb.c:        s->ep[ep].faddr[1] = value;
usb-musb.c:        return s->ep[ep].type[0];
usb-musb.c:        return s->ep[ep].interval[0];
usb-musb.c:        return s->ep[ep].type[1];
usb-musb.c:        return s->ep[ep].interval[1];
usb-musb.c:        return ep ? s->ep[ep].fifosize : s->ep[ep].config;
usb-musb.c:        s->ep[ep].type[0] = value;
usb-musb.c:        s->ep[ep].interval[0] = value;
usb-musb.c:        musb_ep_frame_cancel(&s->ep[ep], 0);
usb-musb.c:        s->ep[ep].type[1] = value;
usb-musb.c:        s->ep[ep].interval[1] = value;
usb-musb.c:        musb_ep_frame_cancel(&s->ep[ep], 1);
usb-musb.c:        s->ep[ep].fifosize = value;
usb-musb.c:        return s->ep[ep].maxp[0];
usb-musb.c:        return s->ep[ep].csr[0];
usb-musb.c:        return s->ep[ep].maxp[1];
usb-musb.c:        ret = s->ep[ep].csr[1];
usb-musb.c:         * ep->csr[1] & MGC_M_RXCSR_AUTOCLEAR.  */
usb-musb.c:        if (s->ep[ep].csr[1] & MGC_M_RXCSR_AUTOCLEAR)
usb-musb.c:            s->ep[ep].csr[1] &= ~MGC_M_RXCSR_RXPKTRDY;
usb-musb.c:        return s->ep[ep].rxcount;
usb-musb.c:        s->ep[ep].maxp[0] = value;
usb-musb.c:            s->ep[ep].csr[0] &= value & 0xa6;
usb-musb.c:            s->ep[ep].csr[0] |= value & 0xff59;
usb-musb.c:            s->ep[ep].csr[0] &= value & 0x85;
usb-musb.c:            s->ep[ep].csr[0] |= value & 0xf7a;
usb-musb.c:        musb_ep_frame_cancel(&s->ep[ep], 0);
usb-musb.c:            s->ep[ep].fifolen[0] = 0;
usb-musb.c:            s->ep[ep].fifostart[0] = 0;
usb-musb.c:                s->ep[ep].csr[0] &=
usb-musb.c:                s->ep[ep].csr[0] &=
usb-musb.c:        s->ep[ep].maxp[1] = value;
usb-musb.c:                (s->ep[ep].csr[1] & MGC_M_RXCSR_RXPKTRDY))
usb-musb.c:        s->ep[ep].csr[1] &= 0x102 | (value & 0x4d);
usb-musb.c:        s->ep[ep].csr[1] |= value & 0xfeb0;
usb-musb.c:        musb_ep_frame_cancel(&s->ep[ep], 1);
usb-musb.c:            s->ep[ep].fifolen[1] = 0;
usb-musb.c:            s->ep[ep].fifostart[1] = 0;
usb-musb.c:            s->ep[ep].csr[1] &= ~(MGC_M_RXCSR_FIFOFULL | MGC_M_RXCSR_RXPKTRDY);
usb-musb.c:        s->ep[ep].rxcount = value;
usb-musb.c:        return s->faddr;
usb-musb.c:        return s->power;
usb-musb.c:        ret = s->intr;
usb-musb.c:        return s->mask;
usb-musb.c:        return s->idx;
usb-musb.c:        return musb_ep_readb(s, s->idx, addr & 0xf);
usb-musb.c:        return s->devctl;
usb-musb.c:        s->faddr = value & 0x7f;
usb-musb.c:        s->power = (value & 0xef) | (s->power & 0x10);
usb-musb.c:        /* MGC_M_POWER_RESET is also read-only in Peripheral Mode */
usb-musb.c:        if ((value & MGC_M_POWER_RESET) && s->port.dev) {
usb-musb.c:            usb_send_msg(s->port.dev, USB_MSG_RESET);
usb-musb.c:            /* Negotiate high-speed operation if MGC_M_POWER_HSENAB is set.  */
usb-musb.c:                            s->port.dev->speed == USB_SPEED_HIGH)
usb-musb.c:                s->power |= MGC_M_POWER_HSMODE;	/* Success */
usb-musb.c:        s->mask = value & 0xff;
usb-musb.c:        s->idx = value & 0xf;
usb-musb.c:        musb_ep_writeb(s, s->idx, addr & 0xf, value);
usb-musb.c:        s->session = !!(value & MGC_M_DEVCTL_SESSION);
usb-musb.c:                        !!s->port.dev,
usb-musb.c:                        !!(s->devctl & MGC_M_DEVCTL_SESSION));
usb-musb.c:        s->devctl &= ~MGC_M_DEVCTL_SESSION;
usb-musb.c:        s->devctl |= value & MGC_M_DEVCTL_SESSION;
usb-musb.c:        ret = s->tx_intr;
usb-musb.c:        ret = s->rx_intr;
usb-musb.c:        return s->tx_mask;
usb-musb.c:        return s->rx_mask;
usb-musb.c:        return s->ep[s->idx].fifoaddr[0];
usb-musb.c:        return s->ep[s->idx].fifoaddr[1];
usb-musb.c:        return musb_ep_readh(s, s->idx, addr & 0xf);
usb-musb.c:        s->tx_mask = value;
usb-musb.c:         * edge-triggered interrupts, thus no need to update.  I may be
usb-musb.c:        s->rx_mask = value;
usb-musb.c:        s->ep[s->idx].fifoaddr[0] = value;
usb-musb.c:        s->ep[s->idx].buf[0] =
usb-musb.c:                s->buf + ((value << 1) & (sizeof(s->buf) / 4 - 1));
usb-musb.c:        s->ep[s->idx].fifoaddr[1] = value;
usb-musb.c:        s->ep[s->idx].buf[1] =
usb-musb.c:                s->buf + ((value << 1) & (sizeof(s->buf) / 4 - 1));
usb-musb.c:        musb_ep_writeh(s, s->idx, addr & 0xf, value);
usb-musb.c:        epnum = ((addr - MUSB_HDRC_FIFO) >> 2) & 0xf;
usb-musb.c:        ep = s->ep + epnum;
usb-musb.c:        if (ep->fifolen[1] >= 16) {
usb-musb.c:        ep->csr[1] &= ~MGC_M_RXCSR_FIFOFULL;
usb-musb.c:        return ep->buf[1][ep->fifostart[1] + ep->fifolen[1] ++];
usb-musb.c:        epnum = ((addr - MUSB_HDRC_FIFO) >> 2) & 0xf;
usb-musb.c:        ep = s->ep + epnum;
usb-musb.c:        if (ep->fifolen[0] >= 16) {
usb-musb.c:        ep->buf[0][ep->fifostart[0] + ep->fifolen[0] ++] = value;
usb-musb.c:            ep->csr[0] |= MGC_M_TXCSR_FIFONOTEMPTY;
usb-net.c:#include "qemu-common.h"
usb-net.c:#include "qemu-queue.h"
usb-net.c:#define CDC_PRODUCT_NUM         0xa4a1  /* Linux-USB Ethernet Gadget */
usb-net.c: * RNDIS Definitions - in theory not specific to USB.
usb-net.c:    /* general oids (table 4-1) */
usb-net.c:        *((le32 *) outbuf) = cpu_to_le32(s->medium);
usb-net.c:        *((le32 *) outbuf) = cpu_to_le32(s->medium);
usb-net.c:        *((le32 *) outbuf) = cpu_to_le32(s->speed);
usb-net.c:        *((le32 *) outbuf) = cpu_to_le32(s->vendorid);
usb-net.c:        *((le32 *) outbuf) = cpu_to_le32(s->filter);
usb-net.c:        *((le32 *) outbuf) = cpu_to_le32(s->media_state);
usb-net.c:    /* statistics OIDs (table 4-2) */
usb-net.c:    /* ieee802.3 OIDs (table 4-3) */
usb-net.c:        memcpy(outbuf, s->conf.macaddr.a, 6);
usb-net.c:        memcpy(outbuf, s->conf.macaddr.a, 6);
usb-net.c:    /* ieee802.3 statistics OIDs (table 4-4) */
usb-net.c:    return -1;
usb-net.c:        s->filter = le32_to_cpup((le32 *) inbuf);
usb-net.c:        if (s->filter) {
usb-net.c:            s->rndis_state = RNDIS_DATA_INITIALIZED;
usb-net.c:            s->rndis_state = RNDIS_INITIALIZED;
usb-net.c:    return -1;
usb-net.c:    struct rndis_response *r = s->rndis_resp.tqh_first;
usb-net.c:    QTAILQ_REMOVE(&s->rndis_resp, r, entries);
usb-net.c:    ret = r->length;
usb-net.c:    memcpy(buf, r->buf, r->length);
usb-net.c:    QTAILQ_INSERT_TAIL(&s->rndis_resp, r, entries);
usb-net.c:    r->length = length;
usb-net.c:    return &r->buf[0];
usb-net.c:    while ((r = s->rndis_resp.tqh_first)) {
usb-net.c:        QTAILQ_REMOVE(&s->rndis_resp, r, entries);
usb-net.c:    resp->MessageType = cpu_to_le32(RNDIS_INITIALIZE_CMPLT);
usb-net.c:    resp->MessageLength = cpu_to_le32(sizeof(rndis_init_cmplt_type));
usb-net.c:    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
usb-net.c:    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);
usb-net.c:    resp->MajorVersion = cpu_to_le32(RNDIS_MAJOR_VERSION);
usb-net.c:    resp->MinorVersion = cpu_to_le32(RNDIS_MINOR_VERSION);
usb-net.c:    resp->DeviceFlags = cpu_to_le32(RNDIS_DF_CONNECTIONLESS);
usb-net.c:    resp->Medium = cpu_to_le32(RNDIS_MEDIUM_802_3);
usb-net.c:    resp->MaxPacketsPerTransfer = cpu_to_le32(1);
usb-net.c:    resp->MaxTransferSize = cpu_to_le32(ETH_FRAME_LEN +
usb-net.c:    resp->PacketAlignmentFactor = cpu_to_le32(0);
usb-net.c:    resp->AFListOffset = cpu_to_le32(0);
usb-net.c:    resp->AFListSize = cpu_to_le32(0);
usb-net.c:    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;
usb-net.c:    buflen = le32_to_cpu(buf->InformationBufferLength);
usb-net.c:    infobuflen = ndis_query(s, le32_to_cpu(buf->OID),
usb-net.c:    resp->MessageType = cpu_to_le32(RNDIS_QUERY_CMPLT);
usb-net.c:    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
usb-net.c:    resp->MessageLength = cpu_to_le32(resplen);
usb-net.c:        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);
usb-net.c:        resp->InformationBufferLength = cpu_to_le32(0);
usb-net.c:        resp->InformationBufferOffset = cpu_to_le32(0);
usb-net.c:    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);
usb-net.c:    resp->InformationBufferOffset =
usb-net.c:            cpu_to_le32(infobuflen ? sizeof(rndis_query_cmplt_type) - 8 : 0);
usb-net.c:    resp->InformationBufferLength = cpu_to_le32(infobuflen);
usb-net.c:    bufoffs = le32_to_cpu(buf->InformationBufferOffset) + 8;
usb-net.c:    buflen = le32_to_cpu(buf->InformationBufferLength);
usb-net.c:    ret = ndis_set(s, le32_to_cpu(buf->OID),
usb-net.c:    resp->MessageType = cpu_to_le32(RNDIS_SET_CMPLT);
usb-net.c:    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
usb-net.c:    resp->MessageLength = cpu_to_le32(sizeof(rndis_set_cmplt_type));
usb-net.c:        resp->Status = cpu_to_le32(RNDIS_STATUS_NOT_SUPPORTED);
usb-net.c:    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);
usb-net.c:    resp->MessageType = cpu_to_le32(RNDIS_RESET_CMPLT);
usb-net.c:    resp->MessageLength = cpu_to_le32(sizeof(rndis_reset_cmplt_type));
usb-net.c:    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);
usb-net.c:    resp->AddressingReset = cpu_to_le32(1); /* reset information */
usb-net.c:    resp->MessageType = cpu_to_le32(RNDIS_KEEPALIVE_CMPLT);
usb-net.c:    resp->MessageLength = cpu_to_le32(sizeof(rndis_keepalive_cmplt_type));
usb-net.c:    resp->RequestID = buf->RequestID; /* Still LE in msg buffer */
usb-net.c:    resp->Status = cpu_to_le32(RNDIS_STATUS_SUCCESS);
usb-net.c:        s->rndis_state = RNDIS_INITIALIZED;
usb-net.c:        s->rndis_state = RNDIS_UNINITIALIZED;
usb-net.c:        s->out_ptr = s->in_ptr = s->in_len = 0;
usb-net.c:                (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-net.c:            dev->remote_wakeup = 0;
usb-net.c:            dev->remote_wakeup = 1;
usb-net.c:        dev->addr = value;
usb-net.c:        if (!s->rndis || value || index != 0)
usb-net.c:        if (!s->rndis || value || index != 0)
usb-net.c:                ret = set_usb_string(data, s->usbstring_mac);
usb-net.c:        data[0] = s->rndis ? DEV_RNDIS_CONFIG_VALUE : DEV_CONFIG_VALUE;
usb-net.c:            s->rndis = 0;
usb-net.c:            s->rndis = 1;
usb-net.c:    if (p->len < 8)
usb-net.c:    ((le32 *) p->data)[0] = cpu_to_le32(1);
usb-net.c:    ((le32 *) p->data)[1] = cpu_to_le32(0);
usb-net.c:    if (!s->rndis_resp.tqh_first)
usb-net.c:    fprintf(stderr, "usbnet: interrupt poll len %u return %d", p->len, ret);
usb-net.c:            fprintf(stderr, " %02x", p->data[i]);
usb-net.c:    if (s->in_ptr > s->in_len) {
usb-net.c:        s->in_ptr = s->in_len = 0;
usb-net.c:    if (!s->in_len) {
usb-net.c:    ret = s->in_len - s->in_ptr;
usb-net.c:    if (ret > p->len)
usb-net.c:        ret = p->len;
usb-net.c:    memcpy(p->data, &s->in_buf[s->in_ptr], ret);
usb-net.c:    s->in_ptr += ret;
usb-net.c:    if (s->in_ptr >= s->in_len &&
usb-net.c:                    (s->rndis || (s->in_len & (64 - 1)) || !ret)) {
usb-net.c:        s->in_ptr = s->in_len = 0;
usb-net.c:    fprintf(stderr, "usbnet: data in len %u return %d", p->len, ret);
usb-net.c:            fprintf(stderr, " %02x", p->data[i]);
usb-net.c:    int ret = p->len;
usb-net.c:    int sz = sizeof(s->out_buf) - s->out_ptr;
usb-net.c:            (struct rndis_packet_msg_type *) s->out_buf;
usb-net.c:    fprintf(stderr, "usbnet: data out len %u\n", p->len);
usb-net.c:        for (i = 0; i < p->len; i++) {
usb-net.c:            fprintf(stderr, " %02x", p->data[i]);
usb-net.c:    memcpy(&s->out_buf[s->out_ptr], p->data, sz);
usb-net.c:    s->out_ptr += sz;
usb-net.c:    if (!s->rndis) {
usb-net.c:            qemu_send_packet(&s->nic->nc, s->out_buf, s->out_ptr);
usb-net.c:            s->out_ptr = 0;
usb-net.c:    len = le32_to_cpu(msg->MessageLength);
usb-net.c:    if (s->out_ptr < 8 || s->out_ptr < len)
usb-net.c:    if (le32_to_cpu(msg->MessageType) == RNDIS_PACKET_MSG) {
usb-net.c:        uint32_t offs = 8 + le32_to_cpu(msg->DataOffset);
usb-net.c:        uint32_t size = le32_to_cpu(msg->DataLength);
usb-net.c:            qemu_send_packet(&s->nic->nc, s->out_buf + offs, size);
usb-net.c:    s->out_ptr -= len;
usb-net.c:    memmove(s->out_buf, &s->out_buf[len], s->out_ptr);
usb-net.c:    switch(p->pid) {
usb-net.c:        switch (p->devep) {
usb-net.c:        switch (p->devep) {
usb-net.c:                        p->pid, p->devep, p->len);
usb-net.c:    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
usb-net.c:    if (s->rndis) {
usb-net.c:        msg = (struct rndis_packet_msg_type *) s->in_buf;
usb-net.c:        if (!s->rndis_state == RNDIS_DATA_INITIALIZED)
usb-net.c:            return -1;
usb-net.c:        if (size + sizeof(struct rndis_packet_msg_type) > sizeof(s->in_buf))
usb-net.c:            return -1;
usb-net.c:        msg->MessageType = cpu_to_le32(RNDIS_PACKET_MSG);
usb-net.c:        msg->MessageLength = cpu_to_le32(size + sizeof(struct rndis_packet_msg_type));
usb-net.c:        msg->DataOffset = cpu_to_le32(sizeof(struct rndis_packet_msg_type) - 8);
usb-net.c:        msg->DataLength = cpu_to_le32(size);
usb-net.c:        /* msg->OOBDataOffset;
usb-net.c:         * msg->OOBDataLength;
usb-net.c:         * msg->NumOOBDataElements;
usb-net.c:         * msg->PerPacketInfoOffset;
usb-net.c:         * msg->PerPacketInfoLength;
usb-net.c:         * msg->VcHandle;
usb-net.c:         * msg->Reserved;
usb-net.c:        s->in_len = size + sizeof(struct rndis_packet_msg_type);
usb-net.c:        if (size > sizeof(s->in_buf))
usb-net.c:            return -1;
usb-net.c:        memcpy(s->in_buf, buf, size);
usb-net.c:        s->in_len = size;
usb-net.c:    s->in_ptr = 0;
usb-net.c:    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
usb-net.c:    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)
usb-net.c:    return !s->in_len;
usb-net.c:    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;
usb-net.c:    s->nic = NULL;
usb-net.c:    qemu_del_vlan_client(&s->nic->nc);
usb-net.c:    s->dev.speed  = USB_SPEED_FULL;
usb-net.c:    s->rndis = 1;
usb-net.c:    s->rndis_state = RNDIS_UNINITIALIZED;
usb-net.c:    QTAILQ_INIT(&s->rndis_resp);
usb-net.c:    s->medium = 0;	/* NDIS_MEDIUM_802_3 */
usb-net.c:    s->speed = 1000000; /* 100MBps, in 100Bps units */
usb-net.c:    s->media_state = 0;	/* NDIS_MEDIA_STATE_CONNECTED */;
usb-net.c:    s->filter = 0;
usb-net.c:    s->vendorid = 0x1234;
usb-net.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
usb-net.c:    s->nic = qemu_new_nic(&net_usbnet_info, &s->conf,
usb-net.c:                          s->dev.qdev.info->name, s->dev.qdev.id, s);
usb-net.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
usb-net.c:    snprintf(s->usbstring_mac, sizeof(s->usbstring_mac),
usb-net.c:             s->conf.macaddr.a[1],
usb-net.c:             s->conf.macaddr.a[2],
usb-net.c:             s->conf.macaddr.a[3],
usb-net.c:             s->conf.macaddr.a[4],
usb-net.c:             s->conf.macaddr.a[5]);
usb-net.c:    if (idx == -1) {
usb-net.c:    dev = usb_create(NULL /* FIXME */, "usb-net");
usb-net.c:    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);
usb-net.c:    qdev_init_nofail(&dev->qdev);
usb-net.c:    .qdev.name      = "usb-net",
usb-ohci.c:#include "qemu-timer.h"
usb-ohci.c:#include "usb-ohci.h"
usb-ohci.c:    /* PXA27x Non-OHCI events */
usb-ohci.c:/* CC & DI - same as in the General Transfer Desciptor */
usb-ohci.c:/* Isochronous Transfer Desciptor - Offset / PacketStatusWord */
usb-ohci.c:    if ((ohci->intr & OHCI_INTR_MIE) &&
usb-ohci.c:        (ohci->intr_status & ohci->intr))
usb-ohci.c:    qemu_set_irq(ohci->irq, level);
usb-ohci.c:    ohci->intr_status |= intr;
usb-ohci.c:    OHCIState *s = port1->opaque;
usb-ohci.c:    OHCIPort *port = &s->rhport[port1->index];
usb-ohci.c:    uint32_t old_state = port->ctrl;
usb-ohci.c:        if (port->port.dev) {
usb-ohci.c:        port->ctrl |= OHCI_PORT_CCS | OHCI_PORT_CSC;
usb-ohci.c:        if (dev->speed == USB_SPEED_LOW)
usb-ohci.c:            port->ctrl |= OHCI_PORT_LSDA;
usb-ohci.c:            port->ctrl &= ~OHCI_PORT_LSDA;
usb-ohci.c:        port->port.dev = dev;
usb-ohci.c:        /* notify of remote-wakeup */
usb-ohci.c:        if ((s->ctl & OHCI_CTL_HCFS) == OHCI_USB_SUSPEND)
usb-ohci.c:        dprintf("usb-ohci: Attached port %d\n", port1->index);
usb-ohci.c:        if (port->ctrl & OHCI_PORT_CCS) {
usb-ohci.c:            port->ctrl &= ~OHCI_PORT_CCS;
usb-ohci.c:            port->ctrl |= OHCI_PORT_CSC;
usb-ohci.c:        if (port->ctrl & OHCI_PORT_PES) {
usb-ohci.c:            port->ctrl &= ~OHCI_PORT_PES;
usb-ohci.c:            port->ctrl |= OHCI_PORT_PESC;
usb-ohci.c:        dev = port->port.dev;
usb-ohci.c:        port->port.dev = NULL;
usb-ohci.c:        dprintf("usb-ohci: Detached port %d\n", port1->index);
usb-ohci.c:    if (old_state != port->ctrl)
usb-ohci.c:    ohci->ctl = 0;
usb-ohci.c:    ohci->old_ctl = 0;
usb-ohci.c:    ohci->status = 0;
usb-ohci.c:    ohci->intr_status = 0;
usb-ohci.c:    ohci->intr = OHCI_INTR_MIE;
usb-ohci.c:    ohci->hcca = 0;
usb-ohci.c:    ohci->ctrl_head = ohci->ctrl_cur = 0;
usb-ohci.c:    ohci->bulk_head = ohci->bulk_cur = 0;
usb-ohci.c:    ohci->per_cur = 0;
usb-ohci.c:    ohci->done = 0;
usb-ohci.c:    ohci->done_count = 7;
usb-ohci.c:    ohci->fsmps = 0x2778;
usb-ohci.c:    ohci->fi = 0x2edf;
usb-ohci.c:    ohci->fit = 0;
usb-ohci.c:    ohci->frt = 0;
usb-ohci.c:    ohci->frame_number = 0;
usb-ohci.c:    ohci->pstart = 0;
usb-ohci.c:    ohci->lst = OHCI_LS_THRESH;
usb-ohci.c:    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;
usb-ohci.c:    ohci->rhdesc_b = 0x0; /* Impl. specific */
usb-ohci.c:    ohci->rhstatus = 0;
usb-ohci.c:    for (i = 0; i < ohci->num_ports; i++)
usb-ohci.c:        port = &ohci->rhport[i];
usb-ohci.c:        port->ctrl = 0;
usb-ohci.c:        if (port->port.dev)
usb-ohci.c:            ohci_attach(&port->port, port->port.dev);
usb-ohci.c:    if (ohci->async_td) {
usb-ohci.c:        usb_cancel_packet(&ohci->usb_packet);
usb-ohci.c:        ohci->async_td = 0;
usb-ohci.c:    dprintf("usb-ohci: Reset %s\n", ohci->name);
usb-ohci.c:    addr += ohci->localmem_base;
usb-ohci.c:    addr += ohci->localmem_base;
usb-ohci.c:    addr += ohci->localmem_base;
usb-ohci.c:    addr += ohci->localmem_base;
usb-ohci.c:            get_words(ohci, addr + 16, td->offset, 8));
usb-ohci.c:    cpu_physical_memory_rw(addr + ohci->localmem_base,
usb-ohci.c:            put_words(ohci, addr + 16, td->offset, 8));
usb-ohci.c:    cpu_physical_memory_rw(addr + ohci->localmem_base,
usb-ohci.c:    ptr = td->cbp;
usb-ohci.c:    n = 0x1000 - (ptr & 0xfff);
usb-ohci.c:    cpu_physical_memory_rw(ptr + ohci->localmem_base, buf, n, write);
usb-ohci.c:    ptr = td->be & ~0xfffu;
usb-ohci.c:    cpu_physical_memory_rw(ptr + ohci->localmem_base, buf, len - n, write);
usb-ohci.c:    n = 0x1000 - (ptr & 0xfff);
usb-ohci.c:    cpu_physical_memory_rw(ptr + ohci->localmem_base, buf, n, write);
usb-ohci.c:    cpu_physical_memory_rw(ptr + ohci->localmem_base, buf, len - n, write);
usb-ohci.c:    ohci->async_complete = 1;
usb-ohci.c:#define USUB(a, b) ((int16_t)((uint16_t)(a) - (uint16_t)(b)))
usb-ohci.c:    addr = ed->head & OHCI_DPTR_MASK;
usb-ohci.c:        printf("usb-ohci: ISO_TD read error at %x\n", addr);
usb-ohci.c:    relative_frame_number = USUB(ohci->frame_number, starting_frame); 
usb-ohci.c:    printf("--- ISO_TD ED head 0x%.8x tailp 0x%.8x\n"
usb-ohci.c:           ed->head & OHCI_DPTR_MASK, ed->tail & OHCI_DPTR_MASK,
usb-ohci.c:           ohci->frame_number, starting_frame, 
usb-ohci.c:        dprintf("usb-ohci: ISO_TD R=%d < 0\n", relative_frame_number);
usb-ohci.c:        /* ISO TD expired - retire the TD to the Done Queue and continue with
usb-ohci.c:        dprintf("usb-ohci: ISO_TD R=%d > FC=%d\n", relative_frame_number, 
usb-ohci.c:        ed->head &= ~OHCI_DPTR_MASK;
usb-ohci.c:        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
usb-ohci.c:        iso_td.next = ohci->done;
usb-ohci.c:        ohci->done = addr;
usb-ohci.c:        if (i < ohci->done_count)
usb-ohci.c:            ohci->done_count = i;
usb-ohci.c:    dir = OHCI_BM(ed->flags, ED_D);
usb-ohci.c:        printf("usb-ohci: Bad direction %d\n", dir);
usb-ohci.c:        printf("usb-ohci: ISO_TD bp 0x%.8x be 0x%.8x\n", iso_td.bp, iso_td.be);
usb-ohci.c:        printf("usb-ohci: ISO_TD cc != not accessed 0x%.8x 0x%.8x\n",
usb-ohci.c:        printf("usb-ohci: ISO_TD start_offset=0x%.8x > next_offset=0x%.8x\n",
usb-ohci.c:        end_offset = next_offset - 1;
usb-ohci.c:            - (start_addr & OHCI_OFFSET_MASK);
usb-ohci.c:        len = end_addr - start_addr + 1;
usb-ohci.c:        ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, len, 0);
usb-ohci.c:        ret = ohci->usb_packet.len;
usb-ohci.c:        for (i = 0; i < ohci->num_ports; i++) {
usb-ohci.c:            dev = ohci->rhport[i].port.dev;
usb-ohci.c:            if ((ohci->rhport[i].ctrl & OHCI_PORT_PES) == 0)
usb-ohci.c:            ohci->usb_packet.pid = pid;
usb-ohci.c:            ohci->usb_packet.devaddr = OHCI_BM(ed->flags, ED_FA);
usb-ohci.c:            ohci->usb_packet.devep = OHCI_BM(ed->flags, ED_EN);
usb-ohci.c:            ohci->usb_packet.data = ohci->usb_buf;
usb-ohci.c:            ohci->usb_packet.len = len;
usb-ohci.c:            ohci->usb_packet.complete_cb = ohci_async_complete_packet;
usb-ohci.c:            ohci->usb_packet.complete_opaque = ohci;
usb-ohci.c:            ret = dev->info->handle_packet(dev, &ohci->usb_packet);
usb-ohci.c:        ohci_copy_iso_td(ohci, start_addr, end_addr, ohci->usb_buf, ret, 1);
usb-ohci.c:            printf("usb-ohci: DataOverrun %d > %zu\n", ret, len);
usb-ohci.c:            printf("usb-ohci: DataUnderrun %d\n", ret);
usb-ohci.c:                printf("usb-ohci: got NAK/STALL %d\n", ret);
usb-ohci.c:                printf("usb-ohci: Bad device response %d\n", ret);
usb-ohci.c:        /* Last data packet of ISO TD - retire the TD to the Done Queue */
usb-ohci.c:        ed->head &= ~OHCI_DPTR_MASK;
usb-ohci.c:        ed->head |= (iso_td.next & OHCI_DPTR_MASK);
usb-ohci.c:        iso_td.next = ohci->done;
usb-ohci.c:        ohci->done = addr;
usb-ohci.c:        if (i < ohci->done_count)
usb-ohci.c:            ohci->done_count = i;
usb-ohci.c:    addr = ed->head & OHCI_DPTR_MASK;
usb-ohci.c:    completion = (addr == ohci->async_td);
usb-ohci.c:    if (completion && !ohci->async_complete) {
usb-ohci.c:        fprintf(stderr, "usb-ohci: TD read error at %x\n", addr);
usb-ohci.c:    dir = OHCI_BM(ed->flags, ED_D);
usb-ohci.c:        fprintf(stderr, "usb-ohci: Bad direction\n");
usb-ohci.c:            len = (td.be & 0xfff) + 0x1001 - (td.cbp & 0xfff);
usb-ohci.c:            len = (td.be - td.cbp) + 1;
usb-ohci.c:            ohci_copy_td(ohci, &td, ohci->usb_buf, len, 0);
usb-ohci.c:            printf(" %.2x", ohci->usb_buf[i]);
usb-ohci.c:        ret = ohci->usb_packet.len;
usb-ohci.c:        ohci->async_td = 0;
usb-ohci.c:        ohci->async_complete = 0;
usb-ohci.c:        for (i = 0; i < ohci->num_ports; i++) {
usb-ohci.c:            dev = ohci->rhport[i].port.dev;
usb-ohci.c:            if ((ohci->rhport[i].ctrl & OHCI_PORT_PES) == 0)
usb-ohci.c:            if (ohci->async_td) {
usb-ohci.c:            ohci->usb_packet.pid = pid;
usb-ohci.c:            ohci->usb_packet.devaddr = OHCI_BM(ed->flags, ED_FA);
usb-ohci.c:            ohci->usb_packet.devep = OHCI_BM(ed->flags, ED_EN);
usb-ohci.c:            ohci->usb_packet.data = ohci->usb_buf;
usb-ohci.c:            ohci->usb_packet.len = len;
usb-ohci.c:            ohci->usb_packet.complete_cb = ohci_async_complete_packet;
usb-ohci.c:            ohci->usb_packet.complete_opaque = ohci;
usb-ohci.c:            ret = dev->info->handle_packet(dev, &ohci->usb_packet);
usb-ohci.c:            ohci->async_td = addr;
usb-ohci.c:            ohci_copy_td(ohci, &td, ohci->usb_buf, ret, 1);
usb-ohci.c:                printf(" %.2x", ohci->usb_buf[i]);
usb-ohci.c:        ed->head &= ~OHCI_ED_C;
usb-ohci.c:            ed->head |= OHCI_ED_C;
usb-ohci.c:            dprintf("usb-ohci: Underrun\n");
usb-ohci.c:                dprintf("usb-ohci: got NAK\n");
usb-ohci.c:                dprintf("usb-ohci: got STALL\n");
usb-ohci.c:                dprintf("usb-ohci: got BABBLE\n");
usb-ohci.c:                fprintf(stderr, "usb-ohci: Bad device response %d\n", ret);
usb-ohci.c:        ed->head |= OHCI_ED_H;
usb-ohci.c:    ed->head &= ~OHCI_DPTR_MASK;
usb-ohci.c:    ed->head |= td.next & OHCI_DPTR_MASK;
usb-ohci.c:    td.next = ohci->done;
usb-ohci.c:    ohci->done = addr;
usb-ohci.c:    if (i < ohci->done_count)
usb-ohci.c:        ohci->done_count = i;
usb-ohci.c:            fprintf(stderr, "usb-ohci: ED read error at %x\n", cur);
usb-ohci.c:            if (ohci->async_td && addr == ohci->async_td) {
usb-ohci.c:                usb_cancel_packet(&ohci->usb_packet);
usb-ohci.c:                ohci->async_td = 0;
usb-ohci.c:    ohci->sof_time = qemu_get_clock(vm_clock);
usb-ohci.c:    qemu_mod_timer(ohci->eof_timer, ohci->sof_time + usb_frame_time);
usb-ohci.c:    if ((ohci->ctl & OHCI_CTL_CLE) && (ohci->status & OHCI_STATUS_CLF)) {
usb-ohci.c:        if (ohci->ctrl_cur && ohci->ctrl_cur != ohci->ctrl_head)
usb-ohci.c:          dprintf("usb-ohci: head %x, cur %x\n",
usb-ohci.c:                          ohci->ctrl_head, ohci->ctrl_cur);
usb-ohci.c:        if (!ohci_service_ed_list(ohci, ohci->ctrl_head, completion)) {
usb-ohci.c:            ohci->ctrl_cur = 0;
usb-ohci.c:            ohci->status &= ~OHCI_STATUS_CLF;
usb-ohci.c:    if ((ohci->ctl & OHCI_CTL_BLE) && (ohci->status & OHCI_STATUS_BLF)) {
usb-ohci.c:        if (!ohci_service_ed_list(ohci, ohci->bulk_head, completion)) {
usb-ohci.c:            ohci->bulk_cur = 0;
usb-ohci.c:            ohci->status &= ~OHCI_STATUS_BLF;
usb-ohci.c:    ohci_read_hcca(ohci, ohci->hcca, &hcca);
usb-ohci.c:    if (ohci->ctl & OHCI_CTL_PLE) {
usb-ohci.c:        n = ohci->frame_number & 0x1f;
usb-ohci.c:    if (ohci->async_td &&
usb-ohci.c:        ohci->old_ctl & (~ohci->ctl) & (OHCI_CTL_BLE | OHCI_CTL_CLE)) {
usb-ohci.c:        usb_cancel_packet(&ohci->usb_packet);
usb-ohci.c:        ohci->async_td = 0;
usb-ohci.c:    ohci->old_ctl = ohci->ctl;
usb-ohci.c:    ohci->frt = ohci->fit;
usb-ohci.c:    ohci->frame_number = (ohci->frame_number + 1) & 0xffff;
usb-ohci.c:    hcca.frame = cpu_to_le16(ohci->frame_number);
usb-ohci.c:    if (ohci->done_count == 0 && !(ohci->intr_status & OHCI_INTR_WD)) {
usb-ohci.c:        if (!ohci->done)
usb-ohci.c:        if (ohci->intr & ohci->intr_status)
usb-ohci.c:            ohci->done |= 1;
usb-ohci.c:        hcca.done = cpu_to_le32(ohci->done);
usb-ohci.c:        ohci->done = 0;
usb-ohci.c:        ohci->done_count = 7;
usb-ohci.c:    if (ohci->done_count != 7 && ohci->done_count != 0)
usb-ohci.c:        ohci->done_count--;
usb-ohci.c:    ohci_put_hcca(ohci, ohci->hcca, &hcca);
usb-ohci.c:    ohci->eof_timer = qemu_new_timer(vm_clock,
usb-ohci.c:    if (ohci->eof_timer == NULL) {
usb-ohci.c:        fprintf(stderr, "usb-ohci: %s: qemu_new_timer failed\n", ohci->name);
usb-ohci.c:    dprintf("usb-ohci: %s: USB Operational\n", ohci->name);
usb-ohci.c:    if (ohci->eof_timer)
usb-ohci.c:        qemu_del_timer(ohci->eof_timer);
usb-ohci.c:    ohci->eof_timer = NULL;
usb-ohci.c:    if (!(ohci->rhport[i].ctrl & OHCI_PORT_CCS)) {
usb-ohci.c:        ohci->rhport[i].ctrl |= OHCI_PORT_CSC;
usb-ohci.c:        if (ohci->rhstatus & OHCI_RHS_DRWE) {
usb-ohci.c:    if (ohci->rhport[i].ctrl & val)
usb-ohci.c:    ohci->rhport[i].ctrl |= val;
usb-ohci.c:/* Set the frame interval - frame interval toggle is manipulated by the hcd only */
usb-ohci.c:    if (val != ohci->fi) {
usb-ohci.c:        dprintf("usb-ohci: %s: FrameInterval = 0x%x (%u)\n",
usb-ohci.c:            ohci->name, ohci->fi, ohci->fi);
usb-ohci.c:    ohci->fi = val;
usb-ohci.c:        ohci->rhport[i].ctrl |= OHCI_PORT_PPS;
usb-ohci.c:        ohci->rhport[i].ctrl &= ~(OHCI_PORT_PPS|
usb-ohci.c:    old_state = ohci->ctl & OHCI_CTL_HCFS;
usb-ohci.c:    ohci->ctl = val;
usb-ohci.c:    new_state = ohci->ctl & OHCI_CTL_HCFS;
usb-ohci.c:        dprintf("usb-ohci: %s: USB Suspended\n", ohci->name);
usb-ohci.c:        dprintf("usb-ohci: %s: USB Resume\n", ohci->name);
usb-ohci.c:        dprintf("usb-ohci: %s: USB Reset\n", ohci->name);
usb-ohci.c:    if ((ohci->ctl & OHCI_CTL_HCFS) != OHCI_USB_OPERATIONAL)
usb-ohci.c:        return (ohci->frt << 31);
usb-ohci.c:    tks = qemu_get_clock(vm_clock) - ohci->sof_time;
usb-ohci.c:        return (ohci->frt << 31);
usb-ohci.c:    fr = (uint16_t)(ohci->fi - tks);
usb-ohci.c:    return (ohci->frt << 31) | fr;
usb-ohci.c:    old_state = ohci->rhstatus;
usb-ohci.c:        ohci->rhstatus &= ~OHCI_RHS_OCIC;
usb-ohci.c:        for (i = 0; i < ohci->num_ports; i++)
usb-ohci.c:        dprintf("usb-ohci: powered down all ports\n");
usb-ohci.c:        for (i = 0; i < ohci->num_ports; i++)
usb-ohci.c:        dprintf("usb-ohci: powered up all ports\n");
usb-ohci.c:        ohci->rhstatus |= OHCI_RHS_DRWE;
usb-ohci.c:        ohci->rhstatus &= ~OHCI_RHS_DRWE;
usb-ohci.c:    if (old_state != ohci->rhstatus)
usb-ohci.c:    port = &ohci->rhport[portnum];
usb-ohci.c:    old_state = port->ctrl;
usb-ohci.c:        port->ctrl &= ~(val & OHCI_PORT_WTC);
usb-ohci.c:        port->ctrl &= ~OHCI_PORT_PES;
usb-ohci.c:        dprintf("usb-ohci: port %d: SUSPEND\n", portnum);
usb-ohci.c:        dprintf("usb-ohci: port %d: RESET\n", portnum);
usb-ohci.c:        usb_send_msg(port->port.dev, USB_MSG_RESET);
usb-ohci.c:        port->ctrl &= ~OHCI_PORT_PRS;
usb-ohci.c:        port->ctrl |= OHCI_PORT_PES | OHCI_PORT_PRSC;
usb-ohci.c:    if (old_state != port->ctrl)
usb-ohci.c:        fprintf(stderr, "usb-ohci: Mis-aligned read\n");
usb-ohci.c:    } else if (addr >= 0x54 && addr < 0x54 + ohci->num_ports * 4) {
usb-ohci.c:        retval = ohci->rhport[(addr - 0x54) >> 2].ctrl | OHCI_PORT_PPS;
usb-ohci.c:            retval = ohci->ctl;
usb-ohci.c:            retval = ohci->status;
usb-ohci.c:            retval = ohci->intr_status;
usb-ohci.c:            retval = ohci->intr;
usb-ohci.c:            retval = ohci->hcca;
usb-ohci.c:            retval = ohci->per_cur;
usb-ohci.c:            retval = ohci->ctrl_head;
usb-ohci.c:            retval = ohci->ctrl_cur;
usb-ohci.c:            retval = ohci->bulk_head;
usb-ohci.c:            retval = ohci->bulk_cur;
usb-ohci.c:            retval = ohci->done;
usb-ohci.c:            retval = (ohci->fit << 31) | (ohci->fsmps << 16) | (ohci->fi);
usb-ohci.c:            retval = ohci->frame_number;
usb-ohci.c:            retval = ohci->pstart;
usb-ohci.c:            retval = ohci->lst;
usb-ohci.c:            retval = ohci->rhdesc_a;
usb-ohci.c:            retval = ohci->rhdesc_b;
usb-ohci.c:            retval = ohci->rhstatus;
usb-ohci.c:            retval = ohci->hstatus & ohci->hmask;
usb-ohci.c:            retval = ohci->hreset;
usb-ohci.c:            retval = ohci->hmask;
usb-ohci.c:            retval = ohci->htest;
usb-ohci.c:        fprintf(stderr, "usb-ohci: Mis-aligned write\n");
usb-ohci.c:    if (addr >= 0x54 && addr < 0x54 + ohci->num_ports * 4) {
usb-ohci.c:        ohci_port_set_status(ohci, (addr - 0x54) >> 2, val);
usb-ohci.c:        /* SOC is read-only */
usb-ohci.c:        ohci->status |= val;
usb-ohci.c:        if (ohci->status & OHCI_STATUS_HCR)
usb-ohci.c:        ohci->intr_status &= ~val;
usb-ohci.c:        ohci->intr |= val;
usb-ohci.c:        ohci->intr &= ~val;
usb-ohci.c:        ohci->hcca = val & OHCI_HCCA_MASK;
usb-ohci.c:        ohci->ctrl_head = val & OHCI_EDPTR_MASK;
usb-ohci.c:        ohci->ctrl_cur = val & OHCI_EDPTR_MASK;
usb-ohci.c:        ohci->bulk_head = val & OHCI_EDPTR_MASK;
usb-ohci.c:        ohci->bulk_cur = val & OHCI_EDPTR_MASK;
usb-ohci.c:        ohci->fsmps = (val & OHCI_FMI_FSMPS) >> 16;
usb-ohci.c:        ohci->fit = (val & OHCI_FMI_FIT) >> 31;
usb-ohci.c:        ohci->pstart = val & 0xffff;
usb-ohci.c:        ohci->lst = val & 0xffff;
usb-ohci.c:        ohci->rhdesc_a &= ~OHCI_RHA_RW_MASK;
usb-ohci.c:        ohci->rhdesc_a |= val & OHCI_RHA_RW_MASK;
usb-ohci.c:        ohci->hstatus &= ~(val & ohci->hmask);
usb-ohci.c:        ohci->hreset = val & ~OHCI_HRESET_FSBIR;
usb-ohci.c:        ohci->hmask = val;
usb-ohci.c:        ohci->htest = val;
usb-ohci.c:        dprintf("usb-ohci: usb_bit_time=%" PRId64 " usb_frame_time=%" PRId64 "\n",
usb-ohci.c:    ohci->mem = cpu_register_io_memory(ohci_readfn, ohci_writefn, ohci);
usb-ohci.c:    ohci->localmem_base = localmem_base;
usb-ohci.c:    ohci->name = name;
usb-ohci.c:    ohci->irq = irq;
usb-ohci.c:    ohci->type = type;
usb-ohci.c:    usb_bus_new(&ohci->bus, dev);
usb-ohci.c:    ohci->num_ports = num_ports;
usb-ohci.c:        usb_register_port(&ohci->bus, &ohci->rhport[i].port, ohci, i, ohci_attach);
usb-ohci.c:    ohci->async_td = 0;
usb-ohci.c:    cpu_register_physical_memory(addr, size, ohci->state.mem);
usb-ohci.c:    pci_config_set_vendor_id(ohci->pci_dev.config, PCI_VENDOR_ID_APPLE);
usb-ohci.c:    pci_config_set_device_id(ohci->pci_dev.config,
usb-ohci.c:    ohci->pci_dev.config[0x09] = 0x10; /* OHCI */
usb-ohci.c:    pci_config_set_class(ohci->pci_dev.config, PCI_CLASS_SERIAL_USB);
usb-ohci.c:    ohci->pci_dev.config[0x3d] = 0x01; /* interrupt pin 1 */
usb-ohci.c:    usb_ohci_init(&ohci->state, &dev->qdev, num_ports,
usb-ohci.c:                  ohci->pci_dev.devfn, ohci->pci_dev.irq[0],
usb-ohci.c:                  OHCI_TYPE_PCI, ohci->pci_dev.name, 0);
usb-ohci.c:    pci_create_simple(bus, devfn, "pci-ohci");
usb-ohci.c:    cpu_register_physical_memory(base, 0x1000, ohci->mem);
usb-ohci.c:    cpu_register_physical_memory(mmio_base, 0x1000, ohci->mem);
usb-ohci.c:    .qdev.name    = "pci-ohci",
usb-ohci.h:#include "qemu-common.h"
usb-serial.c: * Copyright (c) 2008 Samuel Thibault <samuel.thibault@ens-lyon.org>
usb-serial.c:#include "qemu-common.h"
usb-serial.c:#include "qemu-char.h"
usb-serial.c:do { printf("usb-serial: " fmt , ## __VA_ARGS__); } while (0)
usb-serial.c:                                     6: Self-powered,
usb-serial.c:        /* Bulk-In endpoint */
usb-serial.c:        /* Bulk-Out endpoint */
usb-serial.c:    s->event_chr = 0x0d;
usb-serial.c:    s->event_trigger = 0;
usb-serial.c:    s->recv_ptr = 0;
usb-serial.c:    s->recv_used = 0;
usb-serial.c:    if (qemu_chr_ioctl(s->cs, CHR_IOCTL_SERIAL_GET_TIOCM, &flags) == -ENOTSUP)
usb-serial.c:            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-serial.c:            dev->remote_wakeup = 0;
usb-serial.c:            dev->remote_wakeup = 1;
usb-serial.c:        dev->addr = value;
usb-serial.c:            data[8] = s->vendorid & 0xff;
usb-serial.c:            data[9] = ((s->vendorid) >> 8) & 0xff;
usb-serial.c:            data[10] = s->productid & 0xff;
usb-serial.c:            data[11] = ((s->productid) >> 8) & 0xff;
usb-serial.c:            s->recv_ptr = 0;
usb-serial.c:            s->recv_used = 0;
usb-serial.c:        qemu_chr_ioctl(s->cs,CHR_IOCTL_SERIAL_GET_TIOCM, &flags);
usb-serial.c:        qemu_chr_ioctl(s->cs,CHR_IOCTL_SERIAL_SET_TIOCM, &flags);
usb-serial.c:        s->params.speed = (48000000 / 2) / (8 * divisor + subdivisor8);
usb-serial.c:        qemu_chr_ioctl(s->cs, CHR_IOCTL_SERIAL_SET_PARAMS, &s->params);
usb-serial.c:                s->params.parity = 'N';
usb-serial.c:                s->params.parity = 'O';
usb-serial.c:                s->params.parity = 'E';
usb-serial.c:                s->params.stop_bits = 1;
usb-serial.c:                s->params.stop_bits = 2;
usb-serial.c:        qemu_chr_ioctl(s->cs, CHR_IOCTL_SERIAL_SET_PARAMS, &s->params);
usb-serial.c:        s->event_chr = value;
usb-serial.c:        s->error_chr = value;
usb-serial.c:        s->latency = value;
usb-serial.c:        data[0] = s->latency;
usb-serial.c:    uint8_t devep = p->devep;
usb-serial.c:    uint8_t *data = p->data;
usb-serial.c:    int len = p->len;
usb-serial.c:    switch (p->pid) {
usb-serial.c:        qemu_chr_write(s->cs, data, len);
usb-serial.c:        first_len = RECV_BUF - s->recv_ptr;
usb-serial.c:        if (s->event_trigger && s->event_trigger & FTDI_BI) {
usb-serial.c:            s->event_trigger &= ~FTDI_BI;
usb-serial.c:        len -= 2;
usb-serial.c:        if (len > s->recv_used)
usb-serial.c:            len = s->recv_used;
usb-serial.c:        memcpy(data, s->recv_buf + s->recv_ptr, first_len);
usb-serial.c:            memcpy(data + first_len, s->recv_buf, len - first_len);
usb-serial.c:        s->recv_used -= len;
usb-serial.c:        s->recv_ptr = (s->recv_ptr + len) % RECV_BUF;
usb-serial.c:    qemu_chr_close(s->cs);
usb-serial.c:    return RECV_BUF - s->recv_used;
usb-serial.c:    if (size > (RECV_BUF - s->recv_used))
usb-serial.c:        size = RECV_BUF - s->recv_used;
usb-serial.c:    start = s->recv_ptr + s->recv_used;
usb-serial.c:        first_size = RECV_BUF - start;
usb-serial.c:        memcpy(s->recv_buf + start, buf, first_size);
usb-serial.c:            memcpy(s->recv_buf, buf + first_size, size - first_size);
usb-serial.c:        start -= RECV_BUF;
usb-serial.c:        memcpy(s->recv_buf + start, buf, size);
usb-serial.c:    s->recv_used += size;
usb-serial.c:            s->event_trigger |= FTDI_BI;
usb-serial.c:    s->dev.speed = USB_SPEED_FULL;
usb-serial.c:    qemu_chr_add_handlers(s->cs, usb_serial_can_read, usb_serial_read,
usb-serial.c:    dev = usb_create(NULL /* FIXME */, "usb-serial");
usb-serial.c:    qdev_prop_set_chr(&dev->qdev, "chardev", cdrv);
usb-serial.c:        qdev_prop_set_uint16(&dev->qdev, "vendorid", vendorid);
usb-serial.c:        qdev_prop_set_uint16(&dev->qdev, "productid", productid);
usb-serial.c:    qdev_init_nofail(&dev->qdev);
usb-serial.c:    dev = usb_create(NULL /* FIXME */, "usb-braille");
usb-serial.c:    qdev_prop_set_chr(&dev->qdev, "chardev", cdrv);
usb-serial.c:    qdev_init_nofail(&dev->qdev);
usb-serial.c:    .qdev.name      = "usb-serial",
usb-serial.c:    .qdev.name      = "usb-braille",
usb-uhci.c:#include "qemu-timer.h"
usb-uhci.c:#include "usb-uhci.h"
usb-uhci.c:    memset(&async->packet, 0, sizeof(async->packet));
usb-uhci.c:    async->valid = 0;
usb-uhci.c:    async->td    = 0;
usb-uhci.c:    async->token = 0;
usb-uhci.c:    async->done  = 0;
usb-uhci.c:    async->next  = NULL;
usb-uhci.c:    async->next = s->async_pending;
usb-uhci.c:    s->async_pending = async;
usb-uhci.c:    UHCIAsync *curr = s->async_pending;
usb-uhci.c:    UHCIAsync **prev = &s->async_pending;
usb-uhci.c:            *prev = curr->next;
usb-uhci.c:        prev = &curr->next;
usb-uhci.c:        curr = curr->next;
usb-uhci.c:           async->td, async->token, async->done);
usb-uhci.c:    if (!async->done)
usb-uhci.c:        usb_cancel_packet(&async->packet);
usb-uhci.c:    UHCIAsync *async = s->async_pending;
usb-uhci.c:        async->valid--;
usb-uhci.c:        async = async->next;
usb-uhci.c:    UHCIAsync *curr = s->async_pending;
usb-uhci.c:    UHCIAsync **prev = &s->async_pending;
usb-uhci.c:        if (curr->valid > 0) {
usb-uhci.c:            prev = &curr->next;
usb-uhci.c:            curr = curr->next;
usb-uhci.c:        next = curr->next;
usb-uhci.c:    UHCIAsync *curr = s->async_pending;
usb-uhci.c:        next = curr->next;
usb-uhci.c:    s->async_pending = NULL;
usb-uhci.c:    UHCIAsync *async = s->async_pending;
usb-uhci.c:        if (async->token == token) {
usb-uhci.c:            if (async->td == addr) {
usb-uhci.c:        async = async->next;
usb-uhci.c:    if (((s->status2 & 1) && (s->intr & (1 << 2))) ||
usb-uhci.c:        ((s->status2 & 2) && (s->intr & (1 << 3))) ||
usb-uhci.c:        ((s->status & UHCI_STS_USBERR) && (s->intr & (1 << 0))) ||
usb-uhci.c:        ((s->status & UHCI_STS_RD) && (s->intr & (1 << 1))) ||
usb-uhci.c:        (s->status & UHCI_STS_HSERR) ||
usb-uhci.c:        (s->status & UHCI_STS_HCPERR)) {
usb-uhci.c:    qemu_set_irq(s->dev.irq[3], level);
usb-uhci.c:    pci_conf = s->dev.config;
usb-uhci.c:    s->cmd = 0;
usb-uhci.c:    s->status = 0;
usb-uhci.c:    s->status2 = 0;
usb-uhci.c:    s->intr = 0;
usb-uhci.c:    s->fl_base_addr = 0;
usb-uhci.c:    s->sof_timing = 64;
usb-uhci.c:        port = &s->ports[i];
usb-uhci.c:        port->ctrl = 0x0080;
usb-uhci.c:        if (port->port.dev)
usb-uhci.c:            uhci_attach(&port->port, port->port.dev);
usb-uhci.c:        s->sof_timing = val;
usb-uhci.c:        val = s->sof_timing;
usb-uhci.c:        if ((val & UHCI_CMD_RS) && !(s->cmd & UHCI_CMD_RS)) {
usb-uhci.c:            qemu_mod_timer(s->frame_timer, qemu_get_clock(vm_clock));
usb-uhci.c:            s->status &= ~UHCI_STS_HCHALTED;
usb-uhci.c:            s->status |= UHCI_STS_HCHALTED;
usb-uhci.c:                port = &s->ports[i];
usb-uhci.c:                dev = port->port.dev;
usb-uhci.c:        s->cmd = val;
usb-uhci.c:        s->status &= ~val;
usb-uhci.c:            s->status2 = 0;
usb-uhci.c:        s->intr = val;
usb-uhci.c:        if (s->status & UHCI_STS_HCHALTED)
usb-uhci.c:            s->frnum = val & 0x7ff;
usb-uhci.c:            port = &s->ports[n];
usb-uhci.c:            dev = port->port.dev;
usb-uhci.c:                     !(port->ctrl & UHCI_PORT_RESET) ) {
usb-uhci.c:            port->ctrl = (port->ctrl & 0x01fb) | (val & ~0x01fb);
usb-uhci.c:            port->ctrl &= ~(val & 0x000a);
usb-uhci.c:        val = s->cmd;
usb-uhci.c:        val = s->status;
usb-uhci.c:        val = s->intr;
usb-uhci.c:        val = s->frnum;
usb-uhci.c:            port = &s->ports[n];
usb-uhci.c:            val = port->ctrl;
usb-uhci.c:        s->fl_base_addr = val & ~0xfff;
usb-uhci.c:        val = s->fl_base_addr;
usb-uhci.c:    if (s->cmd & UHCI_CMD_EGSM) {
usb-uhci.c:        s->cmd |= UHCI_CMD_FGR;
usb-uhci.c:        s->status |= UHCI_STS_RD;
usb-uhci.c:    UHCIState *s = port1->opaque;
usb-uhci.c:    UHCIPort *port = &s->ports[port1->index];
usb-uhci.c:        if (port->port.dev) {
usb-uhci.c:        port->ctrl |= UHCI_PORT_CCS | UHCI_PORT_CSC;
usb-uhci.c:        if (dev->speed == USB_SPEED_LOW)
usb-uhci.c:            port->ctrl |= UHCI_PORT_LSDA;
usb-uhci.c:            port->ctrl &= ~UHCI_PORT_LSDA;
usb-uhci.c:        port->port.dev = dev;
usb-uhci.c:        if (port->ctrl & UHCI_PORT_CCS) {
usb-uhci.c:            port->ctrl &= ~UHCI_PORT_CCS;
usb-uhci.c:            port->ctrl |= UHCI_PORT_CSC;
usb-uhci.c:        if (port->ctrl & UHCI_PORT_EN) {
usb-uhci.c:            port->ctrl &= ~UHCI_PORT_EN;
usb-uhci.c:            port->ctrl |= UHCI_PORT_ENC;
usb-uhci.c:        dev = port->port.dev;
usb-uhci.c:        port->port.dev = NULL;
usb-uhci.c:           pid2str(p->pid), p->devaddr, p->devep, p->len);
usb-uhci.c:    if (p->pid == USB_TOKEN_OUT || p->pid == USB_TOKEN_SETUP)
usb-uhci.c:        dump_data(p->data, p->len);
usb-uhci.c:        UHCIPort *port = &s->ports[i];
usb-uhci.c:        USBDevice *dev = port->port.dev;
usb-uhci.c:        if (dev && (port->ctrl & UHCI_PORT_EN))
usb-uhci.c:            ret = dev->info->handle_packet(dev, p);
usb-uhci.c:    dprintf("uhci: packet exit. ret %d len %d\n", ret, p->len);
usb-uhci.c:    if (p->pid == USB_TOKEN_IN && ret > 0)
usb-uhci.c:        dump_data(p->data, ret);
usb-uhci.c:/* return -1 if fatal error (frame must be stopped)
usb-uhci.c:    max_len = ((td->token >> 21) + 1) & 0x7ff;
usb-uhci.c:    pid = td->token & 0xff;
usb-uhci.c:    ret = async->packet.len;
usb-uhci.c:    if (td->ctrl & TD_CTRL_IOC)
usb-uhci.c:    if (td->ctrl & TD_CTRL_IOS)
usb-uhci.c:        td->ctrl &= ~TD_CTRL_ACTIVE;
usb-uhci.c:    len = async->packet.len;
usb-uhci.c:    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);
usb-uhci.c:    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);
usb-uhci.c:            cpu_physical_memory_write(td->buffer, async->buffer, len);
usb-uhci.c:        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {
usb-uhci.c:            dprintf("uhci: short packet. td 0x%x token 0x%x\n", async->td, async->token);
usb-uhci.c:        td->ctrl |= TD_CTRL_STALL;
usb-uhci.c:        td->ctrl &= ~TD_CTRL_ACTIVE;
usb-uhci.c:        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;
usb-uhci.c:        td->ctrl &= ~TD_CTRL_ACTIVE;
usb-uhci.c:        return -1;
usb-uhci.c:        td->ctrl |= TD_CTRL_NAK;
usb-uhci.c:    td->ctrl |= TD_CTRL_TIMEOUT;
usb-uhci.c:    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;
usb-uhci.c:        err--;
usb-uhci.c:            td->ctrl &= ~TD_CTRL_ACTIVE;
usb-uhci.c:            s->status |= UHCI_STS_USBERR;
usb-uhci.c:    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |
usb-uhci.c:    if (!(td->ctrl & TD_CTRL_ACTIVE))
usb-uhci.c:    async = uhci_async_find_td(s, addr, td->token);
usb-uhci.c:        async->valid = 32;
usb-uhci.c:        if (!async->done)
usb-uhci.c:    async->valid = 10;
usb-uhci.c:    async->td    = addr;
usb-uhci.c:    async->token = td->token;
usb-uhci.c:    max_len = ((td->token >> 21) + 1) & 0x7ff;
usb-uhci.c:    pid = td->token & 0xff;
usb-uhci.c:    async->packet.pid     = pid;
usb-uhci.c:    async->packet.devaddr = (td->token >> 8) & 0x7f;
usb-uhci.c:    async->packet.devep   = (td->token >> 15) & 0xf;
usb-uhci.c:    async->packet.data    = async->buffer;
usb-uhci.c:    async->packet.len     = max_len;
usb-uhci.c:    async->packet.complete_cb     = uhci_async_complete;
usb-uhci.c:    async->packet.complete_opaque = s;
usb-uhci.c:        cpu_physical_memory_read(td->buffer, async->buffer, max_len);
usb-uhci.c:        len = uhci_broadcast_packet(s, &async->packet);
usb-uhci.c:        len = uhci_broadcast_packet(s, &async->packet);
usb-uhci.c:        s->status |= UHCI_STS_HCPERR;
usb-uhci.c:        return -1;
usb-uhci.c:    async->packet.len = len;
usb-uhci.c:    dprintf("uhci: async complete. td 0x%x token 0x%x\n", async->td, async->token);
usb-uhci.c:    async->done = 1;
usb-uhci.c:    db->count = 0;
usb-uhci.c:    for (i = 0; i < db->count; i++)
usb-uhci.c:        if (db->addr[i] == addr)
usb-uhci.c:    if (db->count >= UHCI_MAX_QUEUES)
usb-uhci.c:    db->addr[db->count++] = addr;
usb-uhci.c:    frame_addr = s->fl_base_addr + ((s->frnum & 0x3ff) << 2);
usb-uhci.c:    dprintf("uhci: processing frame %d addr 0x%x\n" , s->frnum, frame_addr);
usb-uhci.c:    for (cnt = FRAME_MAX_LOOPS; is_valid(link) && cnt; cnt--) {
usb-uhci.c:                 * are already done, and async completion handler will re-process 
usb-uhci.c:    s->pending_int_mask = int_mask;
usb-uhci.c:    if (!(s->cmd & UHCI_CMD_RS)) {
usb-uhci.c:        qemu_del_timer(s->frame_timer);
usb-uhci.c:        /* set hchalted bit in status - UHCI11D 2.1.2 */
usb-uhci.c:        s->status |= UHCI_STS_HCHALTED;
usb-uhci.c:    if (s->pending_int_mask) {
usb-uhci.c:        s->status2 |= s->pending_int_mask;
usb-uhci.c:        s->status  |= UHCI_STS_USBINT;
usb-uhci.c:    s->frnum = (s->frnum + 1) & 0x7ff;
usb-uhci.c:    dprintf("uhci: new frame #%u\n" , s->frnum);
usb-uhci.c:    qemu_mod_timer(s->frame_timer, expire_time);
usb-uhci.c:    uint8_t *pci_conf = s->dev.config;
usb-uhci.c:    usb_bus_new(&s->bus, &s->dev.qdev);
usb-uhci.c:        usb_register_port(&s->bus, &s->ports[i].port, s, i, uhci_attach);
usb-uhci.c:    s->frame_timer = qemu_new_timer(vm_clock, uhci_frame_timer, s);
usb-uhci.c:    s->num_ports_vmstate = NB_PORTS;
usb-uhci.c:    pci_register_bar(&s->dev, 4, 0x20,
usb-uhci.c:    uint8_t *pci_conf = s->dev.config;
usb-uhci.c:    uint8_t *pci_conf = s->dev.config;
usb-uhci.c:        .qdev.name    = "piix3-usb-uhci",
usb-uhci.c:        .qdev.name    = "piix4-usb-uhci",
usb-uhci.c:    pci_create_simple(bus, devfn, "piix3-usb-uhci");
usb-uhci.c:    pci_create_simple(bus, devfn, "piix4-usb-uhci");
usb-uhci.h:#include "qemu-common.h"
usb-wacom.c: * Based on hw/usb-hid.c:
usb-wacom.c:				     6: Self-powered,
usb-wacom.c:    s->dx += dx1;
usb-wacom.c:    s->dy += dy1;
usb-wacom.c:    s->dz += dz1;
usb-wacom.c:    s->buttons_state = buttons_state;
usb-wacom.c:    s->changed = 1;
usb-wacom.c:    s->x = (x * 5040 / 0x7FFF);
usb-wacom.c:    s->y = (y * 3780 / 0x7FFF);
usb-wacom.c:    s->dz += dz;
usb-wacom.c:    s->buttons_state = buttons_state;
usb-wacom.c:    s->changed = 1;
usb-wacom.c:    if (!s->mouse_grabbed) {
usb-wacom.c:        s->eh_entry = qemu_add_mouse_event_handler(usb_mouse_event, s, 0,
usb-wacom.c:        s->mouse_grabbed = 1;
usb-wacom.c:    dx = int_clamp(s->dx, -128, 127);
usb-wacom.c:    dy = int_clamp(s->dy, -128, 127);
usb-wacom.c:    dz = int_clamp(s->dz, -128, 127);
usb-wacom.c:    s->dx -= dx;
usb-wacom.c:    s->dy -= dy;
usb-wacom.c:    s->dz -= dz;
usb-wacom.c:    if (s->buttons_state & MOUSE_EVENT_LBUTTON)
usb-wacom.c:    if (s->buttons_state & MOUSE_EVENT_RBUTTON)
usb-wacom.c:    if (s->buttons_state & MOUSE_EVENT_MBUTTON)
usb-wacom.c:    if (!s->mouse_grabbed) {
usb-wacom.c:        s->eh_entry = qemu_add_mouse_event_handler(usb_wacom_event, s, 1,
usb-wacom.c:        s->mouse_grabbed = 1;
usb-wacom.c:    if (s->buttons_state & MOUSE_EVENT_LBUTTON)
usb-wacom.c:    if (s->buttons_state & MOUSE_EVENT_RBUTTON)
usb-wacom.c:    if (s->buttons_state & MOUSE_EVENT_MBUTTON)
usb-wacom.c:    buf[0] = s->mode;
usb-wacom.c:    buf[1] = s->x & 0xff;
usb-wacom.c:    buf[2] = s->x >> 8;
usb-wacom.c:    buf[3] = s->y & 0xff;
usb-wacom.c:    buf[4] = s->y >> 8;
usb-wacom.c:        buf[6] = (unsigned char) -127;
usb-wacom.c:    s->dx = 0;
usb-wacom.c:    s->dy = 0;
usb-wacom.c:    s->dz = 0;
usb-wacom.c:    s->x = 0;
usb-wacom.c:    s->y = 0;
usb-wacom.c:    s->buttons_state = 0;
usb-wacom.c:    s->mode = WACOM_MODE_HID;
usb-wacom.c:            (dev->remote_wakeup << USB_DEVICE_REMOTE_WAKEUP);
usb-wacom.c:            dev->remote_wakeup = 0;
usb-wacom.c:            dev->remote_wakeup = 1;
usb-wacom.c:        dev->addr = value;
usb-wacom.c:        qemu_remove_mouse_event_handler(s->eh_entry);
usb-wacom.c:        s->mouse_grabbed = 0;
usb-wacom.c:        s->mode = data[0];
usb-wacom.c:        data[1] = s->mode;
usb-wacom.c:        if (s->mode == WACOM_MODE_HID)
usb-wacom.c:        else if (s->mode == WACOM_MODE_WACOM)
usb-wacom.c:        data[0] = s->idle;
usb-wacom.c:        s->idle = (uint8_t) (value >> 8);
usb-wacom.c:    switch (p->pid) {
usb-wacom.c:        if (p->devep == 1) {
usb-wacom.c:            if (!(s->changed || s->idle))
usb-wacom.c:            s->changed = 0;
usb-wacom.c:            if (s->mode == WACOM_MODE_HID)
usb-wacom.c:                ret = usb_mouse_poll(s, p->data, p->len);
usb-wacom.c:            else if (s->mode == WACOM_MODE_WACOM)
usb-wacom.c:                ret = usb_wacom_poll(s, p->data, p->len);
usb-wacom.c:    qemu_remove_mouse_event_handler(s->eh_entry);
usb-wacom.c:    s->dev.speed = USB_SPEED_FULL;
usb-wacom.c:    s->changed = 1;
usb-wacom.c:    .qdev.name      = "usb-wacom-tablet",
usb-wacom.c:    .usbdevice_name = "wacom-tablet",
versatilepb.c: * Copyright (c) 2005-2007 CodeSourcery.
versatilepb.c:#include "arm-misc.h"
versatilepb.c:#include "usb-ohci.h"
versatilepb.c:    flags = s->level & s->mask;
versatilepb.c:    qemu_set_irq(s->parent[s->irq], flags != 0);
versatilepb.c:        if (!(s->pic_enable & mask))
versatilepb.c:        qemu_set_irq(s->parent[i], (s->level & mask) != 0);
versatilepb.c:        s->level |= 1u << irq;
versatilepb.c:        s->level &= ~(1u << irq);
versatilepb.c:    if (s->pic_enable & (1u << irq))
versatilepb.c:        qemu_set_irq(s->parent[irq], level);
versatilepb.c:        return s->level & s->mask;
versatilepb.c:        return s->level;
versatilepb.c:        return s->mask;
versatilepb.c:        return s->level & 1;
versatilepb.c:        return s->pic_enable;
versatilepb.c:        s->mask |= value;
versatilepb.c:        s->mask &= ~value;
versatilepb.c:            s->mask |= 1;
versatilepb.c:            s->mask &= ~1u;
versatilepb.c:        s->pic_enable |= (value & 0x7fe00000);
versatilepb.c:        s->pic_enable &= ~value;
versatilepb.c:    qdev_init_gpio_in(&dev->qdev, vpb_sic_set_irq, 32);
versatilepb.c:        sysbus_init_irq(dev, &s->parent[i]);
versatilepb.c:    s->irq = 31;
versatilepb.c:        if ((!nd->model && !done_smc) || strcmp(nd->model, "smc91c111") == 0) {
versatilepb.c:        usb_ohci_init_pci(pci_bus, -1);
versatilepb.c:        pci_create_simple(pci_bus, -1, "lsi53c895a");
versatilepb.c:        n--;
versatilepb.c:    .desc = "ARM Versatile/PB (ARM926EJ-S)",
versatilepb.c:    .desc = "ARM Versatile/AB (ARM926EJ-S)",
versatile_pci.c: * Copyright (c) 2006-2009 CodeSourcery.
versatile_pci.c:    cpu_register_physical_memory(base + 0x01000000, 0x1000000, s->mem_config);
versatile_pci.c:    cpu_register_physical_memory(base + 0x02000000, 0x1000000, s->mem_config);
versatile_pci.c:    if (s->realview) {
versatile_pci.c:        sysbus_init_irq(dev, &s->irq[i]);
versatile_pci.c:    bus = pci_register_bus(&dev->qdev, "pci",
versatile_pci.c:                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,
versatile_pci.c:    s->mem_config = cpu_register_io_memory(pci_vpb_config_read,
versatile_pci.c:    pci_create_simple(bus, -1, "versatile_pci_host");
versatile_pci.c:    s->realview = 1;
versatile_pci.c:    pci_config_set_vendor_id(d->config, PCI_VENDOR_ID_XILINX);
versatile_pci.c:    pci_config_set_device_id(d->config, PCI_DEVICE_ID_XILINX_XC2VP30);
versatile_pci.c:    d->config[0x04] = 0x00;
versatile_pci.c:    d->config[0x05] = 0x00;
versatile_pci.c:    d->config[0x06] = 0x20;
versatile_pci.c:    d->config[0x07] = 0x02;
versatile_pci.c:    d->config[0x08] = 0x00; // revision
versatile_pci.c:    d->config[0x09] = 0x00; // programming i/f
versatile_pci.c:    pci_config_set_class(d->config, PCI_CLASS_PROCESSOR_CO);
versatile_pci.c:    d->config[0x0D] = 0x10; // latency_timer
vga.c:#include "qemu-timer.h"
vga.c:#define GET_PLANE(data, p) (((data) >> (24 - (p) * 8)) & 0xff)
vga.c:    struct vga_precise_retrace *r = &s->retrace_info.precise;
vga.c:    htotal_chars = s->cr[0x00] + 5;
vga.c:    hretr_start_char = s->cr[0x04];
vga.c:    hretr_skew_chars = (s->cr[0x05] >> 5) & 3;
vga.c:    hretr_end_char = s->cr[0x05] & 0x1f;
vga.c:    vtotal_lines = (s->cr[0x06]
vga.c:                    | (((s->cr[0x07] & 1) | ((s->cr[0x07] >> 4) & 2)) << 8)) + 2
vga.c:    vretr_start_line = s->cr[0x10]
vga.c:        | ((((s->cr[0x07] >> 2) & 1) | ((s->cr[0x07] >> 6) & 2)) << 8)
vga.c:    vretr_end_line = s->cr[0x11] & 0xf;
vga.c:    div2 = (s->cr[0x17] >> 2) & 1;
vga.c:    sldiv2 = (s->cr[0x17] >> 3) & 1;
vga.c:    clocking_mode = (s->sr[0x01] >> 3) & 1;
vga.c:    clock_sel = (s->msr >> 2) & 3;
vga.c:    dots = (s->msr & 1) ? 8 : 9;
vga.c:    r->total_chars = vtotal_lines * htotal_chars;
vga.c:    if (r->freq) {
vga.c:        r->ticks_per_char = get_ticks_per_sec() / (r->total_chars * r->freq);
vga.c:        r->ticks_per_char = get_ticks_per_sec() / chars_per_sec;
vga.c:    r->vstart = vretr_start_line;
vga.c:    r->vend = r->vstart + vretr_end_line + 1;
vga.c:    r->hstart = hretr_start_char + hretr_skew_chars;
vga.c:    r->hend = r->hstart + hretr_end_char + 1;
vga.c:    r->htotal = htotal_chars;
vga.c:        (double) get_ticks_per_sec() / (r->ticks_per_char * r->total_chars),
vga.c:        r->ticks_per_char
vga.c:    struct vga_precise_retrace *r = &s->retrace_info.precise;
vga.c:    uint8_t val = s->st01 & ~(ST01_V_RETRACE | ST01_DISP_ENABLE);
vga.c:    if (r->total_chars) {
vga.c:        cur_char = (cur_tick / r->ticks_per_char) % r->total_chars;
vga.c:        cur_line = cur_char / r->htotal;
vga.c:        if (cur_line >= r->vstart && cur_line <= r->vend) {
vga.c:            cur_line_char = cur_char % r->htotal;
vga.c:            if (cur_line_char >= r->hstart && cur_line_char <= r->hend) {
vga.c:        return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);
vga.c:    return s->st01 ^ (ST01_V_RETRACE | ST01_DISP_ENABLE);
vga.c:    if (s->msr & MSR_COLOR_EMULATION) {
vga.c:            if (s->ar_flip_flop == 0) {
vga.c:                val = s->ar_index;
vga.c:            index = s->ar_index & 0x1f;
vga.c:                val = s->ar[index];
vga.c:            val = s->st00;
vga.c:            val = s->sr_index;
vga.c:            val = s->sr[s->sr_index];
vga.c:            printf("vga: read SR%x = 0x%02x\n", s->sr_index, val);
vga.c:            val = s->dac_state;
vga.c:            val = s->dac_write_index;
vga.c:            val = s->palette[s->dac_read_index * 3 + s->dac_sub_index];
vga.c:            if (++s->dac_sub_index == 3) {
vga.c:                s->dac_sub_index = 0;
vga.c:                s->dac_read_index++;
vga.c:            val = s->fcr;
vga.c:            val = s->msr;
vga.c:            val = s->gr_index;
vga.c:            val = s->gr[s->gr_index];
vga.c:            printf("vga: read GR%x = 0x%02x\n", s->gr_index, val);
vga.c:            val = s->cr_index;
vga.c:            val = s->cr[s->cr_index];
vga.c:            printf("vga: read CR%x = 0x%02x\n", s->cr_index, val);
vga.c:            val = s->st01 = s->retrace(s);
vga.c:            s->ar_flip_flop = 0;
vga.c:        if (s->ar_flip_flop == 0) {
vga.c:            s->ar_index = val;
vga.c:            index = s->ar_index & 0x1f;
vga.c:                s->ar[index] = val & 0x3f;
vga.c:                s->ar[index] = val & ~0x10;
vga.c:                s->ar[index] = val;
vga.c:                s->ar[index] = val & ~0xc0;
vga.c:                s->ar[index] = val & ~0xf0;
vga.c:                s->ar[index] = val & ~0xf0;
vga.c:        s->ar_flip_flop ^= 1;
vga.c:        s->msr = val & ~0x10;
vga.c:        s->update_retrace_info(s);
vga.c:        s->sr_index = val & 7;
vga.c:        printf("vga: write SR%x = 0x%02x\n", s->sr_index, val);
vga.c:        s->sr[s->sr_index] = val & sr_mask[s->sr_index];
vga.c:        if (s->sr_index == 1) s->update_retrace_info(s);
vga.c:        s->dac_read_index = val;
vga.c:        s->dac_sub_index = 0;
vga.c:        s->dac_state = 3;
vga.c:        s->dac_write_index = val;
vga.c:        s->dac_sub_index = 0;
vga.c:        s->dac_state = 0;
vga.c:        s->dac_cache[s->dac_sub_index] = val;
vga.c:        if (++s->dac_sub_index == 3) {
vga.c:            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);
vga.c:            s->dac_sub_index = 0;
vga.c:            s->dac_write_index++;
vga.c:        s->gr_index = val & 0x0f;
vga.c:        printf("vga: write GR%x = 0x%02x\n", s->gr_index, val);
vga.c:        s->gr[s->gr_index] = val & gr_mask[s->gr_index];
vga.c:        s->cr_index = val;
vga.c:        printf("vga: write CR%x = 0x%02x\n", s->cr_index, val);
vga.c:        /* handle CR0-7 protection */
vga.c:        if ((s->cr[0x11] & 0x80) && s->cr_index <= 7) {
vga.c:            if (s->cr_index == 7)
vga.c:                s->cr[7] = (s->cr[7] & ~0x10) | (val & 0x10);
vga.c:        s->cr[s->cr_index] = val;
vga.c:        switch(s->cr_index) {
vga.c:            s->update_retrace_info(s);
vga.c:        s->fcr = val & 0x10;
vga.c:    val = s->vbe_index;
vga.c:    if (s->vbe_index <= VBE_DISPI_INDEX_NB) {
vga.c:        if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_GETCAPS) {
vga.c:            switch(s->vbe_index) {
vga.c:                val = s->vbe_regs[s->vbe_index];
vga.c:            val = s->vbe_regs[s->vbe_index];
vga.c:    printf("VBE: read index=0x%x val=0x%x\n", s->vbe_index, val);
vga.c:    s->vbe_index = val;
vga.c:    if (s->vbe_index <= VBE_DISPI_INDEX_NB) {
vga.c:        printf("VBE: write index=0x%x val=0x%x\n", s->vbe_index, val);
vga.c:        switch(s->vbe_index) {
vga.c:                s->vbe_regs[s->vbe_index] = val;
vga.c:                s->vbe_regs[s->vbe_index] = val;
vga.c:                s->vbe_regs[s->vbe_index] = val;
vga.c:                s->vbe_regs[s->vbe_index] = val;
vga.c:            if (s->vbe_regs[VBE_DISPI_INDEX_BPP] == 4) {
vga.c:              val &= (s->vbe_bank_mask >> 2);
vga.c:              val &= s->vbe_bank_mask;
vga.c:            s->vbe_regs[s->vbe_index] = val;
vga.c:            s->bank_offset = (val << 16);
vga.c:                !(s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED)) {
vga.c:                s->vbe_regs[VBE_DISPI_INDEX_VIRT_WIDTH] =
vga.c:                    s->vbe_regs[VBE_DISPI_INDEX_XRES];
vga.c:                s->vbe_regs[VBE_DISPI_INDEX_VIRT_HEIGHT] =
vga.c:                    s->vbe_regs[VBE_DISPI_INDEX_YRES];
vga.c:                s->vbe_regs[VBE_DISPI_INDEX_X_OFFSET] = 0;
vga.c:                s->vbe_regs[VBE_DISPI_INDEX_Y_OFFSET] = 0;
vga.c:                if (s->vbe_regs[VBE_DISPI_INDEX_BPP] == 4)
vga.c:                    s->vbe_line_offset = s->vbe_regs[VBE_DISPI_INDEX_XRES] >> 1;
vga.c:                    s->vbe_line_offset = s->vbe_regs[VBE_DISPI_INDEX_XRES] *
vga.c:                        ((s->vbe_regs[VBE_DISPI_INDEX_BPP] + 7) >> 3);
vga.c:                s->vbe_start_addr = 0;
vga.c:                    memset(s->vram_ptr, 0,
vga.c:                           s->vbe_regs[VBE_DISPI_INDEX_YRES] * s->vbe_line_offset);
vga.c:                s->gr[0x06] = (s->gr[0x06] & ~0x0c) | 0x05; /* graphic mode + memory map 1 */
vga.c:                s->cr[0x17] |= 3; /* no CGA modes */
vga.c:                s->cr[0x13] = s->vbe_line_offset >> 3;
vga.c:                s->cr[0x01] = (s->vbe_regs[VBE_DISPI_INDEX_XRES] >> 3) - 1;
vga.c:                h = s->vbe_regs[VBE_DISPI_INDEX_YRES] - 1;
vga.c:                s->cr[0x12] = h;
vga.c:                s->cr[0x07] = (s->cr[0x07] & ~0x42) |
vga.c:                s->cr[0x18] = 0xff;
vga.c:                s->cr[0x07] |= 0x10;
vga.c:                s->cr[0x09] |= 0x40;
vga.c:                if (s->vbe_regs[VBE_DISPI_INDEX_BPP] == 4) {
vga.c:                    s->sr[0x01] &= ~8; /* no double line */
vga.c:                    s->sr[4] |= 0x08; /* set chain 4 mode */
vga.c:                    s->sr[2] |= 0x0f; /* activate all planes */
vga.c:                s->gr[0x05] = (s->gr[0x05] & ~0x60) | (shift_control << 5);
vga.c:                s->cr[0x09] &= ~0x9f; /* no double scan */
vga.c:                s->bank_offset = 0;
vga.c:            s->dac_8bit = (val & VBE_DISPI_8BIT_DAC) > 0;
vga.c:            s->vbe_regs[s->vbe_index] = val;
vga.c:                if (val < s->vbe_regs[VBE_DISPI_INDEX_XRES])
vga.c:                if (s->vbe_regs[VBE_DISPI_INDEX_BPP] == 4)
vga.c:                    line_offset = w * ((s->vbe_regs[VBE_DISPI_INDEX_BPP] + 7) >> 3);
vga.c:                h = s->vram_size / line_offset;
vga.c:                if (h < s->vbe_regs[VBE_DISPI_INDEX_YRES])
vga.c:                s->vbe_regs[VBE_DISPI_INDEX_VIRT_WIDTH] = w;
vga.c:                s->vbe_regs[VBE_DISPI_INDEX_VIRT_HEIGHT] = h;
vga.c:                s->vbe_line_offset = line_offset;
vga.c:                s->vbe_regs[s->vbe_index] = val;
vga.c:                s->vbe_start_addr = s->vbe_line_offset * s->vbe_regs[VBE_DISPI_INDEX_Y_OFFSET];
vga.c:                x = s->vbe_regs[VBE_DISPI_INDEX_X_OFFSET];
vga.c:                if (s->vbe_regs[VBE_DISPI_INDEX_BPP] == 4)
vga.c:                    s->vbe_start_addr += x >> 1;
vga.c:                    s->vbe_start_addr += x * ((s->vbe_regs[VBE_DISPI_INDEX_BPP] + 7) >> 3);
vga.c:                s->vbe_start_addr >>= 2;
vga.c:    memory_map_mode = (s->gr[6] >> 2) & 3;
vga.c:        addr += s->bank_offset;
vga.c:        addr -= 0x10000;
vga.c:        addr -= 0x18000;
vga.c:    if (s->sr[4] & 0x08) {
vga.c:        ret = s->vram_ptr[addr];
vga.c:    } else if (s->gr[5] & 0x10) {
vga.c:        plane = (s->gr[4] & 2) | (addr & 1);
vga.c:        ret = s->vram_ptr[((addr & ~1) << 1) | plane];
vga.c:        s->latch = ((uint32_t *)s->vram_ptr)[addr];
vga.c:        if (!(s->gr[5] & 0x08)) {
vga.c:            plane = s->gr[4];
vga.c:            ret = GET_PLANE(s->latch, plane);
vga.c:            ret = (s->latch ^ mask16[s->gr[2]]) & mask16[s->gr[7]];
vga.c:    memory_map_mode = (s->gr[6] >> 2) & 3;
vga.c:        addr += s->bank_offset;
vga.c:        addr -= 0x10000;
vga.c:        addr -= 0x18000;
vga.c:    if (s->sr[4] & 0x08) {
vga.c:        if (s->sr[2] & mask) {
vga.c:            s->vram_ptr[addr] = val;
vga.c:            s->plane_updated |= mask; /* only used to detect font change */
vga.c:            cpu_physical_memory_set_dirty(s->vram_offset + addr);
vga.c:    } else if (s->gr[5] & 0x10) {
vga.c:        plane = (s->gr[4] & 2) | (addr & 1);
vga.c:        if (s->sr[2] & mask) {
vga.c:            s->vram_ptr[addr] = val;
vga.c:            s->plane_updated |= mask; /* only used to detect font change */
vga.c:            cpu_physical_memory_set_dirty(s->vram_offset + addr);
vga.c:        write_mode = s->gr[5] & 3;
vga.c:            b = s->gr[3] & 7;
vga.c:            val = ((val >> b) | (val << (8 - b))) & 0xff;
vga.c:            set_mask = mask16[s->gr[1]];
vga.c:            val = (val & ~set_mask) | (mask16[s->gr[0]] & set_mask);
vga.c:            bit_mask = s->gr[8];
vga.c:            val = s->latch;
vga.c:            bit_mask = s->gr[8];
vga.c:            b = s->gr[3] & 7;
vga.c:            val = (val >> b) | (val << (8 - b));
vga.c:            bit_mask = s->gr[8] & val;
vga.c:            val = mask16[s->gr[0]];
vga.c:        func_select = s->gr[3] >> 3;
vga.c:            val &= s->latch;
vga.c:            val |= s->latch;
vga.c:            val ^= s->latch;
vga.c:        val = (val & bit_mask) | (s->latch & ~bit_mask);
vga.c:        mask = s->sr[2];
vga.c:        s->plane_updated |= mask; /* only used to detect font change */
vga.c:        ((uint32_t *)s->vram_ptr)[addr] =
vga.c:            (((uint32_t *)s->vram_ptr)[addr] & ~write_mask) |
vga.c:        cpu_physical_memory_set_dirty(s->vram_offset + (addr << 2));
vga.c:    palette = s->last_palette;
vga.c:        v = s->ar[i];
vga.c:        if (s->ar[0x10] & 0x80)
vga.c:            v = ((s->ar[0x14] & 0xf) << 4) | (v & 0xf);
vga.c:            v = ((s->ar[0x14] & 0xc) << 4) | (v & 0x3f);
vga.c:        col = s->rgb_to_pixel(c6_to_8(s->palette[v]),
vga.c:                              c6_to_8(s->palette[v + 1]),
vga.c:                              c6_to_8(s->palette[v + 2]));
vga.c:    palette = s->last_palette;
vga.c:        if (s->dac_8bit) {
vga.c:          col = s->rgb_to_pixel(s->palette[v],
vga.c:                                s->palette[v + 1],
vga.c:                                s->palette[v + 2]);
vga.c:          col = s->rgb_to_pixel(c6_to_8(s->palette[v]),
vga.c:                                c6_to_8(s->palette[v + 1]),
vga.c:                                c6_to_8(s->palette[v + 2]));
vga.c:    if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED) {
vga.c:        line_offset = s->vbe_line_offset;
vga.c:        start_addr = s->vbe_start_addr;
vga.c:        line_offset = s->cr[0x13];
vga.c:        start_addr = s->cr[0x0d] | (s->cr[0x0c] << 8);
vga.c:        line_compare = s->cr[0x18] |
vga.c:            ((s->cr[0x07] & 0x10) << 4) |
vga.c:            ((s->cr[0x09] & 0x40) << 3);
vga.c:    s->get_offsets(s, &line_offset, &start_addr, &line_compare);
vga.c:    if (line_offset != s->line_offset ||
vga.c:        start_addr != s->start_addr ||
vga.c:        line_compare != s->line_compare) {
vga.c:        s->line_offset = line_offset;
vga.c:        s->start_addr = start_addr;
vga.c:        s->line_compare = line_compare;
vga.c:        if (is_surface_bgr(s->surface))
vga.c:    cheight = (s->cr[9] & 0x1f) + 1;
vga.c:    if (!(s->sr[1] & 0x01))
vga.c:    if (s->sr[1] & 0x08)
vga.c:    width = (s->cr[0x01] + 1);
vga.c:    if (s->cr[0x06] == 100) {
vga.c:        /* ugly hack for CGA 160x100x16 - explain me the logic */
vga.c:        height = s->cr[0x12] |
vga.c:            ((s->cr[0x07] & 0x02) << 7) |
vga.c:            ((s->cr[0x07] & 0x40) << 3);
vga.c: * - double scan
vga.c: * - double width
vga.c: * - underline
vga.c: * - flashing
vga.c:    v = s->sr[3];
vga.c:    if (offset != s->font_offsets[0]) {
vga.c:        s->font_offsets[0] = offset;
vga.c:    font_base[0] = s->vram_ptr + offset;
vga.c:    font_base[1] = s->vram_ptr + offset;
vga.c:    if (offset != s->font_offsets[1]) {
vga.c:        s->font_offsets[1] = offset;
vga.c:    if (s->plane_updated & (1 << 2)) {
vga.c:        s->plane_updated = 0;
vga.c:    line_offset = s->line_offset;
vga.c:    x_incr = cw * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);
vga.c:    if (width != s->last_width || height != s->last_height ||
vga.c:        cw != s->last_cw || cheight != s->last_ch || s->last_depth) {
vga.c:        s->last_scr_width = width * cw;
vga.c:        s->last_scr_height = height * cheight;
vga.c:        qemu_console_resize(s->ds, s->last_scr_width, s->last_scr_height);
vga.c:        s->last_depth = 0;
vga.c:        s->last_width = width;
vga.c:        s->last_height = height;
vga.c:        s->last_ch = cheight;
vga.c:        s->last_cw = cw;
vga.c:    s->rgb_to_pixel =
vga.c:        rgb_to_pixel_dup_table[get_depth_index(s->ds)];
vga.c:    palette = s->last_palette;
vga.c:    x_incr = cw * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);
vga.c:    cursor_offset = ((s->cr[0x0e] << 8) | s->cr[0x0f]) - s->start_addr;
vga.c:    if (cursor_offset != s->cursor_offset ||
vga.c:        s->cr[0xa] != s->cursor_start ||
vga.c:        s->cr[0xb] != s->cursor_end) {
vga.c:        if (s->cursor_offset < CH_ATTR_SIZE)
vga.c:            s->last_ch_attr[s->cursor_offset] = -1;
vga.c:            s->last_ch_attr[cursor_offset] = -1;
vga.c:        s->cursor_offset = cursor_offset;
vga.c:        s->cursor_start = s->cr[0xa];
vga.c:        s->cursor_end = s->cr[0xb];
vga.c:    cursor_ptr = s->vram_ptr + (s->start_addr + cursor_offset) * 4;
vga.c:    depth_index = get_depth_index(s->ds);
vga.c:    dest = ds_get_data(s->ds);
vga.c:    linesize = ds_get_linesize(s->ds);
vga.c:    ch_attr_ptr = s->last_ch_attr;
vga.c:    offset = s->start_addr * 4;
vga.c:        src = s->vram_ptr + offset;
vga.c:        cx_max = -1;
vga.c:                    if (ch >= 0xb0 && ch <= 0xdf && (s->ar[0x10] & 0x04))
vga.c:                    !(s->cr[0x0a] & 0x20)) {
vga.c:                    line_start = s->cr[0x0a] & 0x1f;
vga.c:                    line_last = s->cr[0x0b] & 0x1f;
vga.c:                    if (line_last > cheight - 1)
vga.c:                        line_last = cheight - 1;
vga.c:                        h = line_last - line_start + 1;
vga.c:        if (cx_max != -1) {
vga.c:            dpy_update(s->ds, cx_min * cw, cy * cheight,
vga.c:                       (cx_max - cx_min + 1) * cw, cheight);
vga.c:        if (line < s->line_compare && line1 >= s->line_compare) {
vga.c:    if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED) {
vga.c:        ret = s->vbe_regs[VBE_DISPI_INDEX_BPP];
vga.c:    if (s->vbe_regs[VBE_DISPI_INDEX_ENABLE] & VBE_DISPI_ENABLED) {
vga.c:        width = s->vbe_regs[VBE_DISPI_INDEX_XRES];
vga.c:        height = s->vbe_regs[VBE_DISPI_INDEX_YRES];
vga.c:        width = (s->cr[0x01] + 1) * 8;
vga.c:        height = s->cr[0x12] |
vga.c:            ((s->cr[0x07] & 0x02) << 7) |
vga.c:            ((s->cr[0x07] & 0x40) << 3);
vga.c:        s->invalidated_y_table[y >> 5] |= 1 << (y & 0x1f);
vga.c:    if (s->map_addr)
vga.c:        cpu_physical_sync_dirty_bitmap(s->map_addr, s->map_end);
vga.c:    if (s->lfb_vram_mapped) {
vga.c:    if (s->vbe_mapped) {
vga.c:                                       VBE_DISPI_LFB_PHYSICAL_ADDRESS + s->vram_size);
vga.c:    if (kvm_enabled() && s->map_addr)
vga.c:            kvm_log_start(s->map_addr, s->map_end - s->map_addr);
vga.c:            mark_dirty(s->map_addr, s->map_end - s->map_addr);
vga.c:    if (kvm_enabled() && s->lfb_vram_mapped) {
vga.c:    if (kvm_enabled() && s->vbe_mapped) {
vga.c:            kvm_log_start(VBE_DISPI_LFB_PHYSICAL_ADDRESS, s->vram_size);
vga.c:    if (kvm_enabled() && s->map_addr && s1)
vga.c:	kvm_log_stop(s->map_addr, s->map_end - s->map_addr);
vga.c:    if (kvm_enabled() && s->lfb_vram_mapped && s2) {
vga.c:    if (kvm_enabled() && s->vbe_mapped && s3) {
vga.c:	kvm_log_stop(VBE_DISPI_LFB_PHYSICAL_ADDRESS, s->vram_size);
vga.c:    printf("vga_draw_graphic: %dbpp, size=%d\n", s->get_bpp(s), s->vram_size);
vga.c:    s->get_offsets(s, &line_offse, &start_addres, &line_compar);
vga.c:    if (s->get_bpp(s) == 24) {
vga.c:        s->get_resolution(s, &reswidth, &resheight);
vga.c:        uint8_t* ptr = s->vram_ptr;
vga.c:            ptr += line_offse - 3 * reswidth;
vga.c:    s->get_resolution(s, &width, &height);
vga.c:    shift_control = (s->gr[0x05] >> 5) & 3;
vga.c:    double_scan = (s->cr[0x09] >> 7);
vga.c:        multi_scan = (((s->cr[0x09] & 0x1f) + 1) << double_scan) - 1;
vga.c:    if (shift_control != s->shift_control ||
vga.c:        double_scan != s->double_scan) {
vga.c:        s->shift_control = shift_control;
vga.c:        s->double_scan = double_scan;
vga.c:        if (s->sr[0x01] & 8) {
vga.c:        if (s->sr[0x01] & 8) {
vga.c:    depth = s->get_bpp(s);
vga.c:    if (s->line_offset != s->last_line_offset ||
vga.c:        disp_width != s->last_width ||
vga.c:        height != s->last_height ||
vga.c:        s->last_depth != depth) {
vga.c:            qemu_free_displaysurface(s->ds);
vga.c:            s->ds->surface = qemu_create_displaysurface_from(disp_width, height, depth,
vga.c:                    s->line_offset,
vga.c:                    s->vram_ptr + (s->start_addr * 4));
vga.c:            s->ds->surface->pf = qemu_different_endianness_pixelformat(depth);
vga.c:            dpy_resize(s->ds);
vga.c:            qemu_console_resize(s->ds, disp_width, height);
vga.c:        s->last_scr_width = disp_width;
vga.c:        s->last_scr_height = height;
vga.c:        s->last_width = disp_width;
vga.c:        s->last_height = height;
vga.c:        s->last_line_offset = s->line_offset;
vga.c:        s->last_depth = depth;
vga.c:    } else if (is_buffer_shared(s->ds->surface) &&
vga.c:               (full_update || s->ds->surface->data != s->vram_ptr + (s->start_addr * 4))) {
vga.c:        s->ds->surface->data = s->vram_ptr + (s->start_addr * 4);
vga.c:        dpy_setdata(s->ds);
vga.c:    s->rgb_to_pixel =
vga.c:        rgb_to_pixel_dup_table[get_depth_index(s->ds)];
vga.c:        if (s->sr[0x01] & 8) {
vga.c:        if (s->sr[0x01] & 8) {
vga.c:        switch(s->get_bpp(s)) {
vga.c:    vga_draw_line = vga_draw_line_table[v * NB_DEPTHS + get_depth_index(s->ds)];
vga.c:    if (!is_buffer_shared(s->ds->surface) && s->cursor_invalidate)
vga.c:        s->cursor_invalidate(s);
vga.c:    line_offset = s->line_offset;
vga.c:           width, height, v, line_offset, s->cr[9], s->cr[0x17], s->line_compare, s->sr[0x01]);
vga.c:    addr1 = (s->start_addr * 4);
vga.c:    y_start = -1;
vga.c:    page_min = -1;
vga.c:    d = ds_get_data(s->ds);
vga.c:    linesize = ds_get_linesize(s->ds);
vga.c:        if (!(s->cr[0x17] & 1)) {
vga.c:            shift = 14 + ((s->cr[0x17] >> 6) & 1);
vga.c:        if (!(s->cr[0x17] & 2)) {
vga.c:        page0 = s->vram_offset + (addr & TARGET_PAGE_MASK);
vga.c:        page1 = s->vram_offset + ((addr + bwidth - 1) & TARGET_PAGE_MASK);
vga.c:        if ((page1 - page0) > TARGET_PAGE_SIZE) {
vga.c:        update |= (s->invalidated_y_table[y >> 5] >> (y & 0x1f)) & 1;
vga.c:            if (!(is_buffer_shared(s->ds->surface))) {
vga.c:                vga_draw_line(s, d, s->vram_ptr + addr, width);
vga.c:                if (s->cursor_draw_line)
vga.c:                    s->cursor_draw_line(s, d, y);
vga.c:                dpy_update(s->ds, 0, y_start,
vga.c:                           disp_width, y - y_start);
vga.c:                y_start = -1;
vga.c:            mask = (s->cr[0x17] & 3) ^ 3;
vga.c:            multi_run--;
vga.c:        if (y == s->line_compare)
vga.c:        dpy_update(s->ds, 0, y_start,
vga.c:                   disp_width, y - y_start);
vga.c:    memset(s->invalidated_y_table, 0, ((height + 31) >> 5) * 4);
vga.c:    if (s->last_scr_width <= 0 || s->last_scr_height <= 0)
vga.c:    s->rgb_to_pixel =
vga.c:        rgb_to_pixel_dup_table[get_depth_index(s->ds)];
vga.c:    if (ds_get_bits_per_pixel(s->ds) == 8)
vga.c:        val = s->rgb_to_pixel(0, 0, 0);
vga.c:    w = s->last_scr_width * ((ds_get_bits_per_pixel(s->ds) + 7) >> 3);
vga.c:    d = ds_get_data(s->ds);
vga.c:    for(i = 0; i < s->last_scr_height; i++) {
vga.c:        d += ds_get_linesize(s->ds);
vga.c:    dpy_update(s->ds, 0, 0,
vga.c:               s->last_scr_width, s->last_scr_height);
vga.c:    if (ds_get_bits_per_pixel(s->ds) == 0) {
vga.c:        if (!(s->ar_index & 0x20)) {
vga.c:            graphic_mode = s->gr[6] & 1;
vga.c:        if (graphic_mode != s->graphic_mode) {
vga.c:            s->graphic_mode = graphic_mode;
vga.c:    s->last_width = -1;
vga.c:    s->last_height = -1;
vga.c:    s->lfb_addr = 0;
vga.c:    s->lfb_end = 0;
vga.c:    s->map_addr = 0;
vga.c:    s->map_end = 0;
vga.c:    s->lfb_vram_mapped = 0;
vga.c:    s->bios_offset = 0;
vga.c:    s->bios_size = 0;
vga.c:    s->sr_index = 0;
vga.c:    memset(s->sr, '\0', sizeof(s->sr));
vga.c:    s->gr_index = 0;
vga.c:    memset(s->gr, '\0', sizeof(s->gr));
vga.c:    s->ar_index = 0;
vga.c:    memset(s->ar, '\0', sizeof(s->ar));
vga.c:    s->ar_flip_flop = 0;
vga.c:    s->cr_index = 0;
vga.c:    memset(s->cr, '\0', sizeof(s->cr));
vga.c:    s->msr = 0;
vga.c:    s->fcr = 0;
vga.c:    s->st00 = 0;
vga.c:    s->st01 = 0;
vga.c:    s->dac_state = 0;
vga.c:    s->dac_sub_index = 0;
vga.c:    s->dac_read_index = 0;
vga.c:    s->dac_write_index = 0;
vga.c:    memset(s->dac_cache, '\0', sizeof(s->dac_cache));
vga.c:    s->dac_8bit = 0;
vga.c:    memset(s->palette, '\0', sizeof(s->palette));
vga.c:    s->bank_offset = 0;
vga.c:    s->vbe_index = 0;
vga.c:    memset(s->vbe_regs, '\0', sizeof(s->vbe_regs));
vga.c:    s->vbe_regs[VBE_DISPI_INDEX_ID] = VBE_DISPI_ID0;
vga.c:    s->vbe_start_addr = 0;
vga.c:    s->vbe_line_offset = 0;
vga.c:    s->vbe_bank_mask = (s->vram_size >> 16) - 1;
vga.c:    memset(s->font_offsets, '\0', sizeof(s->font_offsets));
vga.c:    s->graphic_mode = -1; /* force full update */
vga.c:    s->shift_control = 0;
vga.c:    s->double_scan = 0;
vga.c:    s->line_offset = 0;
vga.c:    s->line_compare = 0;
vga.c:    s->start_addr = 0;
vga.c:    s->plane_updated = 0;
vga.c:    s->last_cw = 0;
vga.c:    s->last_ch = 0;
vga.c:    s->last_width = 0;
vga.c:    s->last_height = 0;
vga.c:    s->last_scr_width = 0;
vga.c:    s->last_scr_height = 0;
vga.c:    s->cursor_start = 0;
vga.c:    s->cursor_end = 0;
vga.c:    s->cursor_offset = 0;
vga.c:    memset(s->invalidated_y_table, '\0', sizeof(s->invalidated_y_table));
vga.c:    memset(s->last_palette, '\0', sizeof(s->last_palette));
vga.c:    memset(s->last_ch_attr, '\0', sizeof(s->last_ch_attr));
vga.c:        memset(&s->retrace_info, 0, sizeof (s->retrace_info));
vga.c:    if (!(s->ar_index & 0x20)) {
vga.c:        graphic_mode = s->gr[6] & 1;
vga.c:    if (graphic_mode != s->graphic_mode) {
vga.c:        s->graphic_mode = graphic_mode;
vga.c:    if (s->last_width == -1) {
vga.c:        s->last_width = 0;
vga.c:        cheight = (s->cr[9] & 0x1f) + 1;
vga.c:        if (!(s->sr[1] & 0x01))
vga.c:        if (s->sr[1] & 0x08)
vga.c:        width = (s->cr[0x01] + 1);
vga.c:        if (s->cr[0x06] == 100) {
vga.c:            /* ugly hack for CGA 160x100x16 - explain me the logic */
vga.c:            height = s->cr[0x12] | 
vga.c:                ((s->cr[0x07] & 0x02) << 7) | 
vga.c:                ((s->cr[0x07] & 0x40) << 3);
vga.c:        if (width != s->last_width || height != s->last_height ||
vga.c:            cw != s->last_cw || cheight != s->last_ch) {
vga.c:            s->last_scr_width = width * cw;
vga.c:            s->last_scr_height = height * cheight;
vga.c:            s->ds->surface->width = width;
vga.c:            s->ds->surface->height = height;
vga.c:            dpy_resize(s->ds);
vga.c:            s->last_width = width;
vga.c:            s->last_height = height;
vga.c:            s->last_ch = cheight;
vga.c:            s->last_cw = cw;
vga.c:        cursor_offset = ((s->cr[0x0e] << 8) | s->cr[0x0f]) - s->start_addr;
vga.c:        if (cursor_offset != s->cursor_offset ||
vga.c:            s->cr[0xa] != s->cursor_start ||
vga.c:            s->cr[0xb] != s->cursor_end || full_update) {
vga.c:            cursor_visible = !(s->cr[0xa] & 0x20);
vga.c:                dpy_cursor(s->ds,
vga.c:                dpy_cursor(s->ds, -1, -1);
vga.c:            s->cursor_offset = cursor_offset;
vga.c:            s->cursor_start = s->cr[0xa];
vga.c:            s->cursor_end = s->cr[0xb];
vga.c:        src = (uint32_t *) s->vram_ptr + s->start_addr;
vga.c:            dpy_update(s->ds, 0, 0, width, height);
vga.c:                dpy_update(s->ds, 0, i, width, TEXTMODE_Y(c_max) - i + 1);
vga.c:        s->get_resolution(s, &width, &height);
vga.c:    s->last_width = 60;
vga.c:    s->last_height = height = 3;
vga.c:    dpy_cursor(s->ds, -1, -1);
vga.c:    s->ds->surface->width = s->last_width;
vga.c:    s->ds->surface->height = height;
vga.c:    dpy_resize(s->ds);
vga.c:    for (dst = chardata, i = 0; i < s->last_width * height; i ++)
vga.c:    width = (s->last_width - size) / 2;
vga.c:    dst = chardata + s->last_width + width;
vga.c:    dpy_update(s->ds, 0, 0, s->last_width, height);
vga.c:    s->graphic_mode = -1;
vga.c:    s->is_vbe_vmstate = 1;
vga.c:    s->is_vbe_vmstate = 0;
vga.c:    s->vram_offset = qemu_ram_alloc(vga_ram_size);
vga.c:    s->vram_ptr = qemu_get_ram_ptr(s->vram_offset);
vga.c:    s->vram_size = vga_ram_size;
vga.c:    s->get_bpp = vga_get_bpp;
vga.c:    s->get_offsets = vga_get_offsets;
vga.c:    s->get_resolution = vga_get_resolution;
vga.c:    s->update = vga_update_display;
vga.c:    s->invalidate = vga_invalidate_display;
vga.c:    s->screen_dump = vga_screen_dump;
vga.c:    s->text_update = vga_update_text;
vga.c:        s->retrace = vga_dumb_retrace;
vga.c:        s->update_retrace_info = vga_dumb_update_retrace_info;
vga.c:        s->retrace = vga_precise_retrace;
vga.c:        s->update_retrace_info = vga_precise_update_retrace_info;
vga.c:    s->bank_offset = 0;
vga.c:                                 VGA_RAM_SIZE, s->vram_offset);
vga.c:    s->vbe_mapped = 1;
vga.c:        ppm_save(screen_dump_filename, ds->surface);
vga.c:        return -1;
vga.c:            ds->width, ds->height, 255);
vga.c:    d1 = ds->data;
vga.c:    for(y = 0; y < ds->height; y++) {
vga.c:        for(x = 0; x < ds->width; x++) {
vga.c:            if (ds->pf.bits_per_pixel == 32)
vga.c:            r = ((v >> ds->pf.rshift) & ds->pf.rmax) * 256 /
vga.c:                (ds->pf.rmax + 1);
vga.c:            g = ((v >> ds->pf.gshift) & ds->pf.gmax) * 256 /
vga.c:                (ds->pf.gmax + 1);
vga.c:            b = ((v >> ds->pf.bshift) & ds->pf.bmax) * 256 /
vga.c:                (ds->pf.bmax + 1);
vga.c:            d += ds->pf.bytes_per_pixel;
vga.c:        d1 += ds->linesize;
vga.c:    dcl->dpy_update = vga_save_dpy_update;
vga.c:    dcl->dpy_resize = vga_save_dpy_resize;
vga.c:    dcl->dpy_refresh = vga_save_dpy_refresh;
vga.c:        screen_dump_dcl = vga_screen_dump_init(s->ds);
vga_int.h: * Copyright (c) 2003-2004 Fabrice Bellard
vga_int.h:#define VGABIOS_CIRRUS_FILENAME "vgabios-cirrus.bin"
vga-isa.c:#include "qemu-timer.h"
vga-isa.c:    s->ds = graphic_console_init(s->update, s->invalidate,
vga-isa.c:                                 s->screen_dump, s->text_update, s);
vga-isa-mm.c:#include "qemu-timer.h"
vga-isa-mm.c:    return vga_ioport_read(&s->vga, addr >> s->it_shift) & 0xff;
vga-isa-mm.c:    vga_ioport_write(&s->vga, addr >> s->it_shift, value & 0xff);
vga-isa-mm.c:    return vga_ioport_read(&s->vga, addr >> s->it_shift) & 0xffff;
vga-isa-mm.c:    vga_ioport_write(&s->vga, addr >> s->it_shift, value & 0xffff);
vga-isa-mm.c:    return vga_ioport_read(&s->vga, addr >> s->it_shift);
vga-isa-mm.c:    vga_ioport_write(&s->vga, addr >> s->it_shift, value);
vga-isa-mm.c:    s->it_shift = it_shift;
vga-isa-mm.c:    s->vga.bank_offset = 0;
vga-isa-mm.c:    vga_common_init(&s->vga, VGA_RAM_SIZE);
vga-isa-mm.c:    s->vga.ds = graphic_console_init(s->vga.update, s->vga.invalidate,
vga-isa-mm.c:                                     s->vga.screen_dump, s->vga.text_update, s);
vga-isa-mm.c:                                 VGA_RAM_SIZE, s->vga.vram_offset);
vga-pci.c:#include "qemu-timer.h"
vga-pci.c:    VGACommonState *s = &d->vga;
vga-pci.c:        cpu_register_physical_memory(addr, s->bios_size, s->bios_offset);
vga-pci.c:        cpu_register_physical_memory(addr, s->vram_size, s->vram_offset);
vga-pci.c:        s->map_addr = addr;
vga-pci.c:        s->map_end = addr + s->vram_size;
vga-pci.c:    VGACommonState *s = &pvs->vga;
vga-pci.c:    if (s->map_addr && pvs->dev.io_regions[0].addr == -1)
vga-pci.c:        s->map_addr = 0;
vga-pci.c:     VGACommonState *s = &d->vga;
vga-pci.c:     uint8_t *pci_conf = d->dev.config;
vga-pci.c:     s->ds = graphic_console_init(s->update, s->invalidate,
vga-pci.c:                                  s->screen_dump, s->text_update, s);
vga-pci.c:     pci_register_bar(&d->dev, 0, VGA_RAM_SIZE,
vga-pci.c:     if (s->bios_size) {
vga-pci.c:        while (bios_total_size < s->bios_size)
vga-pci.c:        pci_register_bar(&d->dev, PCI_ROM_SLOT, bios_total_size,
vga-pci.c:    dev = pci_create(bus, -1, "VGA");
vga-pci.c:    qdev_prop_set_uint32(&dev->qdev, "bios-offset", vga_bios_offset);
vga-pci.c:    qdev_prop_set_uint32(&dev->qdev, "bios-size", vga_bios_size);
vga-pci.c:    qdev_init_nofail(&dev->qdev);
vga-pci.c:        DEFINE_PROP_HEX32("bios-offset", PCIVGAState, vga.bios_offset, 0),
vga-pci.c:        DEFINE_PROP_HEX32("bios-size",   PCIVGAState, vga.bios_size,   0),
vga_template.h:        ((uint32_t *)d)[0] = (-((font_data >> 7)) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[1] = (-((font_data >> 6) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[2] = (-((font_data >> 5) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[3] = (-((font_data >> 4) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[4] = (-((font_data >> 3) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[5] = (-((font_data >> 2) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[6] = (-((font_data >> 1) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[7] = (-((font_data >> 0) & 1) & xorcol) ^ bgcol;
vga_template.h:    } while (--h);
vga_template.h:    } while (--h);
vga_template.h:            ((uint8_t *)d)[8] = v >> (24 * (1 - BIG));
vga_template.h:            ((uint16_t *)d)[8] = v >> (16 * (1 - BIG));
vga_template.h:        ((uint32_t *)d)[0] = (-((font_data >> 7)) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[1] = (-((font_data >> 6) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[2] = (-((font_data >> 5) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[3] = (-((font_data >> 4) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[4] = (-((font_data >> 3) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[5] = (-((font_data >> 2) & 1) & xorcol) ^ bgcol;
vga_template.h:        ((uint32_t *)d)[6] = (-((font_data >> 1) & 1) & xorcol) ^ bgcol;
vga_template.h:        v = (-((font_data >> 0) & 1) & xorcol) ^ bgcol;
vga_template.h:    } while (--h);
vga_template.h:    palette = s1->last_palette;
vga_template.h:    plane_mask = mask16[s1->ar[0x12] & 0xf];
vga_template.h:    palette = s1->last_palette;
vga_template.h:    plane_mask = mask16[s1->ar[0x12] & 0xf];
vga_template.h:    palette = s1->last_palette;
vga_template.h:    plane_mask = mask16[s1->ar[0x12] & 0xf];
vga_template.h:    palette = s1->last_palette;
vga_template.h:    plane_mask = mask16[s1->ar[0x12] & 0xf];
vga_template.h:    palette = s1->last_palette;
vga_template.h:    palette = s1->last_palette;
vga_template.h:        b0 = (plane0[x >> 3] >> (7 - (x & 7))) & 1;
vga_template.h:        b1 = (plane1[x >> 3] >> (7 - (x & 7))) & 1;
vga_template.h:    } while (--w != 0);
vga_template.h:    } while (--w != 0);
vga_template.h:    } while (--w != 0);
vga_template.h:    } while (--w != 0);
virtio-balloon.c: * the COPYING file in the top-level directory.
virtio-balloon.c:#include "qemu-common.h"
virtio-balloon.c:#include "virtio-balloon.h"
virtio-balloon.c:#include "qemu-kvm.h"
virtio-balloon.c:            size_t len = MIN((iov_off + iov[i].iov_len) - offset , size);
virtio-balloon.c:            memcpy(ptr + data_off, iov[i].iov_base + (offset - iov_off), len);
virtio-balloon.c:            size -= len;
virtio-balloon.c:            balloon_page(qemu_get_ram_ptr(addr), !!(vq == s->dvq));
virtio-balloon.c:    config.num_pages = cpu_to_le32(dev->num_pages);
virtio-balloon.c:    config.actual = cpu_to_le32(dev->actual);
virtio-balloon.c:    dev->actual = config.actual;
virtio-balloon.c:        dev->num_pages = (ram_size - target) >> VIRTIO_BALLOON_PFN_SHIFT;
virtio-balloon.c:        virtio_notify_config(&dev->vdev);
virtio-balloon.c:    return ram_size - (dev->actual << VIRTIO_BALLOON_PFN_SHIFT);
virtio-balloon.c:    virtio_save(&s->vdev, f);
virtio-balloon.c:    qemu_put_be32(f, s->num_pages);
virtio-balloon.c:    qemu_put_be32(f, s->actual);
virtio-balloon.c:        return -EINVAL;
virtio-balloon.c:    virtio_load(&s->vdev, f);
virtio-balloon.c:    s->num_pages = qemu_get_be32(f);
virtio-balloon.c:    s->actual = qemu_get_be32(f);
virtio-balloon.c:    s = (VirtIOBalloon *)virtio_common_init("virtio-balloon",
virtio-balloon.c:    s->vdev.get_config = virtio_balloon_get_config;
virtio-balloon.c:    s->vdev.set_config = virtio_balloon_set_config;
virtio-balloon.c:    s->vdev.get_features = virtio_balloon_get_features;
virtio-balloon.c:    s->ivq = virtio_add_queue(&s->vdev, 128, virtio_balloon_handle_output);
virtio-balloon.c:    s->dvq = virtio_add_queue(&s->vdev, 128, virtio_balloon_handle_output);
virtio-balloon.c:    register_savevm("virtio-balloon", -1, 1, virtio_balloon_save, virtio_balloon_load, s);
virtio-balloon.c:    return &s->vdev;
virtio-balloon.h: * Copyright IBM, Corp. 2007-2008
virtio-balloon.h: * the COPYING file in the top-level directory.
virtio-blk.c: * the COPYING file in the top-level directory.
virtio-blk.c:#include <qemu-common.h>
virtio-blk.c:#include "virtio-blk.h"
virtio-blk.c:    while (len--)
virtio-blk.c: * ref: AT Attachment 8 - ATA/ATAPI Command Set (ATA8-ACS)
virtio-blk.c:    uint16_t *p = &bc->identify[0];
virtio-blk.c:    uint64_t lba_sectors = bc->capacity;
virtio-blk.c:    memset(p, 0, sizeof(bc->identify));
virtio-blk.c:    VirtIOBlock *s = req->dev;
virtio-blk.c:    req->in->status = status;
virtio-blk.c:    virtqueue_push(s->vq, &req->elem, req->qiov.size + sizeof(*req->in));
virtio-blk.c:    virtio_notify(&s->vdev, s->vq);
virtio-blk.c:        drive_get_on_error(req->dev->bs, is_read);
virtio-blk.c:    VirtIOBlock *s = req->dev;
virtio-blk.c:        req->next = s->rq;
virtio-blk.c:        s->rq = req;
virtio-blk.c:        int is_read = !(req->out->type & VIRTIO_BLK_T_OUT);
virtio-blk.c:        if (virtio_blk_handle_rw_error(req, -ret, is_read))
virtio-blk.c:    req->dev = s;
virtio-blk.c:        if (!virtqueue_pop(s->vq, &req->elem)) {
virtio-blk.c:    if (req->elem.out_num < 2 || req->elem.in_num < 3) {
virtio-blk.c:    if (req->elem.out_num > 2 && req->elem.in_num > 3) {
virtio-blk.c:     * The scsi inhdr is placed in the second-to-last input segment, just
virtio-blk.c:    req->scsi = (void *)req->elem.in_sg[req->elem.in_num - 2].iov_base;
virtio-blk.c:    size = sizeof(*req->in) + sizeof(*req->scsi);
virtio-blk.c:    hdr.cmd_len = req->elem.out_sg[1].iov_len;
virtio-blk.c:    hdr.cmdp = req->elem.out_sg[1].iov_base;
virtio-blk.c:    if (req->elem.out_num > 2) {
virtio-blk.c:        hdr.iovec_count = req->elem.out_num - 2;
virtio-blk.c:            hdr.dxfer_len += req->elem.out_sg[i + 2].iov_len;
virtio-blk.c:        hdr.dxferp = req->elem.out_sg + 2;
virtio-blk.c:    } else if (req->elem.in_num > 3) {
virtio-blk.c:        hdr.iovec_count = req->elem.in_num - 3;
virtio-blk.c:            hdr.dxfer_len += req->elem.in_sg[i].iov_len;
virtio-blk.c:        hdr.dxferp = req->elem.in_sg;
virtio-blk.c:    hdr.sbp = req->elem.in_sg[req->elem.in_num - 3].iov_base;
virtio-blk.c:    hdr.mx_sb_len = req->elem.in_sg[req->elem.in_num - 3].iov_len;
virtio-blk.c:    ret = bdrv_ioctl(req->dev->bs, SG_IO, &hdr);
virtio-blk.c:    req->scsi->errors = hdr.status;
virtio-blk.c:    req->scsi->residual = hdr.resid;
virtio-blk.c:    req->scsi->sense_len = hdr.sb_len_wr;
virtio-blk.c:    req->scsi->data_len = hdr.dxfer_len;
virtio-blk.c:                virtio_blk_rw_complete(blkreq[i].opaque, -EIO);
virtio-blk.c:    acb = bdrv_aio_flush(req->dev->bs, virtio_blk_flush_complete, req);
virtio-blk.c:    if (req->dev->bs != *old_bs || *num_writes == 32) {
virtio-blk.c:        *old_bs = req->dev->bs;
virtio-blk.c:    blkreq[*num_writes].sector = req->out->sector;
virtio-blk.c:    blkreq[*num_writes].nb_sectors = req->qiov.size / 512;
virtio-blk.c:    blkreq[*num_writes].qiov = &req->qiov;
virtio-blk.c:    acb = bdrv_aio_readv(req->dev->bs, req->out->sector, &req->qiov,
virtio-blk.c:                         req->qiov.size / 512, virtio_blk_rw_complete, req);
virtio-blk.c:        virtio_blk_rw_complete(req, -EIO);
virtio-blk.c:    if (req->elem.out_num < 1 || req->elem.in_num < 1) {
virtio-blk.c:        fprintf(stderr, "virtio-blk missing headers\n");
virtio-blk.c:    if (req->elem.out_sg[0].iov_len < sizeof(*req->out) ||
virtio-blk.c:        req->elem.in_sg[req->elem.in_num - 1].iov_len < sizeof(*req->in)) {
virtio-blk.c:        fprintf(stderr, "virtio-blk header not in correct element\n");
virtio-blk.c:    req->out = (void *)req->elem.out_sg[0].iov_base;
virtio-blk.c:    req->in = (void *)req->elem.in_sg[req->elem.in_num - 1].iov_base;
virtio-blk.c:    if (req->out->type & VIRTIO_BLK_T_FLUSH) {
virtio-blk.c:    } else if (req->out->type & VIRTIO_BLK_T_SCSI_CMD) {
virtio-blk.c:    } else if (req->out->type & VIRTIO_BLK_T_OUT) {
virtio-blk.c:        qemu_iovec_init_external(&req->qiov, &req->elem.out_sg[1],
virtio-blk.c:                                 req->elem.out_num - 1);
virtio-blk.c:        virtio_blk_handle_write(mrb->blkreq, &mrb->num_writes,
virtio-blk.c:            req, &mrb->old_bs);
virtio-blk.c:        qemu_iovec_init_external(&req->qiov, &req->elem.in_sg[0],
virtio-blk.c:                                 req->elem.in_num - 1);
virtio-blk.c:    VirtIOBlockReq *req = s->rq;
virtio-blk.c:    qemu_bh_delete(s->bh);
virtio-blk.c:    s->bh = NULL;
virtio-blk.c:    s->rq = NULL;
virtio-blk.c:        req = req->next;
virtio-blk.c:    if (!s->bh) {
virtio-blk.c:        s->bh = qemu_bh_new(virtio_blk_dma_restart_bh, s);
virtio-blk.c:        qemu_bh_schedule(s->bh);
virtio-blk.c:     * are per-device request lists.
virtio-blk.c:    bdrv_get_geometry(s->bs, &capacity);
virtio-blk.c:    bdrv_get_geometry_hint(s->bs, &cylinders, &heads, &secs);
virtio-blk.c:    stl_raw(&blkcfg.seg_max, 128 - 2);
virtio-blk.c:    memcpy(&blkcfg.identify[VIRTIO_BLK_ID_SN], s->serial_str,
virtio-blk.c:    memcpy(config, &blkcfg, s->config_size);
virtio-blk.c:    if (bdrv_enable_write_cache(s->bs))
virtio-blk.c:    if (strcmp(s->serial_str, "0"))
virtio-blk.c:    if (bdrv_is_read_only(s->bs))
virtio-blk.c:    VirtIOBlockReq *req = s->rq;
virtio-blk.c:    virtio_save(&s->vdev, f);
virtio-blk.c:        qemu_put_buffer(f, (unsigned char*)&req->elem, sizeof(req->elem));
virtio-blk.c:        req = req->next;
virtio-blk.c:        return -EINVAL;
virtio-blk.c:    virtio_load(&s->vdev, f);
virtio-blk.c:        qemu_get_buffer(f, (unsigned char*)&req->elem, sizeof(req->elem));
virtio-blk.c:        req->next = s->rq;
virtio-blk.c:        s->rq = req->next;
virtio-blk.c:    char *ps = (char *)drive_get_serial(dinfo->bdrv);
virtio-blk.c:    s = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK,
virtio-blk.c:    s->config_size = size;
virtio-blk.c:    s->vdev.get_config = virtio_blk_update_config;
virtio-blk.c:    s->vdev.get_features = virtio_blk_get_features;
virtio-blk.c:    s->vdev.reset = virtio_blk_reset;
virtio-blk.c:    s->bs = dinfo->bdrv;
virtio-blk.c:    s->rq = NULL;
virtio-blk.c:        strncpy(s->serial_str, ps, sizeof(s->serial_str));
virtio-blk.c:        snprintf(s->serial_str, sizeof(s->serial_str), "0");
virtio-blk.c:    bdrv_guess_geometry(s->bs, &cylinders, &heads, &secs);
virtio-blk.c:    bdrv_set_geometry_hint(s->bs, cylinders, heads, secs);
virtio-blk.c:    s->vq = virtio_add_queue(&s->vdev, 128, virtio_blk_handle_output);
virtio-blk.c:    register_savevm("virtio-blk", virtio_blk_id++, 2,
virtio-blk.c:    return &s->vdev;
virtio-blk.h: * the COPYING file in the top-level directory.
virtio-blk.h:#define VIRTIO_BLK_F_RO         5       /* Disk is read-only */
virtio-blk.h:/* This is the first element of the read scatter-gather list. */
virtio-blk.h:/* This is the last element of the write scatter-gather list */
virtio-blk.h:/* SCSI pass-through header */
virtio.c: * the COPYING file in the top-level directory.
virtio.c: * lock-step.  We'll leave the calls to wmb() in though to make it obvious for
virtio.c:    target_phys_addr_t pa = vq->pa;
virtio.c:    vq->vring.desc = pa;
virtio.c:    vq->vring.avail = pa + vq->vring.num * sizeof(VRingDesc);
virtio.c:    vq->vring.used = vring_align(vq->vring.avail +
virtio.c:                                 offsetof(VRingAvail, ring[vq->vring.num]),
virtio.c:    pa = vq->vring.avail + offsetof(VRingAvail, flags);
virtio.c:    pa = vq->vring.avail + offsetof(VRingAvail, idx);
virtio.c:    pa = vq->vring.avail + offsetof(VRingAvail, ring[i]);
virtio.c:    pa = vq->vring.used + offsetof(VRingUsed, ring[i].id);
virtio.c:    pa = vq->vring.used + offsetof(VRingUsed, ring[i].len);
virtio.c:    pa = vq->vring.used + offsetof(VRingUsed, idx);
virtio.c:    pa = vq->vring.used + offsetof(VRingUsed, idx);
virtio.c:    pa = vq->vring.used + offsetof(VRingUsed, flags);
virtio.c:    pa = vq->vring.used + offsetof(VRingUsed, flags);
virtio.c:    return vq->vring.avail != 0;
virtio.c:    return vring_avail_idx(vq) == vq->last_avail_idx;
virtio.c:    for (i = 0; i < elem->in_num; i++) {
virtio.c:        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);
virtio.c:        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,
virtio.c:                                  elem->in_sg[i].iov_len,
virtio.c:        offset += elem->in_sg[i].iov_len;
virtio.c:    for (i = 0; i < elem->out_num; i++)
virtio.c:        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,
virtio.c:                                  elem->out_sg[i].iov_len,
virtio.c:                                  0, elem->out_sg[i].iov_len);
virtio.c:    idx = (idx + vring_used_idx(vq)) % vq->vring.num;
virtio.c:    vring_used_ring_id(vq, idx, elem->index);
virtio.c:    vq->inuse -= count;
virtio.c:    uint16_t num_heads = vring_avail_idx(vq) - idx;
virtio.c:    if (num_heads > vq->vring.num) {
virtio.c:    head = vring_avail_ring(vq, idx % vq->vring.num);
virtio.c:    if (head >= vq->vring.num) {
virtio.c:    idx = vq->last_avail_idx;
virtio.c:        max = vq->vring.num;
virtio.c:        desc_pa = vq->vring.desc;
virtio.c:    target_phys_addr_t desc_pa = vq->vring.desc;
virtio.c:    if (!virtqueue_num_heads(vq, vq->last_avail_idx))
virtio.c:    elem->out_num = elem->in_num = 0;
virtio.c:    max = vq->vring.num;
virtio.c:    i = head = virtqueue_get_head(vq, vq->last_avail_idx++);
virtio.c:            elem->in_addr[elem->in_num] = vring_desc_addr(desc_pa, i);
virtio.c:            sg = &elem->in_sg[elem->in_num++];
virtio.c:            sg = &elem->out_sg[elem->out_num++];
virtio.c:        sg->iov_len = vring_desc_len(desc_pa, i);
virtio.c:        len = sg->iov_len;
virtio.c:        sg->iov_base = cpu_physical_memory_map(vring_desc_addr(desc_pa, i),
virtio.c:        if (sg->iov_base == NULL || len != sg->iov_len) {
virtio.c:        if ((elem->in_num + elem->out_num) > max) {
virtio.c:    elem->index = head;
virtio.c:    vq->inuse++;
virtio.c:    return elem->in_num + elem->out_num;
virtio.c:    if (vdev->binding->notify) {
virtio.c:        vdev->binding->notify(vdev->binding_opaque, vector);
virtio.c:    if (vdev->reset)
virtio.c:        vdev->reset(vdev);
virtio.c:    vdev->features = 0;
virtio.c:    vdev->queue_sel = 0;
virtio.c:    vdev->status = 0;
virtio.c:    vdev->isr = 0;
virtio.c:    vdev->config_vector = VIRTIO_NO_VECTOR;
virtio.c:    virtio_notify_vector(vdev, vdev->config_vector);
virtio.c:        vdev->vq[i].vring.desc = 0;
virtio.c:        vdev->vq[i].vring.avail = 0;
virtio.c:        vdev->vq[i].vring.used = 0;
virtio.c:        vdev->vq[i].last_avail_idx = 0;
virtio.c:        vdev->vq[i].pa = 0;
virtio.c:        vdev->vq[i].vector = VIRTIO_NO_VECTOR;
virtio.c:    vdev->get_config(vdev, vdev->config);
virtio.c:    if (addr > (vdev->config_len - sizeof(val)))
virtio.c:        return (uint32_t)-1;
virtio.c:    memcpy(&val, vdev->config + addr, sizeof(val));
virtio.c:    vdev->get_config(vdev, vdev->config);
virtio.c:    if (addr > (vdev->config_len - sizeof(val)))
virtio.c:        return (uint32_t)-1;
virtio.c:    memcpy(&val, vdev->config + addr, sizeof(val));
virtio.c:    vdev->get_config(vdev, vdev->config);
virtio.c:    if (addr > (vdev->config_len - sizeof(val)))
virtio.c:        return (uint32_t)-1;
virtio.c:    memcpy(&val, vdev->config + addr, sizeof(val));
virtio.c:    if (addr > (vdev->config_len - sizeof(val)))
virtio.c:    memcpy(vdev->config + addr, &val, sizeof(val));
virtio.c:    if (vdev->set_config)
virtio.c:        vdev->set_config(vdev, vdev->config);
virtio.c:    if (addr > (vdev->config_len - sizeof(val)))
virtio.c:    memcpy(vdev->config + addr, &val, sizeof(val));
virtio.c:    if (vdev->set_config)
virtio.c:        vdev->set_config(vdev, vdev->config);
virtio.c:    if (addr > (vdev->config_len - sizeof(val)))
virtio.c:    memcpy(vdev->config + addr, &val, sizeof(val));
virtio.c:    if (vdev->set_config)
virtio.c:        vdev->set_config(vdev, vdev->config);
virtio.c:    vdev->vq[n].pa = addr;
virtio.c:    virtqueue_init(&vdev->vq[n]);
virtio.c:    return vdev->vq[n].pa;
virtio.c:    return vdev->vq[n].vring.num;
virtio.c:    if (n < VIRTIO_PCI_QUEUE_MAX && vdev->vq[n].vring.desc) {
virtio.c:        vdev->vq[n].handle_output(vdev, &vdev->vq[n]);
virtio.c:    return n < VIRTIO_PCI_QUEUE_MAX ? vdev->vq[n].vector :
virtio.c:        vdev->vq[n].vector = vector;
virtio.c:        if (vdev->vq[i].vring.num == 0)
virtio.c:    vdev->vq[i].vring.num = queue_size;
virtio.c:    vdev->vq[i].handle_output = handle_output;
virtio.c:    return &vdev->vq[i];
virtio.c:        (!(vdev->features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) ||
virtio.c:         (vq->inuse || vring_avail_idx(vq) != vq->last_avail_idx)))
virtio.c:    vdev->isr |= 0x01;
virtio.c:    virtio_notify_vector(vdev, vq->vector);
virtio.c:    if (!(vdev->status & VIRTIO_CONFIG_S_DRIVER_OK))
virtio.c:    vdev->isr |= 0x03;
virtio.c:    virtio_notify_vector(vdev, vdev->config_vector);
virtio.c:    if (vdev->binding->save_config)
virtio.c:        vdev->binding->save_config(vdev->binding_opaque, f);
virtio.c:    qemu_put_8s(f, &vdev->status);
virtio.c:    qemu_put_8s(f, &vdev->isr);
virtio.c:    qemu_put_be16s(f, &vdev->queue_sel);
virtio.c:    qemu_put_be32s(f, &vdev->features);
virtio.c:    qemu_put_be32(f, vdev->config_len);
virtio.c:    qemu_put_buffer(f, vdev->config, vdev->config_len);
virtio.c:        if (vdev->vq[i].vring.num == 0)
virtio.c:        if (vdev->vq[i].vring.num == 0)
virtio.c:        qemu_put_be32(f, vdev->vq[i].vring.num);
virtio.c:        qemu_put_be64(f, vdev->vq[i].pa);
virtio.c:        qemu_put_be16s(f, &vdev->vq[i].last_avail_idx);
virtio.c:        if (vdev->binding->save_queue)
virtio.c:            vdev->binding->save_queue(vdev->binding_opaque, i, f);
virtio.c:    uint32_t supported_features = vdev->get_features(vdev) |
virtio.c:        vdev->binding->get_features(vdev->binding_opaque);
virtio.c:    if (vdev->binding->load_config) {
virtio.c:        ret = vdev->binding->load_config(vdev->binding_opaque, f);
virtio.c:    qemu_get_8s(f, &vdev->status);
virtio.c:    qemu_get_8s(f, &vdev->isr);
virtio.c:    qemu_get_be16s(f, &vdev->queue_sel);
virtio.c:        return -1;
virtio.c:    vdev->features = features;
virtio.c:    vdev->config_len = qemu_get_be32(f);
virtio.c:    qemu_get_buffer(f, vdev->config, vdev->config_len);
virtio.c:        vdev->vq[i].vring.num = qemu_get_be32(f);
virtio.c:        vdev->vq[i].pa = qemu_get_be64(f);
virtio.c:        qemu_get_be16s(f, &vdev->vq[i].last_avail_idx);
virtio.c:        if (vdev->vq[i].pa) {
virtio.c:            virtqueue_init(&vdev->vq[i]);
virtio.c:        if (vdev->binding->load_queue) {
virtio.c:            ret = vdev->binding->load_queue(vdev->binding_opaque, i, f);
virtio.c:    if (vdev->config)
virtio.c:        qemu_free(vdev->config);
virtio.c:    qemu_free(vdev->vq);
virtio.c:    vdev->device_id = device_id;
virtio.c:    vdev->status = 0;
virtio.c:    vdev->isr = 0;
virtio.c:    vdev->queue_sel = 0;
virtio.c:    vdev->config_vector = VIRTIO_NO_VECTOR;
virtio.c:    vdev->vq = qemu_mallocz(sizeof(VirtQueue) * VIRTIO_PCI_QUEUE_MAX);
virtio.c:        vdev->vq[i].vector = VIRTIO_NO_VECTOR;
virtio.c:    vdev->name = name;
virtio.c:    vdev->config_len = config_size;
virtio.c:    if (vdev->config_len)
virtio.c:        vdev->config = qemu_mallocz(config_size);
virtio.c:        vdev->config = NULL;
virtio.c:    vdev->binding = binding;
virtio.c:    vdev->binding_opaque = opaque;
virtio-console.c: * the COPYING file in the top-level directory.
virtio-console.c:#include "qemu-char.h"
virtio-console.c:#include "virtio-console.h"
virtio-console.c:            len += qemu_chr_write(s->chr, (uint8_t *)elem.out_sg[d].iov_base,
virtio-console.c:    if (!virtio_queue_ready(s->ivq) ||
virtio-console.c:        !(s->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK) ||
virtio-console.c:        virtio_queue_empty(s->ivq))
virtio-console.c:    if (virtqueue_avail_bytes(s->ivq, TARGET_PAGE_SIZE, 0))
virtio-console.c:    if (virtqueue_avail_bytes(s->ivq, 1, 0))
virtio-console.c:        if (!virtqueue_pop(s->ivq, &elem))
virtio-console.c:            int len = MIN(elem.in_sg[i].iov_len, size - offset);
virtio-console.c:        virtqueue_push(s->ivq, &elem, size);
virtio-console.c:    virtio_notify(&s->vdev, s->ivq);
virtio-console.c:    virtio_save(&s->vdev, f);
virtio-console.c:        return -EINVAL;
virtio-console.c:    virtio_load(&s->vdev, f);
virtio-console.c:    s = (VirtIOConsole *)virtio_common_init("virtio-console",
virtio-console.c:    s->vdev.get_features = virtio_console_get_features;
virtio-console.c:    s->ivq = virtio_add_queue(&s->vdev, 128, virtio_console_handle_input);
virtio-console.c:    s->ovq = virtio_add_queue(&s->vdev, 128, virtio_console_handle_output);
virtio-console.c:    s->chr = qdev_init_chardev(dev);
virtio-console.c:    qemu_chr_add_handlers(s->chr, vcon_can_read, vcon_read, vcon_event, s);
virtio-console.c:    register_savevm("virtio-console", -1, 1, virtio_console_save, virtio_console_load, s);
virtio-console.c:    return &s->vdev;
virtio-console.h: * the COPYING file in the top-level directory.
virtio.h: * the COPYING file in the top-level directory.
virtio.h: * transport being used (eg. virtio_ring), the rest are per-device feature bits. */
virtio.h:/* This marks a buffer as write-only (otherwise read-only). */
virtio.h:    return (addr + align - 1) & ~(align - 1);
virtio-net.c: * the COPYING file in the top-level directory.
virtio-net.c:#include "qemu-timer.h"
virtio-net.c:#include "virtio-net.h"
virtio-net.c: * - we could suppress RX interrupt if we were so inclined.
virtio-net.c:    netcfg.status = n->status;
virtio-net.c:    memcpy(netcfg.mac, n->mac, ETH_ALEN);
virtio-net.c:    if (memcmp(netcfg.mac, n->mac, ETH_ALEN)) {
virtio-net.c:        memcpy(n->mac, netcfg.mac, ETH_ALEN);
virtio-net.c:        qemu_format_nic_info_str(&n->nic->nc, n->mac);
virtio-net.c:    VirtIONet *n = DO_UPCAST(NICState, nc, nc)->opaque;
virtio-net.c:    uint16_t old_status = n->status;
virtio-net.c:    if (nc->link_down)
virtio-net.c:        n->status &= ~VIRTIO_NET_S_LINK_UP;
virtio-net.c:        n->status |= VIRTIO_NET_S_LINK_UP;
virtio-net.c:    if (n->status != old_status)
virtio-net.c:        virtio_notify_config(&n->vdev);
virtio-net.c:    n->promisc = 1;
virtio-net.c:    n->allmulti = 0;
virtio-net.c:    n->alluni = 0;
virtio-net.c:    n->nomulti = 0;
virtio-net.c:    n->nouni = 0;
virtio-net.c:    n->nobcast = 0;
virtio-net.c:    n->mac_table.in_use = 0;
virtio-net.c:    n->mac_table.first_multi = 0;
virtio-net.c:    n->mac_table.multi_overflow = 0;
virtio-net.c:    n->mac_table.uni_overflow = 0;
virtio-net.c:    memset(n->mac_table.macs, 0, MAC_TABLE_ENTRIES * ETH_ALEN);
virtio-net.c:    memset(n->vlans, 0, MAX_VLAN >> 3);
virtio-net.c:    if (!n->nic->nc.peer)
virtio-net.c:    if (n->nic->nc.peer->info->type != NET_CLIENT_TYPE_TAP)
virtio-net.c:    n->has_vnet_hdr = tap_has_vnet_hdr(n->nic->nc.peer);
virtio-net.c:    return n->has_vnet_hdr;
virtio-net.c:    n->has_ufo = tap_has_ufo(n->nic->nc.peer);
virtio-net.c:    return n->has_ufo;
virtio-net.c:        tap_using_vnet_hdr(n->nic->nc.peer, 1);
virtio-net.c:    n->mergeable_rx_bufs = !!(features & (1 << VIRTIO_NET_F_MRG_RXBUF));
virtio-net.c:    if (n->has_vnet_hdr) {
virtio-net.c:        tap_set_offload(n->nic->nc.peer,
virtio-net.c:    if (elem->out_num != 2 || elem->out_sg[1].iov_len != sizeof(on)) {
virtio-net.c:        fprintf(stderr, "virtio-net ctrl invalid rx mode command\n");
virtio-net.c:    on = ldub_p(elem->out_sg[1].iov_base);
virtio-net.c:        n->promisc = on;
virtio-net.c:        n->allmulti = on;
virtio-net.c:        n->alluni = on;
virtio-net.c:        n->nomulti = on;
virtio-net.c:        n->nouni = on;
virtio-net.c:        n->nobcast = on;
virtio-net.c:    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET || elem->out_num != 3 ||
virtio-net.c:        elem->out_sg[1].iov_len < sizeof(mac_data) ||
virtio-net.c:        elem->out_sg[2].iov_len < sizeof(mac_data))
virtio-net.c:    n->mac_table.in_use = 0;
virtio-net.c:    n->mac_table.first_multi = 0;
virtio-net.c:    n->mac_table.uni_overflow = 0;
virtio-net.c:    n->mac_table.multi_overflow = 0;
virtio-net.c:    memset(n->mac_table.macs, 0, MAC_TABLE_ENTRIES * ETH_ALEN);
virtio-net.c:    mac_data.entries = ldl_le_p(elem->out_sg[1].iov_base);
virtio-net.c:        (mac_data.entries * ETH_ALEN) > elem->out_sg[1].iov_len)
virtio-net.c:        memcpy(n->mac_table.macs, elem->out_sg[1].iov_base + sizeof(mac_data),
virtio-net.c:        n->mac_table.in_use += mac_data.entries;
virtio-net.c:        n->mac_table.uni_overflow = 1;
virtio-net.c:    n->mac_table.first_multi = n->mac_table.in_use;
virtio-net.c:    mac_data.entries = ldl_le_p(elem->out_sg[2].iov_base);
virtio-net.c:        (mac_data.entries * ETH_ALEN) > elem->out_sg[2].iov_len)
virtio-net.c:        if (n->mac_table.in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {
virtio-net.c:            memcpy(n->mac_table.macs + (n->mac_table.in_use * ETH_ALEN),
virtio-net.c:                   elem->out_sg[2].iov_base + sizeof(mac_data),
virtio-net.c:            n->mac_table.in_use += mac_data.entries;
virtio-net.c:            n->mac_table.multi_overflow = 1;
virtio-net.c:    if (elem->out_num != 2 || elem->out_sg[1].iov_len != sizeof(vid)) {
virtio-net.c:        fprintf(stderr, "virtio-net ctrl invalid vlan command\n");
virtio-net.c:    vid = lduw_le_p(elem->out_sg[1].iov_base);
virtio-net.c:        n->vlans[vid >> 5] |= (1U << (vid & 0x1f));
virtio-net.c:        n->vlans[vid >> 5] &= ~(1U << (vid & 0x1f));
virtio-net.c:            fprintf(stderr, "virtio-net ctrl missing headers\n");
virtio-net.c:            elem.in_sg[elem.in_num - 1].iov_len < sizeof(status)) {
virtio-net.c:            fprintf(stderr, "virtio-net ctrl header not in correct element\n");
virtio-net.c:        stb_p(elem.in_sg[elem.in_num - 1].iov_base, status);
virtio-net.c:    qemu_flush_queued_packets(&n->nic->nc);
virtio-net.c:     * select to re-poll the tap file descriptor */
virtio-net.c:    VirtIONet *n = DO_UPCAST(NICState, nc, nc)->opaque;
virtio-net.c:    if (!virtio_queue_ready(n->rx_vq) ||
virtio-net.c:        !(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))
virtio-net.c:    if (virtio_queue_empty(n->rx_vq) ||
virtio-net.c:        (n->mergeable_rx_bufs &&
virtio-net.c:         !virtqueue_avail_bytes(n->rx_vq, bufsize, 0))) {
virtio-net.c:        virtio_queue_set_notification(n->rx_vq, 1);
virtio-net.c:        if (virtio_queue_empty(n->rx_vq) ||
virtio-net.c:            (n->mergeable_rx_bufs &&
virtio-net.c:             !virtqueue_avail_bytes(n->rx_vq, bufsize, 0)))
virtio-net.c:    virtio_queue_set_notification(n->rx_vq, 0);
virtio-net.c: * N.B. if we introduce a zero-copy API, this operation is no longer free so
virtio-net.c:    if ((hdr->flags & VIRTIO_NET_HDR_F_NEEDS_CSUM) && /* missing csum */
virtio-net.c:        hdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM;
virtio-net.c:        int len = MIN(iov[i].iov_len, count - offset);
virtio-net.c:    hdr->flags = 0;
virtio-net.c:    hdr->gso_type = VIRTIO_NET_HDR_GSO_NONE;
virtio-net.c:    if (n->has_vnet_hdr) {
virtio-net.c:        work_around_broken_dhclient(hdr, buf + offset, size - offset);
virtio-net.c:    iov[0].iov_len  -= hdr_len;
virtio-net.c:    if (n->promisc)
virtio-net.c:    if (n->has_vnet_hdr) {
virtio-net.c:        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))
virtio-net.c:            return !n->nobcast;
virtio-net.c:        } else if (n->nomulti) {
virtio-net.c:        } else if (n->allmulti || n->mac_table.multi_overflow) {
virtio-net.c:        for (i = n->mac_table.first_multi; i < n->mac_table.in_use; i++) {
virtio-net.c:            if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN)) {
virtio-net.c:        if (n->nouni) {
virtio-net.c:        } else if (n->alluni || n->mac_table.uni_overflow) {
virtio-net.c:        } else if (!memcmp(ptr, n->mac, ETH_ALEN)) {
virtio-net.c:        for (i = 0; i < n->mac_table.first_multi; i++) {
virtio-net.c:            if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN)) {
virtio-net.c:    VirtIONet *n = DO_UPCAST(NICState, nc, nc)->opaque;
virtio-net.c:    if (!virtio_net_can_receive(&n->nic->nc))
virtio-net.c:        return -1;
virtio-net.c:    hdr_len = n->mergeable_rx_bufs ?
virtio-net.c:        if ((i != 0 && !n->mergeable_rx_bufs) ||
virtio-net.c:            virtqueue_pop(n->rx_vq, &elem) == 0) {
virtio-net.c:                return -1;
virtio-net.c:            fprintf(stderr, "virtio-net truncating packet\n");
virtio-net.c:            fprintf(stderr, "virtio-net receive queue contains no in buffers\n");
virtio-net.c:        if (!n->mergeable_rx_bufs && elem.in_sg[0].iov_len != hdr_len) {
virtio-net.c:            fprintf(stderr, "virtio-net header not in first element\n");
virtio-net.c:            if (n->mergeable_rx_bufs)
virtio-net.c:                                     buf + offset, size - offset, hdr_len);
virtio-net.c:                       buf + offset, size - offset);
virtio-net.c:        virtqueue_fill(n->rx_vq, &elem, total, i++);
virtio-net.c:        mhdr->num_buffers = i;
virtio-net.c:    virtqueue_flush(n->rx_vq, i);
virtio-net.c:    virtio_notify(&n->vdev, n->rx_vq);
virtio-net.c:    VirtIONet *n = DO_UPCAST(NICState, nc, nc)->opaque;
virtio-net.c:    virtqueue_push(n->tx_vq, &n->async_tx.elem, n->async_tx.len);
virtio-net.c:    virtio_notify(&n->vdev, n->tx_vq);
virtio-net.c:    n->async_tx.elem.out_num = n->async_tx.len = 0;
virtio-net.c:    virtio_queue_set_notification(n->tx_vq, 1);
virtio-net.c:    virtio_net_flush_tx(n, n->tx_vq);
virtio-net.c:    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))
virtio-net.c:    if (n->async_tx.elem.out_num) {
virtio-net.c:        virtio_queue_set_notification(n->tx_vq, 0);
virtio-net.c:        hdr_len = n->mergeable_rx_bufs ?
virtio-net.c:        if (out_num < 1 || out_sg->iov_len != hdr_len) {
virtio-net.c:            fprintf(stderr, "virtio-net header not in first element\n");
virtio-net.c:        if (!n->has_vnet_hdr) {
virtio-net.c:            out_num--;
virtio-net.c:        } else if (n->mergeable_rx_bufs) {
virtio-net.c:            hdr_len -= sizeof(struct virtio_net_hdr);
virtio-net.c:            out_sg->iov_len -= hdr_len;
virtio-net.c:        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,
virtio-net.c:            virtio_queue_set_notification(n->tx_vq, 0);
virtio-net.c:            n->async_tx.elem = elem;
virtio-net.c:            n->async_tx.len  = len;
virtio-net.c:        virtio_notify(&n->vdev, vq);
virtio-net.c:    if (n->tx_timer_active) {
virtio-net.c:        qemu_del_timer(n->tx_timer);
virtio-net.c:        n->tx_timer_active = 0;
virtio-net.c:        qemu_mod_timer(n->tx_timer,
virtio-net.c:        n->tx_timer_active = 1;
virtio-net.c:    n->tx_timer_active = 0;
virtio-net.c:    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))
virtio-net.c:    virtio_queue_set_notification(n->tx_vq, 1);
virtio-net.c:    virtio_net_flush_tx(n, n->tx_vq);
virtio-net.c:    virtio_save(&n->vdev, f);
virtio-net.c:    qemu_put_buffer(f, n->mac, ETH_ALEN);
virtio-net.c:    qemu_put_be32(f, n->tx_timer_active);
virtio-net.c:    qemu_put_be32(f, n->mergeable_rx_bufs);
virtio-net.c:    qemu_put_be16(f, n->status);
virtio-net.c:    qemu_put_byte(f, n->promisc);
virtio-net.c:    qemu_put_byte(f, n->allmulti);
virtio-net.c:    qemu_put_be32(f, n->mac_table.in_use);
virtio-net.c:    qemu_put_buffer(f, n->mac_table.macs, n->mac_table.in_use * ETH_ALEN);
virtio-net.c:    qemu_put_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);
virtio-net.c:    qemu_put_be32(f, n->has_vnet_hdr);
virtio-net.c:    qemu_put_byte(f, n->mac_table.multi_overflow);
virtio-net.c:    qemu_put_byte(f, n->mac_table.uni_overflow);
virtio-net.c:    qemu_put_byte(f, n->alluni);
virtio-net.c:    qemu_put_byte(f, n->nomulti);
virtio-net.c:    qemu_put_byte(f, n->nouni);
virtio-net.c:    qemu_put_byte(f, n->nobcast);
virtio-net.c:    qemu_put_byte(f, n->has_ufo);
virtio-net.c:        return -EINVAL;
virtio-net.c:    virtio_load(&n->vdev, f);
virtio-net.c:    qemu_get_buffer(f, n->mac, ETH_ALEN);
virtio-net.c:    n->tx_timer_active = qemu_get_be32(f);
virtio-net.c:    n->mergeable_rx_bufs = qemu_get_be32(f);
virtio-net.c:        n->status = qemu_get_be16(f);
virtio-net.c:            n->promisc = qemu_get_be32(f);
virtio-net.c:            n->allmulti = qemu_get_be32(f);
virtio-net.c:            n->promisc = qemu_get_byte(f);
virtio-net.c:            n->allmulti = qemu_get_byte(f);
virtio-net.c:        n->mac_table.in_use = qemu_get_be32(f);
virtio-net.c:        if (n->mac_table.in_use <= MAC_TABLE_ENTRIES) {
virtio-net.c:            qemu_get_buffer(f, n->mac_table.macs,
virtio-net.c:                            n->mac_table.in_use * ETH_ALEN);
virtio-net.c:        } else if (n->mac_table.in_use) {
virtio-net.c:            qemu_fseek(f, n->mac_table.in_use * ETH_ALEN, SEEK_CUR);
virtio-net.c:            n->mac_table.multi_overflow = n->mac_table.uni_overflow = 1;
virtio-net.c:            n->mac_table.in_use = 0;
virtio-net.c:        qemu_get_buffer(f, (uint8_t *)n->vlans, MAX_VLAN >> 3);
virtio-net.c:            qemu_error("virtio-net: saved image requires vnet_hdr=on\n");
virtio-net.c:            return -1;
virtio-net.c:        if (n->has_vnet_hdr) {
virtio-net.c:            tap_using_vnet_hdr(n->nic->nc.peer, 1);
virtio-net.c:            tap_set_offload(n->nic->nc.peer,
virtio-net.c:                            (n->vdev.features >> VIRTIO_NET_F_GUEST_CSUM) & 1,
virtio-net.c:                            (n->vdev.features >> VIRTIO_NET_F_GUEST_TSO4) & 1,
virtio-net.c:                            (n->vdev.features >> VIRTIO_NET_F_GUEST_TSO6) & 1,
virtio-net.c:                            (n->vdev.features >> VIRTIO_NET_F_GUEST_ECN)  & 1,
virtio-net.c:                            (n->vdev.features >> VIRTIO_NET_F_GUEST_UFO)  & 1);
virtio-net.c:        n->mac_table.multi_overflow = qemu_get_byte(f);
virtio-net.c:        n->mac_table.uni_overflow = qemu_get_byte(f);
virtio-net.c:        n->alluni = qemu_get_byte(f);
virtio-net.c:        n->nomulti = qemu_get_byte(f);
virtio-net.c:        n->nouni = qemu_get_byte(f);
virtio-net.c:        n->nobcast = qemu_get_byte(f);
virtio-net.c:            qemu_error("virtio-net: saved image requires TUN_F_UFO support\n");
virtio-net.c:            return -1;
virtio-net.c:    for (i = 0; i < n->mac_table.in_use; i++) {
virtio-net.c:        if (n->mac_table.macs[i * ETH_ALEN] & 1) {
virtio-net.c:    n->mac_table.first_multi = i;
virtio-net.c:    if (n->tx_timer_active) {
virtio-net.c:        qemu_mod_timer(n->tx_timer,
virtio-net.c:    VirtIONet *n = DO_UPCAST(NICState, nc, nc)->opaque;
virtio-net.c:    n->nic = NULL;
virtio-net.c:    n = (VirtIONet *)virtio_common_init("virtio-net", VIRTIO_ID_NET,
virtio-net.c:    n->vdev.get_config = virtio_net_get_config;
virtio-net.c:    n->vdev.set_config = virtio_net_set_config;
virtio-net.c:    n->vdev.get_features = virtio_net_get_features;
virtio-net.c:    n->vdev.set_features = virtio_net_set_features;
virtio-net.c:    n->vdev.bad_features = virtio_net_bad_features;
virtio-net.c:    n->vdev.reset = virtio_net_reset;
virtio-net.c:    n->rx_vq = virtio_add_queue(&n->vdev, 256, virtio_net_handle_rx);
virtio-net.c:    n->tx_vq = virtio_add_queue(&n->vdev, 256, virtio_net_handle_tx);
virtio-net.c:    n->ctrl_vq = virtio_add_queue(&n->vdev, 64, virtio_net_handle_ctrl);
virtio-net.c:    qemu_macaddr_default_if_unset(&conf->macaddr);
virtio-net.c:    memcpy(&n->mac[0], &conf->macaddr, sizeof(n->mac));
virtio-net.c:    n->status = VIRTIO_NET_S_LINK_UP;
virtio-net.c:    n->nic = qemu_new_nic(&net_virtio_info, conf, dev->info->name, dev->id, n);
virtio-net.c:    qemu_format_nic_info_str(&n->nic->nc, conf->macaddr.a);
virtio-net.c:    n->tx_timer = qemu_new_timer(vm_clock, virtio_net_tx_timer, n);
virtio-net.c:    n->tx_timer_active = 0;
virtio-net.c:    n->mergeable_rx_bufs = 0;
virtio-net.c:    n->promisc = 1; /* for compatibility */
virtio-net.c:    n->mac_table.macs = qemu_mallocz(MAC_TABLE_ENTRIES * ETH_ALEN);
virtio-net.c:    n->vlans = qemu_mallocz(MAX_VLAN >> 3);
virtio-net.c:    register_savevm("virtio-net", virtio_net_id++, VIRTIO_NET_VM_VERSION,
virtio-net.c:    return &n->vdev;
virtio-net.c:    qemu_purge_queued_packets(&n->nic->nc);
virtio-net.c:    unregister_savevm("virtio-net", n);
virtio-net.c:    qemu_free(n->mac_table.macs);
virtio-net.c:    qemu_free(n->vlans);
virtio-net.c:    qemu_del_timer(n->tx_timer);
virtio-net.c:    qemu_free_timer(n->tx_timer);
virtio-net.c:    virtio_cleanup(&n->vdev);
virtio-net.c:    qemu_del_vlan_client(&n->nic->nc);
virtio-net.h: * the COPYING file in the top-level directory.
virtio-net.h:/* This is the first element of the scatter-gather list.  If you don't
virtio-net.h: * state value, zero = disable, non-zero = enable.  Commands
virtio-net.h: * Commands 2-5 are added with VIRTIO_NET_F_CTRL_RX_EXTRA.
virtio-net.h: * non-perfect, ie. based on hypervisor resources, the guest may
virtio-pci.c: * the COPYING file in the top-level directory.
virtio-pci.c:/* A 32-bit r/o bitmask of the features supported by the host */
virtio-pci.c:/* A 32-bit r/w bitmask of features activated by the guest */
virtio-pci.c:/* A 32-bit r/w PFN for the currently selected queue */
virtio-pci.c:/* A 16-bit r/o queue size for the currently selected queue */
virtio-pci.c:/* A 16-bit r/w queue selector */
virtio-pci.c:/* A 16-bit r/w queue notifier */
virtio-pci.c:/* An 8-bit device status register.  */
virtio-pci.c:/* An 8-bit r/o interrupt status register.  Reading the value will return the
virtio-pci.c: * a read-and-acknowledge. */
virtio-pci.c:/* MSI-X registers: only enabled if MSI-X is enabled. */
virtio-pci.c:/* A 16-bit vector for configuration changes. */
virtio-pci.c:/* A 16-bit vector for selected queue notifications. */
virtio-pci.c:/* The remaining space is defined by each driver as the per-driver
virtio-pci.c: * lock-step.  We'll leave the calls to wmb() in though to make it obvious for
virtio-pci.c:    if (msix_enabled(&proxy->pci_dev))
virtio-pci.c:        msix_notify(&proxy->pci_dev, vector);
virtio-pci.c:        qemu_set_irq(proxy->pci_dev.irq[0], proxy->vdev->isr & 1);
virtio-pci.c:    pci_device_save(&proxy->pci_dev, f);
virtio-pci.c:    msix_save(&proxy->pci_dev, f);
virtio-pci.c:    if (msix_present(&proxy->pci_dev))
virtio-pci.c:        qemu_put_be16(f, proxy->vdev->config_vector);
virtio-pci.c:    if (msix_present(&proxy->pci_dev))
virtio-pci.c:        qemu_put_be16(f, virtio_queue_vector(proxy->vdev, n));
virtio-pci.c:    ret = pci_device_load(&proxy->pci_dev, f);
virtio-pci.c:    msix_load(&proxy->pci_dev, f);
virtio-pci.c:    if (msix_present(&proxy->pci_dev)) {
virtio-pci.c:        qemu_get_be16s(f, &proxy->vdev->config_vector);
virtio-pci.c:        proxy->vdev->config_vector = VIRTIO_NO_VECTOR;
virtio-pci.c:    if (proxy->vdev->config_vector != VIRTIO_NO_VECTOR) {
virtio-pci.c:        return msix_vector_use(&proxy->pci_dev, proxy->vdev->config_vector);
virtio-pci.c:    if (msix_present(&proxy->pci_dev)) {
virtio-pci.c:    virtio_queue_set_vector(proxy->vdev, n, vector);
virtio-pci.c:        return msix_vector_use(&proxy->pci_dev, vector);
virtio-pci.c:    virtio_reset(proxy->vdev);
virtio-pci.c:    msix_reset(&proxy->pci_dev);
virtio-pci.c:    VirtIODevice *vdev = proxy->vdev;
virtio-pci.c:	    if (vdev->bad_features)
virtio-pci.c:		val = vdev->bad_features(vdev);
virtio-pci.c:        if (vdev->set_features)
virtio-pci.c:            vdev->set_features(vdev, val);
virtio-pci.c:        vdev->features = val;
virtio-pci.c:            virtio_reset(proxy->vdev);
virtio-pci.c:            msix_unuse_all_vectors(&proxy->pci_dev);
virtio-pci.c:            virtio_queue_set_addr(vdev, vdev->queue_sel, pa);
virtio-pci.c:            vdev->queue_sel = val;
virtio-pci.c:        vdev->status = val & 0xFF;
virtio-pci.c:        if (vdev->status == 0) {
virtio-pci.c:            virtio_reset(proxy->vdev);
virtio-pci.c:            msix_unuse_all_vectors(&proxy->pci_dev);
virtio-pci.c:        msix_vector_unuse(&proxy->pci_dev, vdev->config_vector);
virtio-pci.c:        if (msix_vector_use(&proxy->pci_dev, val) < 0)
virtio-pci.c:        vdev->config_vector = val;
virtio-pci.c:        msix_vector_unuse(&proxy->pci_dev,
virtio-pci.c:                          virtio_queue_vector(vdev, vdev->queue_sel));
virtio-pci.c:        if (msix_vector_use(&proxy->pci_dev, val) < 0)
virtio-pci.c:        virtio_queue_set_vector(vdev, vdev->queue_sel, val);
virtio-pci.c:    VirtIODevice *vdev = proxy->vdev;
virtio-pci.c:        ret = vdev->get_features(vdev);
virtio-pci.c:        ret |= vdev->binding->get_features(proxy);
virtio-pci.c:        ret = vdev->features;
virtio-pci.c:        ret = virtio_queue_get_addr(vdev, vdev->queue_sel)
virtio-pci.c:        ret = virtio_queue_get_num(vdev, vdev->queue_sel);
virtio-pci.c:        ret = vdev->queue_sel;
virtio-pci.c:        ret = vdev->status;
virtio-pci.c:        ret = vdev->isr;
virtio-pci.c:        vdev->isr = 0;
virtio-pci.c:        qemu_set_irq(proxy->pci_dev.irq[0], 0);
virtio-pci.c:        ret = vdev->config_vector;
virtio-pci.c:        ret = virtio_queue_vector(vdev, vdev->queue_sel);
virtio-pci.c:    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);
virtio-pci.c:    addr -= proxy->addr;
virtio-pci.c:    addr -= config;
virtio-pci.c:    return virtio_config_readb(proxy->vdev, addr);
virtio-pci.c:    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);
virtio-pci.c:    addr -= proxy->addr;
virtio-pci.c:    addr -= config;
virtio-pci.c:    return virtio_config_readw(proxy->vdev, addr);
virtio-pci.c:    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);
virtio-pci.c:    addr -= proxy->addr;
virtio-pci.c:    addr -= config;
virtio-pci.c:    return virtio_config_readl(proxy->vdev, addr);
virtio-pci.c:    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);
virtio-pci.c:    addr -= proxy->addr;
virtio-pci.c:    addr -= config;
virtio-pci.c:    virtio_config_writeb(proxy->vdev, addr, val);
virtio-pci.c:    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);
virtio-pci.c:    addr -= proxy->addr;
virtio-pci.c:    addr -= config;
virtio-pci.c:    virtio_config_writew(proxy->vdev, addr, val);
virtio-pci.c:    uint32_t config = VIRTIO_PCI_CONFIG(&proxy->pci_dev);
virtio-pci.c:    addr -= proxy->addr;
virtio-pci.c:    addr -= config;
virtio-pci.c:    virtio_config_writel(proxy->vdev, addr, val);
virtio-pci.c:    VirtIODevice *vdev = proxy->vdev;
virtio-pci.c:    unsigned config_len = VIRTIO_PCI_REGION_SIZE(pci_dev) + vdev->config_len;
virtio-pci.c:    proxy->addr = addr;
virtio-pci.c:    if (vdev->config_len)
virtio-pci.c:        vdev->get_config(vdev, vdev->config);
virtio-pci.c:            proxy->vdev->status &= ~VIRTIO_CONFIG_S_DRIVER_OK;
virtio-pci.c:    proxy->vdev = vdev;
virtio-pci.c:    config = proxy->pci_dev.config;
virtio-pci.c:    config[0x2e] = vdev->device_id & 0xFF;
virtio-pci.c:    config[0x2f] = (vdev->device_id >> 8) & 0xFF;
virtio-pci.c:    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {
virtio-pci.c:        pci_register_bar(&proxy->pci_dev, 1,
virtio-pci.c:                         msix_bar_size(&proxy->pci_dev),
virtio-pci.c:        vdev->nvectors = 0;
virtio-pci.c:    proxy->pci_dev.config_write = virtio_write_config;
virtio-pci.c:    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;
virtio-pci.c:    if (size & (size-1))
virtio-pci.c:    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,
virtio-pci.c:    if (proxy->class_code != PCI_CLASS_STORAGE_SCSI &&
virtio-pci.c:        proxy->class_code != PCI_CLASS_STORAGE_OTHER)
virtio-pci.c:        proxy->class_code = PCI_CLASS_STORAGE_SCSI;
virtio-pci.c:    if (!proxy->dinfo) {
virtio-pci.c:        qemu_error("virtio-blk-pci: drive property not set\n");
virtio-pci.c:        return -1;
virtio-pci.c:    vdev = virtio_blk_init(&pci_dev->qdev, proxy->dinfo);
virtio-pci.c:    vdev->nvectors = proxy->nvectors;
virtio-pci.c:                    proxy->class_code, 0x00);
virtio-pci.c:    proxy->nvectors = vdev->nvectors;
virtio-pci.c:    drive_uninit(proxy->dinfo);
virtio-pci.c:    if (proxy->class_code != PCI_CLASS_COMMUNICATION_OTHER &&
virtio-pci.c:        proxy->class_code != PCI_CLASS_DISPLAY_OTHER && /* qemu 0.10 */
virtio-pci.c:        proxy->class_code != PCI_CLASS_OTHERS)          /* qemu-kvm  */
virtio-pci.c:        proxy->class_code = PCI_CLASS_COMMUNICATION_OTHER;
virtio-pci.c:    vdev = virtio_console_init(&pci_dev->qdev);
virtio-pci.c:        return -1;
virtio-pci.c:                    proxy->class_code, 0x00);
virtio-pci.c:    vdev = virtio_net_init(&pci_dev->qdev, &proxy->nic);
virtio-pci.c:    vdev->nvectors = proxy->nvectors;
virtio-pci.c:    proxy->nvectors = vdev->nvectors;
virtio-pci.c:    virtio_net_exit(proxy->vdev);
virtio-pci.c:    vdev = virtio_balloon_init(&pci_dev->qdev);
virtio-pci.c:        .qdev.name = "virtio-blk-pci",
virtio-pci.c:        .qdev.name  = "virtio-net-pci",
virtio-pci.c:        .romfile    = "pxe-virtio.bin",
virtio-pci.c:        .qdev.name = "virtio-console-pci",
virtio-pci.c:        .qdev.name = "virtio-balloon-pci",
vmmouse.c:    return (s->status << 16) | s->nb_queue;
vmmouse.c:    if (s->nb_queue > (VMMOUSE_QUEUE_SIZE - 4))
vmmouse.c:    if (s->absolute) {
vmmouse.c:    s->queue[s->nb_queue++] = buttons;
vmmouse.c:    s->queue[s->nb_queue++] = x;
vmmouse.c:    s->queue[s->nb_queue++] = y;
vmmouse.c:    s->queue[s->nb_queue++] = dz;
vmmouse.c:    ps2_mouse_fake_event(s->ps2_mouse);
vmmouse.c:    if (s->entry) {
vmmouse.c:        qemu_remove_mouse_event_handler(s->entry);
vmmouse.c:        s->entry = NULL;
vmmouse.c:    if (s->status == 0)
vmmouse.c:        s->entry = qemu_add_mouse_event_handler(vmmouse_mouse_event,
vmmouse.c:                                                s, s->absolute,
vmmouse.c:    if (s->nb_queue == VMMOUSE_QUEUE_SIZE)
vmmouse.c:    s->queue[s->nb_queue++] = VMMOUSE_VERSION;
vmmouse.c:    s->status = 0;
vmmouse.c:    s->absolute = 0;
vmmouse.c:    s->absolute = 1;
vmmouse.c:    s->status = 0xffff;
vmmouse.c:    if (size == 0 || size > 6 || size > s->nb_queue) {
vmmouse.c:        s->status = 0xffff;
vmmouse.c:        data[i] = s->queue[i];
vmmouse.c:    s->nb_queue -= size;
vmmouse.c:    if (s->nb_queue)
vmmouse.c:        memmove(s->queue, &s->queue[size], sizeof(s->queue[0]) * s->nb_queue);
vmmouse.c:    data[0] = env->regs[R_EAX]; data[1] = env->regs[R_EBX];
vmmouse.c:    data[2] = env->regs[R_ECX]; data[3] = env->regs[R_EDX];
vmmouse.c:    data[4] = env->regs[R_ESI]; data[5] = env->regs[R_EDI];
vmmouse.c:    env->regs[R_EAX] = data[0]; env->regs[R_EBX] = data[1];
vmmouse.c:    env->regs[R_ECX] = data[2]; env->regs[R_EDX] = data[3];
vmmouse.c:    env->regs[R_ESI] = data[4]; env->regs[R_EDI] = data[5];
vmmouse.c:    s->status = 0xffff;
vmmouse.c:    s->ps2_mouse = m;
vmmouse.c:    s->queue_size = VMMOUSE_QUEUE_SIZE;
vmport.c:#include "qemu-kvm.h"
vmport.c:    eax = env->regs[R_EAX];
vmport.c:    command = env->regs[R_ECX];
vmport.c:    if (!s->func[command])
vmport.c:    ret = s->func[command](s->opaque[command], addr);
vmport.c:    env->regs[R_EAX] = vmport_ioport_read(opaque, addr);
vmport.c:    env->regs[R_EBX] = VMPORT_MAGIC;
vmport.c:    env->regs[R_EBX] = 0x1177;
vmware_vga.c: * QEMU VMware-SVGA "chipset".
vmware_vga.c: * FIFO offsets (seen as an array of 32-bit words)
vmware_vga.c:    if (x + w > s->width) {
vmware_vga.c:        x = MIN(x, s->width);
vmware_vga.c:        w = s->width - x;
vmware_vga.c:    if (y + h > s->height) {
vmware_vga.c:        y = MIN(y, s->height);
vmware_vga.c:        h = s->height - y;
vmware_vga.c:    bypl = s->bypp * s->width;
vmware_vga.c:    width = s->bypp * w;
vmware_vga.c:    start = s->bypp * x + bypl * y;
vmware_vga.c:    src = s->vga.vram_ptr + start;
vmware_vga.c:    dst = ds_get_data(s->vga.ds) + start;
vmware_vga.c:    for (; line > 0; line --, src += bypl, dst += bypl)
vmware_vga.c:    dpy_update(s->vga.ds, x, y, w, h);
vmware_vga.c:    memcpy(ds_get_data(s->vga.ds), s->vga.vram_ptr, s->bypp * s->width * s->height);
vmware_vga.c:    dpy_update(s->vga.ds, 0, 0, s->width, s->height);
vmware_vga.c:    struct vmsvga_rect_s *rect = &s->redraw_fifo[s->redraw_fifo_last ++];
vmware_vga.c:    s->redraw_fifo_last &= REDRAW_FIFO_LEN - 1;
vmware_vga.c:    rect->x = x;
vmware_vga.c:    rect->y = y;
vmware_vga.c:    rect->w = w;
vmware_vga.c:    rect->h = h;
vmware_vga.c:    if (s->invalidated) {
vmware_vga.c:        s->redraw_fifo_first = s->redraw_fifo_last;
vmware_vga.c:    /* Overlapping region updates can be optimised out here - if someone
vmware_vga.c:    while (s->redraw_fifo_first != s->redraw_fifo_last) {
vmware_vga.c:        rect = &s->redraw_fifo[s->redraw_fifo_first ++];
vmware_vga.c:        s->redraw_fifo_first &= REDRAW_FIFO_LEN - 1;
vmware_vga.c:        vmsvga_update_rect(s, rect->x, rect->y, rect->w, rect->h);
vmware_vga.c:    uint8_t *vram = ds_get_data(s->ds);
vmware_vga.c:    uint8_t *vram = s->vga.vram_ptr;
vmware_vga.c:    int bypl = s->bypp * s->width;
vmware_vga.c:    int width = s->bypp * w;
vmware_vga.c:    if (s->ds->dpy_copy)
vmware_vga.c:        qemu_console_copy(s->ds, x0, y0, x1, y1, w, h);
vmware_vga.c:            ptr[0] = vram + s->bypp * x0 + bypl * (y0 + h - 1);
vmware_vga.c:            ptr[1] = vram + s->bypp * x1 + bypl * (y1 + h - 1);
vmware_vga.c:            for (; line > 0; line --, ptr[0] -= bypl, ptr[1] -= bypl)
vmware_vga.c:            ptr[0] = vram + s->bypp * x0 + bypl * y0;
vmware_vga.c:            ptr[1] = vram + s->bypp * x1 + bypl * y1;
vmware_vga.c:            for (; line > 0; line --, ptr[0] += bypl, ptr[1] += bypl)
vmware_vga.c:    uint8_t *vram = ds_get_data(s->ds);
vmware_vga.c:    uint8_t *vram = s->vga.vram_ptr;
vmware_vga.c:    int bypp = s->bypp;
vmware_vga.c:    int bypl = bypp * s->width;
vmware_vga.c:    if (s->ds->dpy_fill)
vmware_vga.c:        s->ds->dpy_fill(s->ds, x, y, w, h, c);
vmware_vga.c:        if (line --) {
vmware_vga.c:            for (column = width; column > 0; column --) {
vmware_vga.c:                if (src - col == bypp)
vmware_vga.c:            for (; line > 0; line --) {
vmware_vga.c:    for (i = SVGA_BITMAP_SIZE(c->width, c->height) - 1; i >= 0; i --)
vmware_vga.c:        c->mask[i] = ~c->mask[i];
vmware_vga.c:    if (s->vga.ds->cursor_define)
vmware_vga.c:        s->vga.ds->cursor_define(c->width, c->height, c->bpp, c->hot_x, c->hot_y,
vmware_vga.c:                        (uint8_t *) c->image, (uint8_t *) c->mask);
vmware_vga.c:#define CMD(f)	le32_to_cpu(s->cmd->f)
vmware_vga.c:    if (!s->config || !s->enable)
vmware_vga.c:    return (s->cmd->next_cmd == s->cmd->stop);
vmware_vga.c:    uint32_t cmd = s->fifo[CMD(stop) >> 2];
vmware_vga.c:    s->cmd->stop = cpu_to_le32(CMD(stop) + 4);
vmware_vga.c:        s->cmd->stop = s->cmd->min;
vmware_vga.c:            while (args --)
vmware_vga.c:    s->syncing = 0;
vmware_vga.c:    return s->index;
vmware_vga.c:    s->index = index;
vmware_vga.c:    switch (s->index) {
vmware_vga.c:        return s->svgaid;
vmware_vga.c:        return s->enable;
vmware_vga.c:        return s->width;
vmware_vga.c:        return s->height;
vmware_vga.c:        return s->depth;
vmware_vga.c:        return (s->depth + 7) & ~7;
vmware_vga.c:        return s->wred;
vmware_vga.c:        return s->wgreen;
vmware_vga.c:        return s->wblue;
vmware_vga.c:        return ((s->depth + 7) >> 3) * s->new_width;
vmware_vga.c:        return s->vram_base;
vmware_vga.c:        return s->vga.vram_size;
vmware_vga.c:        return s->fb_size;
vmware_vga.c:        if (s->vga.ds->mouse_set)
vmware_vga.c:        return s->fifo_base;
vmware_vga.c:        return s->fifo_size;
vmware_vga.c:        return s->config;
vmware_vga.c:        return s->syncing;
vmware_vga.c:        return s->guest;
vmware_vga.c:        return s->cursor.id;
vmware_vga.c:        return s->cursor.x;
vmware_vga.c:        return s->cursor.x;
vmware_vga.c:        return s->cursor.on;
vmware_vga.c:        return (s->depth + 7) & ~7;
vmware_vga.c:        return s->scratch_size;
vmware_vga.c:        if (s->index >= SVGA_SCRATCH_BASE &&
vmware_vga.c:                s->index < SVGA_SCRATCH_BASE + s->scratch_size)
vmware_vga.c:            return s->scratch[s->index - SVGA_SCRATCH_BASE];
vmware_vga.c:        printf("%s: Bad register %02x\n", __FUNCTION__, s->index);
vmware_vga.c:    switch (s->index) {
vmware_vga.c:            s->svgaid = value;
vmware_vga.c:        s->enable = value;
vmware_vga.c:        s->config &= !!value;
vmware_vga.c:        s->width = -1;
vmware_vga.c:        s->height = -1;
vmware_vga.c:        s->invalidated = 1;
vmware_vga.c:        s->vga.invalidate(&s->vga);
vmware_vga.c:        if (s->enable) {
vmware_vga.c:	  s->fb_size = ((s->depth + 7) >> 3) * s->new_width * s->new_height;
vmware_vga.c:	  vga_dirty_log_stop(&s->vga);
vmware_vga.c:	  vga_dirty_log_start(&s->vga);
vmware_vga.c:        s->new_width = value;
vmware_vga.c:        s->invalidated = 1;
vmware_vga.c:        s->new_height = value;
vmware_vga.c:        s->invalidated = 1;
vmware_vga.c:        if (value != s->depth) {
vmware_vga.c:            s->config = 0;
vmware_vga.c:            s->fifo = (uint32_t *) s->fifo_ptr;
vmware_vga.c:            if (CMD(min) < (uint8_t *) s->cmd->fifo - (uint8_t *) s->fifo)
vmware_vga.c:        s->config = !!value;
vmware_vga.c:        s->syncing = 1;
vmware_vga.c:        s->guest = value;
vmware_vga.c:                            vmsvga_guest_id[value - GUEST_OS_BASE]);
vmware_vga.c:        s->cursor.id = value;
vmware_vga.c:        s->cursor.x = value;
vmware_vga.c:        s->cursor.y = value;
vmware_vga.c:        s->cursor.on |= (value == SVGA_CURSOR_ON_SHOW);
vmware_vga.c:        s->cursor.on &= (value != SVGA_CURSOR_ON_HIDE);
vmware_vga.c:        if (s->vga.ds->mouse_set && value <= SVGA_CURSOR_ON_SHOW)
vmware_vga.c:            s->vga.ds->mouse_set(s->cursor.x, s->cursor.y, s->cursor.on);
vmware_vga.c:        if (s->index >= SVGA_SCRATCH_BASE &&
vmware_vga.c:                s->index < SVGA_SCRATCH_BASE + s->scratch_size) {
vmware_vga.c:            s->scratch[s->index - SVGA_SCRATCH_BASE] = value;
vmware_vga.c:        printf("%s: Bad register %02x\n", __FUNCTION__, s->index);
vmware_vga.c:    if (s->new_width != s->width || s->new_height != s->height) {
vmware_vga.c:        s->width = s->new_width;
vmware_vga.c:        s->height = s->new_height;
vmware_vga.c:        qemu_console_resize(s->vga.ds, s->width, s->height);
vmware_vga.c:        s->invalidated = 1;
vmware_vga.c:    if (!s->enable) {
vmware_vga.c:        s->vga.update(&s->vga);
vmware_vga.c:     * Is it more efficient to look at vram VGA-dirty bits or wait
vmware_vga.c:    if (s->invalidated) {
vmware_vga.c:        s->invalidated = 0;
vmware_vga.c:    s->index = 0;
vmware_vga.c:    s->enable = 0;
vmware_vga.c:    s->config = 0;
vmware_vga.c:    s->width = -1;
vmware_vga.c:    s->height = -1;
vmware_vga.c:    s->svgaid = SVGA_ID;
vmware_vga.c:    s->depth = ds_get_bits_per_pixel(s->vga.ds);
vmware_vga.c:    s->bypp = ds_get_bytes_per_pixel(s->vga.ds);
vmware_vga.c:    s->cursor.on = 0;
vmware_vga.c:    s->redraw_fifo_first = 0;
vmware_vga.c:    s->redraw_fifo_last = 0;
vmware_vga.c:    switch (s->depth) {
vmware_vga.c:        s->wred   = 0x00000007;
vmware_vga.c:        s->wgreen = 0x00000038;
vmware_vga.c:        s->wblue  = 0x000000c0;
vmware_vga.c:        s->wred   = 0x0000001f;
vmware_vga.c:        s->wgreen = 0x000003e0;
vmware_vga.c:        s->wblue  = 0x00007c00;
vmware_vga.c:        s->wred   = 0x0000001f;
vmware_vga.c:        s->wgreen = 0x000007e0;
vmware_vga.c:        s->wblue  = 0x0000f800;
vmware_vga.c:        s->wred   = 0x00ff0000;
vmware_vga.c:        s->wgreen = 0x0000ff00;
vmware_vga.c:        s->wblue  = 0x000000ff;
vmware_vga.c:        s->wred   = 0x00ff0000;
vmware_vga.c:        s->wgreen = 0x0000ff00;
vmware_vga.c:        s->wblue  = 0x000000ff;
vmware_vga.c:    s->syncing = 0;
vmware_vga.c:    vga_dirty_log_start(&s->vga);
vmware_vga.c:    if (!s->enable) {
vmware_vga.c:        s->vga.invalidate(&s->vga);
vmware_vga.c:    s->invalidated = 1;
vmware_vga.c:    if (!s->enable) {
vmware_vga.c:        s->vga.screen_dump(&s->vga, filename);
vmware_vga.c:    if (s->depth == 32) {
vmware_vga.c:        DisplaySurface *ds = qemu_create_displaysurface_from(s->width,
vmware_vga.c:                s->height, 32, ds_get_linesize(s->vga.ds), s->vga.vram_ptr);
vmware_vga.c:    if (s->vga.text_update)
vmware_vga.c:        s->vga.text_update(&s->vga, chardata);
vmware_vga.c:    if (addr < s->fb_size)
vmware_vga.c:        return *(uint8_t *) (ds_get_data(s->ds) + addr);
vmware_vga.c:        return *(uint8_t *) (s->vram_ptr + addr);
vmware_vga.c:    if (addr < s->fb_size)
vmware_vga.c:        return *(uint16_t *) (ds_get_data(s->ds) + addr);
vmware_vga.c:        return *(uint16_t *) (s->vram_ptr + addr);
vmware_vga.c:    if (addr < s->fb_size)
vmware_vga.c:        return *(uint32_t *) (ds_get_data(s->ds) + addr);
vmware_vga.c:        return *(uint32_t *) (s->vram_ptr + addr);
vmware_vga.c:    if (addr < s->fb_size)
vmware_vga.c:        *(uint8_t *) (ds_get_data(s->ds) + addr) = value;
vmware_vga.c:        *(uint8_t *) (s->vram_ptr + addr) = value;
vmware_vga.c:    if (addr < s->fb_size)
vmware_vga.c:        *(uint16_t *) (ds_get_data(s->ds) + addr) = value;
vmware_vga.c:        *(uint16_t *) (s->vram_ptr + addr) = value;
vmware_vga.c:    if (addr < s->fb_size)
vmware_vga.c:        *(uint32_t *) (ds_get_data(s->ds) + addr) = value;
vmware_vga.c:        *(uint32_t *) (s->vram_ptr + addr) = value;
vmware_vga.c:    s->invalidated = 1;
vmware_vga.c:    if (s->config)
vmware_vga.c:        s->fifo = (uint32_t *) s->fifo_ptr;
vmware_vga.c:    s->scratch_size = SVGA_SCRATCH_SIZE;
vmware_vga.c:    s->scratch = qemu_malloc(s->scratch_size * 4);
vmware_vga.c:    s->vga.ds = graphic_console_init(vmsvga_update_display,
vmware_vga.c:    s->fifo_size = SVGA_FIFO_SIZE;
vmware_vga.c:    s->fifo_offset = qemu_ram_alloc(s->fifo_size);
vmware_vga.c:    s->fifo_ptr = qemu_get_ram_ptr(s->fifo_offset);
vmware_vga.c:    vga_common_init(&s->vga, vga_ram_size);
vmware_vga.c:    vga_init(&s->vga);
vmware_vga.c:    vmstate_register(0, &vmstate_vga_common, &s->vga);
vmware_vga.c:    vga_init_vbe(&s->vga);
vmware_vga.c:    struct vmsvga_state_s *s = &d->chip;
vmware_vga.c:    struct vmsvga_state_s *s = &d->chip;
vmware_vga.c:    s->vram_base = addr;
vmware_vga.c:    iomemtype = s->vga.vram_offset | IO_MEM_RAM;
vmware_vga.c:    cpu_register_physical_memory(s->vram_base, s->vga.vram_size,
vmware_vga.c:    s->vga.map_addr = addr;
vmware_vga.c:    s->vga.map_end = addr + s->vga.vram_size;
vmware_vga.c:    vga_dirty_log_restart(&s->vga);
vmware_vga.c:    struct vmsvga_state_s *s = &d->chip;
vmware_vga.c:    s->fifo_base = addr;
vmware_vga.c:    iomemtype = s->fifo_offset | IO_MEM_RAM;
vmware_vga.c:    cpu_register_physical_memory(s->fifo_base, s->fifo_size,
vmware_vga.c:    pci_config_set_vendor_id(s->card.config, PCI_VENDOR_ID_VMWARE);
vmware_vga.c:    pci_config_set_device_id(s->card.config, SVGA_PCI_DEVICE_ID);
vmware_vga.c:    s->card.config[PCI_COMMAND]		= 0x07;		/* I/O + Memory */
vmware_vga.c:    pci_config_set_class(s->card.config, PCI_CLASS_DISPLAY_VGA);
vmware_vga.c:    s->card.config[0x0c]		= 0x08;		/* Cache line size */
vmware_vga.c:    s->card.config[0x0d]		= 0x40;		/* Latency timer */
vmware_vga.c:    s->card.config[PCI_HEADER_TYPE]	= PCI_HEADER_TYPE_NORMAL;
vmware_vga.c:    s->card.config[0x2c]		= PCI_VENDOR_ID_VMWARE & 0xff;
vmware_vga.c:    s->card.config[0x2d]		= PCI_VENDOR_ID_VMWARE >> 8;
vmware_vga.c:    s->card.config[0x2e]		= SVGA_PCI_DEVICE_ID & 0xff;
vmware_vga.c:    s->card.config[0x2f]		= SVGA_PCI_DEVICE_ID >> 8;
vmware_vga.c:    s->card.config[0x3c]		= 0xff;		/* End */
vmware_vga.c:    pci_register_bar(&s->card, 0, 0x10,
vmware_vga.c:    pci_register_bar(&s->card, 1, VGA_RAM_SIZE,
vmware_vga.c:    pci_register_bar(&s->card, 2, SVGA_FIFO_SIZE,
vmware_vga.c:    vmsvga_init(&s->chip, VGA_RAM_SIZE);
vmware_vga.c:    pci_create_simple(bus, -1, "vmware-svga");
vmware_vga.c:    .qdev.name    = "vmware-svga",
vmware_vga.h:#include "qemu-common.h"
watchdog.c:#include "qemu-common.h"
watchdog.c:#include "qemu-option.h"
watchdog.c:#include "qemu-config.h"
watchdog.c:#include "qemu-queue.h"
watchdog.c:    /* -watchdog ? lists available devices and exits cleanly. */
watchdog.c:                     model->wdt_name, model->wdt_description);
watchdog.c:        if (strcasecmp(model->wdt_name, p) == 0) {
watchdog.c:    fprintf(stderr, "Unknown -watchdog device. Supported devices are:\n");
watchdog.c:                 model->wdt_name, model->wdt_description);
watchdog.c:        return -1;
watchdog.h:#include "qemu-queue.h"
watchdog.h:    /* Short name of the device - used to select it on the command line. */
wdt_i6300esb.c:#include "qemu-common.h"
wdt_i6300esb.c:#include "qemu-timer.h"
wdt_i6300esb.c:                                 * performed depends on the -watchdog-action
wdt_i6300esb.c:                                 * states 0 -> 1 -> 2 when this happens.
wdt_i6300esb.c: * (hence it starts counting down) or has been keep-alived.
wdt_i6300esb.c:    if (!d->enabled)
wdt_i6300esb.c:    d->stage = stage;
wdt_i6300esb.c:    if (d->stage <= 1)
wdt_i6300esb.c:        timeout = d->timer1_preload;
wdt_i6300esb.c:        timeout = d->timer2_preload;
wdt_i6300esb.c:    if (d->clock_scale == CLOCK_SCALE_1KHZ)
wdt_i6300esb.c:    i6300esb_debug("stage %d, timeout %" PRIi64 "\n", d->stage, timeout);
wdt_i6300esb.c:    qemu_mod_timer(d->timer, qemu_get_clock(vm_clock) + timeout);
wdt_i6300esb.c:    qemu_del_timer(d->timer);
wdt_i6300esb.c: * If d->stage == 1 then we perform the first stage action (usually,
wdt_i6300esb.c:    i6300esb_debug("stage %d\n", d->stage);
wdt_i6300esb.c:    if (d->stage == 1) {
wdt_i6300esb.c:        switch (d->int_type) {
wdt_i6300esb.c:        if (d->reboot_enabled) {
wdt_i6300esb.c:            d->previous_reboot_flag = 1;
wdt_i6300esb.c:        if (d->free_run)
wdt_i6300esb.c:        d->reboot_enabled = (data & ESB_WDT_REBOOT) == 0;
wdt_i6300esb.c:        d->clock_scale =
wdt_i6300esb.c:        d->int_type = (data & ESB_WDT_INTTYPE);
wdt_i6300esb.c:        if (!d->locked) {
wdt_i6300esb.c:            d->locked = (data & ESB_WDT_LOCK) != 0;
wdt_i6300esb.c:            d->free_run = (data & ESB_WDT_FUNC) != 0;
wdt_i6300esb.c:            old = d->enabled;
wdt_i6300esb.c:            d->enabled = (data & ESB_WDT_ENABLE) != 0;
wdt_i6300esb.c:            if (!old && d->enabled) /* Enabled transitioned from 0 -> 1 */
wdt_i6300esb.c:            else if (!d->enabled)
wdt_i6300esb.c:            (d->reboot_enabled ? 0 : ESB_WDT_REBOOT) |
wdt_i6300esb.c:            (d->clock_scale == CLOCK_SCALE_1MHZ ? ESB_WDT_FREQ : 0) |
wdt_i6300esb.c:            d->int_type;
wdt_i6300esb.c:            (d->free_run ? ESB_WDT_FUNC : 0) |
wdt_i6300esb.c:            (d->locked ? ESB_WDT_LOCK : 0) |
wdt_i6300esb.c:            (d->enabled ? ESB_WDT_ENABLE : 0);
wdt_i6300esb.c:        data = d->previous_reboot_flag ? 0x1200 : 0;
wdt_i6300esb.c:        d->unlock_state = 1;
wdt_i6300esb.c:    else if (addr == 0xc && val == 0x86 && d->unlock_state == 1)
wdt_i6300esb.c:        d->unlock_state = 2;
wdt_i6300esb.c:        d->unlock_state = 1;
wdt_i6300esb.c:    else if (addr == 0xc && val == 0x86 && d->unlock_state == 1)
wdt_i6300esb.c:        d->unlock_state = 2;
wdt_i6300esb.c:        if (d->unlock_state == 2) {
wdt_i6300esb.c:                    d->previous_reboot_flag = 0;
wdt_i6300esb.c:            d->unlock_state = 0;
wdt_i6300esb.c:        d->unlock_state = 1;
wdt_i6300esb.c:    else if (addr == 0xc && val == 0x86 && d->unlock_state == 1)
wdt_i6300esb.c:        d->unlock_state = 2;
wdt_i6300esb.c:        if (d->unlock_state == 2) {
wdt_i6300esb.c:                d->timer1_preload = val & 0xfffff;
wdt_i6300esb.c:                d->timer2_preload = val & 0xfffff;
wdt_i6300esb.c:            d->unlock_state = 0;
wdt_i6300esb.c:    d->reboot_enabled = 1;
wdt_i6300esb.c:    d->clock_scale = CLOCK_SCALE_1KHZ;
wdt_i6300esb.c:    d->int_type = INT_TYPE_IRQ;
wdt_i6300esb.c:    d->free_run = 0;
wdt_i6300esb.c:    d->locked = 0;
wdt_i6300esb.c:    d->enabled = 0;
wdt_i6300esb.c:    d->timer = qemu_new_timer(vm_clock, i6300esb_timer_expired, d);
wdt_i6300esb.c:    d->timer1_preload = 0xfffff;
wdt_i6300esb.c:    d->timer2_preload = 0xfffff;
wdt_i6300esb.c:    d->stage = 1;
wdt_i6300esb.c:    d->unlock_state = 0;
wdt_i6300esb.c:    d->previous_reboot_flag = 0;
wdt_i6300esb.c:    pci_conf = d->dev.config;
wdt_i6300esb.c:    pci_register_bar(&d->dev, 0, 0x10,
wdt_ib700.c:#include "qemu-common.h"
wdt_ib700.c:#include "qemu-timer.h"
wdt_ib700.c:    qemu_mod_timer(s->timer, qemu_get_clock (vm_clock) + timeout);
wdt_ib700.c:    qemu_del_timer(s->timer);
wdt_ib700.c:    qemu_del_timer(s->timer);
wdt_ib700.c:    s->timer = qemu_new_timer(vm_clock, ib700_timer_expired, s);
wm8750.c:/* pow(10.0, -i / 20.0) * 255, i = 0..42 */
wm8750.c:#define WM8750_OUTVOL_TRANSFORM(x)	wm8750_vol_db_table[(0x7f - x) / 3]
wm8750.c:    if (s->idx_in + s->req_in <= sizeof(s->data_in))
wm8750.c:    s->idx_in = audio_MAX(0, (int) sizeof(s->data_in) - s->req_in);
wm8750.c:    acquired = AUD_read(*s->in[0], s->data_in + s->idx_in,
wm8750.c:                    sizeof(s->data_in) - s->idx_in);
wm8750.c:    while (sent < s->idx_out)
wm8750.c:        sent += AUD_write(*s->out[0], s->data_out + sent, s->idx_out - sent)
wm8750.c:                ?: s->idx_out;
wm8750.c:    s->idx_out = 0;
wm8750.c:    s->req_in = avail_b;
wm8750.c:    s->data_req(s->opaque, s->req_out >> 2, avail_b >> 2);
wm8750.c:    if (s->idx_out >= free_b) {
wm8750.c:        s->idx_out = free_b;
wm8750.c:        s->req_out = 0;
wm8750.c:        s->req_out = free_b - s->idx_out;
wm8750.c:    s->data_req(s->opaque, s->req_out >> 2, s->req_in >> 2);
wm8750.c:    /* FIXME: multiply all volumes by s->invol[2], s->invol[3] */
wm8750.c:    AUD_set_volume_in(s->adc_voice[0], s->mute,
wm8750.c:                    s->inmute[0] ? 0 : WM8750_INVOL_TRANSFORM(s->invol[0]),
wm8750.c:                    s->inmute[1] ? 0 : WM8750_INVOL_TRANSFORM(s->invol[1]));
wm8750.c:    AUD_set_volume_in(s->adc_voice[1], s->mute,
wm8750.c:                    s->inmute[0] ? 0 : WM8750_INVOL_TRANSFORM(s->invol[0]),
wm8750.c:                    s->inmute[1] ? 0 : WM8750_INVOL_TRANSFORM(s->invol[1]));
wm8750.c:    AUD_set_volume_in(s->adc_voice[2], s->mute,
wm8750.c:                    s->inmute[0] ? 0 : WM8750_INVOL_TRANSFORM(s->invol[0]),
wm8750.c:                    s->inmute[1] ? 0 : WM8750_INVOL_TRANSFORM(s->invol[1]));
wm8750.c:    /* FIXME: multiply all volumes by s->outvol[0], s->outvol[1] */
wm8750.c:    AUD_set_volume_out(s->dac_voice[0], s->mute,
wm8750.c:                    s->outmute[0] ? 0 : WM8750_OUTVOL_TRANSFORM(s->outvol[4]),
wm8750.c:                    s->outmute[1] ? 0 : WM8750_OUTVOL_TRANSFORM(s->outvol[5]));
wm8750.c:    AUD_set_volume_out(s->dac_voice[1], s->mute,
wm8750.c:                    s->outmute[0] ? 0 : WM8750_OUTVOL_TRANSFORM(s->outvol[2]),
wm8750.c:                    s->outmute[1] ? 0 : WM8750_OUTVOL_TRANSFORM(s->outvol[3]));
wm8750.c:    AUD_set_volume_out(s->dac_voice[2], s->mute,
wm8750.c:                    s->outmute[0] ? 0 : WM8750_OUTVOL_TRANSFORM(s->outvol[6]),
wm8750.c:                    s->outmute[1] ? 0 : WM8750_OUTVOL_TRANSFORM(s->outvol[6]));
wm8750.c:    if (s->in[0] && *s->in[0])
wm8750.c:        AUD_set_active_in(*s->in[0], 0);
wm8750.c:    if (s->out[0] && *s->out[0])
wm8750.c:        AUD_set_active_out(*s->out[0], 0);
wm8750.c:        if (s->adc_voice[i]) {
wm8750.c:            AUD_close_in(&s->card, s->adc_voice[i]);
wm8750.c:            s->adc_voice[i] = NULL;
wm8750.c:        if (s->dac_voice[i]) {
wm8750.c:            AUD_close_out(&s->card, s->dac_voice[i]);
wm8750.c:            s->dac_voice[i] = NULL;
wm8750.c:    if (!s->enable)
wm8750.c:    in_fmt.freq = s->adc_hz;
wm8750.c:    s->adc_voice[0] = AUD_open_in(&s->card, s->adc_voice[0],
wm8750.c:    s->adc_voice[1] = AUD_open_in(&s->card, s->adc_voice[1],
wm8750.c:    s->adc_voice[2] = AUD_open_in(&s->card, s->adc_voice[2],
wm8750.c:    out_fmt.freq = s->dac_hz;
wm8750.c:    monoout_fmt.freq = s->rate->dac_hz;
wm8750.c:    s->dac_voice[0] = AUD_open_out(&s->card, s->dac_voice[0],
wm8750.c:    s->dac_voice[1] = AUD_open_out(&s->card, s->dac_voice[1],
wm8750.c:    s->dac_voice[2] = AUD_open_out(&s->card, s->dac_voice[2],
wm8750.c:    if (s->in[0] && *s->in[0])
wm8750.c:        AUD_set_active_in(*s->in[0], 1);
wm8750.c:    if (s->out[0] && *s->out[0])
wm8750.c:        AUD_set_active_out(*s->out[0], 1);
wm8750.c:    if (s->master || !s->ext_dac_hz)
wm8750.c:        s->dac_hz = s->rate->dac_hz;
wm8750.c:        s->dac_hz = s->ext_dac_hz;
wm8750.c:    if (s->master || !s->ext_adc_hz)
wm8750.c:        s->adc_hz = s->rate->adc_hz;
wm8750.c:        s->adc_hz = s->ext_adc_hz;
wm8750.c:    if (s->master || (!s->ext_dac_hz && !s->ext_adc_hz)) {
wm8750.c:    s->rate = &wm_rate_table[0];
wm8750.c:    s->enable = 0;
wm8750.c:    s->diff[0] = 0;
wm8750.c:    s->diff[1] = 0;
wm8750.c:    s->ds = 0;
wm8750.c:    s->alc = 0;
wm8750.c:    s->in[0] = &s->adc_voice[0];
wm8750.c:    s->invol[0] = 0x17;
wm8750.c:    s->invol[1] = 0x17;
wm8750.c:    s->invol[2] = 0xc3;
wm8750.c:    s->invol[3] = 0xc3;
wm8750.c:    s->out[0] = &s->dac_voice[0];
wm8750.c:    s->outvol[0] = 0xff;
wm8750.c:    s->outvol[1] = 0xff;
wm8750.c:    s->outvol[2] = 0x79;
wm8750.c:    s->outvol[3] = 0x79;
wm8750.c:    s->outvol[4] = 0x79;
wm8750.c:    s->outvol[5] = 0x79;
wm8750.c:    s->outvol[6] = 0x79;
wm8750.c:    s->inmute[0] = 0;
wm8750.c:    s->inmute[1] = 0;
wm8750.c:    s->outmute[0] = 0;
wm8750.c:    s->outmute[1] = 0;
wm8750.c:    s->mute = 1;
wm8750.c:    s->path[0] = 0;
wm8750.c:    s->path[1] = 0;
wm8750.c:    s->path[2] = 0;
wm8750.c:    s->path[3] = 0;
wm8750.c:    s->mpath[0] = 0;
wm8750.c:    s->mpath[1] = 0;
wm8750.c:    s->format = 0x0a;
wm8750.c:    s->idx_in = sizeof(s->data_in);
wm8750.c:    s->req_in = 0;
wm8750.c:    s->idx_out = 0;
wm8750.c:    s->req_out = 0;
wm8750.c:    s->i2c_len = 0;
wm8750.c:        s->i2c_len = 0;
wm8750.c:        if (s->i2c_len < 2)
wm8750.c:                            __FUNCTION__, s->i2c_len);
wm8750.c:    if (s->i2c_len >= 2) {
wm8750.c:        printf("%s: long message (%i bytes)\n", __FUNCTION__, s->i2c_len);
wm8750.c:    s->i2c_data[s->i2c_len ++] = data;
wm8750.c:    if (s->i2c_len != 2)
wm8750.c:    cmd = s->i2c_data[0] >> 1;
wm8750.c:    value = ((s->i2c_data[0] << 8) | s->i2c_data[1]) & 0x1ff;
wm8750.c:        s->diff[0] = (((value >> 6) & 3) == 3);	/* LINSEL */
wm8750.c:        if (s->diff[0])
wm8750.c:            s->in[0] = &s->adc_voice[0 + s->ds * 1];
wm8750.c:            s->in[0] = &s->adc_voice[((value >> 6) & 3) * 1 + 0];
wm8750.c:        s->diff[1] = (((value >> 6) & 3) == 3);	/* RINSEL */
wm8750.c:        if (s->diff[1])
wm8750.c:            s->in[1] = &s->adc_voice[0 + s->ds * 1];
wm8750.c:            s->in[1] = &s->adc_voice[((value >> 6) & 3) * 1 + 0];
wm8750.c:        s->ds = (value >> 8) & 1;	/* DS */
wm8750.c:        if (s->diff[0])
wm8750.c:            s->in[0] = &s->adc_voice[0 + s->ds * 1];
wm8750.c:        if (s->diff[1])
wm8750.c:            s->in[1] = &s->adc_voice[0 + s->ds * 1];
wm8750.c:        s->monomix[0] = (value >> 6) & 3;	/* MONOMIX */
wm8750.c:        s->monomix[1] = (value >> 1) & 1;	/* DMONOMIX */
wm8750.c:        s->enable = ((value >> 6) & 7) == 3;	/* VMIDSEL, VREF */
wm8750.c:        s->invol[0] = value & 0x3f;		/* LINVOL */
wm8750.c:        s->inmute[0] = (value >> 7) & 1;	/* LINMUTE */
wm8750.c:        s->invol[1] = value & 0x3f;		/* RINVOL */
wm8750.c:        s->inmute[1] = (value >> 7) & 1;	/* RINMUTE */
wm8750.c:        s->pol = (value >> 5) & 3;		/* ADCPOL */
wm8750.c:        s->mute = (value >> 3) & 1;		/* DACMU */
wm8750.c:        s->invol[2] = value & 0xff;		/* LADCVOL */
wm8750.c:        s->invol[3] = value & 0xff;		/* RADCVOL */
wm8750.c:        s->alc = (value >> 7) & 3;		/* ALCSEL */
wm8750.c:        s->outvol[0] = value & 0xff;		/* LDACVOL */
wm8750.c:        s->outvol[1] = value & 0xff;		/* RDACVOL */
wm8750.c:        s->path[0] = (value >> 8) & 1;		/* LD2LO */
wm8750.c:        s->path[1] = (value >> 8) & 1;		/* RD2LO */
wm8750.c:        s->path[2] = (value >> 8) & 1;		/* LD2RO */
wm8750.c:        s->path[3] = (value >> 8) & 1;		/* RD2RO */
wm8750.c:        s->mpath[0] = (value >> 8) & 1;		/* LD2MO */
wm8750.c:        s->mpath[1] = (value >> 8) & 1;		/* RD2MO */
wm8750.c:        s->outvol[2] = value & 0x7f;		/* LOUT1VOL */
wm8750.c:        s->outvol[4] = value & 0x7f;		/* LOUT2VOL */
wm8750.c:        s->outvol[3] = value & 0x7f;		/* ROUT1VOL */
wm8750.c:        s->outvol[5] = value & 0x7f;		/* ROUT2VOL */
wm8750.c:        s->outvol[6] = value & 0x7f;		/* MONOOUTVOL */
wm8750.c:        s->power = value & 0x7e;
wm8750.c:        s->format = value;
wm8750.c:        s->master = (value >> 6) & 1;			/* MS */
wm8750.c:        wm8750_clk_update(s, s->master);
wm8750.c:        s->rate = &wm_rate_table[(value >> 1) & 0x1f];
wm8750.c:        wm8750_reset(&s->i2c);
wm8750.c:    s->rate_vmstate = (s->rate - wm_rate_table) / sizeof(*s->rate);
wm8750.c:    s->rate = &wm_rate_table[s->rate_vmstate & 0x1f];
wm8750.c:    AUD_register_card(CODEC, &s->card);
wm8750.c:    wm8750_reset(&s->i2c);
wm8750.c:    wm8750_reset(&s->i2c);
wm8750.c:    AUD_remove_card(&s->card);
wm8750.c:    s->data_req = data_req;
wm8750.c:    s->opaque = opaque;
wm8750.c:    *(uint32_t *) &s->data_out[s->idx_out] = sample;
wm8750.c:    s->req_out -= 4;
wm8750.c:    s->idx_out += 4;
wm8750.c:    if (s->idx_out >= sizeof(s->data_out) || s->req_out <= 0)
wm8750.c:    void *ret = s->data_out + s->idx_out;
wm8750.c:    s->idx_out += samples << 2;
wm8750.c:    s->req_out -= samples << 2;
wm8750.c:    if (s->idx_in >= sizeof(s->data_in))
wm8750.c:    data = (uint32_t *) &s->data_in[s->idx_in];
wm8750.c:    s->req_in -= 4;
wm8750.c:    s->idx_in += 4;
wm8750.c:    s->ext_adc_hz = new_hz;
wm8750.c:    s->ext_dac_hz = new_hz;
xen_backend.c:#include "qemu-char.h"
xen_backend.c:#include "qemu-log.h"
xen_backend.c:/* ------------------------------------------------------------- */
xen_backend.c:/* ------------------------------------------------------------- */
xen_backend.c:	return -1;
xen_backend.c:        /* move to qemu-allocated memory to make sure
xen_backend.c:    int rc = -1;
xen_backend.c:    return xenstore_write_str(xendev->be, node, val);
xen_backend.c:    return xenstore_write_int(xendev->be, node, ival);
xen_backend.c:    return xenstore_read_str(xendev->be, node);
xen_backend.c:    return xenstore_read_int(xendev->be, node, ival);
xen_backend.c:    return xenstore_read_str(xendev->fe, node);
xen_backend.c:    return xenstore_read_int(xendev->fe, node, ival);
xen_backend.c:/* ------------------------------------------------------------- */
xen_backend.c:    xen_be_printf(xendev, 1, "backend state: %s -> %s\n",
xen_backend.c:		  xenbus_strstate(xendev->be_state), xenbus_strstate(state));
xen_backend.c:    xendev->be_state = state;
xen_backend.c:/* ------------------------------------------------------------- */
xen_backend.c:	if (xendev->dom != dom)
xen_backend.c:	if (xendev->dev != dev)
xen_backend.c:	if (strcmp(xendev->type, type) != 0)
xen_backend.c:    xendev = qemu_mallocz(ops->size);
xen_backend.c:    xendev->type  = type;
xen_backend.c:    xendev->dom   = dom;
xen_backend.c:    xendev->dev   = dev;
xen_backend.c:    xendev->ops   = ops;
xen_backend.c:    snprintf(xendev->be, sizeof(xendev->be), "%s/backend/%s/%d/%d",
xen_backend.c:	     dom0, xendev->type, xendev->dom, xendev->dev);
xen_backend.c:    snprintf(xendev->name, sizeof(xendev->name), "%s-%d",
xen_backend.c:	     xendev->type, xendev->dev);
xen_backend.c:    xendev->debug      = debug;
xen_backend.c:    xendev->local_port = -1;
xen_backend.c:    xendev->evtchndev = xc_evtchn_open();
xen_backend.c:    if (xendev->evtchndev < 0) {
xen_backend.c:    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);
xen_backend.c:    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {
xen_backend.c:	xendev->gnttabdev = xc_gnttab_open();
xen_backend.c:	if (xendev->gnttabdev < 0) {
xen_backend.c:	    xc_evtchn_close(xendev->evtchndev);
xen_backend.c:	xendev->gnttabdev = -1;
xen_backend.c:    if (xendev->ops->alloc)
xen_backend.c:	xendev->ops->alloc(xendev);
xen_backend.c:        xnext = xendev->next.tqe_next;
xen_backend.c:	if (xendev->dom != dom)
xen_backend.c:	if (xendev->dev != dev && dev != -1)
xen_backend.c:	if (xendev->ops->free)
xen_backend.c:	    xendev->ops->free(xendev);
xen_backend.c:	if (xendev->fe) {
xen_backend.c:	    xs_unwatch(xenstore, xendev->fe, token);
xen_backend.c:	    qemu_free(xendev->fe);
xen_backend.c:	if (xendev->evtchndev >= 0)
xen_backend.c:	    xc_evtchn_close(xendev->evtchndev);
xen_backend.c:	if (xendev->gnttabdev >= 0)
xen_backend.c:	    xc_gnttab_close(xendev->gnttabdev);
xen_backend.c:	if (xenstore_read_be_int(xendev, "online", &xendev->online) == -1)
xen_backend.c:	    xendev->online = 0;
xen_backend.c:	if (xendev->ops->backend_changed)
xen_backend.c:	    xendev->ops->backend_changed(xendev, node);
xen_backend.c:	if (xenstore_read_fe_int(xendev, "state", &fe_state) == -1)
xen_backend.c:	if (xendev->fe_state != fe_state)
xen_backend.c:	    xen_be_printf(xendev, 1, "frontend state: %s -> %s\n",
xen_backend.c:			  xenbus_strstate(xendev->fe_state),
xen_backend.c:	xendev->fe_state = fe_state;
xen_backend.c:	qemu_free(xendev->protocol);
xen_backend.c:	xendev->protocol = xenstore_read_fe_str(xendev, "protocol");
xen_backend.c:	if (xendev->protocol)
xen_backend.c:	    xen_be_printf(xendev, 1, "frontend protocol: %s\n", xendev->protocol);
xen_backend.c:	if (xendev->ops->frontend_changed)
xen_backend.c:	    xendev->ops->frontend_changed(xendev, node);
xen_backend.c:/* ------------------------------------------------------------- */
xen_backend.c: * Also sets initial state (-> Initializing) when done.  Which
xen_backend.c: * only affects the xendev->be_state variable as xenbus should
xen_backend.c:    if (xenstore_read_be_int(xendev, "state", &be_state) == -1) {
xen_backend.c:	return -1;
xen_backend.c:	return -1;
xen_backend.c:    xendev->fe = xenstore_read_be_str(xendev, "frontend");
xen_backend.c:    if (xendev->fe == NULL) {
xen_backend.c:	return -1;
xen_backend.c:    if (!xs_watch(xenstore, xendev->fe, token)) {
xen_backend.c:		      xendev->fe);
xen_backend.c:	return -1;
xen_backend.c: * without synchronizing with the frontend.  Fakes hotplug-status.  No
xen_backend.c:    if (!xendev->online) {
xen_backend.c:	return -1;
xen_backend.c:    if (xendev->ops->init)
xen_backend.c:	rc = xendev->ops->init(xendev);
xen_backend.c:    xenstore_write_be_str(xendev, "hotplug-status", "connected");
xen_backend.c:    if (xendev->fe_state != XenbusStateInitialised  &&
xen_backend.c:	xendev->fe_state != XenbusStateConnected) {
xen_backend.c:	if (xendev->ops->flags & DEVOPS_FLAG_IGNORE_STATE) {
xen_backend.c:	    return -1;
xen_backend.c:    if (xendev->ops->connect)
xen_backend.c:	rc = xendev->ops->connect(xendev);
xen_backend.c:    if (xendev->be_state != XenbusStateClosing &&
xen_backend.c:        xendev->be_state != XenbusStateClosed  &&
xen_backend.c:        xendev->ops->disconnect)
xen_backend.c:	xendev->ops->disconnect(xendev);
xen_backend.c:    if (xendev->be_state != state)
xen_backend.c:    if (xendev->fe_state != XenbusStateInitialising)
xen_backend.c:        return -1;
xen_backend.c:    xen_be_printf(xendev, 1, "device reset (for re-connect)\n");
xen_backend.c:    if (xendev->fe_state == XenbusStateClosing ||
xen_backend.c:	xendev->fe_state == XenbusStateClosed) {
xen_backend.c:	xen_be_disconnect(xendev, xendev->fe_state);
xen_backend.c:	switch (xendev->be_state) {
xen_backend.c:	    rc = -1;
xen_backend.c:/* ------------------------------------------------------------- */
xen_backend.c:	return -1;
xen_backend.c:	    dev = -1;
xen_backend.c:    if (dev == -1)
xen_backend.c:    len = strlen(xendev->fe);
xen_backend.c:    if (strncmp(xendev->fe, watch, len) != 0)
xen_backend.c:    port = xc_evtchn_pending(xendev->evtchndev);
xen_backend.c:    if (port != xendev->local_port) {
xen_backend.c:		      port, xendev->local_port);
xen_backend.c:    xc_evtchn_unmask(xendev->evtchndev, port);
xen_backend.c:    if (xendev->ops->event)
xen_backend.c:	xendev->ops->event(xendev);
xen_backend.c:/* -------------------------------------------------------------------- */
xen_backend.c:	return -1;
xen_backend.c:    if (xen_xc == -1) {
xen_backend.c:    return -1;
xen_backend.c:    if (xendev->local_port != -1)
xen_backend.c:    xendev->local_port = xc_evtchn_bind_interdomain
xen_backend.c:	(xendev->evtchndev, xendev->dom, xendev->remote_port);
xen_backend.c:    if (xendev->local_port == -1) {
xen_backend.c:	return -1;
xen_backend.c:    xen_be_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port);
xen_backend.c:    qemu_set_fd_handler(xc_evtchn_fd(xendev->evtchndev),
xen_backend.c:    if (xendev->local_port == -1)
xen_backend.c:    qemu_set_fd_handler(xc_evtchn_fd(xendev->evtchndev), NULL, NULL, NULL);
xen_backend.c:    xc_evtchn_unbind(xendev->evtchndev, xendev->local_port);
xen_backend.c:    xen_be_printf(xendev, 2, "unbind evtchn port %d\n", xendev->local_port);
xen_backend.c:    xendev->local_port = -1;
xen_backend.c:    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);
xen_backend.c:        if (msg_level > xendev->debug)
xen_backend.c:        qemu_log("xen be: %s: ", xendev->name);
xen_backend.c:            fprintf(stderr, "xen be: %s: ", xendev->name);
xen_backend.h:/* ------------------------------------------------------------- */
xen_backend.h:/* driver uses grant tables  ->  open gntdev device (xendev->gnttabdev) */
xen_backend.h:/* ------------------------------------------------------------- */
xen_blkif.h: * compiler-checkable way to use common struct elements, so we can
xen_blkif.h:	dst->operation = src->operation;
xen_blkif.h:	dst->nr_segments = src->nr_segments;
xen_blkif.h:	dst->handle = src->handle;
xen_blkif.h:	dst->id = src->id;
xen_blkif.h:	dst->sector_number = src->sector_number;
xen_blkif.h:	if (n > src->nr_segments)
xen_blkif.h:		n = src->nr_segments;
xen_blkif.h:		dst->seg[i] = src->seg[i];
xen_blkif.h:	dst->operation = src->operation;
xen_blkif.h:	dst->nr_segments = src->nr_segments;
xen_blkif.h:	dst->handle = src->handle;
xen_blkif.h:	dst->id = src->id;
xen_blkif.h:	dst->sector_number = src->sector_number;
xen_blkif.h:	if (n > src->nr_segments)
xen_blkif.h:		n = src->nr_segments;
xen_blkif.h:		dst->seg[i] = src->seg[i];
xen_common.h:#include "qemu-queue.h"
xen_common.h: *  0x00030205 -> 3.1.0
xen_common.h: *  0x00030207 -> 3.2.0
xen_common.h: *  0x00030208 -> unstable
xen_common.h:#include <xen/xen-compat.h>
xen_console.c:#include "qemu-char.h"
xen_console.c:    struct buffer *buffer = &con->buffer;
xen_console.c:    struct xencons_interface *intf = con->sring;
xen_console.c:    cons = intf->out_cons;
xen_console.c:    prod = intf->out_prod;
xen_console.c:    size = prod - cons;
xen_console.c:    if ((size == 0) || (size > sizeof(intf->out)))
xen_console.c:    if ((buffer->capacity - buffer->size) < size) {
xen_console.c:	buffer->capacity += (size + 1024);
xen_console.c:	buffer->data = qemu_realloc(buffer->data, buffer->capacity);
xen_console.c:	buffer->data[buffer->size++] = intf->out[
xen_console.c:	    MASK_XENCONS_IDX(cons++, intf->out)];
xen_console.c:    intf->out_cons = cons;
xen_console.c:    xen_be_send_notify(&con->xendev);
xen_console.c:    if (buffer->max_capacity &&
xen_console.c:	buffer->size > buffer->max_capacity) {
xen_console.c:	size_t over = buffer->size - buffer->max_capacity;
xen_console.c:	uint8_t *maxpos = buffer->data + buffer->max_capacity;
xen_console.c:	memmove(maxpos - over, maxpos, over);
xen_console.c:	buffer->data = qemu_realloc(buffer->data, buffer->max_capacity);
xen_console.c:	buffer->size = buffer->capacity = buffer->max_capacity;
xen_console.c:	if (buffer->consumed > buffer->max_capacity - over)
xen_console.c:	    buffer->consumed = buffer->max_capacity - over;
xen_console.c:    buffer->consumed += len;
xen_console.c:    if (buffer->consumed == buffer->size) {
xen_console.c:	buffer->consumed = 0;
xen_console.c:	buffer->size = 0;
xen_console.c:    struct xencons_interface *intf = con->sring;
xen_console.c:    cons = intf->in_cons;
xen_console.c:    prod = intf->in_prod;
xen_console.c:    space = prod - cons;
xen_console.c:    if (space > sizeof(intf->in))
xen_console.c:    return (sizeof(intf->in) - space);
xen_console.c:    struct xencons_interface *intf = con->sring;
xen_console.c:    prod = intf->in_prod;
xen_console.c:	intf->in[MASK_XENCONS_IDX(prod++, intf->in)] =
xen_console.c:    intf->in_prod = prod;
xen_console.c:    xen_be_send_notify(&con->xendev);
xen_console.c:    size = con->buffer.size - con->buffer.consumed;
xen_console.c:    if (con->chr)
xen_console.c:        len = qemu_chr_write(con->chr, con->buffer.data + con->buffer.consumed,
xen_console.c:	if (!con->backlog) {
xen_console.c:	    con->backlog = 1;
xen_console.c:	    xen_be_printf(&con->xendev, 1, "backlog piling up, nobody listening?\n");
xen_console.c:	buffer_advance(&con->buffer, len);
xen_console.c:	if (con->backlog && len == size) {
xen_console.c:	    con->backlog = 0;
xen_console.c:	    xen_be_printf(&con->xendev, 1, "backlog is gone\n");
xen_console.c:/* -------------------------------------------------------------------- */
xen_console.c:    dom = xs_get_domain_path(xenstore, con->xendev.dom);
xen_console.c:    snprintf(con->console, sizeof(con->console), "%s/console", dom);
xen_console.c:    type = xenstore_read_str(con->console, "type");
xen_console.c:	return -1;
xen_console.c:    if (!serial_hds[con->xendev.dev])
xen_console.c:                      con->xendev.dev);
xen_console.c:        con->chr = serial_hds[con->xendev.dev];
xen_console.c:    if (xenstore_read_int(con->console, "ring-ref", &con->ring_ref) == -1)
xen_console.c:	return -1;
xen_console.c:    if (xenstore_read_int(con->console, "port", &con->xendev.remote_port) == -1)
xen_console.c:	return -1;
xen_console.c:    if (xenstore_read_int(con->console, "limit", &limit) == 0)
xen_console.c:	con->buffer.max_capacity = limit;
xen_console.c:    con->sring = xc_map_foreign_range(xen_xc, con->xendev.dom,
xen_console.c:				      con->ring_ref);
xen_console.c:    if (!con->sring)
xen_console.c:	return -1;
xen_console.c:    xen_be_bind_evtchn(&con->xendev);
xen_console.c:    if (con->chr)
xen_console.c:        qemu_chr_add_handlers(con->chr, xencons_can_receive, xencons_receive,
xen_console.c:		  con->ring_ref,
xen_console.c:		  con->xendev.remote_port,
xen_console.c:		  con->xendev.local_port,
xen_console.c:		  con->buffer.max_capacity);
xen_console.c:    if (con->chr)
xen_console.c:        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);
xen_console.c:    xen_be_unbind_evtchn(&con->xendev);
xen_console.c:    if (con->sring) {
xen_console.c:	munmap(con->sring, XC_PAGE_SIZE);
xen_console.c:	con->sring = NULL;
xen_console.c:    if (con->buffer.size - con->buffer.consumed)
xen_console.c:/* -------------------------------------------------------------------- */
xen_devconfig.c:/* ------------------------------------------------------------- */
xen_devconfig.c:    d->xs_dir = dir;
xen_devconfig.c:	xs_rm(xenstore, 0, d->xs_dir);
xen_devconfig.c:/* ------------------------------------------------------------- */
xen_devconfig.c:	return -1;
xen_devconfig.c:	return -1;
xen_devconfig.c:    xenstore_write_int(fe, "backend-id",      0);
xen_devconfig.c:    xenstore_write_str(be, "domain",          qemu_name ? qemu_name : "no-name");
xen_devconfig.c:    xenstore_write_int(be, "frontend-id",     xen_domid);
xen_devconfig.c:/* ------------------------------------------------------------- */
xen_devconfig.c:    int vdev = 202 * 256 + 16 * disk->unit;
xen_devconfig.c:    int cdrom = disk->bdrv->type == BDRV_TYPE_CDROM;
xen_devconfig.c:    snprintf(disk->bdrv->device_name, sizeof(disk->bdrv->device_name),
xen_devconfig.c:	     "xvd%c", 'a' + disk->unit);
xen_devconfig.c:                  disk->unit, disk->bdrv->device_name, disk->bdrv->filename);
xen_devconfig.c:    xenstore_write_int(fe, "virtual-device",  vdev);
xen_devconfig.c:    xenstore_write_str(fe, "device-type",     devtype);
xen_devconfig.c:    xenstore_write_str(be, "dev",             disk->bdrv->device_name);
xen_devconfig.c:    xenstore_write_str(be, "params",          disk->bdrv->filename);
xen_devconfig.c:	     nic->macaddr[0], nic->macaddr[1], nic->macaddr[2],
xen_devconfig.c:	     nic->macaddr[3], nic->macaddr[4], nic->macaddr[5]);
xen_devconfig.c:    xen_be_printf(NULL, 1, "config nic %d: mac=\"%s\"\n", nic->vlan->id, mac);
xen_devconfig.c:    xen_config_dev_dirs("vif", "qnic", nic->vlan->id, fe, be, sizeof(fe));
xen_devconfig.c:    xenstore_write_int(fe, "handle",     nic->vlan->id);
xen_devconfig.c:    xenstore_write_int(be, "handle",     nic->vlan->id);
xen_disk.c:#include "qemu-char.h"
xen_disk.c:/* ------------------------------------------------------------- */
xen_disk.c:/* ------------------------------------------------------------- */
xen_disk.c:/* ------------------------------------------------------------- */
xen_disk.c:    if (QLIST_EMPTY(&blkdev->freelist)) {
xen_disk.c:	if (blkdev->requests_total >= max_requests)
xen_disk.c:	ioreq->blkdev = blkdev;
xen_disk.c:	blkdev->requests_total++;
xen_disk.c:        qemu_iovec_init(&ioreq->v, BLKIF_MAX_SEGMENTS_PER_REQUEST);
xen_disk.c:	ioreq = QLIST_FIRST(&blkdev->freelist);
xen_disk.c:        qemu_iovec_reset(&ioreq->v);
xen_disk.c:    QLIST_INSERT_HEAD(&blkdev->inflight, ioreq, list);
xen_disk.c:    blkdev->requests_inflight++;
xen_disk.c:    struct XenBlkDev *blkdev = ioreq->blkdev;
xen_disk.c:    QLIST_INSERT_HEAD(&blkdev->finished, ioreq, list);
xen_disk.c:    blkdev->requests_inflight--;
xen_disk.c:    blkdev->requests_finished++;
xen_disk.c:    struct XenBlkDev *blkdev = ioreq->blkdev;
xen_disk.c:    ioreq->blkdev = blkdev;
xen_disk.c:    QLIST_INSERT_HEAD(&blkdev->freelist, ioreq, list);
xen_disk.c:    blkdev->requests_finished--;
xen_disk.c:    struct XenBlkDev *blkdev = ioreq->blkdev;
xen_disk.c:    xen_be_printf(&blkdev->xendev, 3,
xen_disk.c:		  ioreq->req.operation, ioreq->req.nr_segments,
xen_disk.c:		  ioreq->req.handle, ioreq->req.id, ioreq->req.sector_number);
xen_disk.c:    switch (ioreq->req.operation) {
xen_disk.c:	ioreq->prot = PROT_WRITE; /* to memory */
xen_disk.c:	    ioreq->presync = ioreq->postsync = 1;
xen_disk.c:	ioreq->prot = PROT_READ; /* from memory */
xen_disk.c:	    ioreq->postsync = 1;
xen_disk.c:	xen_be_printf(&blkdev->xendev, 0, "error: unknown operation (%d)\n",
xen_disk.c:		      ioreq->req.operation);
xen_disk.c:    if (ioreq->req.operation != BLKIF_OP_READ && blkdev->mode[0] != 'w') {
xen_disk.c:        xen_be_printf(&blkdev->xendev, 0, "error: write req for ro device\n");
xen_disk.c:    ioreq->start = ioreq->req.sector_number * blkdev->file_blk;
xen_disk.c:    for (i = 0; i < ioreq->req.nr_segments; i++) {
xen_disk.c:	    xen_be_printf(&blkdev->xendev, 0, "error: nr_segments too big\n");
xen_disk.c:	if (ioreq->req.seg[i].first_sect > ioreq->req.seg[i].last_sect) {
xen_disk.c:	    xen_be_printf(&blkdev->xendev, 0, "error: first > last sector\n");
xen_disk.c:	if (ioreq->req.seg[i].last_sect * BLOCK_SIZE >= XC_PAGE_SIZE) {
xen_disk.c:	    xen_be_printf(&blkdev->xendev, 0, "error: page crossing\n");
xen_disk.c:	ioreq->domids[i] = blkdev->xendev.dom;
xen_disk.c:	ioreq->refs[i]   = ioreq->req.seg[i].gref;
xen_disk.c:	mem = ioreq->req.seg[i].first_sect * blkdev->file_blk;
xen_disk.c:	len = (ioreq->req.seg[i].last_sect - ioreq->req.seg[i].first_sect + 1) * blkdev->file_blk;
xen_disk.c:        qemu_iovec_add(&ioreq->v, (void*)mem, len);
xen_disk.c:    if (ioreq->start + ioreq->v.size > blkdev->file_size) {
xen_disk.c:	xen_be_printf(&blkdev->xendev, 0, "error: access beyond end of file\n");
xen_disk.c:    ioreq->status = BLKIF_RSP_ERROR;
xen_disk.c:    return -1;
xen_disk.c:    int gnt = ioreq->blkdev->xendev.gnttabdev;
xen_disk.c:    if (ioreq->v.niov == 0)
xen_disk.c:	if (!ioreq->pages)
xen_disk.c:	if (xc_gnttab_munmap(gnt, ioreq->pages, ioreq->v.niov) != 0)
xen_disk.c:	    xen_be_printf(&ioreq->blkdev->xendev, 0, "xc_gnttab_munmap failed: %s\n",
xen_disk.c:	ioreq->blkdev->cnt_map -= ioreq->v.niov;
xen_disk.c:	ioreq->pages = NULL;
xen_disk.c:	for (i = 0; i < ioreq->v.niov; i++) {
xen_disk.c:	    if (!ioreq->page[i])
xen_disk.c:	    if (xc_gnttab_munmap(gnt, ioreq->page[i], 1) != 0)
xen_disk.c:		xen_be_printf(&ioreq->blkdev->xendev, 0, "xc_gnttab_munmap failed: %s\n",
xen_disk.c:	    ioreq->blkdev->cnt_map--;
xen_disk.c:	    ioreq->page[i] = NULL;
xen_disk.c:    int gnt = ioreq->blkdev->xendev.gnttabdev;
xen_disk.c:    if (ioreq->v.niov == 0)
xen_disk.c:	ioreq->pages = xc_gnttab_map_grant_refs
xen_disk.c:	    (gnt, ioreq->v.niov, ioreq->domids, ioreq->refs, ioreq->prot);
xen_disk.c:	if (ioreq->pages == NULL) {
xen_disk.c:	    xen_be_printf(&ioreq->blkdev->xendev, 0,
xen_disk.c:			  ioreq->v.niov, strerror(errno), ioreq->blkdev->cnt_map);
xen_disk.c:	    return -1;
xen_disk.c:	for (i = 0; i < ioreq->v.niov; i++)
xen_disk.c:	    ioreq->v.iov[i].iov_base = ioreq->pages + i * XC_PAGE_SIZE +
xen_disk.c:		(uintptr_t)ioreq->v.iov[i].iov_base;
xen_disk.c:	ioreq->blkdev->cnt_map += ioreq->v.niov;
xen_disk.c:	for (i = 0; i < ioreq->v.niov; i++) {
xen_disk.c:	    ioreq->page[i] = xc_gnttab_map_grant_ref
xen_disk.c:		(gnt, ioreq->domids[i], ioreq->refs[i], ioreq->prot);
xen_disk.c:	    if (ioreq->page[i] == NULL) {
xen_disk.c:		xen_be_printf(&ioreq->blkdev->xendev, 0,
xen_disk.c:			      ioreq->refs[i], strerror(errno), ioreq->blkdev->cnt_map);
xen_disk.c:		return -1;
xen_disk.c:	    ioreq->v.iov[i].iov_base = ioreq->page[i] + (uintptr_t)ioreq->v.iov[i].iov_base;
xen_disk.c:	    ioreq->blkdev->cnt_map++;
xen_disk.c:    struct XenBlkDev *blkdev = ioreq->blkdev;
xen_disk.c:    if (ioreq_map(ioreq) == -1)
xen_disk.c:    if (ioreq->presync)
xen_disk.c:	bdrv_flush(blkdev->bs);
xen_disk.c:    switch (ioreq->req.operation) {
xen_disk.c:	pos = ioreq->start;
xen_disk.c:	for (i = 0; i < ioreq->v.niov; i++) {
xen_disk.c:	    rc = bdrv_read(blkdev->bs, pos / BLOCK_SIZE,
xen_disk.c:			   ioreq->v.iov[i].iov_base,
xen_disk.c:			   ioreq->v.iov[i].iov_len / BLOCK_SIZE);
xen_disk.c:		xen_be_printf(&blkdev->xendev, 0, "rd I/O error (%p, len %zd)\n",
xen_disk.c:			      ioreq->v.iov[i].iov_base,
xen_disk.c:			      ioreq->v.iov[i].iov_len);
xen_disk.c:	    len += ioreq->v.iov[i].iov_len;
xen_disk.c:	    pos += ioreq->v.iov[i].iov_len;
xen_disk.c:	pos = ioreq->start;
xen_disk.c:	for (i = 0; i < ioreq->v.niov; i++) {
xen_disk.c:	    rc = bdrv_write(blkdev->bs, pos / BLOCK_SIZE,
xen_disk.c:			    ioreq->v.iov[i].iov_base,
xen_disk.c:			    ioreq->v.iov[i].iov_len / BLOCK_SIZE);
xen_disk.c:		xen_be_printf(&blkdev->xendev, 0, "wr I/O error (%p, len %zd)\n",
xen_disk.c:			      ioreq->v.iov[i].iov_base,
xen_disk.c:			      ioreq->v.iov[i].iov_len);
xen_disk.c:	    len += ioreq->v.iov[i].iov_len;
xen_disk.c:	    pos += ioreq->v.iov[i].iov_len;
xen_disk.c:	/* unknown operation (shouldn't happen -- parse catches this) */
xen_disk.c:    if (ioreq->postsync)
xen_disk.c:	bdrv_flush(blkdev->bs);
xen_disk.c:    ioreq->status = BLKIF_RSP_OKAY;
xen_disk.c:    ioreq->status = BLKIF_RSP_ERROR;
xen_disk.c:    return -1;
xen_disk.c:        xen_be_printf(&ioreq->blkdev->xendev, 0, "%s I/O error\n",
xen_disk.c:                      ioreq->req.operation == BLKIF_OP_READ ? "read" : "write");
xen_disk.c:        ioreq->aio_errors++;
xen_disk.c:    ioreq->aio_inflight--;
xen_disk.c:    if (ioreq->aio_inflight > 0)
xen_disk.c:    ioreq->status = ioreq->aio_errors ? BLKIF_RSP_ERROR : BLKIF_RSP_OKAY;
xen_disk.c:    qemu_bh_schedule(ioreq->blkdev->bh);
xen_disk.c:    struct XenBlkDev *blkdev = ioreq->blkdev;
xen_disk.c:    if (ioreq_map(ioreq) == -1)
xen_disk.c:    ioreq->aio_inflight++;
xen_disk.c:    if (ioreq->presync)
xen_disk.c:	bdrv_flush(blkdev->bs); /* FIXME: aio_flush() ??? */
xen_disk.c:    switch (ioreq->req.operation) {
xen_disk.c:        ioreq->aio_inflight++;
xen_disk.c:        bdrv_aio_readv(blkdev->bs, ioreq->start / BLOCK_SIZE,
xen_disk.c:                       &ioreq->v, ioreq->v.size / BLOCK_SIZE,
xen_disk.c:        ioreq->aio_inflight++;
xen_disk.c:        bdrv_aio_writev(blkdev->bs, ioreq->start / BLOCK_SIZE,
xen_disk.c:                        &ioreq->v, ioreq->v.size / BLOCK_SIZE,
xen_disk.c:	/* unknown operation (shouldn't happen -- parse catches this) */
xen_disk.c:    if (ioreq->postsync)
xen_disk.c:	bdrv_flush(blkdev->bs); /* FIXME: aio_flush() ??? */
xen_disk.c:    ioreq->status = BLKIF_RSP_ERROR;
xen_disk.c:    return -1;
xen_disk.c:    struct XenBlkDev  *blkdev = ioreq->blkdev;
xen_disk.c:    resp.id        = ioreq->req.id;
xen_disk.c:    resp.operation = ioreq->req.operation;
xen_disk.c:    resp.status    = ioreq->status;
xen_disk.c:    switch (blkdev->protocol) {
xen_disk.c:	dst = RING_GET_RESPONSE(&blkdev->rings.native, blkdev->rings.native.rsp_prod_pvt);
xen_disk.c:        dst = RING_GET_RESPONSE(&blkdev->rings.x86_32_part,
xen_disk.c:                                blkdev->rings.x86_32_part.rsp_prod_pvt);
xen_disk.c:        dst = RING_GET_RESPONSE(&blkdev->rings.x86_64_part,
xen_disk.c:                                blkdev->rings.x86_64_part.rsp_prod_pvt);
xen_disk.c:    blkdev->rings.common.rsp_prod_pvt++;
xen_disk.c:    RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&blkdev->rings.common, send_notify);
xen_disk.c:    if (blkdev->rings.common.rsp_prod_pvt == blkdev->rings.common.req_cons) {
xen_disk.c:	RING_FINAL_CHECK_FOR_REQUESTS(&blkdev->rings.common, have_requests);
xen_disk.c:    } else if (RING_HAS_UNCONSUMED_REQUESTS(&blkdev->rings.common)) {
xen_disk.c:	blkdev->more_work++;
xen_disk.c:    while (!QLIST_EMPTY(&blkdev->finished)) {
xen_disk.c:        ioreq = QLIST_FIRST(&blkdev->finished);
xen_disk.c:	xen_be_send_notify(&blkdev->xendev);
xen_disk.c:    switch (blkdev->protocol) {
xen_disk.c:	memcpy(&ioreq->req, RING_GET_REQUEST(&blkdev->rings.native, rc),
xen_disk.c:	       sizeof(ioreq->req));
xen_disk.c:        blkif_get_x86_32_req(&ioreq->req,
xen_disk.c:                             RING_GET_REQUEST(&blkdev->rings.x86_32_part, rc));
xen_disk.c:        blkif_get_x86_64_req(&ioreq->req,
xen_disk.c:                             RING_GET_REQUEST(&blkdev->rings.x86_64_part, rc));
xen_disk.c:    blkdev->more_work = 0;
xen_disk.c:    rc = blkdev->rings.common.req_cons;
xen_disk.c:    rp = blkdev->rings.common.sring->req_prod;
xen_disk.c:        if (RING_REQUEST_CONS_OVERFLOW(&blkdev->rings.common, rc))
xen_disk.c:            blkdev->more_work++;
xen_disk.c:        blkdev->rings.common.req_cons = ++rc;
xen_disk.c:                xen_be_send_notify(&blkdev->xendev);
xen_disk.c:    if (blkdev->more_work && blkdev->requests_inflight < max_requests)
xen_disk.c:        qemu_bh_schedule(blkdev->bh);
xen_disk.c:/* ------------------------------------------------------------- */
xen_disk.c:    QLIST_INIT(&blkdev->inflight);
xen_disk.c:    QLIST_INIT(&blkdev->finished);
xen_disk.c:    QLIST_INIT(&blkdev->freelist);
xen_disk.c:    blkdev->bh = qemu_bh_new(blk_bh, blkdev);
xen_disk.c:    if (blkdev->params == NULL) {
xen_disk.c:	blkdev->params = xenstore_read_be_str(&blkdev->xendev, "params");
xen_disk.c:        h = strchr(blkdev->params, ':');
xen_disk.c:	    blkdev->fileproto = blkdev->params;
xen_disk.c:	    blkdev->filename  = h+1;
xen_disk.c:	    blkdev->fileproto = "<unset>";
xen_disk.c:	    blkdev->filename  = blkdev->params;
xen_disk.c:    if (blkdev->mode == NULL)
xen_disk.c:	blkdev->mode = xenstore_read_be_str(&blkdev->xendev, "mode");
xen_disk.c:    if (blkdev->type == NULL)
xen_disk.c:	blkdev->type = xenstore_read_be_str(&blkdev->xendev, "type");
xen_disk.c:    if (blkdev->dev == NULL)
xen_disk.c:	blkdev->dev = xenstore_read_be_str(&blkdev->xendev, "dev");
xen_disk.c:    if (blkdev->devtype == NULL)
xen_disk.c:	blkdev->devtype = xenstore_read_be_str(&blkdev->xendev, "device-type");
xen_disk.c:    if (blkdev->params == NULL ||
xen_disk.c:	blkdev->mode == NULL   ||
xen_disk.c:	blkdev->type == NULL   ||
xen_disk.c:	blkdev->dev == NULL)
xen_disk.c:	return -1;
xen_disk.c:    /* read-only ? */
xen_disk.c:    if (strcmp(blkdev->mode, "w") == 0) {
xen_disk.c:    if (blkdev->devtype && !strcmp(blkdev->devtype, "cdrom"))
xen_disk.c:    index = (blkdev->xendev.dev - 202 * 256) / 16;
xen_disk.c:    blkdev->dinfo = drive_get(IF_XEN, 0, index);
xen_disk.c:    if (!blkdev->dinfo) {
xen_disk.c:        /* setup via xenbus -> create new block driver instance */
xen_disk.c:        xen_be_printf(&blkdev->xendev, 2, "create new bdrv (xenbus setup)\n");
xen_disk.c:	blkdev->bs = bdrv_new(blkdev->dev);
xen_disk.c:	if (blkdev->bs) {
xen_disk.c:	    if (bdrv_open2(blkdev->bs, blkdev->filename, qflags,
xen_disk.c:                           bdrv_find_whitelisted_format(blkdev->fileproto))
xen_disk.c:		bdrv_delete(blkdev->bs);
xen_disk.c:		blkdev->bs = NULL;
xen_disk.c:	if (!blkdev->bs)
xen_disk.c:	    return -1;
xen_disk.c:        /* setup via qemu cmdline -> already setup for us */
xen_disk.c:        xen_be_printf(&blkdev->xendev, 2, "get configured bdrv (cmdline setup)\n");
xen_disk.c:	blkdev->bs = blkdev->dinfo->bdrv;
xen_disk.c:    blkdev->file_blk  = BLOCK_SIZE;
xen_disk.c:    blkdev->file_size = bdrv_getlength(blkdev->bs);
xen_disk.c:    if (blkdev->file_size < 0) {
xen_disk.c:        xen_be_printf(&blkdev->xendev, 1, "bdrv_getlength: %d (%s) | drv %s\n",
xen_disk.c:                      (int)blkdev->file_size, strerror(-blkdev->file_size),
xen_disk.c:                      blkdev->bs->drv ? blkdev->bs->drv->format_name : "-");
xen_disk.c:	blkdev->file_size = 0;
xen_disk.c:    have_barriers = blkdev->bs->drv && blkdev->bs->drv->bdrv_flush ? 1 : 0;
xen_disk.c:		  blkdev->type, blkdev->fileproto, blkdev->filename,
xen_disk.c:		  blkdev->file_size, blkdev->file_size >> 20);
xen_disk.c:    xenstore_write_be_int(&blkdev->xendev, "feature-barrier", have_barriers);
xen_disk.c:    xenstore_write_be_int(&blkdev->xendev, "info",            info);
xen_disk.c:    xenstore_write_be_int(&blkdev->xendev, "sector-size",     blkdev->file_blk);
xen_disk.c:    xenstore_write_be_int(&blkdev->xendev, "sectors",
xen_disk.c:			  blkdev->file_size / blkdev->file_blk);
xen_disk.c:    if (xenstore_read_fe_int(&blkdev->xendev, "ring-ref", &blkdev->ring_ref) == -1)
xen_disk.c:	return -1;
xen_disk.c:    if (xenstore_read_fe_int(&blkdev->xendev, "event-channel",
xen_disk.c:                             &blkdev->xendev.remote_port) == -1)
xen_disk.c:	return -1;
xen_disk.c:    blkdev->protocol = BLKIF_PROTOCOL_NATIVE;
xen_disk.c:    if (blkdev->xendev.protocol) {
xen_disk.c:        if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_32) == 0)
xen_disk.c:            blkdev->protocol = BLKIF_PROTOCOL_X86_32;
xen_disk.c:        if (strcmp(blkdev->xendev.protocol, XEN_IO_PROTO_ABI_X86_64) == 0)
xen_disk.c:            blkdev->protocol = BLKIF_PROTOCOL_X86_64;
xen_disk.c:    blkdev->sring = xc_gnttab_map_grant_ref(blkdev->xendev.gnttabdev,
xen_disk.c:					    blkdev->xendev.dom,
xen_disk.c:					    blkdev->ring_ref,
xen_disk.c:    if (!blkdev->sring)
xen_disk.c:	return -1;
xen_disk.c:    blkdev->cnt_map++;
xen_disk.c:    switch (blkdev->protocol) {
xen_disk.c:	blkif_sring_t *sring_native = blkdev->sring;
xen_disk.c:	BACK_RING_INIT(&blkdev->rings.native, sring_native, XC_PAGE_SIZE);
xen_disk.c:	blkif_x86_32_sring_t *sring_x86_32 = blkdev->sring;
xen_disk.c:        BACK_RING_INIT(&blkdev->rings.x86_32_part, sring_x86_32, XC_PAGE_SIZE);
xen_disk.c:	blkif_x86_64_sring_t *sring_x86_64 = blkdev->sring;
xen_disk.c:        BACK_RING_INIT(&blkdev->rings.x86_64_part, sring_x86_64, XC_PAGE_SIZE);
xen_disk.c:    xen_be_bind_evtchn(&blkdev->xendev);
xen_disk.c:    xen_be_printf(&blkdev->xendev, 1, "ok: proto %s, ring-ref %d, "
xen_disk.c:		  blkdev->xendev.protocol, blkdev->ring_ref,
xen_disk.c:		  blkdev->xendev.remote_port, blkdev->xendev.local_port);
xen_disk.c:    if (blkdev->bs) {
xen_disk.c:        if (!blkdev->dinfo) {
xen_disk.c:            bdrv_close(blkdev->bs);
xen_disk.c:            bdrv_delete(blkdev->bs);
xen_disk.c:	blkdev->bs = NULL;
xen_disk.c:    xen_be_unbind_evtchn(&blkdev->xendev);
xen_disk.c:    if (blkdev->sring) {
xen_disk.c:	xc_gnttab_munmap(blkdev->xendev.gnttabdev, blkdev->sring, 1);
xen_disk.c:	blkdev->cnt_map--;
xen_disk.c:	blkdev->sring = NULL;
xen_disk.c:    while (!QLIST_EMPTY(&blkdev->freelist)) {
xen_disk.c:	ioreq = QLIST_FIRST(&blkdev->freelist);
xen_disk.c:        qemu_iovec_destroy(&ioreq->v);
xen_disk.c:    qemu_free(blkdev->params);
xen_disk.c:    qemu_free(blkdev->mode);
xen_disk.c:    qemu_free(blkdev->type);
xen_disk.c:    qemu_free(blkdev->dev);
xen_disk.c:    qemu_free(blkdev->devtype);
xen_disk.c:    qemu_bh_delete(blkdev->bh);
xen_disk.c:    qemu_bh_schedule(blkdev->bh);
xen_domainbuild.c:#include "qemu-timer.h"
xen_domainbuild.c:	return -1;
xen_domainbuild.c:	return -1;
xen_domainbuild.c:            return -1;
xen_domainbuild.c:            return -1;
xen_domainbuild.c:    xenstore_write_str(vm,  "name",   qemu_name ? qemu_name : "no-name");
xen_domainbuild.c:    xenstore_write_str(dom, "name",   qemu_name ? qemu_name : "no-name");
xen_domainbuild.c:    xenstore_write_int(dom, "store/ring-ref",   xenstore_mfn);
xen_domainbuild.c:    xenstore_write_int(dom, "console/ring-ref", console_mfn);
xen_domainbuild.c:/* ------------------------------------------------------------- */
xen_domainbuild.c:        case -1:
xen_domainbuild.c:            /* EOF -> qemu exited */
xen_domainbuild.c:    return -1;
xenfb.c: *  Copyright IBM, Corp. 2005-2006
xenfb.c: *  Copyright Red Hat, Inc. 2006-2008
xenfb.c:#include "qemu-char.h"
xenfb.c:/* -------------------------------------------------------------------- */
xenfb.c:/* -------------------------------------------------------------------- */
xenfb.c:    if (xenstore_read_fe_int(&c->xendev, "page-ref", &mfn) == -1)
xenfb.c:	return -1;
xenfb.c:    if (xenstore_read_fe_int(&c->xendev, "event-channel", &c->xendev.remote_port) == -1)
xenfb.c:	return -1;
xenfb.c:    c->page = xc_map_foreign_range(xen_xc, c->xendev.dom,
xenfb.c:    if (c->page == NULL)
xenfb.c:	return -1;
xenfb.c:    xen_be_bind_evtchn(&c->xendev);
xenfb.c:    xen_be_printf(&c->xendev, 1, "ring mfn %d, remote-port %d, local-port %d\n",
xenfb.c:		  mfn, c->xendev.remote_port, c->xendev.local_port);
xenfb.c:    xen_be_unbind_evtchn(&c->xendev);
xenfb.c:    if (c->page) {
xenfb.c:	munmap(c->page, XC_PAGE_SIZE);
xenfb.c:	c->page = NULL;
xenfb.c:/* -------------------------------------------------------------------- */
xenfb.c: * Scancodes are hardware-specific.  These maps assumes a
xenfb.c:    struct xenkbd_page *page = xenfb->c.page;
xenfb.c:    if (xenfb->c.xendev.be_state != XenbusStateConnected)
xenfb.c:    prod = page->in_prod;
xenfb.c:    if (prod - page->in_cons == XENKBD_IN_RING_LEN) {
xenfb.c:	return -1;
xenfb.c:    page->in_prod = prod + 1;
xenfb.c:    return xen_be_send_notify(&xenfb->c.xendev);
xenfb.c:	xenfb->extended = 1;
xenfb.c:    if (xenfb->extended) {
xenfb.c:	xenfb->extended = 0;
xenfb.c:    int dw = ds_get_width(xenfb->c.ds);
xenfb.c:    int dh = ds_get_height(xenfb->c.ds);
xenfb.c:    if (xenfb->abs_pointer_wanted)
xenfb.c:			    dx * (dw - 1) / 0x7fff,
xenfb.c:			    dy * (dh - 1) / 0x7fff,
xenfb.c:	int lastDown = xenfb->button_state & (1 << i);
xenfb.c:    xenfb->button_state = button_state;
xenfb.c:    if (!in->c.ds) {
xenfb.c:	return -1;
xenfb.c:    xenstore_write_be_int(xendev, "feature-abs-pointer", 1);
xenfb.c:    if (xenstore_read_fe_int(xendev, "request-abs-pointer",
xenfb.c:                             &in->abs_pointer_wanted) == -1)
xenfb.c:	in->abs_pointer_wanted = 0;
xenfb.c:    rc = common_bind(&in->c);
xenfb.c:    in->qmouse = qemu_add_mouse_event_handler(xenfb_mouse_event, in,
xenfb.c:					      in->abs_pointer_wanted,
xenfb.c:    if (in->qmouse) {
xenfb.c:	qemu_remove_mouse_event_handler(in->qmouse);
xenfb.c:	in->qmouse = NULL;
xenfb.c:    common_unbind(&in->c);
xenfb.c:    struct xenkbd_page *page = xenfb->c.page;
xenfb.c:    if (page->out_prod == page->out_cons)
xenfb.c:    page->out_cons = page->out_prod;
xenfb.c:    xen_be_send_notify(&xenfb->c.xendev);
xenfb.c:/* -------------------------------------------------------------------- */
xenfb.c:    struct xenfb_page *page = xenfb->c.page;
xenfb.c:    char *protocol = xenfb->c.xendev.protocol;
xenfb.c:    int mode, ret = -1;
xenfb.c:    pd = page->pd;
xenfb.c:	ptr32 = (void*)page->pd;
xenfb.c:	ptr64 = ((void*)page->pd) + 4;
xenfb.c:	ptr32 = ((void*)page->pd) - 4;
xenfb.c:	ptr64 = (void*)page->pd;
xenfb.c:	pd   = ((void*)page->pd) - 4;
xenfb.c:	pd   = ((void*)page->pd) + 4;
xenfb.c:    if (xenfb->pixels) {
xenfb.c:        munmap(xenfb->pixels, xenfb->fbpages * XC_PAGE_SIZE);
xenfb.c:        xenfb->pixels = NULL;
xenfb.c:    xenfb->fbpages = (xenfb->fb_len + (XC_PAGE_SIZE - 1)) / XC_PAGE_SIZE;
xenfb.c:    n_fbdirs = xenfb->fbpages * mode / 8;
xenfb.c:    n_fbdirs = (n_fbdirs + (XC_PAGE_SIZE - 1)) / XC_PAGE_SIZE;
xenfb.c:    fbmfns = qemu_mallocz(sizeof(unsigned long) * xenfb->fbpages);
xenfb.c:    map = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,
xenfb.c:    xenfb_copy_mfns(mode, xenfb->fbpages, fbmfns, map);
xenfb.c:    xenfb->pixels = xc_map_foreign_pages(xen_xc, xenfb->c.xendev.dom,
xenfb.c:					 PROT_READ | PROT_WRITE, fbmfns, xenfb->fbpages);
xenfb.c:    if (xenfb->pixels == NULL)
xenfb.c:    size_t mfn_sz = sizeof(*((struct xenfb_page *)0)->pd);
xenfb.c:    size_t pd_len = sizeof(((struct xenfb_page *)0)->pd) / mfn_sz;
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "fb size limit %zu exceeds %zu, corrected\n",
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "frontend fb size %zu limited to %zu\n",
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "can't handle frontend fb depth %d\n",
xenfb.c:	return -1;
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "invalid frontend stride %d\n", row_stride);
xenfb.c:	return -1;
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "invalid frontend width %d limited to %d\n",
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "invalid frontend offset %d (max %zu)\n",
xenfb.c:		      offset, fb_len - 1);
xenfb.c:	return -1;
xenfb.c:    max_height = (fb_len - offset) / row_stride;
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 0, "invalid frontend height %d limited to %d\n",
xenfb.c:    xenfb->fb_len = fb_len;
xenfb.c:    xenfb->row_stride = row_stride;
xenfb.c:    xenfb->depth = depth;
xenfb.c:    xenfb->width = width;
xenfb.c:    xenfb->height = height;
xenfb.c:    xenfb->offset = offset;
xenfb.c:    xenfb->up_fullscreen = 1;
xenfb.c:    xenfb->do_resize = 1;
xenfb.c:    xen_be_printf(&xenfb->c.xendev, 1, "framebuffer %dx%dx%d offset %d stride %d\n",
xenfb.c:	SRC_T *src = (SRC_T *)(xenfb->pixels				\
xenfb.c:			       + xenfb->offset				\
xenfb.c:			       + (line * xenfb->row_stride)		\
xenfb.c:			       + (x * xenfb->depth / 8));		\
xenfb.c:	const int RSS = 32 - (RSB + GSB + BSB);				\
xenfb.c:	const int GSS = 32 - (GSB + BSB);				\
xenfb.c:	const int BSS = 32 - (BSB);					\
xenfb.c:	const uint32_t RSM = (~0U) << (32 - RSB);			\
xenfb.c:	const uint32_t GSM = (~0U) << (32 - GSB);			\
xenfb.c:	const uint32_t BSM = (~0U) << (32 - BSB);			\
xenfb.c:	const int RDS = 32 - (RDB + GDB + BDB);				\
xenfb.c:	const int GDS = 32 - (GDB + BDB);				\
xenfb.c:	const int BDS = 32 - (BDB);					\
xenfb.c:	const uint32_t RDM = (~0U) << (32 - RDB);			\
xenfb.c:	const uint32_t GDM = (~0U) << (32 - GDB);			\
xenfb.c:	const uint32_t BDM = (~0U) << (32 - BDB);			\
xenfb.c:	    src = (SRC_T *) ((unsigned long) src + xenfb->depth / 8);	\
xenfb.c:    int bpp = ds_get_bits_per_pixel(xenfb->c.ds);
xenfb.c:    int linesize = ds_get_linesize(xenfb->c.ds);
xenfb.c:    uint8_t *data = ds_get_data(xenfb->c.ds);
xenfb.c:    if (!is_buffer_shared(xenfb->c.ds->surface)) {
xenfb.c:        switch (xenfb->depth) {
xenfb.c:        xen_be_printf(&xenfb->c.xendev, 0, "%s: oops: convert %d -> %d bpp?\n",
xenfb.c:                      __FUNCTION__, xenfb->depth, bpp);
xenfb.c:    dpy_update(xenfb->c.ds, x, y, w, h);
xenfb.c:    struct xenfb_page *page = xenfb->c.page;
xenfb.c:    prod = page->in_prod;
xenfb.c:    cons = page->in_cons;
xenfb.c:    return prod - cons == XENFB_IN_RING_LEN;
xenfb.c:    struct xenfb_page *page = xenfb->c.page;
xenfb.c:    prod = page->in_prod;
xenfb.c:    page->in_prod = prod + 1;
xenfb.c:    xen_be_send_notify(&xenfb->c.xendev);
xenfb.c:    if (xenfb->c.xendev.be_state != XenbusStateConnected)
xenfb.c:    if (xenfb->feature_update) {
xenfb.c:        for (l = xenfb->c.ds->listeners; l != NULL; l = l->next) {
xenfb.c:            if (l->idle)
xenfb.c:            if (!l->gui_timer_interval) {
xenfb.c:                if (period > l->gui_timer_interval)
xenfb.c:                    period = l->gui_timer_interval;
xenfb.c:	if (xenfb->refresh_period != period) {
xenfb.c:	    xenfb->refresh_period = period;
xenfb.c:            xen_be_printf(&xenfb->c.xendev, 1, "refresh period: %d\n", period);
xenfb.c:	xenfb->up_fullscreen = 1;
xenfb.c:    if (xenfb->do_resize) {
xenfb.c:        xenfb->do_resize = 0;
xenfb.c:        switch (xenfb->depth) {
xenfb.c:            /* console.c supported depth -> buffer can be used directly */
xenfb.c:            qemu_free_displaysurface(xenfb->c.ds);
xenfb.c:            xenfb->c.ds->surface = qemu_create_displaysurface_from
xenfb.c:                (xenfb->width, xenfb->height, xenfb->depth,
xenfb.c:                 xenfb->row_stride, xenfb->pixels + xenfb->offset);
xenfb.c:            qemu_resize_displaysurface(xenfb->c.ds, xenfb->width, xenfb->height);
xenfb.c:        xen_be_printf(&xenfb->c.xendev, 1, "update: resizing: %dx%d @ %d bpp%s\n",
xenfb.c:                      xenfb->width, xenfb->height, xenfb->depth,
xenfb.c:                      is_buffer_shared(xenfb->c.ds->surface) ? " (shared)" : "");
xenfb.c:        dpy_resize(xenfb->c.ds);
xenfb.c:        xenfb->up_fullscreen = 1;
xenfb.c:    if (xenfb->up_fullscreen) {
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 3, "update: fullscreen\n");
xenfb.c:	xenfb_guest_copy(xenfb, 0, 0, xenfb->width, xenfb->height);
xenfb.c:    } else if (xenfb->up_count) {
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 3, "update: %d rects\n", xenfb->up_count);
xenfb.c:	for (i = 0; i < xenfb->up_count; i++)
xenfb.c:			     xenfb->up_rects[i].x,
xenfb.c:			     xenfb->up_rects[i].y,
xenfb.c:			     xenfb->up_rects[i].w,
xenfb.c:			     xenfb->up_rects[i].h);
xenfb.c:	xen_be_printf(&xenfb->c.xendev, 3, "update: nothing\n");
xenfb.c:    xenfb->up_count = 0;
xenfb.c:    xenfb->up_fullscreen = 0;
xenfb.c:    xenfb->up_fullscreen = 1;
xenfb.c:    struct xenfb_page *page = xenfb->c.page;
xenfb.c:    prod = page->out_prod;
xenfb.c:    if (prod == page->out_cons)
xenfb.c:    for (cons = page->out_cons; cons != prod; cons++) {
xenfb.c:	switch (event->type) {
xenfb.c:	    if (xenfb->up_count == UP_QUEUE)
xenfb.c:		xenfb->up_fullscreen = 1;
xenfb.c:	    if (xenfb->up_fullscreen)
xenfb.c:	    x = MAX(event->update.x, 0);
xenfb.c:	    y = MAX(event->update.y, 0);
xenfb.c:	    w = MIN(event->update.width, xenfb->width - x);
xenfb.c:	    h = MIN(event->update.height, xenfb->height - y);
xenfb.c:                xen_be_printf(&xenfb->c.xendev, 1, "bogus update ignored\n");
xenfb.c:	    if (x != event->update.x ||
xenfb.c:                y != event->update.y ||
xenfb.c:		w != event->update.width ||
xenfb.c:		h != event->update.height) {
xenfb.c:                xen_be_printf(&xenfb->c.xendev, 1, "bogus update clipped\n");
xenfb.c:	    if (w == xenfb->width && h > xenfb->height / 2) {
xenfb.c:		xenfb->up_fullscreen = 1;
xenfb.c:		xenfb->up_rects[xenfb->up_count].x = x;
xenfb.c:		xenfb->up_rects[xenfb->up_count].y = y;
xenfb.c:		xenfb->up_rects[xenfb->up_count].w = w;
xenfb.c:		xenfb->up_rects[xenfb->up_count].h = h;
xenfb.c:		xenfb->up_count++;
xenfb.c:	    if (xenfb_configure_fb(xenfb, xenfb->fb_len,
xenfb.c:				   event->resize.width,
xenfb.c:				   event->resize.height,
xenfb.c:				   event->resize.depth,
xenfb.c:				   xenfb->fb_len,
xenfb.c:				   event->resize.offset,
xenfb.c:				   event->resize.stride) < 0)
xenfb.c:    page->out_cons = cons;
xenfb.c:    fb->refresh_period = -1;
xenfb.c:    xenstore_write_be_int(xendev, "feature-resize", 1);
xenfb.c:    if (xenstore_read_fe_int(xendev, "videoram", &videoram) == -1)
xenfb.c:    rc = common_bind(&fb->c);
xenfb.c:    fb_page = fb->c.page;
xenfb.c:			    fb_page->width, fb_page->height, fb_page->depth,
xenfb.c:			    fb_page->mem_length, 0, fb_page->line_length);
xenfb.c:    if (!fb->have_console) {
xenfb.c:        fb->c.ds = graphic_console_init(xenfb_update,
xenfb.c:        fb->have_console = 1;
xenfb.c:    if (xenstore_read_fe_int(xendev, "feature-update", &fb->feature_update) == -1)
xenfb.c:	fb->feature_update = 0;
xenfb.c:    if (fb->feature_update)
xenfb.c:	xenstore_write_be_int(xendev, "request-update", 1);
xenfb.c:    xen_be_printf(xendev, 1, "feature-update=%d, videoram=%d\n",
xenfb.c:		  fb->feature_update, videoram);
xenfb.c:     * FIXME: qemu can't un-init gfx display (yet?).
xenfb.c:    fb->pixels = mmap(fb->pixels, fb->fbpages * XC_PAGE_SIZE,
xenfb.c:                      -1, 0);
xenfb.c:    common_unbind(&fb->c);
xenfb.c:    fb->feature_update = 0;
xenfb.c:    fb->bug_trigger    = 0;
xenfb.c:    if (fb->bug_trigger == 0 && strcmp(node, "state") == 0 &&
xenfb.c:        xendev->fe_state == XenbusStateConnected &&
xenfb.c:        xendev->be_state == XenbusStateConnected) {
xenfb.c:        xen_be_printf(xendev, 2, "re-trigger connected (frontend bug)\n");
xenfb.c:        fb->bug_trigger = 1; /* only once */
xenfb.c:    xen_be_send_notify(&xenfb->c.xendev);
xenfb.c:/* -------------------------------------------------------------------- */
xenfb.c:    fb->c.ds = graphic_console_init(xenfb_update,
xenfb.c:    fb->have_console = 1;
xenfb.c:    in->c.ds = fb->c.ds;
xenfb.c:    /* retry ->init() */
xen.h: *   stuff needed outside xen-*.c, i.e. interfaces to qemu.
xen.h:/* xen-machine.c */
xen_machine_pv.c:    env->halted = 1;
xen_machine_pv.c:    .desc = "Xen Para-virtualized PC",
xen_nic.c:#include "qemu-char.h"
xen_nic.c:/* ------------------------------------------------------------- */
xen_nic.c:/* ------------------------------------------------------------- */
xen_nic.c:    RING_IDX i = netdev->tx_ring.rsp_prod_pvt;
xen_nic.c:    resp = RING_GET_RESPONSE(&netdev->tx_ring, i);
xen_nic.c:    resp->id     = txp->id;
xen_nic.c:    resp->status = st;
xen_nic.c:    if (txp->flags & NETTXF_extra_info)
xen_nic.c:	RING_GET_RESPONSE(&netdev->tx_ring, ++i)->status = NETIF_RSP_NULL;
xen_nic.c:    netdev->tx_ring.rsp_prod_pvt = ++i;
xen_nic.c:    RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&netdev->tx_ring, notify);
xen_nic.c:	xen_be_send_notify(&netdev->xendev);
xen_nic.c:    if (i == netdev->tx_ring.req_cons) {
xen_nic.c:	RING_FINAL_CHECK_FOR_REQUESTS(&netdev->tx_ring, more_to_do);
xen_nic.c:	    netdev->tx_work++;
xen_nic.c:    RING_IDX cons = netdev->tx_ring.req_cons;
xen_nic.c:	txp = RING_GET_REQUEST(&netdev->tx_ring, cons++);
xen_nic.c:    netdev->tx_ring.req_cons = cons;
xen_nic.c:	rc = netdev->tx_ring.req_cons;
xen_nic.c:	rp = netdev->tx_ring.sring->req_prod;
xen_nic.c:	    if (RING_REQUEST_CONS_OVERFLOW(&netdev->tx_ring, rc))
xen_nic.c:	    memcpy(&txreq, RING_GET_REQUEST(&netdev->tx_ring, rc), sizeof(txreq));
xen_nic.c:	    netdev->tx_ring.req_cons = ++rc;
xen_nic.c:	     * feature-{sg,gso,whatelse} flags in xenstore (yet?) */
xen_nic.c:		xen_be_printf(&netdev->xendev, 0, "FIXME: extra info flag\n");
xen_nic.c:		xen_be_printf(&netdev->xendev, 0, "FIXME: more data flag\n");
xen_nic.c:		xen_be_printf(&netdev->xendev, 0, "bad packet size: %d\n", txreq.size);
xen_nic.c:		xen_be_printf(&netdev->xendev, 0, "error: page crossing\n");
xen_nic.c:	    xen_be_printf(&netdev->xendev, 3, "tx packet ref %d, off %d, len %d, flags 0x%x%s%s%s%s\n",
xen_nic.c:	    page = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,
xen_nic.c:					   netdev->xendev.dom,
xen_nic.c:		xen_be_printf(&netdev->xendev, 0, "error: tx gref dereference failed (%d)\n",
xen_nic.c:                /* have read-only mapping -> can't fill checksum in-place */
xen_nic.c:                qemu_send_packet(&netdev->nic->nc, tmpbuf, txreq.size);
xen_nic.c:                qemu_send_packet(&netdev->nic->nc, page + txreq.offset, txreq.size);
xen_nic.c:	    xc_gnttab_munmap(netdev->xendev.gnttabdev, page, 1);
xen_nic.c:	if (!netdev->tx_work)
xen_nic.c:	netdev->tx_work = 0;
xen_nic.c:/* ------------------------------------------------------------- */
xen_nic.c:    RING_IDX i = netdev->rx_ring.rsp_prod_pvt;
xen_nic.c:    resp = RING_GET_RESPONSE(&netdev->rx_ring, i);
xen_nic.c:    resp->offset     = offset;
xen_nic.c:    resp->flags      = flags;
xen_nic.c:    resp->id         = req->id;
xen_nic.c:    resp->status     = (int16_t)size;
xen_nic.c:	resp->status = (int16_t)st;
xen_nic.c:    xen_be_printf(&netdev->xendev, 3, "rx response: idx %d, status %d, flags 0x%x\n",
xen_nic.c:		  i, resp->status, resp->flags);
xen_nic.c:    netdev->rx_ring.rsp_prod_pvt = ++i;
xen_nic.c:    RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&netdev->rx_ring, notify);
xen_nic.c:	xen_be_send_notify(&netdev->xendev);
xen_nic.c:    struct XenNetDev *netdev = DO_UPCAST(NICState, nc, nc)->opaque;
xen_nic.c:    if (netdev->xendev.be_state != XenbusStateConnected)
xen_nic.c:    rc = netdev->rx_ring.req_cons;
xen_nic.c:    rp = netdev->rx_ring.sring->req_prod;
xen_nic.c:    if (rc == rp || RING_REQUEST_CONS_OVERFLOW(&netdev->rx_ring, rc)) {
xen_nic.c:	xen_be_printf(&netdev->xendev, 2, "%s: no rx buffers (%d/%d)\n",
xen_nic.c:    struct XenNetDev *netdev = DO_UPCAST(NICState, nc, nc)->opaque;
xen_nic.c:    if (netdev->xendev.be_state != XenbusStateConnected)
xen_nic.c:	return -1;
xen_nic.c:    rc = netdev->rx_ring.req_cons;
xen_nic.c:    rp = netdev->rx_ring.sring->req_prod;
xen_nic.c:    if (rc == rp || RING_REQUEST_CONS_OVERFLOW(&netdev->rx_ring, rc)) {
xen_nic.c:	xen_be_printf(&netdev->xendev, 2, "no buffer, drop packet\n");
xen_nic.c:	return -1;
xen_nic.c:    if (size > XC_PAGE_SIZE - NET_IP_ALIGN) {
xen_nic.c:	xen_be_printf(&netdev->xendev, 0, "packet too big (%lu > %ld)",
xen_nic.c:		      (unsigned long)size, XC_PAGE_SIZE - NET_IP_ALIGN);
xen_nic.c:	return -1;
xen_nic.c:    memcpy(&rxreq, RING_GET_REQUEST(&netdev->rx_ring, rc), sizeof(rxreq));
xen_nic.c:    netdev->rx_ring.req_cons = ++rc;
xen_nic.c:    page = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,
xen_nic.c:				   netdev->xendev.dom,
xen_nic.c:	xen_be_printf(&netdev->xendev, 0, "error: rx gref dereference failed (%d)\n",
xen_nic.c:	return -1;
xen_nic.c:    xc_gnttab_munmap(netdev->xendev.gnttabdev, page, 1);
xen_nic.c:/* ------------------------------------------------------------- */
xen_nic.c:    if (netdev->mac == NULL)
xen_nic.c:	netdev->mac = xenstore_read_be_str(&netdev->xendev, "mac");
xen_nic.c:    if (netdev->mac == NULL)
xen_nic.c:	return -1;
xen_nic.c:    if (net_parse_macaddr(netdev->conf.macaddr.a, netdev->mac) < 0)
xen_nic.c:        return -1;
xen_nic.c:    netdev->conf.vlan = qemu_find_vlan(netdev->xendev.dev, 1);
xen_nic.c:    netdev->conf.peer = NULL;
xen_nic.c:    netdev->nic = qemu_new_nic(&net_xen_info, &netdev->conf,
xen_nic.c:    snprintf(netdev->nic->nc.info_str, sizeof(netdev->nic->nc.info_str),
xen_nic.c:             "nic: xenbus vif macaddr=%s", netdev->mac);
xen_nic.c:    xenstore_write_be_int(&netdev->xendev, "feature-rx-copy", 1);
xen_nic.c:    xenstore_write_be_int(&netdev->xendev, "feature-rx-flip", 0);
xen_nic.c:    if (xenstore_read_fe_int(&netdev->xendev, "tx-ring-ref",
xen_nic.c:				   &netdev->tx_ring_ref) == -1)
xen_nic.c:	return -1;
xen_nic.c:    if (xenstore_read_fe_int(&netdev->xendev, "rx-ring-ref",
xen_nic.c:				   &netdev->rx_ring_ref) == -1)
xen_nic.c:    if (xenstore_read_fe_int(&netdev->xendev, "event-channel",
xen_nic.c:				   &netdev->xendev.remote_port) == -1)
xen_nic.c:	return -1;
xen_nic.c:    if (xenstore_read_fe_int(&netdev->xendev, "request-rx-copy", &rx_copy) == -1)
xen_nic.c:	xen_be_printf(&netdev->xendev, 0, "frontend doesn't support rx-copy.\n");
xen_nic.c:	return -1;
xen_nic.c:    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,
xen_nic.c:					  netdev->xendev.dom,
xen_nic.c:					  netdev->tx_ring_ref,
xen_nic.c:    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,
xen_nic.c:					  netdev->xendev.dom,
xen_nic.c:					  netdev->rx_ring_ref,
xen_nic.c:    if (!netdev->txs || !netdev->rxs)
xen_nic.c:	return -1;
xen_nic.c:    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);
xen_nic.c:    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);
xen_nic.c:    xen_be_bind_evtchn(&netdev->xendev);
xen_nic.c:    xen_be_printf(&netdev->xendev, 1, "ok: tx-ring-ref %d, rx-ring-ref %d, "
xen_nic.c:		  netdev->tx_ring_ref, netdev->rx_ring_ref,
xen_nic.c:		  netdev->xendev.remote_port, netdev->xendev.local_port);
xen_nic.c:    xen_be_unbind_evtchn(&netdev->xendev);
xen_nic.c:    if (netdev->txs) {
xen_nic.c:	xc_gnttab_munmap(netdev->xendev.gnttabdev, netdev->txs, 1);
xen_nic.c:	netdev->txs = NULL;
xen_nic.c:    if (netdev->rxs) {
xen_nic.c:	xc_gnttab_munmap(netdev->xendev.gnttabdev, netdev->rxs, 1);
xen_nic.c:	netdev->rxs = NULL;
xen_nic.c:    if (netdev->nic) {
xen_nic.c:        qemu_del_vlan_client(&netdev->nic->nc);
xen_nic.c:        netdev->nic = NULL;
xen_nic.c:    qemu_free(netdev->mac);
xen_nic.c:/* ------------------------------------------------------------- */
xilinx_ethlite.c:    if (s->regs[R_TX_GIE0] & GIE_GIE) {
xilinx_ethlite.c:        qemu_irq_pulse(s->irq);
xilinx_ethlite.c:            r = s->regs[addr];
xilinx_ethlite.c:            r = s->regs[addr];
xilinx_ethlite.c:                qemu_send_packet(&s->nic->nc,
xilinx_ethlite.c:                                 (void *) &s->regs[base],
xilinx_ethlite.c:                                 s->regs[base + R_TX_LEN0]);
xilinx_ethlite.c:                D(qemu_log("eth_tx %d\n", s->regs[base + R_TX_LEN0]));
xilinx_ethlite.c:                if (s->regs[base + R_TX_CTRL0] & CTRL_I)
xilinx_ethlite.c:                memcpy(&s->conf.macaddr.a[0], &s->regs[base], 6);
xilinx_ethlite.c:                if (s->regs[base + R_TX_CTRL0] & CTRL_I)
xilinx_ethlite.c:            s->regs[addr] = value & ~(CTRL_P | CTRL_S);
xilinx_ethlite.c:            s->regs[addr] = value;
xilinx_ethlite.c:            s->regs[addr] = cpu_to_be32(value);
xilinx_ethlite.c:    struct xlx_ethlite *s = DO_UPCAST(NICState, nc, nc)->opaque;
xilinx_ethlite.c:    r = !(s->regs[R_RX_CTRL0] & CTRL_S);
xilinx_ethlite.c:    struct xlx_ethlite *s = DO_UPCAST(NICState, nc, nc)->opaque;
xilinx_ethlite.c:    unsigned int rxbase = s->rxbuf * (0x800 / 4);
xilinx_ethlite.c:    if (!(buf[0] & 0x80) && memcmp(&s->conf.macaddr.a[0], buf, 6))
xilinx_ethlite.c:    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_S) {
xilinx_ethlite.c:        D(qemu_log("ethlite lost packet %x\n", s->regs[R_RX_CTRL0]));
xilinx_ethlite.c:        return -1;
xilinx_ethlite.c:    memcpy(&s->regs[rxbase + R_RX_BUF0], buf, size);
xilinx_ethlite.c:       uint32_t d = s->regs[rxbase + R_RX_BUF0 + i];
xilinx_ethlite.c:       s->regs[rxbase + R_RX_BUF0 + i] = be32_to_cpu(d);
xilinx_ethlite.c:    s->regs[rxbase + R_RX_CTRL0] |= CTRL_S;
xilinx_ethlite.c:    if (s->regs[rxbase + R_RX_CTRL0] & CTRL_I)
xilinx_ethlite.c:    s->rxbuf ^= s->c_rx_pingpong;
xilinx_ethlite.c:    struct xlx_ethlite *s = DO_UPCAST(NICState, nc, nc)->opaque;
xilinx_ethlite.c:    s->nic = NULL;
xilinx_ethlite.c:    sysbus_init_irq(dev, &s->irq);
xilinx_ethlite.c:    s->rxbuf = 0;
xilinx_ethlite.c:    qemu_macaddr_default_if_unset(&s->conf.macaddr);
xilinx_ethlite.c:    s->nic = qemu_new_nic(&net_xilinx_ethlite_info, &s->conf,
xilinx_ethlite.c:                          dev->qdev.info->name, dev->qdev.id, s);
xilinx_ethlite.c:    qemu_format_nic_info_str(&s->nic->nc, s->conf.macaddr.a);
xilinx.h:    qdev_prop_set_uint32(dev, "kind-of-intr", kind_of_intr);
xilinx.h:    qdev_prop_set_uint32(dev, "nr-timers", nr);
xilinx.h:    qemu_check_nic_model(nd, "xilinx-ethlite");
xilinx_intc.c:    /* Configuration reg chosen at synthesis-time. QEMU populates
xilinx_intc.c:       the bits at board-setup.  */
xilinx_intc.c:    p->regs[R_IPR] = p->regs[R_ISR] & p->regs[R_IER];
xilinx_intc.c:        if (p->regs[R_IPR] & (1 << i))
xilinx_intc.c:    p->regs[R_IVR] = i;
xilinx_intc.c:    if ((p->regs[R_MER] & 1) && p->regs[R_IPR]) {
xilinx_intc.c:        qemu_irq_raise(p->parent_irq);
xilinx_intc.c:        qemu_irq_lower(p->parent_irq);
xilinx_intc.c:            if (addr < ARRAY_SIZE(p->regs))
xilinx_intc.c:                r = p->regs[addr];
xilinx_intc.c:            p->regs[R_ISR] &= ~value; /* ACK.  */
xilinx_intc.c:            p->regs[R_IER] |= value;  /* Atomic set ie.  */
xilinx_intc.c:            p->regs[R_IER] &= ~value; /* Atomic clear ie.  */
xilinx_intc.c:            if (addr < ARRAY_SIZE(p->regs))
xilinx_intc.c:                p->regs[addr] = value;
xilinx_intc.c:    if (!(p->regs[R_MER] & 2)) {
xilinx_intc.c:        qemu_irq_lower(p->parent_irq);
xilinx_intc.c:    if (!(p->c_kind_of_intr & (1 << irq)) || level) {
xilinx_intc.c:        p->regs[R_ISR] &= ~(1 << irq);
xilinx_intc.c:        p->regs[R_ISR] |= (level << irq);
xilinx_intc.c:    qdev_init_gpio_in(&dev->qdev, irq_handler, 32);
xilinx_intc.c:    sysbus_init_irq(dev, &p->parent_irq);
xilinx_intc.c:        DEFINE_PROP_UINT32("kind-of-intr", struct xlx_pic, c_kind_of_intr, 0),
xilinx_timer.c:#include "qemu-timer.h"
xilinx_timer.c:    for (i = 0; i < t->nr_timers; i++) {
xilinx_timer.c:        csr = t->timers[i].regs[R_TCSR];
xilinx_timer.c:    qemu_set_irq(t->irq, !!irq);
xilinx_timer.c:    xt = &t->timers[timer];
xilinx_timer.c:                r = ptimer_get_count(xt->ptimer);
xilinx_timer.c:                if (!(xt->regs[R_TCSR] & TCSR_UDT))
xilinx_timer.c:                         timer, r, xt->regs[R_TCSR] & TCSR_UDT));
xilinx_timer.c:            if (addr < ARRAY_SIZE(xt->regs))
xilinx_timer.c:                r = xt->regs[addr];
xilinx_timer.c:              xt->nr, xt->regs[R_TCSR] & TCSR_UDT));
xilinx_timer.c:    ptimer_stop(xt->ptimer);
xilinx_timer.c:    if (xt->regs[R_TCSR] & TCSR_UDT)
xilinx_timer.c:        count = xt->regs[R_TLR];
xilinx_timer.c:        count = ~0 - xt->regs[R_TLR];
xilinx_timer.c:    ptimer_set_count(xt->ptimer, count);
xilinx_timer.c:    ptimer_run(xt->ptimer, 1);
xilinx_timer.c:    xt = &t->timers[timer];
xilinx_timer.c:            xt->regs[addr] = value;
xilinx_timer.c:            if (addr < ARRAY_SIZE(xt->regs))
xilinx_timer.c:                xt->regs[addr] = value;
xilinx_timer.c:    struct timerblock *t = xt->parent;
xilinx_timer.c:    xt->regs[R_TCSR] |= TCSR_TINT;
xilinx_timer.c:    if (xt->regs[R_TCSR] & TCSR_ARHT)
xilinx_timer.c:    sysbus_init_irq(dev, &t->irq);
xilinx_timer.c:    t->timers = qemu_mallocz(sizeof t->timers[0] * t->nr_timers);
xilinx_timer.c:    for (i = 0; i < t->nr_timers; i++) {
xilinx_timer.c:        struct xlx_timer *xt = &t->timers[i];
xilinx_timer.c:        xt->parent = t;
xilinx_timer.c:        xt->nr = i;
xilinx_timer.c:        xt->bh = qemu_bh_new(timer_hit, xt);
xilinx_timer.c:        xt->ptimer = ptimer_init(xt->bh);
xilinx_timer.c:        ptimer_set_freq(xt->ptimer, t->freq_hz);
xilinx_timer.c:    sysbus_init_mmio(dev, R_MAX * 4 * t->nr_timers, timer_regs);
xilinx_timer.c:        DEFINE_PROP_UINT32("nr-timers", struct timerblock, nr_timers, 0),
xilinx_uartlite.c:#include "qemu-char.h"
xilinx_uartlite.c:    if (s->rx_fifo_len)
xilinx_uartlite.c:        s->regs[R_STATUS] |= STATUS_IE;
xilinx_uartlite.c:    irq = (s->regs[R_STATUS] & STATUS_IE) && (s->regs[R_CTRL] & CONTROL_IE);
xilinx_uartlite.c:    qemu_set_irq(s->irq, irq);
xilinx_uartlite.c:    r = s->regs[R_STATUS];
xilinx_uartlite.c:    r |= (s->rx_fifo_len == sizeof (s->rx_fifo)) << 1;
xilinx_uartlite.c:    r |= (!!s->rx_fifo_len);
xilinx_uartlite.c:    s->regs[R_STATUS] = r;
xilinx_uartlite.c:            r = s->rx_fifo[(s->rx_fifo_pos - s->rx_fifo_len) & 7];
xilinx_uartlite.c:            if (s->rx_fifo_len)
xilinx_uartlite.c:                s->rx_fifo_len--;
xilinx_uartlite.c:            if (addr < ARRAY_SIZE(s->regs))
xilinx_uartlite.c:                r = s->regs[addr];
xilinx_uartlite.c:                s->rx_fifo_pos = 0;
xilinx_uartlite.c:                s->rx_fifo_len = 0;
xilinx_uartlite.c:            s->regs[addr] = value;
xilinx_uartlite.c:            if (s->chr)
xilinx_uartlite.c:                qemu_chr_write(s->chr, &ch, 1);
xilinx_uartlite.c:            s->regs[addr] = value;
xilinx_uartlite.c:            s->regs[R_STATUS] |= STATUS_IE;
xilinx_uartlite.c:            if (addr < ARRAY_SIZE(s->regs))
xilinx_uartlite.c:                s->regs[addr] = value;
xilinx_uartlite.c:    if (s->rx_fifo_len >= 8) {
xilinx_uartlite.c:    s->rx_fifo[s->rx_fifo_pos] = *buf;
xilinx_uartlite.c:    s->rx_fifo_pos++;
xilinx_uartlite.c:    s->rx_fifo_pos &= 0x7;
xilinx_uartlite.c:    s->rx_fifo_len++;
xilinx_uartlite.c:    r = s->rx_fifo_len < sizeof(s->rx_fifo);
xilinx_uartlite.c:    sysbus_init_irq(dev, &s->irq);
xilinx_uartlite.c:    s->chr = qdev_init_chardev(&dev->qdev);
xilinx_uartlite.c:    if (s->chr)
xilinx_uartlite.c:        qemu_chr_add_handlers(s->chr, uart_can_rx, uart_rx, uart_event, s);
zaurus.c: * Copyright (c) 2006-2008 Openedhand Ltd.
zaurus.c:    level = s->gpio_level & s->gpio_dir;
zaurus.c:    for (diff = s->prev_level ^ level; diff; diff ^= 1 << bit) {
zaurus.c:        bit = ffs(diff) - 1;
zaurus.c:        qemu_set_irq(s->handler[bit], (level >> bit) & 1);
zaurus.c:    s->prev_level = level;
zaurus.c:        return s->mcr;
zaurus.c:        return s->cdr;
zaurus.c:        return s->status;
zaurus.c:        return s->power;
zaurus.c:        return s->ccr;
zaurus.c:        return s->irr;
zaurus.c:        return s->imr;
zaurus.c:        return s->isr;
zaurus.c:        return s->gpio_dir;
zaurus.c:        return s->gpio_level;
zaurus.c:        s->mcr = value;
zaurus.c:        s->cdr = value;
zaurus.c:        s->power = value;
zaurus.c:            s->power |= 0x8040;
zaurus.c:        s->ccr = value;
zaurus.c:        s->irr = value;
zaurus.c:        s->imr = value;
zaurus.c:        s->isr = value;
zaurus.c:        s->gpio_dir = value;
zaurus.c:        s->gpio_level = value & s->gpio_dir;
zaurus.c:        s->gpio_level |= (1 << line);
zaurus.c:        s->gpio_level &= ~(1 << line);
zaurus.c:    return s->in;
zaurus.c:        exit(-1);
zaurus.c:    s->handler[line] = handler;
zaurus.c:    qemu_put_be16s(f, &s->status);
zaurus.c:    qemu_put_be16s(f, &s->power);
zaurus.c:    qemu_put_be32s(f, &s->gpio_level);
zaurus.c:    qemu_put_be32s(f, &s->gpio_dir);
zaurus.c:    qemu_put_be32s(f, &s->prev_level);
zaurus.c:    qemu_put_be16s(f, &s->mcr);
zaurus.c:    qemu_put_be16s(f, &s->cdr);
zaurus.c:    qemu_put_be16s(f, &s->ccr);
zaurus.c:    qemu_put_be16s(f, &s->irr);
zaurus.c:    qemu_put_be16s(f, &s->imr);
zaurus.c:    qemu_put_be16s(f, &s->isr);
zaurus.c:    qemu_get_be16s(f, &s->status);
zaurus.c:    qemu_get_be16s(f, &s->power);
zaurus.c:    qemu_get_be32s(f, &s->gpio_level);
zaurus.c:    qemu_get_be32s(f, &s->gpio_dir);
zaurus.c:    qemu_get_be32s(f, &s->prev_level);
zaurus.c:    qemu_get_be16s(f, &s->mcr);
zaurus.c:    qemu_get_be16s(f, &s->cdr);
zaurus.c:    qemu_get_be16s(f, &s->ccr);
zaurus.c:    qemu_get_be16s(f, &s->irr);
zaurus.c:    qemu_get_be16s(f, &s->imr);
zaurus.c:    qemu_get_be16s(f, &s->isr);
zaurus.c:    s->status = 0x02;
zaurus.c:    s->in = qemu_allocate_irqs(scoop_gpio_set, s, 16);
zaurus.c:    .uuid		= { -1 },
zaurus.c:    .touch_xp		= -1,
zaurus.c:    .adadj		= -1,
